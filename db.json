{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"source/Activity是如何画到屏幕上的/1.png","path":"Activity是如何画到屏幕上的/1.png","modified":0},{"_id":"source/责任链模式/链式结构.png","path":"责任链模式/链式结构.png","modified":0},{"_id":"source/责任链模式/Touch事件传递过程.png","path":"责任链模式/Touch事件传递过程.png","modified":0},{"_id":"source/责任链模式/Touch事件传递机制例子.png","path":"责任链模式/Touch事件传递机制例子.png","modified":0},{"_id":"source/浅谈SurfaceView与GLSurfaceView/2.jpg","path":"浅谈SurfaceView与GLSurfaceView/2.jpg","modified":0},{"_id":"source/浅谈SurfaceView与GLSurfaceView/1.jpg","path":"浅谈SurfaceView与GLSurfaceView/1.jpg","modified":0},{"_id":"source/我也来谈一谈Java-GC/5.png","path":"我也来谈一谈Java-GC/5.png","modified":0},{"_id":"source/我也来谈一谈Java-GC/4.png","path":"我也来谈一谈Java-GC/4.png","modified":0},{"_id":"source/我也来谈一谈Java-GC/3.png","path":"我也来谈一谈Java-GC/3.png","modified":0},{"_id":"source/我也来谈一谈Java-GC/2.png","path":"我也来谈一谈Java-GC/2.png","modified":0},{"_id":"source/我也来谈一谈Java-GC/1.png","path":"我也来谈一谈Java-GC/1.png","modified":0},{"_id":"source/安卓皮肤包机制的原理/image.jpeg","path":"安卓皮肤包机制的原理/image.jpeg","modified":0},{"_id":"source/安卓广播的底层实现原理/2.png","path":"安卓广播的底层实现原理/2.png","modified":0},{"_id":"source/安卓广播的底层实现原理/1.png","path":"安卓广播的底层实现原理/1.png","modified":0},{"_id":"source/安卓嵌套滚动NestedScroll了解一下/2.png","path":"安卓嵌套滚动NestedScroll了解一下/2.png","modified":0},{"_id":"source/安卓嵌套滚动NestedScroll了解一下/1.gif","path":"安卓嵌套滚动NestedScroll了解一下/1.gif","modified":0},{"_id":"source/学习HTTP协议-用socket实现http访问/7.jpg","path":"学习HTTP协议-用socket实现http访问/7.jpg","modified":0},{"_id":"source/学习HTTP协议-用socket实现http访问/6.jpg","path":"学习HTTP协议-用socket实现http访问/6.jpg","modified":0},{"_id":"source/学习HTTP协议-用socket实现http访问/5.jpg","path":"学习HTTP协议-用socket实现http访问/5.jpg","modified":0},{"_id":"source/学习HTTP协议-用socket实现http访问/4.jpg","path":"学习HTTP协议-用socket实现http访问/4.jpg","modified":0},{"_id":"source/学习HTTP协议-用socket实现http访问/3.jpg","path":"学习HTTP协议-用socket实现http访问/3.jpg","modified":0},{"_id":"source/学习HTTP协议-用socket实现http访问/2.jpg","path":"学习HTTP协议-用socket实现http访问/2.jpg","modified":0},{"_id":"source/学习HTTP协议-用socket实现http访问/1.jpg","path":"学习HTTP协议-用socket实现http访问/1.jpg","modified":0},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/9.jpg","path":"学习HTTP协议-在安卓上的使用Cookie与Session/9.jpg","modified":0},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/8.jpg","path":"学习HTTP协议-在安卓上的使用Cookie与Session/8.jpg","modified":0},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/7.jpg","path":"学习HTTP协议-在安卓上的使用Cookie与Session/7.jpg","modified":0},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/6.jpg","path":"学习HTTP协议-在安卓上的使用Cookie与Session/6.jpg","modified":0},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/5.jpg","path":"学习HTTP协议-在安卓上的使用Cookie与Session/5.jpg","modified":0},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/4.jpg","path":"学习HTTP协议-在安卓上的使用Cookie与Session/4.jpg","modified":0},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/3.jpg","path":"学习HTTP协议-在安卓上的使用Cookie与Session/3.jpg","modified":0},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/2.jpg","path":"学习HTTP协议-在安卓上的使用Cookie与Session/2.jpg","modified":0},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/1.jpg","path":"学习HTTP协议-在安卓上的使用Cookie与Session/1.jpg","modified":0},{"_id":"source/如何实现安卓消息推送/4.png","path":"如何实现安卓消息推送/4.png","modified":0},{"_id":"source/如何实现安卓消息推送/3.png","path":"如何实现安卓消息推送/3.png","modified":0},{"_id":"source/如何实现安卓消息推送/2.png","path":"如何实现安卓消息推送/2.png","modified":0},{"_id":"source/如何实现安卓消息推送/1.png","path":"如何实现安卓消息推送/1.png","modified":0},{"_id":"source/在android上使用grpc/proto_gen.jpeg","path":"在android上使用grpc/proto_gen.jpeg","modified":0},{"_id":"source/写给安卓程序员的cc-编译入门/1.png","path":"写给安卓程序员的cc-编译入门/1.png","modified":0},{"_id":"source/从源码看安卓应用的启动过程/2.png","path":"从源码看安卓应用的启动过程/2.png","modified":0},{"_id":"source/从源码看安卓应用的启动过程/1.png","path":"从源码看安卓应用的启动过程/1.png","modified":0},{"_id":"source/从源码看Activity生命周期/4.png","path":"从源码看Activity生命周期/4.png","modified":0},{"_id":"source/从源码看Activity生命周期/3.png","path":"从源码看Activity生命周期/3.png","modified":0},{"_id":"source/从源码看Activity生命周期/2.png","path":"从源码看Activity生命周期/2.png","modified":0},{"_id":"source/从源码看Activity生命周期/1.png","path":"从源码看Activity生命周期/1.png","modified":0},{"_id":"themes/fexo/source/sass/styles.scss","path":"sass/styles.scss","modified":0},{"_id":"source/head.jpg","path":"head.jpg","modified":0},{"_id":"themes/fexo/source/sass/component/prev-net.scss","path":"sass/component/prev-net.scss","modified":0},{"_id":"themes/fexo/source/js/zenscroll.js","path":"js/zenscroll.js","modified":0},{"_id":"themes/fexo/source/js/util.js","path":"js/util.js","modified":0},{"_id":"themes/fexo/source/js/scroll-spy.js","path":"js/scroll-spy.js","modified":0},{"_id":"themes/fexo/source/js/fastclick.js","path":"js/fastclick.js","modified":0},{"_id":"themes/fexo/source/js/bundle.js","path":"js/bundle.js","modified":0},{"_id":"themes/fexo/source/js/app.js","path":"js/app.js","modified":0},{"_id":"themes/fexo/source/images/avatar.jpeg","path":"images/avatar.jpeg","modified":0},{"_id":"themes/fexo/source/fonts/fontello.woff2","path":"fonts/fontello.woff2","modified":0},{"_id":"themes/fexo/source/fonts/fontello.woff","path":"fonts/fontello.woff","modified":0},{"_id":"themes/fexo/source/fonts/fontello.ttf","path":"fonts/fontello.ttf","modified":0},{"_id":"themes/fexo/source/fonts/fontello.svg","path":"fonts/fontello.svg","modified":0},{"_id":"themes/fexo/source/fonts/fontello.eot","path":"fonts/fontello.eot","modified":0},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff2","path":"fonts/calligraffitti-regular-webfont.woff2","modified":0},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff","path":"fonts/calligraffitti-regular-webfont.woff","modified":0},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.ttf","path":"fonts/calligraffitti-regular-webfont.ttf","modified":0},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.svg","path":"fonts/calligraffitti-regular-webfont.svg","modified":0},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.eot","path":"fonts/calligraffitti-regular-webfont.eot","modified":0},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.woff","path":"fonts/PoiretOne-Regular.woff","modified":0},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.ttf","path":"fonts/PoiretOne-Regular.ttf","modified":0},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.svg","path":"fonts/PoiretOne-Regular.svg","modified":0},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.eot","path":"fonts/PoiretOne-Regular.eot","modified":0},{"_id":"themes/fexo/source/fonts/Lobster-Regular.woff","path":"fonts/Lobster-Regular.woff","modified":0},{"_id":"themes/fexo/source/fonts/Lobster-Regular.ttf","path":"fonts/Lobster-Regular.ttf","modified":0},{"_id":"themes/fexo/source/fonts/Lobster-Regular.svg","path":"fonts/Lobster-Regular.svg","modified":0},{"_id":"themes/fexo/source/fonts/Lobster-Regular.eot","path":"fonts/Lobster-Regular.eot","modified":0},{"_id":"themes/fexo/source/css/styles.css.map","path":"css/styles.css.map","modified":0},{"_id":"themes/fexo/source/css/styles.css","path":"css/styles.css","modified":0},{"_id":"source/ToolBar-学习笔记/5.jpg","path":"ToolBar-学习笔记/5.jpg","modified":0},{"_id":"source/ToolBar-学习笔记/4.jpg","path":"ToolBar-学习笔记/4.jpg","modified":0},{"_id":"source/ToolBar-学习笔记/3.jpg","path":"ToolBar-学习笔记/3.jpg","modified":0},{"_id":"source/ToolBar-学习笔记/2.jpg","path":"ToolBar-学习笔记/2.jpg","modified":0},{"_id":"source/ToolBar-学习笔记/1.jpg","path":"ToolBar-学习笔记/1.jpg","modified":0},{"_id":"source/Retrofit-学习笔记/8.jpg","path":"Retrofit-学习笔记/8.jpg","modified":0},{"_id":"source/Retrofit-学习笔记/7.jpg","path":"Retrofit-学习笔记/7.jpg","modified":0},{"_id":"source/Retrofit-学习笔记/6.jpg","path":"Retrofit-学习笔记/6.jpg","modified":0},{"_id":"source/Retrofit-学习笔记/5.jpg","path":"Retrofit-学习笔记/5.jpg","modified":0},{"_id":"source/Retrofit-学习笔记/4.jpg","path":"Retrofit-学习笔记/4.jpg","modified":0},{"_id":"source/Retrofit-学习笔记/3.jpg","path":"Retrofit-学习笔记/3.jpg","modified":0},{"_id":"source/Retrofit-学习笔记/2.jpg","path":"Retrofit-学习笔记/2.jpg","modified":0},{"_id":"source/Retrofit-学习笔记/1.jpg","path":"Retrofit-学习笔记/1.jpg","modified":0},{"_id":"source/OpenSLES学习笔记/3.png","path":"OpenSLES学习笔记/3.png","modified":0},{"_id":"source/OpenSLES学习笔记/2.png","path":"OpenSLES学习笔记/2.png","modified":0},{"_id":"source/OpenSLES学习笔记/1.png","path":"OpenSLES学习笔记/1.png","modified":0},{"_id":"source/OkHttp源码解析/3.png","path":"OkHttp源码解析/3.png","modified":0},{"_id":"source/OkHttp源码解析/2.png","path":"OkHttp源码解析/2.png","modified":0},{"_id":"source/OkHttp源码解析/1.png","path":"OkHttp源码解析/1.png","modified":0},{"_id":"source/Java多线程-线程池/2.png","path":"Java多线程-线程池/2.png","modified":0},{"_id":"source/Java多线程-线程池/1.png","path":"Java多线程-线程池/1.png","modified":0},{"_id":"source/Java多线程-Future模式/1.png","path":"Java多线程-Future模式/1.png","modified":0},{"_id":"source/GTest实例解析/1.jpg","path":"GTest实例解析/1.jpg","modified":0},{"_id":"source/DrawerLayout-学习笔记/7.jpg","path":"DrawerLayout-学习笔记/7.jpg","modified":0},{"_id":"source/DrawerLayout-学习笔记/6.jpg","path":"DrawerLayout-学习笔记/6.jpg","modified":0},{"_id":"source/DrawerLayout-学习笔记/5.jpg","path":"DrawerLayout-学习笔记/5.jpg","modified":0},{"_id":"source/DrawerLayout-学习笔记/4.jpg","path":"DrawerLayout-学习笔记/4.jpg","modified":0},{"_id":"source/DrawerLayout-学习笔记/3.jpg","path":"DrawerLayout-学习笔记/3.jpg","modified":0},{"_id":"source/DrawerLayout-学习笔记/2.jpg","path":"DrawerLayout-学习笔记/2.jpg","modified":0},{"_id":"source/DrawerLayout-学习笔记/1.jpg","path":"DrawerLayout-学习笔记/1.jpg","modified":0},{"_id":"source/CNAME","path":"CNAME","modified":0},{"_id":"source/Android温故而知新-launchMode/standard3.png","path":"Android温故而知新-launchMode/standard3.png","modified":0},{"_id":"source/Android温故而知新-launchMode/standard2.png","path":"Android温故而知新-launchMode/standard2.png","modified":0},{"_id":"source/Android温故而知新-launchMode/standard1.png","path":"Android温故而知新-launchMode/standard1.png","modified":0},{"_id":"source/Android温故而知新-launchMode/singleTop5.png","path":"Android温故而知新-launchMode/singleTop5.png","modified":0},{"_id":"source/Android温故而知新-launchMode/singleTop4.png","path":"Android温故而知新-launchMode/singleTop4.png","modified":0},{"_id":"source/Android温故而知新-launchMode/singleTop3.png","path":"Android温故而知新-launchMode/singleTop3.png","modified":0},{"_id":"source/Android温故而知新-launchMode/singleTop2.png","path":"Android温故而知新-launchMode/singleTop2.png","modified":0},{"_id":"source/Android温故而知新-launchMode/singleTop1.png","path":"Android温故而知新-launchMode/singleTop1.png","modified":0},{"_id":"source/Android温故而知新-launchMode/singleTask2.png","path":"Android温故而知新-launchMode/singleTask2.png","modified":0},{"_id":"source/Android温故而知新-launchMode/singleTask1.png","path":"Android温故而知新-launchMode/singleTask1.png","modified":0},{"_id":"source/Android温故而知新-launchMode/singleInstance3.png","path":"Android温故而知新-launchMode/singleInstance3.png","modified":0},{"_id":"source/Android温故而知新-launchMode/singleInstance2.png","path":"Android温故而知新-launchMode/singleInstance2.png","modified":0},{"_id":"source/Android温故而知新-launchMode/singleInstance1.png","path":"Android温故而知新-launchMode/singleInstance1.png","modified":0},{"_id":"source/Android温故而知新-Java的四种引用/1.png","path":"Android温故而知新-Java的四种引用/1.png","modified":0},{"_id":"source/Android温故而知新-Handler/2.png","path":"Android温故而知新-Handler/2.png","modified":0},{"_id":"source/Android温故而知新-Handler/1.png","path":"Android温故而知新-Handler/1.png","modified":0},{"_id":"source/Android温故而知新-ClassLoader/1.png","path":"Android温故而知新-ClassLoader/1.png","modified":0},{"_id":"source/Android温故而知新-AIDL/1.png","path":"Android温故而知新-AIDL/1.png","modified":0},{"_id":"source/Activity是如何画到屏幕上的/2.png","path":"Activity是如何画到屏幕上的/2.png","modified":0}],"Cache":[{"_id":"source/Activity是如何画到屏幕上的/2.png","shasum":"35c7bb33d2f887149ba626ed53b3162ed8d2ac01","modified":1537528790000},{"_id":"source/Activity是如何画到屏幕上的/1.png","shasum":"debc8cd768ed120de79b9d4cf59f4d08c5d2cb26","modified":1537528790000},{"_id":"source/Android温故而知新-Handler/1.png","shasum":"609a5ac68dbf3da398b7da6e601c730c5f3457e1","modified":1537528790000},{"_id":"source/Android温故而知新-Java的四种引用/1.png","shasum":"1903b1ddbf40c8f9d3b0513380833b11d4f2f746","modified":1537528790000},{"_id":"source/Android温故而知新-launchMode/singleTop1.png","shasum":"5b4e346fd5b817d6b9e2561792397e52eb5c14be","modified":1537528790000},{"_id":"source/Android温故而知新-launchMode/singleTop2.png","shasum":"1b7e94e098bc5b0ef1b65b1ca657e0fa5c0495c4","modified":1537528790000},{"_id":"source/Android温故而知新-launchMode/standard1.png","shasum":"b889819d9da5c520ae1cc9a62935f90f048966ed","modified":1537528790000},{"_id":"source/Android温故而知新-launchMode/singleTop5.png","shasum":"fe674f3faf34cebf316563d44de0e7898bc65a73","modified":1537528790000},{"_id":"source/CNAME","shasum":"c7cb3d91a694837c9e8ffb170e337117ff6ce49d","modified":1496443658000},{"_id":"source/DrawerLayout-学习笔记/1.jpg","shasum":"1a1368dfbac23b479812fe84f102184d549a4c98","modified":1496443658000},{"_id":"source/DrawerLayout-学习笔记/2.jpg","shasum":"8d7c95ce009525f48e47a6de17e8f4d96347068b","modified":1496443658000},{"_id":"source/DrawerLayout-学习笔记/5.jpg","shasum":"d830ab772f92330b2c5e7476dc6ca3fec343d550","modified":1496443658000},{"_id":"source/DrawerLayout-学习笔记/6.jpg","shasum":"8c9fe475e5beb5b877886843d335cab1449df347","modified":1496443658000},{"_id":"source/DrawerLayout-学习笔记/3.jpg","shasum":"bd3d95b33b66306f61cfed5a869a5091496a2f08","modified":1496443658000},{"_id":"source/DrawerLayout-学习笔记/4.jpg","shasum":"d64e85ba03bd98399ac3b6b68d99ef30da19b3b1","modified":1496443658000},{"_id":"source/DrawerLayout-学习笔记/7.jpg","shasum":"180a84f0559f14906d924067241ea5b74ee27e39","modified":1496443658000},{"_id":"source/Java多线程-线程池/1.png","shasum":"afa10d94a480c4490e61ded63a4893b9d5f7a7e2","modified":1537528790000},{"_id":"source/OkHttp源码解析/1.png","shasum":"ce03edaea0a7e87b745c4215cc82e3c38e506901","modified":1537528790000},{"_id":"source/OkHttp源码解析/2.png","shasum":"ad3a791101933b98338079a09f65d18b433a29e5","modified":1537528790000},{"_id":"source/OpenSLES学习笔记/1.png","shasum":"2fb3944dba82b74bd5ffc439d7f8ae493e19ceba","modified":1537528790000},{"_id":"source/OpenSLES学习笔记/2.png","shasum":"3c0cb5d4ccea5d261fc86ef695cc78d69693de6f","modified":1537528790000},{"_id":"source/OpenSLES学习笔记/3.png","shasum":"2e66ca0578da312ca9b27693170761e06d7f831b","modified":1537528790000},{"_id":"source/Retrofit-学习笔记/2.jpg","shasum":"1577be4677801ddbbc25c5af5d1466f04a10f0cb","modified":1496443658000},{"_id":"source/Retrofit-学习笔记/3.jpg","shasum":"4646315828e672833e42450949da1d5f99897907","modified":1496443658000},{"_id":"source/Retrofit-学习笔记/4.jpg","shasum":"7d9ba9c23107656f00ade70544658e96f72c1453","modified":1496443658000},{"_id":"source/Retrofit-学习笔记/5.jpg","shasum":"7147cb1e0ed1d771d71cda564af15369e32c82cc","modified":1496443658000},{"_id":"source/Retrofit-学习笔记/7.jpg","shasum":"5bbb31731860d741fc6440e00af04e2d171ef6f4","modified":1496443658000},{"_id":"source/Retrofit-学习笔记/6.jpg","shasum":"af52d69d5bca71994c2818df74b1985c3077748b","modified":1496443658000},{"_id":"source/Retrofit-学习笔记/8.jpg","shasum":"a9b081cbf55a638728dfa4a220ab3e53525bba7d","modified":1496443658000},{"_id":"source/ToolBar-学习笔记/3.jpg","shasum":"714276352a2a1c690098d9843740503b27623fbd","modified":1496443658000},{"_id":"source/ToolBar-学习笔记/2.jpg","shasum":"3fb70bb82f049f3ab465b87cb6e07e9036fc4f36","modified":1496443658000},{"_id":"source/ToolBar-学习笔记/4.jpg","shasum":"17a1219db2c52dfa273a46a8593e55bfe3631d92","modified":1496443658000},{"_id":"source/ToolBar-学习笔记/1.jpg","shasum":"25a1dfbe2965580783076680941c4d25f252c512","modified":1496443658000},{"_id":"source/_posts/Activity是如何画到屏幕上的.md","shasum":"1b8e46a98285ccaf449ca30daace6438611b80d8","modified":1537528790000},{"_id":"source/ToolBar-学习笔记/5.jpg","shasum":"574f078706926749984a044666681d08529a6a72","modified":1496443658000},{"_id":"source/_posts/Android温故而知新-AIDL.md","shasum":"423450d0d0f44a24883bd265aac522618dbf0895","modified":1537528790000},{"_id":"source/_posts/Android温故而知新-Java的四种引用.md","shasum":"2467761998213774bad96597901fc4dd3ede7556","modified":1537528790000},{"_id":"source/_posts/Android温故而知新-Handler.md","shasum":"7575c7366f8e4731673b5de0ff146cb9f6a959dd","modified":1537528790000},{"_id":"source/_posts/Android温故而知新-ClassLoader.md","shasum":"a317b85e58bd25114df9b285134e2e65e2881a60","modified":1537528790000},{"_id":"source/_posts/Dagger2学习笔记-一.md","shasum":"007b53c33f88a60bc1b5e1fac2a68b63cccf201e","modified":1537528790000},{"_id":"source/_posts/Android温故而知新-launchMode.md","shasum":"2af29bd1599fb78e431b7ca5b6c71102e9902c7e","modified":1537528790000},{"_id":"source/_posts/Dagger2学习笔记-二.md","shasum":"c0eb4fcc9fc64690458feacd93f8fe15786cd9e1","modified":1537528790000},{"_id":"source/_posts/CNAME","shasum":"c7cb3d91a694837c9e8ffb170e337117ff6ce49d","modified":1496443658000},{"_id":"source/_posts/GTest实例解析.md","shasum":"aa7f06092fdd08bf50ea677f4ee4c45705a81d9c","modified":1537528790000},{"_id":"source/_posts/DrawerLayout-学习笔记.md","shasum":"9849e8e69f74ce45ef5ff2e9893c5939dcff5e6b","modified":1537528790000},{"_id":"source/_posts/Java多线程-Future模式.md","shasum":"f07976d36e37b0d9b6f2226cdcf0d08d0f69d8f2","modified":1537528790000},{"_id":"source/_posts/GTest源码剖析-测试代码的注册.md","shasum":"8c7d4c54b4eef28f141bb3b65e1147171b390ade","modified":1537528790000},{"_id":"source/_posts/Java多线程-如何正确的终止线程.md","shasum":"b3732be12bf78fb3a870d43ccfddb404bad702ff","modified":1537528790000},{"_id":"source/_posts/Java多线程-各种线程锁.md","shasum":"939618a50b089cff87e6aac2c7edbac273da1e5b","modified":1537528790000},{"_id":"source/_posts/Java多线程-线程池.md","shasum":"33fa9c93546072e8fb3b404b6e914563e65c55ba","modified":1537528790000},{"_id":"source/_posts/Java自定义注解和动态代理.md","shasum":"d394fe80690fae1b38266601ebf4dacc6999eb97","modified":1537528790000},{"_id":"source/_posts/OkHttp源码解析.md","shasum":"cd7e6ff2698d96c55a00e62a1acb044922895ce2","modified":1537528790000},{"_id":"source/_posts/ToolBar-学习笔记.md","shasum":"e1cfa7f36e8699ec06afaf84c48f96bda5a1c910","modified":1537528790000},{"_id":"source/_posts/OpenSLES学习笔记.md","shasum":"7558b0f124cef231ae0d081bc241144c645707fd","modified":1537528790000},{"_id":"source/_posts/Retrofit-学习笔记.md","shasum":"ba9ef61e736ea0b47d05379b6bef87d543adfdd9","modified":1537528790000},{"_id":"source/_posts/automake学习笔记-helloworld.md","shasum":"06587fcda8edeee57cc48b8f868628af47b8d7f7","modified":1537528790000},{"_id":"source/_posts/automake学习笔记-安装与发布.md","shasum":"23ec0d4e5bea91372bd2b5f5da2858b6a728029e","modified":1537528790000},{"_id":"source/_posts/automake学习笔记-模块化编译.md","shasum":"fd7f2322a06dd2eddea3b9bb8dc2618f73624531","modified":1537528790000},{"_id":"source/_posts/automake学习笔记-交叉编译.md","shasum":"cdee0b144d2e76010efcbf5f57f036511f2b9713","modified":1537528790000},{"_id":"source/_posts/c++模板中的class和typename.md","shasum":"184d3ae18065dc579fd5c9b40aa3db11b941d636","modified":1537528790000},{"_id":"source/_posts/java泛型那些事.md","shasum":"ff712bb7f2f078bcaf58cc649731f0d1dc6bf710","modified":1537528790000},{"_id":"source/_posts/lua元表.md","shasum":"e86dc72e42c907c3e5df2d160871824b170a3377","modified":1496443658000},{"_id":"source/_posts/kotlin到底好在哪里.md","shasum":"262fb16bcc61a83a61734c9995f263b0d820c98e","modified":1537528790000},{"_id":"source/_posts/lua泛型for的原理.md","shasum":"11a8c82e136bb0201f695ba76fc2fdba262ec429","modified":1496443658000},{"_id":"source/_posts/lua面向对象编程.md","shasum":"690559730552eeedda2ffafcb6d0663b39ab53af","modified":1496443658000},{"_id":"source/_posts/使用hexo搭建个人博客.md","shasum":"6762d527a4ee975d2483f44a738ba6176794ee09","modified":1537528790000},{"_id":"source/_posts/从源码看安卓应用的启动过程.md","shasum":"d11e226180da0003866f9e0222fe9b7d1ac6e060","modified":1537528790000},{"_id":"source/_posts/从源码看Activity生命周期.md","shasum":"78874750195d2e3c8128aaadc68cb7ce6f00867e","modified":1537528790000},{"_id":"source/_posts/再谈Java泛型.md","shasum":"d33ca2ac1d28083f9d54d8ff2482bf8b754f02df","modified":1537528790000},{"_id":"source/_posts/在android上使用grpc.md","shasum":"37a83a7ea28c74db374c72723281d25bb5778758","modified":1537528790000},{"_id":"source/_posts/写给安卓程序员的cc-编译入门.md","shasum":"6e9b1e60815a2c1d88b936ff397c5f8739145657","modified":1537528790000},{"_id":"source/_posts/在Android中使用注解生成Java代码-AbstractProcessor.md","shasum":"59499a09a391408e548319eda347e4218d8a61ee","modified":1537528790000},{"_id":"source/_posts/如何实现安卓消息推送.md","shasum":"64d212e2dd6702fa4ee1fb1365ae893d864639a6","modified":1537528790000},{"_id":"source/_posts/学习HTTP协议-在安卓上的使用Cookie与Session.md","shasum":"7917d8d7633df60e909423f3049e85ee325f0958","modified":1537528790000},{"_id":"source/_posts/学习HTTP协议-用socket实现http访问.md","shasum":"b0db2869ccd84aa78032a55bdc634c3b7932fbbe","modified":1537528790000},{"_id":"source/_posts/安卓嵌套滚动NestedScroll了解一下.md","shasum":"d0d46424a80118d23c4128162331b2c0cafdb514","modified":1537528790000},{"_id":"source/_posts/安卓皮肤包机制的原理.md","shasum":"649ef9fbede49ea1fa329882dd625f3c2dba0f1a","modified":1537528790000},{"_id":"source/_posts/安卓广播的底层实现原理.md","shasum":"58cf34c0ea5be280c1c32e4134b5829939597dc3","modified":1537528790000},{"_id":"source/_posts/小米笔记本pro 15.6寸安装ubuntu16.04无法使用wifi的解决方法.md","shasum":"c563fa4db3c1a887214c55e6a3715976f46ead30","modified":1537528790000},{"_id":"source/_posts/我也来谈一谈Java-GC.md","shasum":"412efef466102297394f447597cb55e4e46715c2","modified":1537528790000},{"_id":"source/_posts/用PowerMock进行Android单元测试与BDD行为驱动开发.md","shasum":"e862c2a548809561900faca8b357933dcad848b5","modified":1537528790000},{"_id":"source/_posts/读书笔记-《道法自然—面向对象实践指南》.md","shasum":"4f91e87b0681c97b835afece0c10d3adc816fa63","modified":1537528790000},{"_id":"source/_posts/读书笔记-《代码整洁之道》.md","shasum":"dacdb73f75fdcf62e6889877b6adff75cc496fb5","modified":1496443658000},{"_id":"source/_posts/浅谈SurfaceView与GLSurfaceView.md","shasum":"c698b2857e83e5b217d47e9838f3da0d8567aba6","modified":1537528993000},{"_id":"source/_posts/读书笔记-《第一行代码——Android》.md","shasum":"44cc0d3e1d57a7cc8caa85a00907e876fa664890","modified":1496443658000},{"_id":"source/_posts/读书笔记-《黑客与画家》.md","shasum":"6e80889acc4b826130c4d6b3682173c2b70e4e06","modified":1496443658000},{"_id":"source/about/index.md","shasum":"bc1e33abe97db8273e6b12f35bb578534dde20a2","modified":1537528790000},{"_id":"source/_posts/责任链模式.md","shasum":"0189e326bde002d983bfd4634074946b756e5614","modified":1537528790000},{"_id":"source/link/index.md","shasum":"357e194d549590b0ff8dcf404137578b10530196","modified":1537528790000},{"_id":"source/head.jpg","shasum":"02cfa3e329a8fff4756f336b15488a3f6fa0e783","modified":1496443658000},{"_id":"source/tag/index.md","shasum":"34c7b76f347ad9f82a1b085bc6691d24c8fb126b","modified":1537528790000},{"_id":"source/从源码看Activity生命周期/2.png","shasum":"4255db23b9bd4b2673d0b085ca9fbd7e4390356c","modified":1537528790000},{"_id":"source/从源码看安卓应用的启动过程/1.png","shasum":"5d5d9456b8eb99dfa258ee212f1c1bdaada1b2e7","modified":1537528790000},{"_id":"source/从源码看Activity生命周期/4.png","shasum":"925d24241f189296ba1b47007b0b0abd918f085f","modified":1537528790000},{"_id":"source/写给安卓程序员的cc-编译入门/1.png","shasum":"a81d7333cdb5e80da8891f1cfa8351ff8c942fd2","modified":1537528790000},{"_id":"source/如何实现安卓消息推送/2.png","shasum":"61d53257c0aa150dd2e090949bb81beb2bf77cd1","modified":1537528790000},{"_id":"source/如何实现安卓消息推送/1.png","shasum":"56147ada9a79b36d06a2b08b191393fbd422e6b9","modified":1537528790000},{"_id":"source/如何实现安卓消息推送/3.png","shasum":"6a1d99f11d5fa2eda4502df7d5f08dcc4893d39c","modified":1537528790000},{"_id":"source/如何实现安卓消息推送/4.png","shasum":"f891f2143896296785a1bb3d6440829e308ed13a","modified":1537528790000},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/4.jpg","shasum":"3a79ec8254a714302c108f80edf52eb34f97ba76","modified":1496443658000},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/1.jpg","shasum":"01fee1734f999cf6907e7363bf940f259cdbd096","modified":1496443658000},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/2.jpg","shasum":"37042f8420bb0d38c2b8829b8921907ab3b7ba75","modified":1496443658000},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/3.jpg","shasum":"a4cd99529e06cde03c86de83ad798981c8a916ac","modified":1496443658000},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/6.jpg","shasum":"fcbaab58a97f22457892caf6e7549a34ce6ce242","modified":1496443658000},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/5.jpg","shasum":"48bb3883ee86eaef233065c106e6cb681df4fcee","modified":1496443658000},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/9.jpg","shasum":"cd77fb9f1242143d8430958a0b19fea94f1f5c4a","modified":1496443658000},{"_id":"source/学习HTTP协议-用socket实现http访问/3.jpg","shasum":"745d3eb20e1d42ed0ccad9596d5efe2c59f619a7","modified":1496443658000},{"_id":"source/学习HTTP协议-用socket实现http访问/5.jpg","shasum":"5c8d09c4b8742d59d7c7b72c5a9c46b5c7b372a4","modified":1496443658000},{"_id":"source/学习HTTP协议-用socket实现http访问/4.jpg","shasum":"f84a7d6674febbe035a6dccdd311dd5e406b5dc4","modified":1496443658000},{"_id":"source/学习HTTP协议-用socket实现http访问/7.jpg","shasum":"d76e0337a125de3fca3c520dec0bcdfd8464872c","modified":1496443658000},{"_id":"source/学习HTTP协议-用socket实现http访问/6.jpg","shasum":"6ca6b0a230be1d9f4c16beccfcbb2b144a7a08b0","modified":1496443658000},{"_id":"source/安卓嵌套滚动NestedScroll了解一下/2.png","shasum":"a2b8fbd312d5e1e4f1f5244b7a664a7bb185a58b","modified":1537528790000},{"_id":"source/安卓广播的底层实现原理/1.png","shasum":"9c925240a537d1263966733e9f781dd3c29648be","modified":1537528790000},{"_id":"source/安卓广播的底层实现原理/2.png","shasum":"59feeedc152b8400146290c20c52b2bff4492f01","modified":1537528790000},{"_id":"source/安卓皮肤包机制的原理/image.jpeg","shasum":"1ab724d684cd700c0865dcba77efd028b9973de1","modified":1537528790000},{"_id":"source/我也来谈一谈Java-GC/2.png","shasum":"d468934241d14a35beab12ecca80ea5936aa89e2","modified":1537528790000},{"_id":"source/浅谈SurfaceView与GLSurfaceView/1.jpg","shasum":"ed1a9c30ad3943b6eda1a430c94d41b3c875ff51","modified":1537528790000},{"_id":"source/浅谈SurfaceView与GLSurfaceView/2.jpg","shasum":"6d4604703c9c2f5ef0a31c69ee153dcf279b0079","modified":1537528790000},{"_id":"source/责任链模式/Touch事件传递机制例子.png","shasum":"0e3c89ec086baf4bbf09c3f4059c1144858f48ad","modified":1496443658000},{"_id":"source/责任链模式/链式结构.png","shasum":"3f6938381305c17724f5fa9bf3a5eed0ffe7bfbb","modified":1496443658000},{"_id":"source/Android温故而知新-AIDL/1.png","shasum":"2d4455f7682b0a88a8dc34066cb504b4dfaad82b","modified":1537528790000},{"_id":"source/Android温故而知新-launchMode/singleInstance2.png","shasum":"0d4b9733fe6ab325d013fcfe67451cb85e000280","modified":1537528790000},{"_id":"source/Android温故而知新-launchMode/singleInstance1.png","shasum":"cf61ec2c4735211cad1ecdc2deb940416860f0fd","modified":1537528790000},{"_id":"source/Android温故而知新-launchMode/singleInstance3.png","shasum":"6ad5db13f2cfd0334a93fc6950d2326c1c68c388","modified":1537528790000},{"_id":"source/Android温故而知新-launchMode/singleTask1.png","shasum":"c32ab30f9b1b32468e67c12c16d8a88cab7fda9f","modified":1537528790000},{"_id":"source/Android温故而知新-launchMode/singleTask2.png","shasum":"9b4241e3bc764d7d693bfaec462e8d42cdf27b56","modified":1537528790000},{"_id":"source/Android温故而知新-launchMode/singleTop4.png","shasum":"2e04fc22f20490033d3461fd50583c9e34017086","modified":1537528790000},{"_id":"source/Android温故而知新-launchMode/singleTop3.png","shasum":"d3a4843821215b325aecf69d035b21527b970794","modified":1537528790000},{"_id":"source/Android温故而知新-launchMode/standard2.png","shasum":"8404ca9d713d7c9b1badb13479a149c430cffc8f","modified":1537528790000},{"_id":"source/Android温故而知新-launchMode/standard3.png","shasum":"cd0f47c6c7dadf39cc9735afe98fd2f17fc8e507","modified":1537528790000},{"_id":"source/GTest实例解析/1.jpg","shasum":"b93eed3e0078af4a801df5f03e05e60ee5818e31","modified":1496443658000},{"_id":"source/Java多线程-Future模式/1.png","shasum":"b51d61d942ffe0b5db050814a71f71802079bbf4","modified":1537528790000},{"_id":"source/OkHttp源码解析/3.png","shasum":"93dfb4e0200e6f9f66ca81679cdc7f9194a77649","modified":1537528790000},{"_id":"source/Retrofit-学习笔记/1.jpg","shasum":"df6d9b6866a07723a2d9ae476e0678da06c34b6c","modified":1496443658000},{"_id":"source/从源码看Activity生命周期/1.png","shasum":"3c05c4b1adc9bf2950832cd92b3cb2d21dde1e80","modified":1537528790000},{"_id":"source/从源码看安卓应用的启动过程/2.png","shasum":"6d902016370e3ef413dbac0113c16e0c91ba3c81","modified":1537528790000},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/7.jpg","shasum":"ccd9492ddd2c01bb6e23bdea7fb5b0c564ead0b5","modified":1496443658000},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/8.jpg","shasum":"0603ad18102173f78c6171a464409a354360f5d6","modified":1496443658000},{"_id":"source/我也来谈一谈Java-GC/1.png","shasum":"a606895d331630174eda5709793038d62a6dffce","modified":1537528790000},{"_id":"source/我也来谈一谈Java-GC/4.png","shasum":"dffb1b5f1aa1742aca8c0d7cbd7a7cc6d68be7d0","modified":1537528790000},{"_id":"source/我也来谈一谈Java-GC/3.png","shasum":"bc44ea5c4f43ef10f3b54ee1b20d25996622d0e2","modified":1537528790000},{"_id":"source/责任链模式/Touch事件传递过程.png","shasum":"62b88092173964ebd41fc77e4e6fcacdb506e3fc","modified":1496443658000},{"_id":"source/Android温故而知新-ClassLoader/1.png","shasum":"b9f9a75061beffe87f550cf3425a7ba26274643a","modified":1537528790000},{"_id":"source/Android温故而知新-Handler/2.png","shasum":"8c202a0c258a9836acd3240e11f94f20e6f33ff0","modified":1537528790000},{"_id":"source/从源码看Activity生命周期/3.png","shasum":"908831f54630d5f5ceb12a3eaf37873422226d2c","modified":1537528790000},{"_id":"source/在android上使用grpc/proto_gen.jpeg","shasum":"d8115287cbf64e80bf258adef0d9ba51c033733d","modified":1496443658000},{"_id":"source/Java多线程-线程池/2.png","shasum":"63de1cc6e70d173108aaa75a15583aad749f0bce","modified":1537528790000},{"_id":"source/学习HTTP协议-用socket实现http访问/1.jpg","shasum":"300cc7098c616d5c2e0b28db47d2dc8b1732ef75","modified":1496443658000},{"_id":"source/安卓嵌套滚动NestedScroll了解一下/1.gif","shasum":"a1f21b3abbf5656dbe9a70e4416519c98996b0c3","modified":1537528790000},{"_id":"source/我也来谈一谈Java-GC/5.png","shasum":"04ebdb3ea1f1b8a07a347e0e2bf26c780d53a5e4","modified":1537528790000},{"_id":"themes/fexo/source/sass/pages/_tag.scss","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537528790000},{"_id":"source/学习HTTP协议-用socket实现http访问/2.jpg","shasum":"35480d5b35636ab51af44e48ca77c057bf4e771f","modified":1496443658000},{"_id":"themes/fexo/_config.yml","shasum":"8fd881533d6ae95165480fe83d43f29e54056352","modified":1537528790000},{"_id":"themes/fexo/gulpfile.js","shasum":"5995b9c4e8e18d1670ad30b2881d49fa17e56415","modified":1537528790000},{"_id":"themes/fexo/LICENSE","shasum":"db4cb5aef6072a96721b5428fdd999647c049d55","modified":1537528790000},{"_id":"themes/fexo/README.md","shasum":"35cd346c229e17ed83609ee94b5d6493c4ab9982","modified":1537528790000},{"_id":"themes/fexo/languages/en.yml","shasum":"b58364c7dfac61eddd64510f74ca7516da48f0cf","modified":1537528790000},{"_id":"themes/fexo/languages/default.yml","shasum":"1a6762d52295b0f7586f40c35e713c0fd33c2a2b","modified":1537528790000},{"_id":"themes/fexo/languages/zh-CN.yml","shasum":"1a6762d52295b0f7586f40c35e713c0fd33c2a2b","modified":1537528790000},{"_id":"themes/fexo/languages/no.yml","shasum":"bf11017d77f64fbafb9c99ac219d076b20d53afc","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/baidu-analytics.ejs","shasum":"c19e4abec19c23840fff7f8a51f4aefbb2b7e8ca","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/baidu-push.ejs","shasum":"6950255d74efac8811d5b05d0d7a263c3c96486d","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/component/back-top.ejs","shasum":"47f2b8306b901f0fffc6aa0cfa40db697a0c5aff","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/component/category-box.ejs","shasum":"f18e08e5c8718d5cd6672fc01e25ba457db0a385","modified":1537528790000},{"_id":"themes/fexo/languages/zh-TW.yml","shasum":"6141b4c7a094c74bd9df7c08908d92b561c1a0c0","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/component/category.ejs","shasum":"2429158ff177b8876de765498b54d0c91b3fc551","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/article.ejs","shasum":"ab0adc8f18a96eab18bb584233c0e8d4ddba71fc","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/component/comments.ejs","shasum":"043ed1e5625860696fe42bb88c998668faf71449","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/component/date.ejs","shasum":"163fbd874481cb9e2b6da5282701a3fbaa4e367a","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/component/disqus.ejs","shasum":"21de7498d235a52337335108fce7446e1a21ea1c","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/component/duoshuo.ejs","shasum":"b732200315e4c82e92bc7bd0ad33eb171d246e26","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/component/gentie.ejs","shasum":"9b78a138fb93a71b481ab25c8dea2e082e5e9d6c","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/component/donation.ejs","shasum":"65bf93ad8e149033e6f93d673cc85ee223615589","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/component/item-post.ejs","shasum":"722e5dbde2d4683eea08f2af922358db45b253b1","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/component/item-tag.ejs","shasum":"1b4c4e090c33ccfd44b531a5de9af16eec266512","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/component/item-year.ejs","shasum":"906a6aea44a30e83c4c4e449294c7e4d831c188e","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/component/pagination.ejs","shasum":"ffbb548aee6e15cae924ee7f922f28b2403e8e45","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/component/item-category-name.ejs","shasum":"8ab52c9b5d5db1d3c1d343ecb405c4e15cd144ac","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/component/modal.ejs","shasum":"8edceb2fd6c770691bd5cf4a35236c1def8410fe","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/component/page-header.ejs","shasum":"14bad32082d87d7eeb45c0e9079e72f0ae65dbf4","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/component/tag-box.ejs","shasum":"d648ea91ec9dc72bca80d70fbb66f7655bd0ea12","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/component/title.ejs","shasum":"e2fcdd904123186648513cfca4c7ad04921d2d57","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/component/toc.ejs","shasum":"000be428e925f5595af29eeba37ba6111f7f6511","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/component/tag-list.ejs","shasum":"8535c40b573744ced738b051383c0feca80eb0e9","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/component/prev-net.ejs","shasum":"d1cb2e61814bcbd25ccb1628f99b18316e029892","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/component/toolbox.ejs","shasum":"fcfcccc5b231c4050f1a665b70f7738f9d070541","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/google-analytics.ejs","shasum":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/load-script.ejs","shasum":"4675c917548817118f4a3c5d84acc98d6c61a1d8","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/home.ejs","shasum":"225b8a001c7aace46f2b39676e968e7cba9a4277","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/head.ejs","shasum":"794916e761ea82fb606a2173af68e9bf524f6efb","modified":1537528790000},{"_id":"themes/fexo/layout/_partial/style.ejs","shasum":"d1e80d7cf8b22929f5c6d8590eac38b069ea055d","modified":1537528790000},{"_id":"themes/fexo/layout/about.ejs","shasum":"f1f06842f3fac2c7dd74811722431c5720e6cf8d","modified":1537528790000},{"_id":"themes/fexo/layout/archive.ejs","shasum":"9c22251c328e937c444a9f5d4b324f97a78d324f","modified":1537528790000},{"_id":"themes/fexo/layout/category.ejs","shasum":"6d7f43a3d3180e7eb120601bae701664911cf8e6","modified":1537528790000},{"_id":"themes/fexo/layout/index.ejs","shasum":"9d33cd03e7a8adf8bbc124c248def36c15e681d0","modified":1537528790000},{"_id":"themes/fexo/layout/layout.ejs","shasum":"ae485be0f6c0c431245e0cac21dc109c9d0125e8","modified":1537528790000},{"_id":"themes/fexo/layout/link.ejs","shasum":"0144bdb1bc5f19763535b79b3302bf85bc0afbff","modified":1537528790000},{"_id":"themes/fexo/layout/post.ejs","shasum":"8cf15be489f8f3c11ac0215c16cbce36c854555f","modified":1537528790000},{"_id":"themes/fexo/layout/project.ejs","shasum":"6648041e1319c8ee3e16c882b33bb457c67a9527","modified":1537528790000},{"_id":"themes/fexo/layout/search.ejs","shasum":"8c6fc59bed1facf14dd6a48bdf8dd44452583f4d","modified":1537528790000},{"_id":"themes/fexo/layout/tag.ejs","shasum":"2cadf0acdf7c8e76bd4f27c6d7fe97eefe42ef5e","modified":1537528790000},{"_id":"themes/fexo/package.json","shasum":"351b5b21f5ea8851103ee1891248be43f3c27027","modified":1537528790000},{"_id":"themes/fexo/source/css/styles.css","shasum":"c4d6a1f5403cf2fe2674ba82eb2b32b0fd7dfdb8","modified":1537528790000},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.eot","shasum":"2a4ef0d00fb77d16e37c3da429698b029e7d2d2f","modified":1537528790000},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.ttf","shasum":"2b186ce205301f7f3abd441f0372b72adcd2aee3","modified":1537528790000},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.woff","shasum":"1cebcedde2c52261591bc322b176638798336a24","modified":1537528790000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.eot","shasum":"4c7bcece73621f648fa71d58fa13c28670fed8ca","modified":1537528790000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff2","shasum":"ba50c427166090361b0dab4c72136c7b451e86d4","modified":1537528790000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff","shasum":"1364845a3815740c572e29c83fd8d54f1c1ef5de","modified":1537528790000},{"_id":"themes/fexo/source/fonts/fontello.eot","shasum":"7732065eeaec4614e9548955d9bd30ccd7b149c1","modified":1537528790000},{"_id":"themes/fexo/source/fonts/fontello.woff2","shasum":"1dfbc23328582f7cd9bcbe538224f6c762023e43","modified":1537528790000},{"_id":"themes/fexo/source/fonts/fontello.woff","shasum":"45737fea847f3942ef405f00ea4df940fbb6bbd9","modified":1537528790000},{"_id":"themes/fexo/source/fonts/fontello.ttf","shasum":"e255d37ca14348e9a8532667a757ab552e58caff","modified":1537528790000},{"_id":"themes/fexo/source/fonts/fontello.svg","shasum":"33a984f4482a5ba5e7bc67d82e8db63cda4e3ae1","modified":1537528790000},{"_id":"themes/fexo/source/images/avatar.jpeg","shasum":"8070d5f8c87a105b50bb28500c0c1237fae57afb","modified":1537528790000},{"_id":"themes/fexo/source/js/app.js","shasum":"a6d6e7fba3d69d0dec2c4d18debe0dc4cc7ab319","modified":1537528790000},{"_id":"themes/fexo/source/js/bundle.js","shasum":"7da160b15a43ce19273ec85204828bd42628546f","modified":1537528790000},{"_id":"themes/fexo/source/js/fastclick.js","shasum":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1537528790000},{"_id":"themes/fexo/source/sass/_animate.scss","shasum":"8de97c948cb4b9c9b7a87c0f7332ed534c378e26","modified":1537528790000},{"_id":"themes/fexo/source/js/util.js","shasum":"8136da2bec1faf5fe3e14fa436f501292fca8c07","modified":1537528790000},{"_id":"themes/fexo/source/js/scroll-spy.js","shasum":"81b81362fcd63592045a673b54ce1edb7a6e3028","modified":1537528790000},{"_id":"themes/fexo/source/js/zenscroll.js","shasum":"bea2a3571555fdae64e8fc56f161f9a4f427b335","modified":1537528790000},{"_id":"themes/fexo/source/sass/_common.scss","shasum":"b1fc97d6d24a92a9a7a9d39be4fe844f5c0f6d44","modified":1537528790000},{"_id":"themes/fexo/source/sass/_fonts.scss","shasum":"10e188d379782ae2ee10427544919557036d0137","modified":1537528790000},{"_id":"themes/fexo/source/sass/_fontello.scss","shasum":"f2d6b86bb63459884cf63e8c045fd10c827396eb","modified":1537528790000},{"_id":"themes/fexo/source/sass/_highlight-js.scss","shasum":"38a5c4d9f3a2943aff9bde1d624d710587e3bc05","modified":1537528790000},{"_id":"themes/fexo/source/sass/_normalize.scss","shasum":"e58275a588bb631a37a2988145eea231ed23176b","modified":1537528790000},{"_id":"themes/fexo/source/sass/_type.scss","shasum":"cc7a25654593030f5214d5adf85f12a954c373c5","modified":1537528790000},{"_id":"themes/fexo/source/sass/_base.scss","shasum":"83f01dbe82e47ce781c6e7eb8a793d95d97e168b","modified":1537528790000},{"_id":"themes/fexo/source/sass/_variable.scss","shasum":"7b05581ef035a88bd1191914ff992103c7812bdf","modified":1537528790000},{"_id":"themes/fexo/source/sass/component/_category-box.scss","shasum":"a807145b74d1b98270ea19ae35edd25b4c448bfa","modified":1537528790000},{"_id":"themes/fexo/source/sass/component/_back-top.scss","shasum":"1c67da7007f4b9d8c65deea3d82c0f579e65f2c2","modified":1537528790000},{"_id":"themes/fexo/source/sass/component/_donation.scss","shasum":"172a3d5f747ba028d7e10e6f03ebc1db4d487a54","modified":1537528790000},{"_id":"themes/fexo/source/sass/component/_comments.scss","shasum":"3e9b61bc08f38f947f54e942986a19a7f95ce723","modified":1537528790000},{"_id":"themes/fexo/source/sass/component/_hint.scss","shasum":"2812b4e10313168f2e082b740c60d64a151d94c8","modified":1537528790000},{"_id":"themes/fexo/source/sass/component/_item-category-name.scss","shasum":"119840d160cd263b57e79e2099a81079d7eeee3d","modified":1537528790000},{"_id":"themes/fexo/source/sass/component/_index.scss","shasum":"a741a0bfb47d0acdef12cdeb968c104bb002f86d","modified":1537528790000},{"_id":"themes/fexo/source/sass/component/_item-post.scss","shasum":"1fb2e9be2d2edbb538cfbce7c80d5847f88e2f05","modified":1537528790000},{"_id":"themes/fexo/source/sass/component/_list-post.scss","shasum":"43564f6443385bf34e15672d1477d1c7560f5563","modified":1537528790000},{"_id":"themes/fexo/source/sass/component/_item-year.scss","shasum":"12c147dd4ab9587cd622083c86c2f6cf07d8e26a","modified":1537528790000},{"_id":"themes/fexo/source/sass/component/_modal.scss","shasum":"2f0ed96df388ec28445b1ce5c6a61a0a697f9a68","modified":1537528790000},{"_id":"themes/fexo/source/sass/component/_item-title.scss","shasum":"cdaca2858abc9428ef01103a7fbea8f095d856aa","modified":1537528790000},{"_id":"themes/fexo/source/sass/component/_page-header.scss","shasum":"893d0595ef48323dce449ef0d17308ce02b36087","modified":1537528790000},{"_id":"themes/fexo/source/sass/component/_pagination.scss","shasum":"12c1880c518aee2e3ccf59661d01c308639f8a9e","modified":1537528790000},{"_id":"themes/fexo/source/sass/component/_table.scss","shasum":"4899fb31d1be8d5c9c397fcbcfc2ff0c5b2e7f7f","modified":1537528790000},{"_id":"themes/fexo/source/sass/component/_tag-box.scss","shasum":"7601951d09a75a7c39493bfa1b1da5ac989d9cda","modified":1537528790000},{"_id":"themes/fexo/source/sass/component/_toc.scss","shasum":"3b4c083cb2ba4a88ca35b6d8259ee991c83b3406","modified":1537528790000},{"_id":"themes/fexo/source/sass/component/_toolbox-mobile.scss","shasum":"f15b215b9bb103ee1773a01d8badd81bb7643710","modified":1537528790000},{"_id":"themes/fexo/source/sass/component/_toolbox.scss","shasum":"964a480d4e7fad100463195cde2a3f67f9765c23","modified":1537528790000},{"_id":"themes/fexo/source/sass/component/prev-net.scss","shasum":"2a5befab6cef93c9023a548422d5af4ab614f84d","modified":1537528790000},{"_id":"themes/fexo/source/sass/pages/_about.scss","shasum":"7d61e627ea5376390081e0b93db426ffc6c4dee8","modified":1537528790000},{"_id":"themes/fexo/source/sass/pages/_archive.scss","shasum":"fefd54282a42ebb68b711f1cfefa1f67abbde05b","modified":1537528790000},{"_id":"themes/fexo/source/sass/pages/_link.scss","shasum":"d3a249423c7ee88d1cb3a12e03f6c42a0a4d45a1","modified":1537528790000},{"_id":"themes/fexo/source/sass/pages/_home.scss","shasum":"b65bb069ed28fbf223c5bb7e760882f79d20fa46","modified":1537528790000},{"_id":"themes/fexo/source/sass/pages/_index.scss","shasum":"d9fe73a87585abad06a7dd77b67ec7ce6c24402c","modified":1537528790000},{"_id":"themes/fexo/source/sass/pages/_category.scss","shasum":"713242d10c0c8687c9e2f287f1beeb38de6cdbad","modified":1537528790000},{"_id":"themes/fexo/source/sass/pages/_search.scss","shasum":"fd28f01829628c9d21f9391d5067ddcd836dad13","modified":1537528790000},{"_id":"themes/fexo/source/sass/pages/_project.scss","shasum":"bcbaded3d378bbaa1497f4c3843994ea589f3149","modified":1537528790000},{"_id":"themes/fexo/source/sass/pages/_post.scss","shasum":"c6f694568af362f9fe1e7e2b9909e47303178116","modified":1537528790000},{"_id":"themes/fexo/source/sass/styles.scss","shasum":"86ebe05d6a2931dd6fceef1e50c31ca996dc20be","modified":1537528790000},{"_id":"themes/fexo/source/css/styles.css.map","shasum":"8153b0247617810c1333dbd40840975e0b966ecb","modified":1537528790000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.ttf","shasum":"4688935c427ae40dcbf16523bc11d9fc10e359b5","modified":1537528790000},{"_id":"source/_posts/npm-debug.log","shasum":"edfa7584626fa0d4a031a9f753e1424e9e77b1c4","modified":1537528790000},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.svg","shasum":"e21109783f218cb7849b12e867e0b775ce3fadda","modified":1537528790000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.svg","shasum":"76e1e4cee6f2b5d596c635631938ee5eb6ab3e67","modified":1537528790000},{"_id":"themes/fexo/source/fonts/Lobster-Regular.eot","shasum":"4f0c85f63beb0d95610317e16f1d4acdd2962eee","modified":1537528790000},{"_id":"themes/fexo/source/fonts/Lobster-Regular.ttf","shasum":"50a84291b7012bfdcf9ff5116d6c7aa3f257f37f","modified":1537528790000},{"_id":"themes/fexo/source/fonts/Lobster-Regular.woff","shasum":"298b80b1c9f694e1a055d62a5d809863c89baf50","modified":1537528790000},{"_id":"themes/fexo/source/fonts/Lobster-Regular.svg","shasum":"be1cab622c673942fb4d11a23c012227938b4792","modified":1537528790000},{"_id":"public/Activity是如何画到屏幕上的/1.png","modified":1537529149104,"shasum":"debc8cd768ed120de79b9d4cf59f4d08c5d2cb26"},{"_id":"public/责任链模式/链式结构.png","modified":1537529149118,"shasum":"3f6938381305c17724f5fa9bf3a5eed0ffe7bfbb"},{"_id":"public/责任链模式/Touch事件传递过程.png","modified":1537529149128,"shasum":"62b88092173964ebd41fc77e4e6fcacdb506e3fc"},{"_id":"public/责任链模式/Touch事件传递机制例子.png","modified":1537529149136,"shasum":"0e3c89ec086baf4bbf09c3f4059c1144858f48ad"},{"_id":"public/浅谈SurfaceView与GLSurfaceView/2.jpg","modified":1537529149140,"shasum":"6d4604703c9c2f5ef0a31c69ee153dcf279b0079"},{"_id":"public/浅谈SurfaceView与GLSurfaceView/1.jpg","modified":1537529149146,"shasum":"ed1a9c30ad3943b6eda1a430c94d41b3c875ff51"},{"_id":"public/我也来谈一谈Java-GC/5.png","modified":1537529149155,"shasum":"04ebdb3ea1f1b8a07a347e0e2bf26c780d53a5e4"},{"_id":"public/我也来谈一谈Java-GC/4.png","modified":1537529149168,"shasum":"dffb1b5f1aa1742aca8c0d7cbd7a7cc6d68be7d0"},{"_id":"public/我也来谈一谈Java-GC/3.png","modified":1537529149173,"shasum":"bc44ea5c4f43ef10f3b54ee1b20d25996622d0e2"},{"_id":"public/我也来谈一谈Java-GC/2.png","modified":1537529149179,"shasum":"d468934241d14a35beab12ecca80ea5936aa89e2"},{"_id":"public/我也来谈一谈Java-GC/1.png","modified":1537529149184,"shasum":"a606895d331630174eda5709793038d62a6dffce"},{"_id":"public/安卓皮肤包机制的原理/image.jpeg","modified":1537529149188,"shasum":"1ab724d684cd700c0865dcba77efd028b9973de1"},{"_id":"public/安卓广播的底层实现原理/2.png","modified":1537529149191,"shasum":"59feeedc152b8400146290c20c52b2bff4492f01"},{"_id":"public/安卓广播的底层实现原理/1.png","modified":1537529149194,"shasum":"9c925240a537d1263966733e9f781dd3c29648be"},{"_id":"public/安卓嵌套滚动NestedScroll了解一下/2.png","modified":1537529149197,"shasum":"a2b8fbd312d5e1e4f1f5244b7a664a7bb185a58b"},{"_id":"public/安卓嵌套滚动NestedScroll了解一下/1.gif","modified":1537529149203,"shasum":"a1f21b3abbf5656dbe9a70e4416519c98996b0c3"},{"_id":"public/学习HTTP协议-用socket实现http访问/7.jpg","modified":1537529149210,"shasum":"d76e0337a125de3fca3c520dec0bcdfd8464872c"},{"_id":"public/学习HTTP协议-用socket实现http访问/6.jpg","modified":1537529149218,"shasum":"6ca6b0a230be1d9f4c16beccfcbb2b144a7a08b0"},{"_id":"public/学习HTTP协议-用socket实现http访问/5.jpg","modified":1537529149221,"shasum":"5c8d09c4b8742d59d7c7b72c5a9c46b5c7b372a4"},{"_id":"public/学习HTTP协议-用socket实现http访问/4.jpg","modified":1537529149225,"shasum":"f84a7d6674febbe035a6dccdd311dd5e406b5dc4"},{"_id":"public/学习HTTP协议-用socket实现http访问/3.jpg","modified":1537529149233,"shasum":"745d3eb20e1d42ed0ccad9596d5efe2c59f619a7"},{"_id":"public/学习HTTP协议-用socket实现http访问/2.jpg","modified":1537529149242,"shasum":"35480d5b35636ab51af44e48ca77c057bf4e771f"},{"_id":"public/学习HTTP协议-用socket实现http访问/1.jpg","modified":1537529149249,"shasum":"300cc7098c616d5c2e0b28db47d2dc8b1732ef75"},{"_id":"public/学习HTTP协议-在安卓上的使用Cookie与Session/9.jpg","modified":1537529149252,"shasum":"cd77fb9f1242143d8430958a0b19fea94f1f5c4a"},{"_id":"public/学习HTTP协议-在安卓上的使用Cookie与Session/8.jpg","modified":1537529149255,"shasum":"0603ad18102173f78c6171a464409a354360f5d6"},{"_id":"public/学习HTTP协议-在安卓上的使用Cookie与Session/7.jpg","modified":1537529149261,"shasum":"ccd9492ddd2c01bb6e23bdea7fb5b0c564ead0b5"},{"_id":"public/学习HTTP协议-在安卓上的使用Cookie与Session/6.jpg","modified":1537529149269,"shasum":"fcbaab58a97f22457892caf6e7549a34ce6ce242"},{"_id":"public/学习HTTP协议-在安卓上的使用Cookie与Session/5.jpg","modified":1537529149273,"shasum":"48bb3883ee86eaef233065c106e6cb681df4fcee"},{"_id":"public/学习HTTP协议-在安卓上的使用Cookie与Session/4.jpg","modified":1537529149277,"shasum":"3a79ec8254a714302c108f80edf52eb34f97ba76"},{"_id":"public/学习HTTP协议-在安卓上的使用Cookie与Session/3.jpg","modified":1537529149281,"shasum":"a4cd99529e06cde03c86de83ad798981c8a916ac"},{"_id":"public/学习HTTP协议-在安卓上的使用Cookie与Session/2.jpg","modified":1537529149285,"shasum":"37042f8420bb0d38c2b8829b8921907ab3b7ba75"},{"_id":"public/学习HTTP协议-在安卓上的使用Cookie与Session/1.jpg","modified":1537529149291,"shasum":"01fee1734f999cf6907e7363bf940f259cdbd096"},{"_id":"public/如何实现安卓消息推送/4.png","modified":1537529149294,"shasum":"f891f2143896296785a1bb3d6440829e308ed13a"},{"_id":"public/如何实现安卓消息推送/3.png","modified":1537529149296,"shasum":"6a1d99f11d5fa2eda4502df7d5f08dcc4893d39c"},{"_id":"public/如何实现安卓消息推送/2.png","modified":1537529149299,"shasum":"61d53257c0aa150dd2e090949bb81beb2bf77cd1"},{"_id":"public/如何实现安卓消息推送/1.png","modified":1537529149301,"shasum":"56147ada9a79b36d06a2b08b191393fbd422e6b9"},{"_id":"public/在android上使用grpc/proto_gen.jpeg","modified":1537529149304,"shasum":"d8115287cbf64e80bf258adef0d9ba51c033733d"},{"_id":"public/写给安卓程序员的cc-编译入门/1.png","modified":1537529149308,"shasum":"a81d7333cdb5e80da8891f1cfa8351ff8c942fd2"},{"_id":"public/从源码看安卓应用的启动过程/2.png","modified":1537529149311,"shasum":"6d902016370e3ef413dbac0113c16e0c91ba3c81"},{"_id":"public/从源码看安卓应用的启动过程/1.png","modified":1537529149319,"shasum":"5d5d9456b8eb99dfa258ee212f1c1bdaada1b2e7"},{"_id":"public/从源码看Activity生命周期/4.png","modified":1537529149331,"shasum":"925d24241f189296ba1b47007b0b0abd918f085f"},{"_id":"public/从源码看Activity生命周期/3.png","modified":1537529149344,"shasum":"908831f54630d5f5ceb12a3eaf37873422226d2c"},{"_id":"public/从源码看Activity生命周期/2.png","modified":1537529149351,"shasum":"4255db23b9bd4b2673d0b085ca9fbd7e4390356c"},{"_id":"public/从源码看Activity生命周期/1.png","modified":1537529149367,"shasum":"3c05c4b1adc9bf2950832cd92b3cb2d21dde1e80"},{"_id":"public/sass/styles.scss","modified":1537529149372,"shasum":"86ebe05d6a2931dd6fceef1e50c31ca996dc20be"},{"_id":"public/head.jpg","modified":1537529149389,"shasum":"02cfa3e329a8fff4756f336b15488a3f6fa0e783"},{"_id":"public/sass/component/prev-net.scss","modified":1537529149398,"shasum":"2a5befab6cef93c9023a548422d5af4ab614f84d"},{"_id":"public/js/zenscroll.js","modified":1537529149408,"shasum":"bea2a3571555fdae64e8fc56f161f9a4f427b335"},{"_id":"public/js/util.js","modified":1537529149424,"shasum":"8136da2bec1faf5fe3e14fa436f501292fca8c07"},{"_id":"public/js/scroll-spy.js","modified":1537529149430,"shasum":"81b81362fcd63592045a673b54ce1edb7a6e3028"},{"_id":"public/js/fastclick.js","modified":1537529149434,"shasum":"06cef196733a710e77ad7e386ced6963f092dc55"},{"_id":"public/js/bundle.js","modified":1537529149441,"shasum":"7da160b15a43ce19273ec85204828bd42628546f"},{"_id":"public/js/app.js","modified":1537529149449,"shasum":"a6d6e7fba3d69d0dec2c4d18debe0dc4cc7ab319"},{"_id":"public/images/avatar.jpeg","modified":1537529149451,"shasum":"8070d5f8c87a105b50bb28500c0c1237fae57afb"},{"_id":"public/fonts/fontello.woff2","modified":1537529149454,"shasum":"1dfbc23328582f7cd9bcbe538224f6c762023e43"},{"_id":"public/fonts/fontello.woff","modified":1537529149470,"shasum":"45737fea847f3942ef405f00ea4df940fbb6bbd9"},{"_id":"public/fonts/fontello.ttf","modified":1537529149482,"shasum":"e255d37ca14348e9a8532667a757ab552e58caff"},{"_id":"public/fonts/fontello.svg","modified":1537529149492,"shasum":"33a984f4482a5ba5e7bc67d82e8db63cda4e3ae1"},{"_id":"public/fonts/fontello.eot","modified":1537529149503,"shasum":"7732065eeaec4614e9548955d9bd30ccd7b149c1"},{"_id":"public/fonts/calligraffitti-regular-webfont.woff2","modified":1537529149514,"shasum":"ba50c427166090361b0dab4c72136c7b451e86d4"},{"_id":"public/fonts/calligraffitti-regular-webfont.woff","modified":1537529149521,"shasum":"1364845a3815740c572e29c83fd8d54f1c1ef5de"},{"_id":"public/fonts/calligraffitti-regular-webfont.ttf","modified":1537529149536,"shasum":"4688935c427ae40dcbf16523bc11d9fc10e359b5"},{"_id":"public/fonts/calligraffitti-regular-webfont.svg","modified":1537529149572,"shasum":"76e1e4cee6f2b5d596c635631938ee5eb6ab3e67"},{"_id":"public/fonts/calligraffitti-regular-webfont.eot","modified":1537529149582,"shasum":"4c7bcece73621f648fa71d58fa13c28670fed8ca"},{"_id":"public/fonts/PoiretOne-Regular.woff","modified":1537529149634,"shasum":"1cebcedde2c52261591bc322b176638798336a24"},{"_id":"public/fonts/PoiretOne-Regular.ttf","modified":1537529149638,"shasum":"2b186ce205301f7f3abd441f0372b72adcd2aee3"},{"_id":"public/fonts/PoiretOne-Regular.svg","modified":1537529149649,"shasum":"e21109783f218cb7849b12e867e0b775ce3fadda"},{"_id":"public/fonts/PoiretOne-Regular.eot","modified":1537529149653,"shasum":"2a4ef0d00fb77d16e37c3da429698b029e7d2d2f"},{"_id":"public/fonts/Lobster-Regular.woff","modified":1537529149664,"shasum":"298b80b1c9f694e1a055d62a5d809863c89baf50"},{"_id":"public/fonts/Lobster-Regular.ttf","modified":1537529149685,"shasum":"50a84291b7012bfdcf9ff5116d6c7aa3f257f37f"},{"_id":"public/fonts/Lobster-Regular.svg","modified":1537529149697,"shasum":"be1cab622c673942fb4d11a23c012227938b4792"},{"_id":"public/fonts/Lobster-Regular.eot","modified":1537529149705,"shasum":"4f0c85f63beb0d95610317e16f1d4acdd2962eee"},{"_id":"public/css/styles.css.map","modified":1537529149714,"shasum":"8153b0247617810c1333dbd40840975e0b966ecb"},{"_id":"public/css/styles.css","modified":1537529149730,"shasum":"c4d6a1f5403cf2fe2674ba82eb2b32b0fd7dfdb8"},{"_id":"public/ToolBar-学习笔记/5.jpg","modified":1537529149735,"shasum":"574f078706926749984a044666681d08529a6a72"},{"_id":"public/ToolBar-学习笔记/4.jpg","modified":1537529149738,"shasum":"17a1219db2c52dfa273a46a8593e55bfe3631d92"},{"_id":"public/ToolBar-学习笔记/3.jpg","modified":1537529149741,"shasum":"714276352a2a1c690098d9843740503b27623fbd"},{"_id":"public/ToolBar-学习笔记/2.jpg","modified":1537529149745,"shasum":"3fb70bb82f049f3ab465b87cb6e07e9036fc4f36"},{"_id":"public/ToolBar-学习笔记/1.jpg","modified":1537529149749,"shasum":"25a1dfbe2965580783076680941c4d25f252c512"},{"_id":"public/Retrofit-学习笔记/8.jpg","modified":1537529149752,"shasum":"a9b081cbf55a638728dfa4a220ab3e53525bba7d"},{"_id":"public/Retrofit-学习笔记/7.jpg","modified":1537529149757,"shasum":"5bbb31731860d741fc6440e00af04e2d171ef6f4"},{"_id":"public/Retrofit-学习笔记/6.jpg","modified":1537529149760,"shasum":"af52d69d5bca71994c2818df74b1985c3077748b"},{"_id":"public/Retrofit-学习笔记/5.jpg","modified":1537529149762,"shasum":"7147cb1e0ed1d771d71cda564af15369e32c82cc"},{"_id":"public/Retrofit-学习笔记/4.jpg","modified":1537529149770,"shasum":"7d9ba9c23107656f00ade70544658e96f72c1453"},{"_id":"public/Retrofit-学习笔记/3.jpg","modified":1537529149776,"shasum":"4646315828e672833e42450949da1d5f99897907"},{"_id":"public/Retrofit-学习笔记/2.jpg","modified":1537529149780,"shasum":"1577be4677801ddbbc25c5af5d1466f04a10f0cb"},{"_id":"public/Retrofit-学习笔记/1.jpg","modified":1537529149783,"shasum":"df6d9b6866a07723a2d9ae476e0678da06c34b6c"},{"_id":"public/OpenSLES学习笔记/3.png","modified":1537529149786,"shasum":"2e66ca0578da312ca9b27693170761e06d7f831b"},{"_id":"public/OpenSLES学习笔记/2.png","modified":1537529149792,"shasum":"3c0cb5d4ccea5d261fc86ef695cc78d69693de6f"},{"_id":"public/OpenSLES学习笔记/1.png","modified":1537529149798,"shasum":"2fb3944dba82b74bd5ffc439d7f8ae493e19ceba"},{"_id":"public/OkHttp源码解析/3.png","modified":1537529149805,"shasum":"93dfb4e0200e6f9f66ca81679cdc7f9194a77649"},{"_id":"public/OkHttp源码解析/2.png","modified":1537529149809,"shasum":"ad3a791101933b98338079a09f65d18b433a29e5"},{"_id":"public/OkHttp源码解析/1.png","modified":1537529149811,"shasum":"ce03edaea0a7e87b745c4215cc82e3c38e506901"},{"_id":"public/Java多线程-线程池/2.png","modified":1537529149815,"shasum":"63de1cc6e70d173108aaa75a15583aad749f0bce"},{"_id":"public/Java多线程-线程池/1.png","modified":1537529149819,"shasum":"afa10d94a480c4490e61ded63a4893b9d5f7a7e2"},{"_id":"public/Java多线程-Future模式/1.png","modified":1537529149825,"shasum":"b51d61d942ffe0b5db050814a71f71802079bbf4"},{"_id":"public/GTest实例解析/1.jpg","modified":1537529149832,"shasum":"b93eed3e0078af4a801df5f03e05e60ee5818e31"},{"_id":"public/DrawerLayout-学习笔记/7.jpg","modified":1537529149836,"shasum":"180a84f0559f14906d924067241ea5b74ee27e39"},{"_id":"public/DrawerLayout-学习笔记/6.jpg","modified":1537529149839,"shasum":"8c9fe475e5beb5b877886843d335cab1449df347"},{"_id":"public/DrawerLayout-学习笔记/5.jpg","modified":1537529149842,"shasum":"d830ab772f92330b2c5e7476dc6ca3fec343d550"},{"_id":"public/DrawerLayout-学习笔记/4.jpg","modified":1537529149844,"shasum":"d64e85ba03bd98399ac3b6b68d99ef30da19b3b1"},{"_id":"public/DrawerLayout-学习笔记/3.jpg","modified":1537529149847,"shasum":"bd3d95b33b66306f61cfed5a869a5091496a2f08"},{"_id":"public/DrawerLayout-学习笔记/2.jpg","modified":1537529149849,"shasum":"8d7c95ce009525f48e47a6de17e8f4d96347068b"},{"_id":"public/DrawerLayout-学习笔记/1.jpg","modified":1537529149857,"shasum":"1a1368dfbac23b479812fe84f102184d549a4c98"},{"_id":"public/CNAME","modified":1537529149859,"shasum":"c7cb3d91a694837c9e8ffb170e337117ff6ce49d"},{"_id":"public/Android温故而知新-launchMode/standard3.png","modified":1537529149863,"shasum":"cd0f47c6c7dadf39cc9735afe98fd2f17fc8e507"},{"_id":"public/Android温故而知新-launchMode/standard2.png","modified":1537529149868,"shasum":"8404ca9d713d7c9b1badb13479a149c430cffc8f"},{"_id":"public/Android温故而知新-launchMode/standard1.png","modified":1537529149872,"shasum":"b889819d9da5c520ae1cc9a62935f90f048966ed"},{"_id":"public/Android温故而知新-launchMode/singleTop5.png","modified":1537529149892,"shasum":"fe674f3faf34cebf316563d44de0e7898bc65a73"},{"_id":"public/Android温故而知新-launchMode/singleTop4.png","modified":1537529149904,"shasum":"2e04fc22f20490033d3461fd50583c9e34017086"},{"_id":"public/Android温故而知新-launchMode/singleTop3.png","modified":1537529149930,"shasum":"d3a4843821215b325aecf69d035b21527b970794"},{"_id":"public/Android温故而知新-launchMode/singleTop2.png","modified":1537529149952,"shasum":"1b7e94e098bc5b0ef1b65b1ca657e0fa5c0495c4"},{"_id":"public/Android温故而知新-launchMode/singleTop1.png","modified":1537529149961,"shasum":"5b4e346fd5b817d6b9e2561792397e52eb5c14be"},{"_id":"public/Android温故而知新-launchMode/singleTask2.png","modified":1537529149970,"shasum":"9b4241e3bc764d7d693bfaec462e8d42cdf27b56"},{"_id":"public/Android温故而知新-launchMode/singleTask1.png","modified":1537529149974,"shasum":"c32ab30f9b1b32468e67c12c16d8a88cab7fda9f"},{"_id":"public/Android温故而知新-launchMode/singleInstance3.png","modified":1537529149999,"shasum":"6ad5db13f2cfd0334a93fc6950d2326c1c68c388"},{"_id":"public/Android温故而知新-launchMode/singleInstance2.png","modified":1537529150006,"shasum":"0d4b9733fe6ab325d013fcfe67451cb85e000280"},{"_id":"public/Android温故而知新-launchMode/singleInstance1.png","modified":1537529150016,"shasum":"cf61ec2c4735211cad1ecdc2deb940416860f0fd"},{"_id":"public/Android温故而知新-Java的四种引用/1.png","modified":1537529150019,"shasum":"1903b1ddbf40c8f9d3b0513380833b11d4f2f746"},{"_id":"public/Android温故而知新-Handler/2.png","modified":1537529150043,"shasum":"8c202a0c258a9836acd3240e11f94f20e6f33ff0"},{"_id":"public/Android温故而知新-Handler/1.png","modified":1537529150052,"shasum":"609a5ac68dbf3da398b7da6e601c730c5f3457e1"},{"_id":"public/Android温故而知新-ClassLoader/1.png","modified":1537529150065,"shasum":"b9f9a75061beffe87f550cf3425a7ba26274643a"},{"_id":"public/Android温故而知新-AIDL/1.png","modified":1537529150084,"shasum":"2d4455f7682b0a88a8dc34066cb504b4dfaad82b"},{"_id":"public/Activity是如何画到屏幕上的/2.png","modified":1537529150089,"shasum":"35c7bb33d2f887149ba626ed53b3162ed8d2ac01"},{"_id":"public/tag/index.html","modified":1537529150210,"shasum":"d7b69dfb9946c3262c7552f18e9a067fb4e121f8"},{"_id":"public/link/index.html","modified":1537529150219,"shasum":"c2c415729873c9e0e0d3b32cf7d3c278f52c5169"},{"_id":"public/about/index.html","modified":1537529150226,"shasum":"8a0943e798fae1301ecfb50385a08accc7abe965"},{"_id":"public/2018/09/21/浅谈SurfaceView与GLSurfaceView/index.html","modified":1537529150317,"shasum":"0af48483fb5fdf910cc4dda2ede3fff62d2c5f56"},{"_id":"public/2018/09/01/OpenSLES学习笔记/index.html","modified":1537529150386,"shasum":"69195acdc5fe2263e2573fb7ade0be18eeba3c18"},{"_id":"public/2018/07/29/写给安卓程序员的cc-编译入门/index.html","modified":1537529150414,"shasum":"6bc5bfda84260f02ec651f276149724c3b5b8339"},{"_id":"public/2018/06/04/安卓嵌套滚动NestedScroll了解一下/index.html","modified":1537529150442,"shasum":"304909d349c2656f2c004bdce7f35a96be521684"},{"_id":"public/2018/03/08/从源码看安卓应用的启动过程/index.html","modified":1537529150466,"shasum":"bd148cf48c26790d5444d8140179e4a794b57c35"},{"_id":"public/2018/03/07/从源码看Activity生命周期/index.html","modified":1537529150496,"shasum":"fa9d3aa28dabc1854b6c0eb1c182069468f03b38"},{"_id":"public/2018/02/28/Activity是如何画到屏幕上的/index.html","modified":1537529150546,"shasum":"c1248b8e5f10799cadbed5c4d6dbca9d4166bd0b"},{"_id":"public/2018/02/20/kotlin到底好在哪里/index.html","modified":1537529150585,"shasum":"33963cff5f5ee730e840e144fac18988924f6b94"},{"_id":"public/2018/02/10/安卓广播的底层实现原理/index.html","modified":1537529150649,"shasum":"e5aedb1b8fdbd6a58b8921a1fc3ff1d2a29ef064"},{"_id":"public/2018/02/04/再谈Java泛型/index.html","modified":1537529150723,"shasum":"b4b8116ea49b9afdcb82d39e777d064470817b6e"},{"_id":"public/2018/01/06/小米笔记本pro 15.6寸安装ubuntu16.04无法使用wifi的解决方法/index.html","modified":1537529150740,"shasum":"3e796161faeda7cb6717b63a29e80b1af3d51129"},{"_id":"public/2018/01/06/java泛型那些事/index.html","modified":1537529150798,"shasum":"2f355d88540b25e058cce16547f91136e788a243"},{"_id":"public/2017/12/30/OkHttp源码解析/index.html","modified":1537529150853,"shasum":"3cecd058ce64ef615eb45e3a96bdc8bcfe8f3899"},{"_id":"public/2017/12/14/如何实现安卓消息推送/index.html","modified":1537529150909,"shasum":"1b571a24878ca7e48bf498d7e98b62bcd12259dc"},{"_id":"public/2017/11/10/我也来谈一谈Java-GC/index.html","modified":1537529150922,"shasum":"57bb1236646557374d5ad02bd73615609de048e7"},{"_id":"public/2017/09/28/Android温故而知新-ClassLoader/index.html","modified":1537529151008,"shasum":"42f9a1d94b6bbb47a31b9f53c09fda2978849db7"},{"_id":"public/2017/09/26/Android温故而知新-AIDL/index.html","modified":1537529151093,"shasum":"25d2b55024bae6128d7aa6849922ccf8abb162f6"},{"_id":"public/2017/09/09/Java多线程-Future模式/index.html","modified":1537529151128,"shasum":"a258026f67fa2c8935fda23270b702042ba4c4a3"},{"_id":"public/2017/09/05/Java多线程-线程池/index.html","modified":1537529151152,"shasum":"4314e8aebf71f50c74acedfa7a0bbaabe7c71471"},{"_id":"public/2017/08/31/Java多线程-各种线程锁/index.html","modified":1537529151242,"shasum":"ecec66cbe12ad93bd8bef7ab70464e7276734611"},{"_id":"public/2017/08/26/用PowerMock进行Android单元测试与BDD行为驱动开发/index.html","modified":1537529151283,"shasum":"214da6f2e1a08b08bb05782638fe18c2a373b45b"},{"_id":"public/2017/08/24/Java多线程-如何正确的终止线程/index.html","modified":1537529151302,"shasum":"0d5723b69ccfd857a8afcfe44d9327b3ca526a64"},{"_id":"public/2017/08/01/安卓皮肤包机制的原理/index.html","modified":1537529151329,"shasum":"7a11d7db034175463fa4d1fca6883e0d368ee6c5"},{"_id":"public/2017/07/06/Android温故而知新-Java的四种引用/index.html","modified":1537529151353,"shasum":"50c8c627d87b547064a2dbcb83421b320bf55c8c"},{"_id":"public/2017/07/02/Android温故而知新-Handler/index.html","modified":1537529151402,"shasum":"d64273e175e2131ac502108ca50fa67ba85e9aa8"},{"_id":"public/2017/06/30/Android温故而知新-launchMode/index.html","modified":1537529151426,"shasum":"0803935f91db2755ac95fbe2c0237a89a31fa872"},{"_id":"public/2017/06/06/c++模板中的class和typename/index.html","modified":1537529151526,"shasum":"00708967529de63586a2cb92ae67ff649d715f9c"},{"_id":"public/2017/06/03/在Android中使用注解生成Java代码-AbstractProcessor/index.html","modified":1537529151571,"shasum":"5567bd94bbdf2171519065ed6e4022db7aa65f16"},{"_id":"public/2017/05/17/Dagger2学习笔记-二/index.html","modified":1537529151604,"shasum":"f47a774c2f4b6da063cde8c21b16f04ea68c0f68"},{"_id":"public/2017/05/13/Dagger2学习笔记-一/index.html","modified":1537529151649,"shasum":"09042e1e819243019ed65a7c99440f6d71e87ddf"},{"_id":"public/2017/04/02/automake学习笔记-交叉编译/index.html","modified":1537529151675,"shasum":"5dd523bd78ab58ac35ab0309d17aa256c370bf17"},{"_id":"public/2017/03/26/automake学习笔记-安装与发布/index.html","modified":1537529151705,"shasum":"896fe139d0c9852669c5ea1018944fefb5c4acfc"},{"_id":"public/2017/03/21/automake学习笔记-模块化编译/index.html","modified":1537529151764,"shasum":"650452712eaede99ef7582bc06113d9b5ac937a6"},{"_id":"public/2017/03/17/automake学习笔记-helloworld/index.html","modified":1537529151804,"shasum":"d55bfd9f535639c6b419c4a835c80cdbd717eade"},{"_id":"public/2017/03/03/在android上使用grpc/index.html","modified":1537529151862,"shasum":"fd1b63f0be31f15c4152cd68ba446dd1f957c663"},{"_id":"public/2016/11/18/责任链模式/index.html","modified":1537529151930,"shasum":"0bfa78d3b7ec0c4edc4805147585df5dd3af7b5f"},{"_id":"public/2016/11/16/lua面向对象编程/index.html","modified":1537529152002,"shasum":"7b1941b18d5bd91c65ee98f2de618fdee198fb71"},{"_id":"public/2016/10/28/lua元表/index.html","modified":1537529152026,"shasum":"45b13f2338e808c875d118aad1120d09c0085b71"},{"_id":"public/2016/10/23/lua泛型for的原理/index.html","modified":1537529152067,"shasum":"dea847eb17cb11bfeaad00aad818dcd3370b87bf"},{"_id":"public/2016/05/27/Java自定义注解和动态代理/index.html","modified":1537529152136,"shasum":"b9d77d1764e0099b4efce8fa20e7f04f7386a1a9"},{"_id":"public/2016/03/04/学习HTTP协议-用socket实现http访问/index.html","modified":1537529152225,"shasum":"c61105667456c2269981c44e1cc2f0d57e674833"},{"_id":"public/2016/03/03/学习HTTP协议-在安卓上的使用Cookie与Session/index.html","modified":1537529152320,"shasum":"be2a3fffd122d4d3fd986469fbfae8925b19de6b"},{"_id":"public/2016/02/22/Retrofit-学习笔记/index.html","modified":1537529152422,"shasum":"9db705c81d7ccc4302e1a73291e5aacfe84dca55"},{"_id":"public/2016/02/15/GTest源码剖析-测试代码的注册/index.html","modified":1537529152485,"shasum":"c916d2e2c6dac508006c5711c0326d046764e9bb"},{"_id":"public/2016/02/11/读书笔记-《黑客与画家》/index.html","modified":1537529152493,"shasum":"26e1744386313db17a185f35d7669322003c6718"},{"_id":"public/2016/02/10/读书笔记-《第一行代码——Android》/index.html","modified":1537529152500,"shasum":"c152e701e7dca871d01220d972108eda07be4030"},{"_id":"public/2016/02/08/GTest实例解析/index.html","modified":1537529152551,"shasum":"fd5d2ca1f95db363427ac6d06b8dfc7d379e4a22"},{"_id":"public/2016/01/30/读书笔记-《代码整洁之道》/index.html","modified":1537529152569,"shasum":"cf2da72a8e3f06abe66a9ab2ca02051b0726a344"},{"_id":"public/2016/01/27/DrawerLayout-学习笔记/index.html","modified":1537529152654,"shasum":"f9e42ce19729c38d79891d87312e782ed4292ce7"},{"_id":"public/2016/01/25/ToolBar-学习笔记/index.html","modified":1537529152704,"shasum":"3040b72668d19513fc6493fea030f0f365141cd3"},{"_id":"public/2016/01/21/读书笔记-《道法自然—面向对象实践指南》/index.html","modified":1537529152732,"shasum":"d253d2f7793e510c56c1671f3925cc094ab80648"},{"_id":"public/2016/01/19/使用hexo搭建个人博客/index.html","modified":1537529152754,"shasum":"58db77115d64b73867acea4aacf5d2651a4a051e"},{"_id":"public/archives/index.html","modified":1537529152772,"shasum":"b589d37117e9fa49d67e9d33ec7faac410ec8d11"},{"_id":"public/archives/page/2/index.html","modified":1537529152790,"shasum":"4559f3fdd18b72607d4258882a35c35b59456ec4"},{"_id":"public/archives/page/3/index.html","modified":1537529152799,"shasum":"c6b528d4d1ad3a3628d735f1981fedee5e233f7a"},{"_id":"public/archives/page/4/index.html","modified":1537529152807,"shasum":"d4eefda9cc2b700d0e78c257190865212bb64c22"},{"_id":"public/archives/page/5/index.html","modified":1537529152816,"shasum":"58f55371a204ab8385bb426858e9ca4a3025c29a"},{"_id":"public/archives/page/6/index.html","modified":1537529152825,"shasum":"a72e9879997828c20e40008b264ac1cf09063a1c"},{"_id":"public/archives/2016/index.html","modified":1537529152835,"shasum":"ff0530912297876153e06e5297d96924671d574d"},{"_id":"public/archives/2016/page/2/index.html","modified":1537529152845,"shasum":"75aa6146f3ef1df0df25aaaf6073b710d24e571f"},{"_id":"public/archives/2016/01/index.html","modified":1537529152857,"shasum":"b7c2f7a66593f300f6cea4497fbaf5cd449461e6"},{"_id":"public/archives/2016/02/index.html","modified":1537529152863,"shasum":"02974c397b17c2f172fe91350fedcf09bbfbdd69"},{"_id":"public/archives/2016/03/index.html","modified":1537529152870,"shasum":"d4ac2b11abf48c8054e13f8f311f918b122c7f8a"},{"_id":"public/archives/2016/05/index.html","modified":1537529152874,"shasum":"e754390f6811c7c91903f6fce3a5e8bec5f32291"},{"_id":"public/archives/2016/10/index.html","modified":1537529152880,"shasum":"7759348b578f713a08ff904e3127546a70ff2fef"},{"_id":"public/archives/2016/11/index.html","modified":1537529152888,"shasum":"3eb57a640e605e3e6fc5f26e619f7986ece94e19"},{"_id":"public/archives/2017/index.html","modified":1537529152901,"shasum":"63fd9b8fc3acabc7f5056040917ea6917d1d0bf0"},{"_id":"public/archives/2017/page/2/index.html","modified":1537529152910,"shasum":"8fcee5d59a68680a2d29e372aab4fa487863c2f6"},{"_id":"public/archives/2017/page/3/index.html","modified":1537529152919,"shasum":"624dfcb36b924b1be21a3d93c8ac7c09de9f7b46"},{"_id":"public/archives/2017/03/index.html","modified":1537529152928,"shasum":"03ef67ba2a1ff077e7c215793a35efcbfd42b857"},{"_id":"public/archives/2017/04/index.html","modified":1537529152934,"shasum":"ba7ab08cbf2186e72f6b05887701d81e6dfc6d73"},{"_id":"public/archives/2017/05/index.html","modified":1537529152940,"shasum":"924fbbc6bb4b6634488381a1ee5bdbb53ee93806"},{"_id":"public/archives/2017/06/index.html","modified":1537529152948,"shasum":"d167f442474bb3d6e3705572ba853ce6982bd00e"},{"_id":"public/archives/2017/07/index.html","modified":1537529152951,"shasum":"fe09af06d9c0492b699dc89709db4d9415f594a1"},{"_id":"public/archives/2017/08/index.html","modified":1537529152955,"shasum":"a942c0c501888f801aad0bbf0797e21994335335"},{"_id":"public/archives/2017/09/index.html","modified":1537529152964,"shasum":"0686b9f81a50304ead05cdf7775ad2599405c865"},{"_id":"public/archives/2017/11/index.html","modified":1537529152969,"shasum":"b4e41c9e9084aeb6868478e52ace96a604a89bd8"},{"_id":"public/archives/2017/12/index.html","modified":1537529152978,"shasum":"bd9265573b104a2c68bb9f58f24c653439e0a761"},{"_id":"public/archives/2018/index.html","modified":1537529152990,"shasum":"102edf4a26045b118edd6590316677d20372d097"},{"_id":"public/archives/2018/page/2/index.html","modified":1537529152996,"shasum":"0e1373dba4e0181c4656f179270f31aefc9e6dd7"},{"_id":"public/archives/2018/01/index.html","modified":1537529153004,"shasum":"ba402911bfd86c2e0f70c74ef2edaf59a5c75575"},{"_id":"public/archives/2018/02/index.html","modified":1537529153011,"shasum":"2e447665717adb374f0716ff90d48bc9ee51eed5"},{"_id":"public/archives/2018/03/index.html","modified":1537529153020,"shasum":"679302acb41686beaf09977f6bde2e86106adf7b"},{"_id":"public/archives/2018/06/index.html","modified":1537529153025,"shasum":"d644a01ab7ea8d9caa9d3cc602bd9296492c0674"},{"_id":"public/archives/2018/07/index.html","modified":1537529153030,"shasum":"cbd353fafd3aab1e5b34d6ea90cbf974633659a0"},{"_id":"public/archives/2018/09/index.html","modified":1537529153039,"shasum":"12f9fc3e135b308f298bbd65cf53adf21ad86be3"},{"_id":"public/index.html","modified":1537529153048,"shasum":"1b3199e84d547c8135421d51cadf6b58b90b24c1"},{"_id":"public/page/2/index.html","modified":1537529153056,"shasum":"fbf28e9055aa5587ba2cb988ec0c11f60edaf5bc"},{"_id":"public/page/3/index.html","modified":1537529153069,"shasum":"236dbc816f7f458e6c0e272a39107d0827ba1623"},{"_id":"public/page/4/index.html","modified":1537529153078,"shasum":"cbdf3237939ce41d9103b809441a8fb9c0b72a41"},{"_id":"public/page/5/index.html","modified":1537529153097,"shasum":"81bfaeef527d848290052c11d233470efa9ac693"},{"_id":"public/page/6/index.html","modified":1537529153101,"shasum":"81d531f313b03fa50160c94036ff9646518bb90d"},{"_id":"public/tags/技术相关/index.html","modified":1537529153155,"shasum":"8d67071e934029f800749cc8624f7968b4d1fbee"},{"_id":"public/tags/技术相关/page/2/index.html","modified":1537529153218,"shasum":"5e3ed45b7b376992eef2187d6ec5e331ae019585"},{"_id":"public/tags/技术相关/page/3/index.html","modified":1537529153301,"shasum":"6b3815d86c08aca0c8dc82cc00b7365ed257237a"},{"_id":"public/tags/技术相关/page/4/index.html","modified":1537529153450,"shasum":"287ea8f1a57dd68cefb532b3f576f892ca7e94b2"},{"_id":"public/tags/技术相关/page/5/index.html","modified":1537529153528,"shasum":"f26d02bf4b13313bdbe42bbdf5ccf329ec39ea80"},{"_id":"public/tags/设计模式/index.html","modified":1537529153583,"shasum":"1ffefeb06fbaef156b30c10c0ec3bff39e2ed4e2"},{"_id":"public/tags/读书笔记/index.html","modified":1537529153626,"shasum":"6d5d7c70c94426d10d5402f0526c34714f925e7c"},{"_id":"public/tags/Android/index.html","modified":1537529153698,"shasum":"00671800d587407d885b552de6a35c59c368ad44"},{"_id":"public/tags/Android/page/2/index.html","modified":1537529153756,"shasum":"df8739f5b6a42ef87e98f15286ea1c1d08b3b5d5"},{"_id":"public/tags/Android/page/3/index.html","modified":1537529153810,"shasum":"467d96f2ba9169862cdd4a34c6adc82fbad523ef"},{"_id":"public/tags/单元测试/index.html","modified":1537529153874,"shasum":"11d2e7ddac22687d45ff90ebf4b2a3e8a4896cf4"},{"_id":"public/tags/java/index.html","modified":1537529153918,"shasum":"8c5a3a24c3d517b957c143da3d8306be20378557"},{"_id":"public/tags/Http协议/index.html","modified":1537529153963,"shasum":"0b41ea6a3f1f7f63db752b7051b704f442eec806"},{"_id":"public/tags/C-C/index.html","modified":1537529154008,"shasum":"f70320205a070ac1308bd79f67a9d51a57a398d7"},{"_id":"public/tags/hexo/index.html","modified":1537529154052,"shasum":"5571bd9e56b57c7d9585c8aa89e279571293a312"},{"_id":"public/tags/lua/index.html","modified":1537529154094,"shasum":"f6575365fbff8be42b980590372d8748f8a7adde"},{"_id":"public/tags/kotlin/index.html","modified":1537529154132,"shasum":"4fbde80c82051d465b6e007f7ce29ff893baf073"},{"_id":"public/tags/编译相关/index.html","modified":1537529154169,"shasum":"d720aa3ffacd4820a1da2987a4cd4b3b54377553"}],"Category":[],"Data":[],"Page":[{"title":"tag","layout":"tag","comments":0,"_content":"","source":"tag/index.md","raw":"---\ntitle: tag\nlayout: tag\ncomments: false\n---\n","date":"2018-09-21T11:19:50.000Z","updated":"2018-09-21T11:19:50.000Z","path":"tag/index.html","_id":"cjmbx2uld0000w3fyx1nrkw4l"},{"title":"link","layout":"link","comments":0,"_content":"","source":"link/index.md","raw":"---\ntitle: link\nlayout: link\ncomments: false\n---\n","date":"2018-09-21T11:19:50.000Z","updated":"2018-09-21T11:19:50.000Z","path":"link/index.html","_id":"cjmbx2ulk0001w3fy1f7mn11n"},{"title":"about","layout":"about","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: about\nlayout: about\ncomments: false\n---\n","date":"2018-09-21T11:19:50.000Z","updated":"2018-09-21T11:19:50.000Z","path":"about/index.html","_id":"cjmbx2ult0002w3fy8bffc9my"}],"Post":[{"title":"责任链模式","date":"2016-11-17T18:01:31.000Z","_content":"# 什么是责任链模式\n\n责任链模式是一种对象的行为模式，它包含了一些命令对象和一系列的处理对象。是一种链型的结构，每个处理对象可以处理特定的命令对象，当遇到不能处理的命令对象的时候，就会把它传递给下一个处理对象，直到没有最后一个处理对象。\n\n{% img /责任链模式/链式结构.png %}\n\n# 责任链模式的实现\n\n从责任链模式的定义来看，使用单链表去实现它是一种最容易想到和最形象的做法。假设我们有一个解压程序，它可以解压多种不同的压缩格式。\n\n数据定义成下面的样子:\n\n```cpp\nstruct Data{\n    Data(unsigned char* data, int size) :data(data), size(size) {}\n\n    unsigned char* data;\n    unsigned int size;\n};\n```\n\n每个解压器类根据自己是否能够解压接收到的数据，判断应该直接解压数据还是传递给下一个解压器程序去解压。所以将这一逻辑抽象出来，我们可以得到下面的抽象基类:\n\n```cpp\nclass Decompressor{\npublic:\n    Decompressor() : mSuccessor(0){}\n    Decompressor(const Decompressor* successor) : mSuccessor(successor){}\n\n    void setSuccessor(const Decompressor* successor){\n        mSuccessor = successor;\n    }\n\n    Data decompress(const Data& data) const{\n        if(canDecompress(data)){\n            return doDecompress(data);\n        }else if(mSuccessor!=0){\n            return mSuccessor->decompress(data);\n        }\n        return Data(0, 0);\n    }\n\nprivate:\n    const Decompressor* mSuccessor;\n\n    virtual bool canDecompress(const Data& data)const = 0;\n    virtual Data doDecompress(const Data& data)const = 0;\n};\n```\n\n我们模拟三种数据的解压器:\n\n```cpp\nclass GZipDecompressor : public Decompressor{\npublic:\n    GZipDecompressor() { }\n    GZipDecompressor(Decompressor* successor):Decompressor(successor) { }\n\nprivate:\n    virtual bool canDecompress(const Data& data)const{\n        cout<<\"GZipDecompressor:canDecompress\"<<endl;\n        const char* d = (const char*)data.data;\n        return d && 0==strncmp(d, \"gzip\", strlen(\"gzip\"));\n    }\n\n    virtual Data doDecompress(const Data& data)const{\n        cout<<\"GZipDecompressor:doDecompress\"<<endl;\n        const char* d = \"doDecompress by GZipDecompressor\";\n        return Data((unsigned char*)d, strlen(d));\n    }\n};\n```\n\n```cpp\nclass RarDecompressor : public Decompressor{\npublic:\n    RarDecompressor() { }\n    RarDecompressor(Decompressor* successor):Decompressor(successor) { }\n\nprivate:\n    virtual bool canDecompress(const Data& data)const{\n        cout<<\"RarDecompressor:canDecompress\"<<endl;\n        const char* d = (const char*)data.data;\n        return d && 0==strncmp(d, \"rar\", strlen(\"rar\"));\n    }\n\n    virtual Data doDecompress(const Data& data)const{\n        cout<<\"RarDecompressor:doDecompress\"<<endl;\n        const char* d = \"doDecompress by RarDecompressor\";\n        return Data((unsigned char*)d, strlen(d));\n    }\n};\n```\n\n```cpp\nclass ZipDecompressor : public Decompressor{\npublic:\n    ZipDecompressor() { }\n    ZipDecompressor(Decompressor* successor):Decompressor(successor) { }\n\nprivate:\n    virtual bool canDecompress(const Data& data)const{\n        cout<<\"ZipDecompressor:canDecompress\"<<endl;\n        const char* d = (const char*)data.data;\n        return d && 0==strncmp(d, \"zip\", strlen(\"zip\"));\n    }\n\n    virtual Data doDecompress(const Data& data)const{\n        cout<<\"ZipDecompressor:doDecompress\"<<endl;\n        const char* d = \"doDecompress by ZipDecompressor\";\n        return Data((unsigned char*)d, strlen(d));\n    }\n};\n```\n\n嗯哼，是否直观的实现方式。最后是main函数和输出结果:\n\n```cpp\nint main(){\n    RarDecompressor rarDecompressor;\n    GZipDecompressor gzipDecompressor(&rarDecompressor);\n    ZipDecompressor zipDecompressor(&gzipDecompressor);\n\n    Data input((unsigned char*)\"gzip\",strlen(\"gzip\"));\n    Data output = zipDecompressor.decompress(input);\n\n    if(output.data){\n        const char* out = (const char*)output.data;\n        cout<<\"result : \"<<out<<endl;\n    }else{\n        cout<<\"result : null\"<<endl;\n    }\n\n    return 0;\n}\n```\n\n> ZipDecompressor:canDecompress  \n> GZipDecompressor:canDecompress  \n> GZipDecompressor:doDecompress  \n> result : doDecompress by GZipDecompressor\n\n可以看到，数据经过了ZipDecompressor和GZipDecompressor，最后由GZipDecompressor解压处理，整个过程没有经过RarDecompressor\n\n当然为了使代码可维护性更高，我们可以再编写一个SuperDecompressor类来包装解压操作:\n\n```cpp\nclass SuperDecompressor{\npublic:\n    Data decompressCompressedFile(const Data& data);\n\nprivate:\n    ZipDecompressor mZipDecompressor;\n    RarDecompressor mRarDecompressor;\n    GZipDecompressor mGZipDecompressor;\n};\n\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    mZipDecompressor.setSuccessor(&mGZipDecompressor);\n    mGZipDecompressor.setSuccessor(&mRarDecompressor);\n    mRarDecompressor.setSuccessor(0);\n\n    return mZipDecompressor.decompress(data);\n}\n```\n\n这个时候main函数会显得比较简单:\n\n```cpp\nint main(){\n    SuperDecompressor decompressor;\n\n    Data input((unsigned char*)\"gzip\",strlen(\"gzip\"));\n    Data output = decompressor.decompressCompressedFile(input);\n\n    if(output.data){\n        const char* out = (const char*)output.data;\n        cout<<\"result : \"<<out<<endl;\n    }else{\n        cout<<\"result : null\"<<endl;\n    }\n\n    return 0;\n}\n```\n\n输出的结果是一样的:\n> ZipDecompressor:canDecompress  \n> GZipDecompressor:canDecompress  \n> GZipDecompressor:doDecompress  \n> result : doDecompress by GZipDecompressor\n\n# 优化\n\n依靠我们程序员的直觉，下面两段代码都是很容易出错的，尤其是当Decompressor的数目很多的时候。\n\n```cpp\nint main(){\n\t //下面的三行代码容易出错\n    RarDecompressor rarDecompressor;\n    GZipDecompressor gzipDecompressor(&rarDecompressor);\n    ZipDecompressor zipDecompressor(&gzipDecompressor);\n\n    Data input((unsigned char*)\"gzip\",strlen(\"gzip\"));\n    Data output = zipDecompressor.decompress(input);\n\n    if(output.data){\n        const char* out = (const char*)output.data;\n        cout<<\"result : \"<<out<<endl;\n    }else{\n        cout<<\"result : null\"<<endl;\n    }\n\n    return 0;\n}\n```\n\n```cpp\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    mZipDecompressor.setSuccessor(&mGZipDecompressor);\n    mGZipDecompressor.setSuccessor(&mRarDecompressor);\n    mRarDecompressor.setSuccessor(0);\n\n    return mZipDecompressor.decompress(data);\n}\n```\n\n其实使用构造函数和setter方法设置下一个处理类有一个很大的问题，就是在编码的时候很容易就写错了，会出现一些意想不到的bug，而且比较难发现。同时，每次需要修改处理类的顺序或者删除其中的一个或几个处理类，都需要使用setter方法对处理链进行修改，不仅繁琐，而且也比较容易出错。\n\n基于以上的原因，我们会去想，有没有一种更加灵活的实现方式，使得构建处理链不容易出错，而且也能很简单而且很安全的修改处理链呢？\n\n其实我们可以用下面的链式结构去优化:\n\n```cpp\nclass Decompressor{\npublic:\n    Decompressor() : mSuccessor(0){}\n\n    Decompressor& next(Decompressor& successor){\n        mSuccessor = &successor;\n        successor.setSuccessor(0);\n        return successor;\n    }\n\n    Data decompress(const Data& data) const{\n        if(canDecompress(data)){\n            return doDecompress(data);\n        }else if(mSuccessor!=0){\n            return mSuccessor->decompress(data);\n        }\n        return Data(0, 0);\n    }\n\nprivate:\n    const Decompressor* mSuccessor;\n\n    virtual bool canDecompress(const Data& data)const = 0;\n    virtual Data doDecompress(const Data& data)const = 0;\n\n    void setSuccessor(const Decompressor* successor){\n        mSuccessor = successor;\n    }\n};\n```\n\n在这里，我们添加了一个next方法，同时把setSuccessor设为private,于是使用的方法就会变得简洁了许多。\n\n```cpp\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    mZipDecompressor.next(mGZipDecompressor).next(mRarDecompressor);\n    return mZipDecompressor.decompress(data);\n}\n```\n\n# 另一种灵活的实现方式\n\n\n联想一下linux的管道机制：__前一个命令的结果会传递给后一个命令__。\n\n是不是可以从中得到启发呢？是不是可以有一种架构可以使得通过下面的形式就能得到最终处理后的结果？\n\n```cpp\n\tData decompressedData = compressedData | mZipDecompressor | mGZipDecompressor | mRarDecompressor;\n```\n\n首先，很容易想到我们需要通过重载操作符去实现这种机制。我们可以重载 \"|\" 操作符，将Data和Decompressor作为参数传入，再将处理后或者没有处理的Data作为返回值返回，传到下一个Decompressor那里去。\n\n基本的思想是这样的，但是这里有个很重要的问题要处理：我们如何知道上一个Decompressor有没有解压过数据？\n\n当然可以直接调用Decompressor::canDecompress看看是否是可解压的就能知道上一个Decompressor有没有处理过数据。但是这样的处理模式有一些风险，而且也比较浪费资源，明明前一个Decompressor已经解压完成了，但是后面的Decompressor还回去判断是否可以解压，这个判断可能比较复杂。\n\n第二种解决方案就是拓展Data结构体，添加一个是否已经解压字段。这样能够完美的解决问题，但是Data的职责就变重了，他不仅要保存数据，还要知道保存的数据究竟是解压过的还是没有解压过的。而且这个标志字段只有在解压的过程中才有用，因为一般数据在存储的时候我们已经知道它是否被压缩过了，我们总不会会将未解压和解压过的数据混在一起存放的。\n\n其实还有第三种解决方法:\n\n```cpp\nstruct DataWrapper{\n    DataWrapper(const Data& data) : data(data),isDecompressed(false) {}\n\n    Data data;\n    bool isDecompressed;\n};\n```\n在DataWrapper添加了一个属性isDecompressed来标志数据是否已经解压。这个Wrapper可以只在解压过程中临时使用，不影响数据的存储。\n\n然后实现的重点就是重载操作符了，其实它的实现很简单:\n\n```cpp\nDataWrapper& operator | (DataWrapper& data, const Decompressor& decompressor){\n    if(!data.isDecompressed && decompressor.canDecompress(data.data)){\n        data.data = decompressor.doDecompress(data.data);\n        data.isDecompressed = true;\n    }\n\n    return data;\n}\n```\n\n现在Decompressor就只需要提供判断是否可以解压和进行解压的功能。所以我们可以将Decompressor基类简化下面这样。其实这样的Decompressor就相当于java里面的接口了，面向接口编程可以使得业务逻辑更加清晰，而且也更易于维护。\n\n```cpp\nclass Decompressor{\npublic:\n    virtual bool canDecompress(const Data& data)const = 0;\n    virtual Data doDecompress(const Data& data)const = 0;\n};\n```\n\n所以我们的SuperDecompressor类就可以写成下面的样子:\n\n```cpp\nclass SuperDecompressor{\npublic:\n    Data decompressCompressedFile(const Data& data);\n\nprivate:\n    ZipDecompressor mZipDecompressor;\n    RarDecompressor mRarDecompressor;\n    GZipDecompressor mGZipDecompressor;\n};\n\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mZipDecompressor | mGZipDecompressor | mRarDecompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n```\n\n而main函数是一样的:\n\n```cpp\nint main(){\n    SuperDecompressor decompressor;\n\n    Data input((unsigned char*)\"gzip\",strlen(\"gzip\"));\n\n    Data output = decompressor.decompressCompressedFile(input);\n\n    if(output.data){\n        const char* out = (const char*)output.data;\n        cout<<\"result : \"<<out<<endl;\n    }else{\n        cout<<\"result : null\"<<endl;\n    }\n\n    return 0;\n}\n```\n\n输出结果如下:\n\n> ZipDecompressor:canDecompress  \n> GZipDecompressor:canDecompress  \n> GZipDecompressor:doDecompress  \n> result : doDecompress by GZipDecompressor  \n\n所以如果我们现在需要将SuperDecompressor拓展成一个真正万能的解压类，不仅能解压压缩文件，也能解压图片，还能解压Base64编码的超级解压类也很简单了:\n\n```cpp\nclass SuperDecompressor{\n    Data decompressUnknowType(const Data& data);\n    Data decompressImage(const Data& data);\n    Data decompressCompressedFile(const Data& data);\n    Data decompressBase64(const Data& data);\n\nprivate:\n    ZipDecompressor mZipDecompressor;\n    RarDecompressor mRarDecompressor;\n    GZipDecompressor mGZipDecompressor;\n\n    JpgDecompressor mJpgDecompressor;\n    PngDecompressor mPngDecompressor;\n\n    Base64Decompressor mBase64Decompressor;\n};\n\nData SuperDecompressor::decompressUnknowType(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mZipDecompressor | mRarDecompressor | mGZipDecompressor\n            | mJpgDecompressor | mPngDecompressor\n            | mBase64Decompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n\nData SuperDecompressor::decompressImage(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mJpgDecompressor | mPngDecompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mZipDecompressor | mRarDecompressor | mGZipDecompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n\nData SuperDecompressor::decompressBase64(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mBase64Decompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n```\n\n当然，这种处理方式在数据已经被解压的情况下依然会传给下一个解压器，直到经过了整条处理链。所以会造成一定的资源浪费。\n\n# 责任链模式的实际应用场景\n\n责任链模式的实际应用，最广为人知的就是安卓View的Touch事件的传递机制了。其实这是一种双向的责任链模式。在接收到Touch事件的时候，父View会通知子View，如果子View不处理，父View才去处理。光说可能有点难懂，我们直接看源码吧:\n\n```java\npublic boolean dispatchTouchEvent(MotionEvent ev) {\n    boolean result = false;             // 默认状态为没有消费过\n\n    if (!onInterceptTouchEvent(ev)) {   // 如果没有拦截交给子View\n        result = child.dispatchTouchEvent(ev);\n    }\n\n    if (!result) {                      // 如果事件没有被消费,询问自身onTouchEvent\n        result = onTouchEvent(ev);\n    }\n\n    return result;\n}\n```\n\n代码看起来也不好懂？没关系，我用个实际的例子解释一下就明白了。首先我们有下面的一个Activity:\n\n{% img /责任链模式/Touch事件传递机制例子.png %}\n\n当我们点击最中间的那个View的时候Touch事件的传递过程如下图:\n\n{% img /责任链模式/Touch事件传递过程.png %}\n\nTouch事件通过Activity、ViewGroup1、ViewGroup2的dispatchTouchEvent方法最后到达View的dispatchTouchEvent方法，在View被处理，所以返回true。于是Activity、ViewGroup1、ViewGroup2的dispatchTouchEvent方法都会直接返回，而不会调用处理方法onTouchEvent\n\n\n# 总结\n\n这一部分本来应该讲一讲责任链模式的优缺点的，但是我自己其实不太喜欢这样的总结性的东西。所以还是留给读者自己体会吧。\n","source":"_posts/责任链模式.md","raw":"title: 责任链模式\ndate: 2016-11-18 02:01:31\ntags:\n    - 技术相关\n    - 设计模式\n---\n# 什么是责任链模式\n\n责任链模式是一种对象的行为模式，它包含了一些命令对象和一系列的处理对象。是一种链型的结构，每个处理对象可以处理特定的命令对象，当遇到不能处理的命令对象的时候，就会把它传递给下一个处理对象，直到没有最后一个处理对象。\n\n{% img /责任链模式/链式结构.png %}\n\n# 责任链模式的实现\n\n从责任链模式的定义来看，使用单链表去实现它是一种最容易想到和最形象的做法。假设我们有一个解压程序，它可以解压多种不同的压缩格式。\n\n数据定义成下面的样子:\n\n```cpp\nstruct Data{\n    Data(unsigned char* data, int size) :data(data), size(size) {}\n\n    unsigned char* data;\n    unsigned int size;\n};\n```\n\n每个解压器类根据自己是否能够解压接收到的数据，判断应该直接解压数据还是传递给下一个解压器程序去解压。所以将这一逻辑抽象出来，我们可以得到下面的抽象基类:\n\n```cpp\nclass Decompressor{\npublic:\n    Decompressor() : mSuccessor(0){}\n    Decompressor(const Decompressor* successor) : mSuccessor(successor){}\n\n    void setSuccessor(const Decompressor* successor){\n        mSuccessor = successor;\n    }\n\n    Data decompress(const Data& data) const{\n        if(canDecompress(data)){\n            return doDecompress(data);\n        }else if(mSuccessor!=0){\n            return mSuccessor->decompress(data);\n        }\n        return Data(0, 0);\n    }\n\nprivate:\n    const Decompressor* mSuccessor;\n\n    virtual bool canDecompress(const Data& data)const = 0;\n    virtual Data doDecompress(const Data& data)const = 0;\n};\n```\n\n我们模拟三种数据的解压器:\n\n```cpp\nclass GZipDecompressor : public Decompressor{\npublic:\n    GZipDecompressor() { }\n    GZipDecompressor(Decompressor* successor):Decompressor(successor) { }\n\nprivate:\n    virtual bool canDecompress(const Data& data)const{\n        cout<<\"GZipDecompressor:canDecompress\"<<endl;\n        const char* d = (const char*)data.data;\n        return d && 0==strncmp(d, \"gzip\", strlen(\"gzip\"));\n    }\n\n    virtual Data doDecompress(const Data& data)const{\n        cout<<\"GZipDecompressor:doDecompress\"<<endl;\n        const char* d = \"doDecompress by GZipDecompressor\";\n        return Data((unsigned char*)d, strlen(d));\n    }\n};\n```\n\n```cpp\nclass RarDecompressor : public Decompressor{\npublic:\n    RarDecompressor() { }\n    RarDecompressor(Decompressor* successor):Decompressor(successor) { }\n\nprivate:\n    virtual bool canDecompress(const Data& data)const{\n        cout<<\"RarDecompressor:canDecompress\"<<endl;\n        const char* d = (const char*)data.data;\n        return d && 0==strncmp(d, \"rar\", strlen(\"rar\"));\n    }\n\n    virtual Data doDecompress(const Data& data)const{\n        cout<<\"RarDecompressor:doDecompress\"<<endl;\n        const char* d = \"doDecompress by RarDecompressor\";\n        return Data((unsigned char*)d, strlen(d));\n    }\n};\n```\n\n```cpp\nclass ZipDecompressor : public Decompressor{\npublic:\n    ZipDecompressor() { }\n    ZipDecompressor(Decompressor* successor):Decompressor(successor) { }\n\nprivate:\n    virtual bool canDecompress(const Data& data)const{\n        cout<<\"ZipDecompressor:canDecompress\"<<endl;\n        const char* d = (const char*)data.data;\n        return d && 0==strncmp(d, \"zip\", strlen(\"zip\"));\n    }\n\n    virtual Data doDecompress(const Data& data)const{\n        cout<<\"ZipDecompressor:doDecompress\"<<endl;\n        const char* d = \"doDecompress by ZipDecompressor\";\n        return Data((unsigned char*)d, strlen(d));\n    }\n};\n```\n\n嗯哼，是否直观的实现方式。最后是main函数和输出结果:\n\n```cpp\nint main(){\n    RarDecompressor rarDecompressor;\n    GZipDecompressor gzipDecompressor(&rarDecompressor);\n    ZipDecompressor zipDecompressor(&gzipDecompressor);\n\n    Data input((unsigned char*)\"gzip\",strlen(\"gzip\"));\n    Data output = zipDecompressor.decompress(input);\n\n    if(output.data){\n        const char* out = (const char*)output.data;\n        cout<<\"result : \"<<out<<endl;\n    }else{\n        cout<<\"result : null\"<<endl;\n    }\n\n    return 0;\n}\n```\n\n> ZipDecompressor:canDecompress  \n> GZipDecompressor:canDecompress  \n> GZipDecompressor:doDecompress  \n> result : doDecompress by GZipDecompressor\n\n可以看到，数据经过了ZipDecompressor和GZipDecompressor，最后由GZipDecompressor解压处理，整个过程没有经过RarDecompressor\n\n当然为了使代码可维护性更高，我们可以再编写一个SuperDecompressor类来包装解压操作:\n\n```cpp\nclass SuperDecompressor{\npublic:\n    Data decompressCompressedFile(const Data& data);\n\nprivate:\n    ZipDecompressor mZipDecompressor;\n    RarDecompressor mRarDecompressor;\n    GZipDecompressor mGZipDecompressor;\n};\n\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    mZipDecompressor.setSuccessor(&mGZipDecompressor);\n    mGZipDecompressor.setSuccessor(&mRarDecompressor);\n    mRarDecompressor.setSuccessor(0);\n\n    return mZipDecompressor.decompress(data);\n}\n```\n\n这个时候main函数会显得比较简单:\n\n```cpp\nint main(){\n    SuperDecompressor decompressor;\n\n    Data input((unsigned char*)\"gzip\",strlen(\"gzip\"));\n    Data output = decompressor.decompressCompressedFile(input);\n\n    if(output.data){\n        const char* out = (const char*)output.data;\n        cout<<\"result : \"<<out<<endl;\n    }else{\n        cout<<\"result : null\"<<endl;\n    }\n\n    return 0;\n}\n```\n\n输出的结果是一样的:\n> ZipDecompressor:canDecompress  \n> GZipDecompressor:canDecompress  \n> GZipDecompressor:doDecompress  \n> result : doDecompress by GZipDecompressor\n\n# 优化\n\n依靠我们程序员的直觉，下面两段代码都是很容易出错的，尤其是当Decompressor的数目很多的时候。\n\n```cpp\nint main(){\n\t //下面的三行代码容易出错\n    RarDecompressor rarDecompressor;\n    GZipDecompressor gzipDecompressor(&rarDecompressor);\n    ZipDecompressor zipDecompressor(&gzipDecompressor);\n\n    Data input((unsigned char*)\"gzip\",strlen(\"gzip\"));\n    Data output = zipDecompressor.decompress(input);\n\n    if(output.data){\n        const char* out = (const char*)output.data;\n        cout<<\"result : \"<<out<<endl;\n    }else{\n        cout<<\"result : null\"<<endl;\n    }\n\n    return 0;\n}\n```\n\n```cpp\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    mZipDecompressor.setSuccessor(&mGZipDecompressor);\n    mGZipDecompressor.setSuccessor(&mRarDecompressor);\n    mRarDecompressor.setSuccessor(0);\n\n    return mZipDecompressor.decompress(data);\n}\n```\n\n其实使用构造函数和setter方法设置下一个处理类有一个很大的问题，就是在编码的时候很容易就写错了，会出现一些意想不到的bug，而且比较难发现。同时，每次需要修改处理类的顺序或者删除其中的一个或几个处理类，都需要使用setter方法对处理链进行修改，不仅繁琐，而且也比较容易出错。\n\n基于以上的原因，我们会去想，有没有一种更加灵活的实现方式，使得构建处理链不容易出错，而且也能很简单而且很安全的修改处理链呢？\n\n其实我们可以用下面的链式结构去优化:\n\n```cpp\nclass Decompressor{\npublic:\n    Decompressor() : mSuccessor(0){}\n\n    Decompressor& next(Decompressor& successor){\n        mSuccessor = &successor;\n        successor.setSuccessor(0);\n        return successor;\n    }\n\n    Data decompress(const Data& data) const{\n        if(canDecompress(data)){\n            return doDecompress(data);\n        }else if(mSuccessor!=0){\n            return mSuccessor->decompress(data);\n        }\n        return Data(0, 0);\n    }\n\nprivate:\n    const Decompressor* mSuccessor;\n\n    virtual bool canDecompress(const Data& data)const = 0;\n    virtual Data doDecompress(const Data& data)const = 0;\n\n    void setSuccessor(const Decompressor* successor){\n        mSuccessor = successor;\n    }\n};\n```\n\n在这里，我们添加了一个next方法，同时把setSuccessor设为private,于是使用的方法就会变得简洁了许多。\n\n```cpp\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    mZipDecompressor.next(mGZipDecompressor).next(mRarDecompressor);\n    return mZipDecompressor.decompress(data);\n}\n```\n\n# 另一种灵活的实现方式\n\n\n联想一下linux的管道机制：__前一个命令的结果会传递给后一个命令__。\n\n是不是可以从中得到启发呢？是不是可以有一种架构可以使得通过下面的形式就能得到最终处理后的结果？\n\n```cpp\n\tData decompressedData = compressedData | mZipDecompressor | mGZipDecompressor | mRarDecompressor;\n```\n\n首先，很容易想到我们需要通过重载操作符去实现这种机制。我们可以重载 \"|\" 操作符，将Data和Decompressor作为参数传入，再将处理后或者没有处理的Data作为返回值返回，传到下一个Decompressor那里去。\n\n基本的思想是这样的，但是这里有个很重要的问题要处理：我们如何知道上一个Decompressor有没有解压过数据？\n\n当然可以直接调用Decompressor::canDecompress看看是否是可解压的就能知道上一个Decompressor有没有处理过数据。但是这样的处理模式有一些风险，而且也比较浪费资源，明明前一个Decompressor已经解压完成了，但是后面的Decompressor还回去判断是否可以解压，这个判断可能比较复杂。\n\n第二种解决方案就是拓展Data结构体，添加一个是否已经解压字段。这样能够完美的解决问题，但是Data的职责就变重了，他不仅要保存数据，还要知道保存的数据究竟是解压过的还是没有解压过的。而且这个标志字段只有在解压的过程中才有用，因为一般数据在存储的时候我们已经知道它是否被压缩过了，我们总不会会将未解压和解压过的数据混在一起存放的。\n\n其实还有第三种解决方法:\n\n```cpp\nstruct DataWrapper{\n    DataWrapper(const Data& data) : data(data),isDecompressed(false) {}\n\n    Data data;\n    bool isDecompressed;\n};\n```\n在DataWrapper添加了一个属性isDecompressed来标志数据是否已经解压。这个Wrapper可以只在解压过程中临时使用，不影响数据的存储。\n\n然后实现的重点就是重载操作符了，其实它的实现很简单:\n\n```cpp\nDataWrapper& operator | (DataWrapper& data, const Decompressor& decompressor){\n    if(!data.isDecompressed && decompressor.canDecompress(data.data)){\n        data.data = decompressor.doDecompress(data.data);\n        data.isDecompressed = true;\n    }\n\n    return data;\n}\n```\n\n现在Decompressor就只需要提供判断是否可以解压和进行解压的功能。所以我们可以将Decompressor基类简化下面这样。其实这样的Decompressor就相当于java里面的接口了，面向接口编程可以使得业务逻辑更加清晰，而且也更易于维护。\n\n```cpp\nclass Decompressor{\npublic:\n    virtual bool canDecompress(const Data& data)const = 0;\n    virtual Data doDecompress(const Data& data)const = 0;\n};\n```\n\n所以我们的SuperDecompressor类就可以写成下面的样子:\n\n```cpp\nclass SuperDecompressor{\npublic:\n    Data decompressCompressedFile(const Data& data);\n\nprivate:\n    ZipDecompressor mZipDecompressor;\n    RarDecompressor mRarDecompressor;\n    GZipDecompressor mGZipDecompressor;\n};\n\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mZipDecompressor | mGZipDecompressor | mRarDecompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n```\n\n而main函数是一样的:\n\n```cpp\nint main(){\n    SuperDecompressor decompressor;\n\n    Data input((unsigned char*)\"gzip\",strlen(\"gzip\"));\n\n    Data output = decompressor.decompressCompressedFile(input);\n\n    if(output.data){\n        const char* out = (const char*)output.data;\n        cout<<\"result : \"<<out<<endl;\n    }else{\n        cout<<\"result : null\"<<endl;\n    }\n\n    return 0;\n}\n```\n\n输出结果如下:\n\n> ZipDecompressor:canDecompress  \n> GZipDecompressor:canDecompress  \n> GZipDecompressor:doDecompress  \n> result : doDecompress by GZipDecompressor  \n\n所以如果我们现在需要将SuperDecompressor拓展成一个真正万能的解压类，不仅能解压压缩文件，也能解压图片，还能解压Base64编码的超级解压类也很简单了:\n\n```cpp\nclass SuperDecompressor{\n    Data decompressUnknowType(const Data& data);\n    Data decompressImage(const Data& data);\n    Data decompressCompressedFile(const Data& data);\n    Data decompressBase64(const Data& data);\n\nprivate:\n    ZipDecompressor mZipDecompressor;\n    RarDecompressor mRarDecompressor;\n    GZipDecompressor mGZipDecompressor;\n\n    JpgDecompressor mJpgDecompressor;\n    PngDecompressor mPngDecompressor;\n\n    Base64Decompressor mBase64Decompressor;\n};\n\nData SuperDecompressor::decompressUnknowType(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mZipDecompressor | mRarDecompressor | mGZipDecompressor\n            | mJpgDecompressor | mPngDecompressor\n            | mBase64Decompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n\nData SuperDecompressor::decompressImage(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mJpgDecompressor | mPngDecompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mZipDecompressor | mRarDecompressor | mGZipDecompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n\nData SuperDecompressor::decompressBase64(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mBase64Decompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n```\n\n当然，这种处理方式在数据已经被解压的情况下依然会传给下一个解压器，直到经过了整条处理链。所以会造成一定的资源浪费。\n\n# 责任链模式的实际应用场景\n\n责任链模式的实际应用，最广为人知的就是安卓View的Touch事件的传递机制了。其实这是一种双向的责任链模式。在接收到Touch事件的时候，父View会通知子View，如果子View不处理，父View才去处理。光说可能有点难懂，我们直接看源码吧:\n\n```java\npublic boolean dispatchTouchEvent(MotionEvent ev) {\n    boolean result = false;             // 默认状态为没有消费过\n\n    if (!onInterceptTouchEvent(ev)) {   // 如果没有拦截交给子View\n        result = child.dispatchTouchEvent(ev);\n    }\n\n    if (!result) {                      // 如果事件没有被消费,询问自身onTouchEvent\n        result = onTouchEvent(ev);\n    }\n\n    return result;\n}\n```\n\n代码看起来也不好懂？没关系，我用个实际的例子解释一下就明白了。首先我们有下面的一个Activity:\n\n{% img /责任链模式/Touch事件传递机制例子.png %}\n\n当我们点击最中间的那个View的时候Touch事件的传递过程如下图:\n\n{% img /责任链模式/Touch事件传递过程.png %}\n\nTouch事件通过Activity、ViewGroup1、ViewGroup2的dispatchTouchEvent方法最后到达View的dispatchTouchEvent方法，在View被处理，所以返回true。于是Activity、ViewGroup1、ViewGroup2的dispatchTouchEvent方法都会直接返回，而不会调用处理方法onTouchEvent\n\n\n# 总结\n\n这一部分本来应该讲一讲责任链模式的优缺点的，但是我自己其实不太喜欢这样的总结性的东西。所以还是留给读者自己体会吧。\n","slug":"责任链模式","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2uly0003w3fyu385owcq"},{"title":"读书笔记 -《黑客与画家》","date":"2016-02-11T12:22:40.000Z","_content":"这本书是一本文集，也有点像paul graham的自传。以成长的各个阶段为引子，讲到了paul graham对书呆子、优秀程序员、创业和编程语言等的观点看法。\n\n其实不太适合这个阶段的我读，创业、程序语言的设计这些离我还太遥远。不像书中的”黑客“从初中高中就开始学习编程，在大学时期甚至更早之前就能做出一些很厉害的东西。我经历的实际项目一个巴掌都数的过来，甚至还不知道书中“黑客”推崇备至的lisp代码到底长什么样子，很多东西看来了不能产生太深的感悟。\n\n但换个角度，把它当成一本闲时读物，用来拓展眼界还是极好的。\n\n以前我不明白为什么公司里面的项目组普遍在十人左右，现在才知道小团体和可测量性之间的关系，组织机构越精简往往能提供越大的生产力。\n\n书中对现存编程语言的解析还有对未来编程语言的预测也让我大开眼界，了解到了一些以前从来没有去注意的细节之处。\n\n而要说最大的收获的话，应该就是对于编写代码的方式有了和以前不太一样的理解了。刚学编程那会儿，总是直接上手敲代码，完全没有事前的思考，所以总会写出一堆不堪入目的东西。之后看受一些书本和前辈的影响，又总是喜欢做一些“完美”的设计。通常是考虑了一堆多余的东西，到了真正要编码的时候又发现能力不足以把这些东西都实现，其实就是陷入了“过早优化”。\n\n这本书和《道法自然》的建议有点类似，设计的时候只需要考虑必须实现的功能就可以了。“把整个程序想清楚的时间点，应该是在编写代码的同时，而不是在编写代码之前，这与作家、画家和建筑师的做法完全一样”。人们往往很难在没有实际编码之前就将遇到的问题和未知的需求都考虑在内，所以一开始的设计不应该是一种解决所有问题的方案，不应该太早的决定一个程序应该怎么做。而应该设计一种灵活可变的方案，类似打草稿、画轮廓，然后在编写代码的时候再慢慢修改和填充。\n\n最近看书有点急。大概是以前看的书太少了，好不容易有时间，有心情去看书，所以才看得那么匆忙，一本还没看完就开另一本，同时实际动手敲代码的时间也少的可怜。时间还剩下一个月左右，是该调整一下了，书还是得看仔细点，代码也应该敲多点。\n","source":"_posts/读书笔记-《黑客与画家》.md","raw":"title: 读书笔记 -《黑客与画家》\ndate: 2016-02-11 20:22:40\ntags:\n\t- 读书笔记\n---\n这本书是一本文集，也有点像paul graham的自传。以成长的各个阶段为引子，讲到了paul graham对书呆子、优秀程序员、创业和编程语言等的观点看法。\n\n其实不太适合这个阶段的我读，创业、程序语言的设计这些离我还太遥远。不像书中的”黑客“从初中高中就开始学习编程，在大学时期甚至更早之前就能做出一些很厉害的东西。我经历的实际项目一个巴掌都数的过来，甚至还不知道书中“黑客”推崇备至的lisp代码到底长什么样子，很多东西看来了不能产生太深的感悟。\n\n但换个角度，把它当成一本闲时读物，用来拓展眼界还是极好的。\n\n以前我不明白为什么公司里面的项目组普遍在十人左右，现在才知道小团体和可测量性之间的关系，组织机构越精简往往能提供越大的生产力。\n\n书中对现存编程语言的解析还有对未来编程语言的预测也让我大开眼界，了解到了一些以前从来没有去注意的细节之处。\n\n而要说最大的收获的话，应该就是对于编写代码的方式有了和以前不太一样的理解了。刚学编程那会儿，总是直接上手敲代码，完全没有事前的思考，所以总会写出一堆不堪入目的东西。之后看受一些书本和前辈的影响，又总是喜欢做一些“完美”的设计。通常是考虑了一堆多余的东西，到了真正要编码的时候又发现能力不足以把这些东西都实现，其实就是陷入了“过早优化”。\n\n这本书和《道法自然》的建议有点类似，设计的时候只需要考虑必须实现的功能就可以了。“把整个程序想清楚的时间点，应该是在编写代码的同时，而不是在编写代码之前，这与作家、画家和建筑师的做法完全一样”。人们往往很难在没有实际编码之前就将遇到的问题和未知的需求都考虑在内，所以一开始的设计不应该是一种解决所有问题的方案，不应该太早的决定一个程序应该怎么做。而应该设计一种灵活可变的方案，类似打草稿、画轮廓，然后在编写代码的时候再慢慢修改和填充。\n\n最近看书有点急。大概是以前看的书太少了，好不容易有时间，有心情去看书，所以才看得那么匆忙，一本还没看完就开另一本，同时实际动手敲代码的时间也少的可怜。时间还剩下一个月左右，是该调整一下了，书还是得看仔细点，代码也应该敲多点。\n","slug":"读书笔记-《黑客与画家》","published":1,"updated":"2017-06-02T22:47:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2um50008w3fy7y1xk2yn"},{"title":"读书笔记 -《道法自然—面向对象实践指南》","date":"2016-01-21T08:59:47.000Z","_content":"\n不可否认，我一开始是被这本书的名字吸引才去读的。《道法自然》，这名字逼格真心不要太高。但真的开始阅读，你就会发现它绝对不是标题党。依稀记得那天凌晨4点多睡不着，刷知乎看到有人推荐这本书，于是冲着标题去下载来看。结果一发不可收拾，那一天我就没干别的事，都被它吸引住了。\n\n之前也看过不少讲设计模式的书，像什么《大话设计模式》、《head first设计模式》、《设计模式之禅》等等。当然它们也是好书。尤其是《设计模式之禅》，在读《道法自然》之前我最推崇的讲设计模式的书就是它了。但相比起来，我还是觉得《道法自然》讲的更加的透彻和易于理解。\n\n《道法自然—面向对象实践指南》这本书真要算起来其实并不是严格意义上的讲设计模式的书籍。它以实际的开发案例--FishGUI项目为主线，从立项到需求分析，再到架构设计，最后到编码和优化。通过文字，将整个项目的流程一点不漏的展现在读者面前。在实际编码那几章，通过分析项目的需求，确定使用的设计模式，分析为什么要使用这种模式，有什么优缺点，又谈到怎么去应用到FishGUI这个框架中。有时候甚至会对比其他的框架的源代码讲到多种设计之间的差异和优缺点，例如书中在消息机制那里就分析了MFC、.net和java AWT的设计。相比起其他讲设计模式的书，它更加贴合实际开发，也讲到更加的透彻。毕竟是通过一个实际的项目去讲，能让人更透彻的取理解所讲到的模式。\n\n这本书还有一个吸引我的地方，之前读到的关于设计模式的书籍，要不是用的c#要不用的是java，但这本书使用的编程语言是c\\+\\+，也不是说其他语言不好，但作为一个大部分时间都在学习c\\+\\+的人来说，看c\\+\\+语言更有一种亲切感。同时这本书在最后的一章里面还讲到了在FishGUI这个项目中使用c\\+\\+时遇到的坑。对于c\\+\\+程序员来说，这本书真心不能错过。\n\n读完这本书，除了对于一些设计模式理解的更为透彻之外，我认为更重要的收获是对编程思想或者编程习惯的培养：\n\n1. 实际编码之前一定要有分析和设计的阶段\n2. 只实现你真正需要的东西 \n2. 面向接口编程而不是面向实现编程\n3. 边编码边做一些优化性的重构\n\n我想这本书我以后肯定会再读的，因为现在的项目经验还不足，相信做多几个实际的项目之后再看一遍，肯定会有不一样的见解和更多的收获。\n\n看这本书总共花了10天左右的时间吧，其实这个过程中也发现了自己在读书方面的缺点。就是后劲不足，在刚刚开始的时候每天都很有热情的去阅读，速度很快，看到也很仔细，但读了一半热情下来之后就没有之前那么入神了。这也是我接下来必须改进的地方，以前读的书太少，2016年有太多的书想要读。这是今年读完的第一本书，希望有始有终，之后的日子可以培养起看书的好习惯。  \n\n","source":"_posts/读书笔记-《道法自然—面向对象实践指南》.md","raw":"title: 读书笔记 -《道法自然—面向对象实践指南》\ndate: 2016-01-21 16:59:47\ntags:\n    - 读书笔记 \n---\n\n不可否认，我一开始是被这本书的名字吸引才去读的。《道法自然》，这名字逼格真心不要太高。但真的开始阅读，你就会发现它绝对不是标题党。依稀记得那天凌晨4点多睡不着，刷知乎看到有人推荐这本书，于是冲着标题去下载来看。结果一发不可收拾，那一天我就没干别的事，都被它吸引住了。\n\n之前也看过不少讲设计模式的书，像什么《大话设计模式》、《head first设计模式》、《设计模式之禅》等等。当然它们也是好书。尤其是《设计模式之禅》，在读《道法自然》之前我最推崇的讲设计模式的书就是它了。但相比起来，我还是觉得《道法自然》讲的更加的透彻和易于理解。\n\n《道法自然—面向对象实践指南》这本书真要算起来其实并不是严格意义上的讲设计模式的书籍。它以实际的开发案例--FishGUI项目为主线，从立项到需求分析，再到架构设计，最后到编码和优化。通过文字，将整个项目的流程一点不漏的展现在读者面前。在实际编码那几章，通过分析项目的需求，确定使用的设计模式，分析为什么要使用这种模式，有什么优缺点，又谈到怎么去应用到FishGUI这个框架中。有时候甚至会对比其他的框架的源代码讲到多种设计之间的差异和优缺点，例如书中在消息机制那里就分析了MFC、.net和java AWT的设计。相比起其他讲设计模式的书，它更加贴合实际开发，也讲到更加的透彻。毕竟是通过一个实际的项目去讲，能让人更透彻的取理解所讲到的模式。\n\n这本书还有一个吸引我的地方，之前读到的关于设计模式的书籍，要不是用的c#要不用的是java，但这本书使用的编程语言是c\\+\\+，也不是说其他语言不好，但作为一个大部分时间都在学习c\\+\\+的人来说，看c\\+\\+语言更有一种亲切感。同时这本书在最后的一章里面还讲到了在FishGUI这个项目中使用c\\+\\+时遇到的坑。对于c\\+\\+程序员来说，这本书真心不能错过。\n\n读完这本书，除了对于一些设计模式理解的更为透彻之外，我认为更重要的收获是对编程思想或者编程习惯的培养：\n\n1. 实际编码之前一定要有分析和设计的阶段\n2. 只实现你真正需要的东西 \n2. 面向接口编程而不是面向实现编程\n3. 边编码边做一些优化性的重构\n\n我想这本书我以后肯定会再读的，因为现在的项目经验还不足，相信做多几个实际的项目之后再看一遍，肯定会有不一样的见解和更多的收获。\n\n看这本书总共花了10天左右的时间吧，其实这个过程中也发现了自己在读书方面的缺点。就是后劲不足，在刚刚开始的时候每天都很有热情的去阅读，速度很快，看到也很仔细，但读了一半热情下来之后就没有之前那么入神了。这也是我接下来必须改进的地方，以前读的书太少，2016年有太多的书想要读。这是今年读完的第一本书，希望有始有终，之后的日子可以培养起看书的好习惯。  \n\n","slug":"读书笔记-《道法自然—面向对象实践指南》","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2um7000bw3fy1pk2qhdp"},{"title":"读书笔记 -《第一行代码——Android》","date":"2016-02-10T14:29:03.000Z","_content":"\n很久之前就打算学安卓了，但总被各种事情干扰，一直断断续续。这本书是我第一本真正读完的安卓入门教程。\n\n这本书不愧被称为“Android初学者的最佳入门书”。它涵盖了安卓软件开发的方方面面，不仅讲到了四大组件、UI、碎片、广播机制、数据存储、服务、多媒体、网络、定位服务、传感器这些安卓开发知识，也讲简单提到了git和安卓测试工程的使用。在书本的最后还通过一个比较完整的天气app把书中大部分的内容以实际项目的形式回顾了一遍。\n\n我觉得这本书最大的优点就是点到为止，不像之前读过的那些书，用大篇幅去把各个部件属性和控件都不厌其烦的描述一遍。因为很多东西只要知道有这个东西，知道它的部分关键属性，其他的到需要用到的时候在去查看文档就可以了。\n\n但这本书又不仅是简单的介绍安卓那些组件和类的使用方法，它还介绍了listview加载数据的优化方法、全局获取Context的技巧和制定自己的Log类等实用的安卓编程技巧。虽然由于安卓版本更新太快，有部分代码已经过时，但对于善于使用搜索引擎的程序员来说也不是什么大问题。\n\n总的来说，这本书除了每节末尾的不太相关的RPG剧情描述之外，其它都很合我口味，很幸运可以在入门的阶段遇到这本书。\n\n经过这一段时间的学习，也对安卓编程有了一点心得，接下来就可以正式开始我的毕业设计手机端部分了。边编码，边深入学习java、安卓编程和单元测试等知识。希望在大学的最后一段时间，能够学多点东西，提高自己的编程能力。","source":"_posts/读书笔记-《第一行代码——Android》.md","raw":"title: 读书笔记 -《第一行代码——Android》\ndate: 2016-02-10 22:29:03\ntags:\n\t- 读书笔记\n---\n\n很久之前就打算学安卓了，但总被各种事情干扰，一直断断续续。这本书是我第一本真正读完的安卓入门教程。\n\n这本书不愧被称为“Android初学者的最佳入门书”。它涵盖了安卓软件开发的方方面面，不仅讲到了四大组件、UI、碎片、广播机制、数据存储、服务、多媒体、网络、定位服务、传感器这些安卓开发知识，也讲简单提到了git和安卓测试工程的使用。在书本的最后还通过一个比较完整的天气app把书中大部分的内容以实际项目的形式回顾了一遍。\n\n我觉得这本书最大的优点就是点到为止，不像之前读过的那些书，用大篇幅去把各个部件属性和控件都不厌其烦的描述一遍。因为很多东西只要知道有这个东西，知道它的部分关键属性，其他的到需要用到的时候在去查看文档就可以了。\n\n但这本书又不仅是简单的介绍安卓那些组件和类的使用方法，它还介绍了listview加载数据的优化方法、全局获取Context的技巧和制定自己的Log类等实用的安卓编程技巧。虽然由于安卓版本更新太快，有部分代码已经过时，但对于善于使用搜索引擎的程序员来说也不是什么大问题。\n\n总的来说，这本书除了每节末尾的不太相关的RPG剧情描述之外，其它都很合我口味，很幸运可以在入门的阶段遇到这本书。\n\n经过这一段时间的学习，也对安卓编程有了一点心得，接下来就可以正式开始我的毕业设计手机端部分了。边编码，边深入学习java、安卓编程和单元测试等知识。希望在大学的最后一段时间，能够学多点东西，提高自己的编程能力。","slug":"读书笔记-《第一行代码——Android》","published":1,"updated":"2017-06-02T22:47:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2um8000dw3fygp5mqe0p"},{"title":"读书笔记 -《代码整洁之道》","date":"2016-01-30T07:22:14.000Z","_content":"\n长呼一口气，终于看完了。明明就只有300多页，但这本《代码整洁之道》还真是难啃啊。\n\n书是好书，讲的也十分细致。就连命名、方法定义的顺序、注释这些小细节都用了不少的文字去强调。虽然有些观点我不太认同（比如我觉得类成员变量就应该多一个字符m或者下划线去和临时变量做区别）但绝大部分的建议和条款我觉得都讲的十分有道理。总结了几个自认为最重要的点：\n\n1. 不管是变量还是函数，命名都应该有意义且名副其实\n1. 应该按照垂直格式摆放函数定义\n1. 注释应该正确且有用\n1. 函数应该只做一件事，且应该尽量短小\n1. 模块不应该了解它所操作的对象的内部情形\n\n\n作者对于代码的要求堪称苛刻，看他写代码的过程真的可以算是精雕细琢，最终呈现的代码可谓优雅。虽然我也不能指望自己通过读完一本书，写代码的能力就有质的飞跃。但这本书起码提醒了我一些以前没有注意到的地方，以后写代码的时候试试提醒自己，能有所提高也就不负我这几天的努力了。\n\n要说这本书难啃也是真的。中间有大量的代码实例，而且很多都是著名的开源框架的源码（如Tomcat、Spring和JUnit），在阅读这本书的过程中大部分时间我是花在理解这些代码上的。因为对java不太熟悉，这些框架更是一个都没有用过，所以读起来十分的痛苦，中间好几次都想放弃了。\n\n多亏最终坚持了下来，我还得到了一些以后的学习道路的启示：\n\n一是java还需要重新好好学一遍。毕竟现在正在学安卓，我的java基础实在弱的可以，尤其是并发编程相关的知识可以说就是一张白纸。\n\n二是需要学习一下测试驱动开发（TDD）相关的知识。我发现最近看的书，都把测试放在了很重要的位置上。以前写代码就没有做过单元测试，所以拿到测试部门的时候总会出现这样那样不应该出现的问题。java方面jUnit是一定要去学习的，而c\\+\\+其实也有类似googletest这样的测试框架。为了写出高质量的代码，这部分的知识也应该去好好补一补了。\n\n所以我下一步打算找找java还有测试相关的书籍来看看。\n","source":"_posts/读书笔记-《代码整洁之道》.md","raw":"title: 读书笔记 -《代码整洁之道》\ndate: 2016-01-30 15:22:14\ntags:\n\t- 读书笔记\n---\n\n长呼一口气，终于看完了。明明就只有300多页，但这本《代码整洁之道》还真是难啃啊。\n\n书是好书，讲的也十分细致。就连命名、方法定义的顺序、注释这些小细节都用了不少的文字去强调。虽然有些观点我不太认同（比如我觉得类成员变量就应该多一个字符m或者下划线去和临时变量做区别）但绝大部分的建议和条款我觉得都讲的十分有道理。总结了几个自认为最重要的点：\n\n1. 不管是变量还是函数，命名都应该有意义且名副其实\n1. 应该按照垂直格式摆放函数定义\n1. 注释应该正确且有用\n1. 函数应该只做一件事，且应该尽量短小\n1. 模块不应该了解它所操作的对象的内部情形\n\n\n作者对于代码的要求堪称苛刻，看他写代码的过程真的可以算是精雕细琢，最终呈现的代码可谓优雅。虽然我也不能指望自己通过读完一本书，写代码的能力就有质的飞跃。但这本书起码提醒了我一些以前没有注意到的地方，以后写代码的时候试试提醒自己，能有所提高也就不负我这几天的努力了。\n\n要说这本书难啃也是真的。中间有大量的代码实例，而且很多都是著名的开源框架的源码（如Tomcat、Spring和JUnit），在阅读这本书的过程中大部分时间我是花在理解这些代码上的。因为对java不太熟悉，这些框架更是一个都没有用过，所以读起来十分的痛苦，中间好几次都想放弃了。\n\n多亏最终坚持了下来，我还得到了一些以后的学习道路的启示：\n\n一是java还需要重新好好学一遍。毕竟现在正在学安卓，我的java基础实在弱的可以，尤其是并发编程相关的知识可以说就是一张白纸。\n\n二是需要学习一下测试驱动开发（TDD）相关的知识。我发现最近看的书，都把测试放在了很重要的位置上。以前写代码就没有做过单元测试，所以拿到测试部门的时候总会出现这样那样不应该出现的问题。java方面jUnit是一定要去学习的，而c\\+\\+其实也有类似googletest这样的测试框架。为了写出高质量的代码，这部分的知识也应该去好好补一补了。\n\n所以我下一步打算找找java还有测试相关的书籍来看看。\n","slug":"读书笔记-《代码整洁之道》","published":1,"updated":"2017-06-02T22:47:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2um9000fw3fybyn4dva2"},{"title":"用PowerMock进行Android单元测试与BDD行为驱动开发","date":"2017-08-26T09:18:28.000Z","_content":"\n很久之前就有听说过mockito和PowerMock的大名了,无奈我司写单元测试的风气不浓,加上一直以来业务繁忙,惰性使我一直没有写单元测试的习惯。\n\n正好现在手头上的是一个全新的项目,可以在初期有时间也有冲动将各种需要的东西都用上。于是这几天就好好学习了一番,感觉PowerMock的确是无比强大。\n\n# 什么是mock\n\n维基百科上是这么写的:\n\n> 在面向对象程序设计中，模拟对象（英语：mock object，也译作模仿对象）是以可控的方式模拟真实对象行为的假的对象。程序员通常创造模拟对象来测试其他对象的行为，很类似汽车设计者使用碰撞测试假人来模拟车辆碰撞中人的动态行为。  \n> 在单元测试中，模拟对象可以模拟复杂的、真实的（非模拟）对象的行为， 如果真实的对象无法放入单元测试中，使用模拟对象就很有帮助。\n\n如果我们使用依赖注入的方式编写代码,例如Context通常都是外部传入的:\n\n```\nclass ClassA{\n\tpublic static boolean staticFunc(Context context, int arg) {\n\t\t...\n\t}\n}\n```\n\n这个方法如果不使用mock object的方法,我们很难脱离安卓环境去编写单元测试,因为Context是系统生成的。\n\n而使用mock技术去模拟一个Context出来,就可以在android studio中编写并且脱离安卓环境运行单元测试了。\n\n# PowerMock\n\n[powermock](https://github.com/powermock/powermock)是一个流行的java mock框架,通过它我们可以很方便的实现模拟对象。它实际上是继承并且拓展了EasyMock、Mockito等其他的流行框架。\n\n在android studio上导入powermock框架很简单,只需要在build.gradle中添加dependencies就好了:\n\n```\ndependencies {\n\t...\n    testCompile 'junit:junit:4.12'\n\n    testCompile 'org.powermock:powermock-core:1.6.1'\n    testCompile 'org.powermock:powermock-module-junit4:1.6.1'\n    testCompile 'org.powermock:powermock-module-junit4-rule:1.6.1'\n    testCompile 'org.powermock:powermock-api-mockito:1.6.1'\n}\n```\n\n这里有个坑点，之前我用的是1.5.6版本的powermock,但是我的junit是4.12版本的,于是在使用@RunWith(PowerMockRunner.class)的时候会报错:\n\n> org.powermock.reflect.exceptions.FieldNotFoundException: Field 'fTestClass' was not found in class org.junit.internal.runners.MethodValidator.\n\n到stackoverflow上搜索到国外大神的[回答](https://stackoverflow.com/questions/26192929/unable-to-run-junit-test-with-powermockrunner)是powermock小于1.6.1的版本在使用junit 4.12的一个bug,在1.6.1被修复。所以要么用junit 4.12 + powermock 1.6.1,要么使用junit 4.11 + powermock 1.5.6.\n\n# mock的简单用法\n\n先说一下最近我拿到的一个需求。我们的应用的按钮点击启动其他应用的响应需要在服务器上配置。服务器上可能配的是包名启动应用,也可能是action启动应用,还有可能是Uri启动应用。\n\n所以我这样写了一个工具类:\n\n```\npublic class AppUtils {\n\tpublic static boolean startApp(Context context, StartAppParam param) {\n\t\t...\n\t}\n\t\n\t public static class StartAppParam {\n        private String packageName;\n        private String activity;\n        private String action;\n        private String uri;\n        private List<String> categorys = new ArrayList<>();\n        ...\n    }\n}\n```\n\n在服务器上配置一个json,传到客户端解析成StartAppParam,然后调用AppUtils. startApp方法。这样就可以实现这个需求了。\n\n我们使用TDD的方式开发这个功能。首先考虑只配置Action的方式启动:\n\n```\n@Test\n    public void testOpenAppByAction() {\n\t\tContext context = Mockito.mock(Context.class);\n\t\t\n\t\tAppUtils.StartAppParam param = Mockito.mock(AppUtils.StartAppParam.class);\n\t\tPowerMockito.when(param.getAction()).thenReturn(\"package\");\n\t\t\n\t\tassertTrue(AppUtils.startApp(context, param));\n\t\t    \n\t\tMockito.verify(context, Mockito.times(1)).startActivity(Matchers.any(Intent.class));\n    }\n```\n\n首先,使用Mockito.mock方法可以创建一个模拟对象出来。我们这里使用模拟的Context就可以直接在android studio中运行单元测试了。\n\n同时param也用mock的方式创建了出来,而且还模拟了它的getAction方法,让该方法返回\"package\",表示配置了使用Action去启动应用:\n\n```\nAppUtils.StartAppParam param = Mockito.mock(AppUtils.StartAppParam .class);\nPowerMockito.when(param.getAction()).thenReturn(\"package\");\n```\n\n\n然后Mockito.verify方法可以用来验证调用了方法的调用次数,比如这里我们就验证了startActivity被调用了一次。\n\n# mock 方法内部创建的对象\n\n当然这个测试不充分,因为我们没有验证到底是不是通过Action启动的。也就是说我们还需要判断是不是通过new Intent(param.getAction())的方式创建了一个Intent出来。\n\n这就用到了PowerMock的一个很屌的功能了,它不仅可以在外部mock一个对象通过参数传给需要测试的方法,更可以直接mock方法内部创建的对象(比如这里的Intent)!\n\n```\n@RunWith(PowerMockRunner.class)\npublic class AppUtilsTest {\n\n    @Test\n    @PrepareForTest({AppUtils.class})\n    public void testOpenAppByAction() throws Exception {\n        Intent intent = Mockito.mock(Intent.class);\n        PowerMockito.whenNew(Intent.class).withArguments(\"package\").thenReturn(intent);\n\n        Context context = Mockito.mock(Context.class);\n\n        AppUtils.StartAppParam param = Mockito.mock(AppUtils.StartAppParam.class);\n        PowerMockito.when(param.getAction()).thenReturn(\"package\");\n\n        assertTrue(AppUtils.startApp(context, param));\n        \n        Mockito.verify(context, Mockito.times(1)).startActivity(intent);\n        Mockito.verify(intent, Mockito.times(0)).setData(Matchers.any(Uri.class));\n        Mockito.verify(intent, Mockito.times(0)).addCategory(Matchers.anyString());\n        Mockito.verify(intent, Mockito.times(0)).setClassName(Matchers.anyString(), Matchers.anyString());\n    }\n}\n```\n\n首先需要用@RunWith(PowerMockRunner.class)注解AppUtilsTest类,用@PrepareForTest({AppUtils.class})注解testOpenAppByAction方法,传入的AppUtils.class表示需要在AppUtils类内部实现mock操作。\n\n然后mock一个Intent出来,接着使用下面的方法使得使用new Intent(\"package\")得到的Intent是我们mock出来的intent,注意这里连传入的\"package\"参数也需要匹配才能得到我们mock出来的intent。否则只能得到null:\n\n```\nPowerMockito.whenNew(Intent.class).withArguments(\"package\").thenReturn(intent);\n```\n\n所以我们在后面只需要验证startActivity调用的intent是不是我们mock出来的对象,就可以验证是不是通过Action启动的应用了:\n\n```\nMockito.verify(context, Mockito.times(1)).startActivity(intent);\n```\n\n当然,为了保险我们可以顺便确认一下Intent的其他方法是不是没有被调用到:\n\n```\nMockito.verify(intent, Mockito.times(0)).setData(Matchers.any(Uri.class));\nMockito.verify(intent, Mockito.times(0)).addCategory(Matchers.anyString());\nMockito.verify(intent, Mockito.times(0)).setClassName(Matchers.anyString(), Matchers.anyString());\n```\n\n# 使用BDD的方式编写单元测试\n\nBDD (Behavior-driven development,行为驱动开发)通过用自然语言书写非程序员可读的测试用例扩展了测试驱动开发方法。也就是说用bdd方式写的代码就连不是程序员的人也能看得懂,这种可读性的重要性就不用我多费口舌了吧。\n\n其实Mockito的BDD方式的写法我觉得并不是特别的像自然语言。所以我想用C++的单元测试框架Catch框架来举例:\n\n```\nGIVEN(\"a enable stub publish server entry\") {\n    StubPublishServerEntry entry(true);\n\tentry.Start();\n\n    WHEN(\"publish service\") {\n        entry.PublishService(service, on_result, on_success, on_error);\n\n        THEN(\"publish successfully\") {\n            REQUIRE(service_entry != nullptr);\n            REQUIRE(service_entry->IsPublished());\n            REQUIRE(is_on_success);\n            REQUIRE_FALSE(is_on_error);\n        }\n    }\n}\n```\n\n这是我之前的半成品项目中的一个代码片段。如果将代码部分去掉,只留下GIVEN、WHEN、THEN三个宏里面的东西,基本只有是懂英语的人都能看得懂这段代码想做什么:\n\n```\nGIVEN(\"a enable stub publish server entry\") {\n    ...\n    WHEN(\"publish service\") {\n        ...\n        THEN(\"publish successfully\") {\n            ...  \n        }\n    }\n}\n```\n\nPowerMock也是支持BDD的(应该说Mockito是支持BDD的),我们可以将上面写的测试用例改成BDD的写法:\n\n```\npublic void testOpenAppByAction() throws Exception {\n    Intent intent = Mockito.mock(Intent.class);\n    PowerMockito.whenNew(Intent.class).withArguments(\"package\").thenReturn(intent);\n\n    Context context = Mockito.mock(Context.class);\n\n    AppUtils.StartAppParam param = Mockito.mock(AppUtils.StartAppParam .class);\n\n    //given\n    BDDMockito.given(param.getAction()).willReturn(\"package\");\n\n    //when\n    assertTrue(AppUtils.startApp(context, param));\n\n    //then\n    BDDMockito.then(context).should().startActivity(intent);\n    BDDMockito.then(intent).should(Mockito.never()).setData(Matchers.any(Uri.class));\n    BDDMockito.then(intent).should(Mockito.never()).addCategory(Matchers.anyString());\n    BDDMockito.then(intent).should(Mockito.never()).setClassName(Matchers.anyString(), Matchers.anyString());\n}\n```\n\n感觉是不是和自然语言还是差别蛮大的,我们改造改造,将一些方法改成通过import static的方式import:\n\n```\npublic void testOpenAppByAction() throws Exception {\n    Intent intent = mock(Intent.class);\n    whenNew(Intent.class).withArguments(\"package\").thenReturn(intent);\n\n    Context context = mock(Context.class);\n\n    AppUtils.StartAppParam param = mock(AppUtils.StartAppParam .class);\n\n    //given\n    given(param.getAction()).willReturn(\"package\");\n\n    //when\n    assertTrue(AppUtils.startApp(context, param));\n\n    //then\n    then(context).should().startActivity(intent);\n    then(intent).should(never()).setData(any(Uri.class));\n    then(intent).should(never()).addCategory(anyString());\n    then(intent).should(never()).setClassName(anyString(), anyString());\n}\n```\n\n这样是不是好多了？让我们继续改造:\n\n```\npublic class AppUtilsTest {\n    @Mock\n    private Intent mIntent;\n\n    @Mock\n    private Context mContext;\n\n    @Mock\n    private AppUtils.StartAppParam mParam;\n\n    @Before\n    public void setUp() throws Exception {\n        whenNew(Intent.class).withArguments(\"package\").thenReturn(mIntent);\n    }\n\n    @Test\n    @PrepareForTest({AppUtils.class})\n    public void testOpenAppByAction() {\n        given(mParam.getAction()).willReturn(\"package\");\n\n        //when\n        assertTrue(AppUtils.startApp(mContext, mParam));\n\n        then(mContext).should().startActivity(mIntent);\n        then(mIntent).should(never()).setData(any(Uri.class));\n        then(mIntent).should(never()).addCategory(anyString());\n        then(mIntent).should(never()).setClassName(anyString(), anyString());\n    }\n}\n```\n\n因为Intent、Context、AppUtils.StartAppParam都是需要在不同测试用例中经常被用到的,我们将它写成成员变量并且用@Mock实现自动mock,省去Mockito.mock()方法的调用。\n\n然后将whenNew方法放到由@Before注解的setUp()方法中。\n\n现在看testOpenAppByAction是不是简洁多了？只要有一点代码功底的人都能很容易看明白这个用例到底是用来验证什么的。\n\n当然,这里的BDD写法和上面Catch的写法比起来在像自然语言方面还是有点差距的。\n\n现在我们已经将测试用例写出来了，就可以开始写代码让这个测试用例通过了。像这样先写行为测试用例再写代码的开发方式就叫做BDD。\n\n\n# mock 静态方法\n\n我们下一个需要实现的功能是什么呢？就实现通过包名启动应用吧。将设只配置了包名,但没有配置Activity名。我们就需要先找到这个应用的Launch Activity,然后再去启动应用。\n\n所以我们在AppUtils中新增了一个方法,用于从包名获取Activity名:\n\n```\npublic class AppUtils {\n\tpublic static boolean startApp(Context context, StartAppParam param) {\n\t\t...\n\t}\n\t\n\tpublic static String getLaunchActivityByPackage(Context context, String packageName) {\n\t\treturn null;\n\t}\n}\n```\n\n如果是正常的开发流程我们需要写一个getLaunchActivityByPackage测试用例，再实现这个方法。这里我就省略了这步,让getLaunchActivityByPackage这个方法先不实现,直接返回null,测试的时候直接mock就好了。\n\n之后我们再去写startAppByPackage的测试用例:\n\n```\n@Test\npublic void startAppByPackage() {\n    mockStatic(AppUtils.class);\n\n    given(AppUtils.startApp(any(Context.class), any(AppUtils.StartAppParam.class)))\n            .willCallRealMethod();\n    given(AppUtils.getLaunchActivityByPackage(any(Context.class), anyString()))\n            .willReturn(\"LauncActivity\");\n    given(mParam.getPackageName()).willReturn(\"packageName\");\n\n    //when\n    assertTrue(AppUtils.startApp(mContext, mParam));\n\n    //then\n    verifyStatic(); //开启static方法的验证,需要开启才能验证AppUtils.getLaunchActivityByPackage是否被调用\n    AppUtils.getLaunchActivityByPackage(any(Context.class), eq(\"packageName\"));\n    then(mIntent).should().setClassName(mParam.getPackageName(), \"LauncActivity\");\n    then(mContext).should().startActivity(mIntent);\n}\n```\n\n首先我们使用mockStatic去模拟AppUtils,然后配置AppUtils.startApp调用实际的方法,而getLaunchActivityByPackage直接返回\"LauncActivity\"。\n\n在验证getLaunchActivityByPackage是否被调用的时候要先调用verifyStatic()。\n\n之后再用下面的方式验证是不是调用了AppUtils.getLaunchActivityByPackage并且传入了\"packageName\"\n\n```\nAppUtils.getLaunchActivityByPackage(any(Context.class), eq(\"packageName\"));\n```\n\n这里多说一点,假设getLaunchActivityByPackage是一个private的方法,我们可以用下面的方式去mock它:\n\n```\nwhen(AppUtils.class, \"getLaunchActivityByPackage\", any(Context.class), anyString())\n        .thenReturn(\"LauncActivity\");\n```\n\n\n# 完整Demo\n\n其他剩下的测试用例我就不一个一个去讲了,基本上通过之前对PowerMock用法的介绍大家也应该能自己实现了。\n\n完整的demo代码可以从[这里](https://github.com/bluesky466/UnitTestDemo)获取\n","source":"_posts/用PowerMock进行Android单元测试与BDD行为驱动开发.md","raw":"title: 用PowerMock进行Android单元测试与BDD行为驱动开发\ndate: 2017-08-26 17:18:28\ntags:\n    - 技术相关\n    - Android\n    - 单元测试\n---\n\n很久之前就有听说过mockito和PowerMock的大名了,无奈我司写单元测试的风气不浓,加上一直以来业务繁忙,惰性使我一直没有写单元测试的习惯。\n\n正好现在手头上的是一个全新的项目,可以在初期有时间也有冲动将各种需要的东西都用上。于是这几天就好好学习了一番,感觉PowerMock的确是无比强大。\n\n# 什么是mock\n\n维基百科上是这么写的:\n\n> 在面向对象程序设计中，模拟对象（英语：mock object，也译作模仿对象）是以可控的方式模拟真实对象行为的假的对象。程序员通常创造模拟对象来测试其他对象的行为，很类似汽车设计者使用碰撞测试假人来模拟车辆碰撞中人的动态行为。  \n> 在单元测试中，模拟对象可以模拟复杂的、真实的（非模拟）对象的行为， 如果真实的对象无法放入单元测试中，使用模拟对象就很有帮助。\n\n如果我们使用依赖注入的方式编写代码,例如Context通常都是外部传入的:\n\n```\nclass ClassA{\n\tpublic static boolean staticFunc(Context context, int arg) {\n\t\t...\n\t}\n}\n```\n\n这个方法如果不使用mock object的方法,我们很难脱离安卓环境去编写单元测试,因为Context是系统生成的。\n\n而使用mock技术去模拟一个Context出来,就可以在android studio中编写并且脱离安卓环境运行单元测试了。\n\n# PowerMock\n\n[powermock](https://github.com/powermock/powermock)是一个流行的java mock框架,通过它我们可以很方便的实现模拟对象。它实际上是继承并且拓展了EasyMock、Mockito等其他的流行框架。\n\n在android studio上导入powermock框架很简单,只需要在build.gradle中添加dependencies就好了:\n\n```\ndependencies {\n\t...\n    testCompile 'junit:junit:4.12'\n\n    testCompile 'org.powermock:powermock-core:1.6.1'\n    testCompile 'org.powermock:powermock-module-junit4:1.6.1'\n    testCompile 'org.powermock:powermock-module-junit4-rule:1.6.1'\n    testCompile 'org.powermock:powermock-api-mockito:1.6.1'\n}\n```\n\n这里有个坑点，之前我用的是1.5.6版本的powermock,但是我的junit是4.12版本的,于是在使用@RunWith(PowerMockRunner.class)的时候会报错:\n\n> org.powermock.reflect.exceptions.FieldNotFoundException: Field 'fTestClass' was not found in class org.junit.internal.runners.MethodValidator.\n\n到stackoverflow上搜索到国外大神的[回答](https://stackoverflow.com/questions/26192929/unable-to-run-junit-test-with-powermockrunner)是powermock小于1.6.1的版本在使用junit 4.12的一个bug,在1.6.1被修复。所以要么用junit 4.12 + powermock 1.6.1,要么使用junit 4.11 + powermock 1.5.6.\n\n# mock的简单用法\n\n先说一下最近我拿到的一个需求。我们的应用的按钮点击启动其他应用的响应需要在服务器上配置。服务器上可能配的是包名启动应用,也可能是action启动应用,还有可能是Uri启动应用。\n\n所以我这样写了一个工具类:\n\n```\npublic class AppUtils {\n\tpublic static boolean startApp(Context context, StartAppParam param) {\n\t\t...\n\t}\n\t\n\t public static class StartAppParam {\n        private String packageName;\n        private String activity;\n        private String action;\n        private String uri;\n        private List<String> categorys = new ArrayList<>();\n        ...\n    }\n}\n```\n\n在服务器上配置一个json,传到客户端解析成StartAppParam,然后调用AppUtils. startApp方法。这样就可以实现这个需求了。\n\n我们使用TDD的方式开发这个功能。首先考虑只配置Action的方式启动:\n\n```\n@Test\n    public void testOpenAppByAction() {\n\t\tContext context = Mockito.mock(Context.class);\n\t\t\n\t\tAppUtils.StartAppParam param = Mockito.mock(AppUtils.StartAppParam.class);\n\t\tPowerMockito.when(param.getAction()).thenReturn(\"package\");\n\t\t\n\t\tassertTrue(AppUtils.startApp(context, param));\n\t\t    \n\t\tMockito.verify(context, Mockito.times(1)).startActivity(Matchers.any(Intent.class));\n    }\n```\n\n首先,使用Mockito.mock方法可以创建一个模拟对象出来。我们这里使用模拟的Context就可以直接在android studio中运行单元测试了。\n\n同时param也用mock的方式创建了出来,而且还模拟了它的getAction方法,让该方法返回\"package\",表示配置了使用Action去启动应用:\n\n```\nAppUtils.StartAppParam param = Mockito.mock(AppUtils.StartAppParam .class);\nPowerMockito.when(param.getAction()).thenReturn(\"package\");\n```\n\n\n然后Mockito.verify方法可以用来验证调用了方法的调用次数,比如这里我们就验证了startActivity被调用了一次。\n\n# mock 方法内部创建的对象\n\n当然这个测试不充分,因为我们没有验证到底是不是通过Action启动的。也就是说我们还需要判断是不是通过new Intent(param.getAction())的方式创建了一个Intent出来。\n\n这就用到了PowerMock的一个很屌的功能了,它不仅可以在外部mock一个对象通过参数传给需要测试的方法,更可以直接mock方法内部创建的对象(比如这里的Intent)!\n\n```\n@RunWith(PowerMockRunner.class)\npublic class AppUtilsTest {\n\n    @Test\n    @PrepareForTest({AppUtils.class})\n    public void testOpenAppByAction() throws Exception {\n        Intent intent = Mockito.mock(Intent.class);\n        PowerMockito.whenNew(Intent.class).withArguments(\"package\").thenReturn(intent);\n\n        Context context = Mockito.mock(Context.class);\n\n        AppUtils.StartAppParam param = Mockito.mock(AppUtils.StartAppParam.class);\n        PowerMockito.when(param.getAction()).thenReturn(\"package\");\n\n        assertTrue(AppUtils.startApp(context, param));\n        \n        Mockito.verify(context, Mockito.times(1)).startActivity(intent);\n        Mockito.verify(intent, Mockito.times(0)).setData(Matchers.any(Uri.class));\n        Mockito.verify(intent, Mockito.times(0)).addCategory(Matchers.anyString());\n        Mockito.verify(intent, Mockito.times(0)).setClassName(Matchers.anyString(), Matchers.anyString());\n    }\n}\n```\n\n首先需要用@RunWith(PowerMockRunner.class)注解AppUtilsTest类,用@PrepareForTest({AppUtils.class})注解testOpenAppByAction方法,传入的AppUtils.class表示需要在AppUtils类内部实现mock操作。\n\n然后mock一个Intent出来,接着使用下面的方法使得使用new Intent(\"package\")得到的Intent是我们mock出来的intent,注意这里连传入的\"package\"参数也需要匹配才能得到我们mock出来的intent。否则只能得到null:\n\n```\nPowerMockito.whenNew(Intent.class).withArguments(\"package\").thenReturn(intent);\n```\n\n所以我们在后面只需要验证startActivity调用的intent是不是我们mock出来的对象,就可以验证是不是通过Action启动的应用了:\n\n```\nMockito.verify(context, Mockito.times(1)).startActivity(intent);\n```\n\n当然,为了保险我们可以顺便确认一下Intent的其他方法是不是没有被调用到:\n\n```\nMockito.verify(intent, Mockito.times(0)).setData(Matchers.any(Uri.class));\nMockito.verify(intent, Mockito.times(0)).addCategory(Matchers.anyString());\nMockito.verify(intent, Mockito.times(0)).setClassName(Matchers.anyString(), Matchers.anyString());\n```\n\n# 使用BDD的方式编写单元测试\n\nBDD (Behavior-driven development,行为驱动开发)通过用自然语言书写非程序员可读的测试用例扩展了测试驱动开发方法。也就是说用bdd方式写的代码就连不是程序员的人也能看得懂,这种可读性的重要性就不用我多费口舌了吧。\n\n其实Mockito的BDD方式的写法我觉得并不是特别的像自然语言。所以我想用C++的单元测试框架Catch框架来举例:\n\n```\nGIVEN(\"a enable stub publish server entry\") {\n    StubPublishServerEntry entry(true);\n\tentry.Start();\n\n    WHEN(\"publish service\") {\n        entry.PublishService(service, on_result, on_success, on_error);\n\n        THEN(\"publish successfully\") {\n            REQUIRE(service_entry != nullptr);\n            REQUIRE(service_entry->IsPublished());\n            REQUIRE(is_on_success);\n            REQUIRE_FALSE(is_on_error);\n        }\n    }\n}\n```\n\n这是我之前的半成品项目中的一个代码片段。如果将代码部分去掉,只留下GIVEN、WHEN、THEN三个宏里面的东西,基本只有是懂英语的人都能看得懂这段代码想做什么:\n\n```\nGIVEN(\"a enable stub publish server entry\") {\n    ...\n    WHEN(\"publish service\") {\n        ...\n        THEN(\"publish successfully\") {\n            ...  \n        }\n    }\n}\n```\n\nPowerMock也是支持BDD的(应该说Mockito是支持BDD的),我们可以将上面写的测试用例改成BDD的写法:\n\n```\npublic void testOpenAppByAction() throws Exception {\n    Intent intent = Mockito.mock(Intent.class);\n    PowerMockito.whenNew(Intent.class).withArguments(\"package\").thenReturn(intent);\n\n    Context context = Mockito.mock(Context.class);\n\n    AppUtils.StartAppParam param = Mockito.mock(AppUtils.StartAppParam .class);\n\n    //given\n    BDDMockito.given(param.getAction()).willReturn(\"package\");\n\n    //when\n    assertTrue(AppUtils.startApp(context, param));\n\n    //then\n    BDDMockito.then(context).should().startActivity(intent);\n    BDDMockito.then(intent).should(Mockito.never()).setData(Matchers.any(Uri.class));\n    BDDMockito.then(intent).should(Mockito.never()).addCategory(Matchers.anyString());\n    BDDMockito.then(intent).should(Mockito.never()).setClassName(Matchers.anyString(), Matchers.anyString());\n}\n```\n\n感觉是不是和自然语言还是差别蛮大的,我们改造改造,将一些方法改成通过import static的方式import:\n\n```\npublic void testOpenAppByAction() throws Exception {\n    Intent intent = mock(Intent.class);\n    whenNew(Intent.class).withArguments(\"package\").thenReturn(intent);\n\n    Context context = mock(Context.class);\n\n    AppUtils.StartAppParam param = mock(AppUtils.StartAppParam .class);\n\n    //given\n    given(param.getAction()).willReturn(\"package\");\n\n    //when\n    assertTrue(AppUtils.startApp(context, param));\n\n    //then\n    then(context).should().startActivity(intent);\n    then(intent).should(never()).setData(any(Uri.class));\n    then(intent).should(never()).addCategory(anyString());\n    then(intent).should(never()).setClassName(anyString(), anyString());\n}\n```\n\n这样是不是好多了？让我们继续改造:\n\n```\npublic class AppUtilsTest {\n    @Mock\n    private Intent mIntent;\n\n    @Mock\n    private Context mContext;\n\n    @Mock\n    private AppUtils.StartAppParam mParam;\n\n    @Before\n    public void setUp() throws Exception {\n        whenNew(Intent.class).withArguments(\"package\").thenReturn(mIntent);\n    }\n\n    @Test\n    @PrepareForTest({AppUtils.class})\n    public void testOpenAppByAction() {\n        given(mParam.getAction()).willReturn(\"package\");\n\n        //when\n        assertTrue(AppUtils.startApp(mContext, mParam));\n\n        then(mContext).should().startActivity(mIntent);\n        then(mIntent).should(never()).setData(any(Uri.class));\n        then(mIntent).should(never()).addCategory(anyString());\n        then(mIntent).should(never()).setClassName(anyString(), anyString());\n    }\n}\n```\n\n因为Intent、Context、AppUtils.StartAppParam都是需要在不同测试用例中经常被用到的,我们将它写成成员变量并且用@Mock实现自动mock,省去Mockito.mock()方法的调用。\n\n然后将whenNew方法放到由@Before注解的setUp()方法中。\n\n现在看testOpenAppByAction是不是简洁多了？只要有一点代码功底的人都能很容易看明白这个用例到底是用来验证什么的。\n\n当然,这里的BDD写法和上面Catch的写法比起来在像自然语言方面还是有点差距的。\n\n现在我们已经将测试用例写出来了，就可以开始写代码让这个测试用例通过了。像这样先写行为测试用例再写代码的开发方式就叫做BDD。\n\n\n# mock 静态方法\n\n我们下一个需要实现的功能是什么呢？就实现通过包名启动应用吧。将设只配置了包名,但没有配置Activity名。我们就需要先找到这个应用的Launch Activity,然后再去启动应用。\n\n所以我们在AppUtils中新增了一个方法,用于从包名获取Activity名:\n\n```\npublic class AppUtils {\n\tpublic static boolean startApp(Context context, StartAppParam param) {\n\t\t...\n\t}\n\t\n\tpublic static String getLaunchActivityByPackage(Context context, String packageName) {\n\t\treturn null;\n\t}\n}\n```\n\n如果是正常的开发流程我们需要写一个getLaunchActivityByPackage测试用例，再实现这个方法。这里我就省略了这步,让getLaunchActivityByPackage这个方法先不实现,直接返回null,测试的时候直接mock就好了。\n\n之后我们再去写startAppByPackage的测试用例:\n\n```\n@Test\npublic void startAppByPackage() {\n    mockStatic(AppUtils.class);\n\n    given(AppUtils.startApp(any(Context.class), any(AppUtils.StartAppParam.class)))\n            .willCallRealMethod();\n    given(AppUtils.getLaunchActivityByPackage(any(Context.class), anyString()))\n            .willReturn(\"LauncActivity\");\n    given(mParam.getPackageName()).willReturn(\"packageName\");\n\n    //when\n    assertTrue(AppUtils.startApp(mContext, mParam));\n\n    //then\n    verifyStatic(); //开启static方法的验证,需要开启才能验证AppUtils.getLaunchActivityByPackage是否被调用\n    AppUtils.getLaunchActivityByPackage(any(Context.class), eq(\"packageName\"));\n    then(mIntent).should().setClassName(mParam.getPackageName(), \"LauncActivity\");\n    then(mContext).should().startActivity(mIntent);\n}\n```\n\n首先我们使用mockStatic去模拟AppUtils,然后配置AppUtils.startApp调用实际的方法,而getLaunchActivityByPackage直接返回\"LauncActivity\"。\n\n在验证getLaunchActivityByPackage是否被调用的时候要先调用verifyStatic()。\n\n之后再用下面的方式验证是不是调用了AppUtils.getLaunchActivityByPackage并且传入了\"packageName\"\n\n```\nAppUtils.getLaunchActivityByPackage(any(Context.class), eq(\"packageName\"));\n```\n\n这里多说一点,假设getLaunchActivityByPackage是一个private的方法,我们可以用下面的方式去mock它:\n\n```\nwhen(AppUtils.class, \"getLaunchActivityByPackage\", any(Context.class), anyString())\n        .thenReturn(\"LauncActivity\");\n```\n\n\n# 完整Demo\n\n其他剩下的测试用例我就不一个一个去讲了,基本上通过之前对PowerMock用法的介绍大家也应该能自己实现了。\n\n完整的demo代码可以从[这里](https://github.com/bluesky466/UnitTestDemo)获取\n","slug":"用PowerMock进行Android单元测试与BDD行为驱动开发","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2umb000hw3fyizrxr687"},{"title":"浅谈SurfaceView与GLSurfaceView","date":"2018-09-20T16:10:51.000Z","_content":"\n#　什么是Surface\n\n让我们看看Surface的官方介绍:\n\n> Handle onto a raw buffer that is being managed by the screen compositor.\n\nSurface是一个raw buffer的句柄,我们可以通过它在raw buffer上进行绘制．\n\n对应到代码其实就是可以通过Surface获得一个Canvas:\n\n```\nCanvas canvas = mSurface.lockCanvas(null);\n//使用Canvas进行绘制\nmSurface.unlockCanvasAndPost(canvas);\n```\n\nSurface其实是安卓中专门用来画图的地方.\n\n# SurfaceView\n\nSurface可能大家比较陌生,但是SurfaceView和GLSurfaceView相信大家或多或少都会听说过．\n\nSurfaceView其实就是对Surface进行了一次封装,它内部帮我们管理了一个Surface．我们使用SurfaceView其实最终都是获取到这个Surface去绘制．\n\n这里开门见山,直接抛出一个简单的SurfaceView的用法,下面的Demo用SurfaceView画了一个１００*１００的红色矩形\n\n```\npublic class MySurfaceView extends SurfaceView implements SurfaceHolder.Callback {\n    private DrawThread mDrawThread;\n\n    public MySurfaceView(Context context) {\n        this(context, null);\n    }\n\n    public MySurfaceView(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public MySurfaceView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        getHolder().addCallback(this);\n    }\n\n    @Override\n    public void surfaceCreated(SurfaceHolder holder) {\n        mDrawThread = new DrawThread(holder.getSurface());\n        mDrawThread.start();\n    }\n\n    @Override\n    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {\n\n    }\n\n    @Override\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        mDrawThread.stopDraw();\n        try {\n            mDrawThread.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static class DrawThread extends Thread {\n        private Surface mSurface;\n        private boolean mRunning = true;\n        private Paint mPaint = new Paint();\n\n        DrawThread(Surface surface) {\n            mSurface = surface;\n            mPaint.setColor(Color.RED);\n        }\n\n        void stopDraw() {\n            mRunning = false;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n\n            while (mRunning) {\n                Canvas canvas = mSurface.lockCanvas(null);\n                canvas.drawColor(Color.WHITE);\n                canvas.drawRect(0, 0, 100, 100, mPaint);\n                mSurface.unlockCanvasAndPost(canvas);\n\n                try {\n                    Thread.sleep(50);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n运行效果如下:\n\n{% img /浅谈SurfaceView与GLSurfaceView/1.jpg %}\n\n这个Demo有几个关键代码,第一个是在构造函数里面使用getHolder()获取到SurfaceHolder,然后使用addCallback注册了个监听．这样就能监听SurfaceView内部Surface的生命周期．\n\n接着我们在surfaceCreated回调里面开启了一个DrawThread线程．它的主要工作就是在一个while循环里面不停的绘制．\n\n通过代码我们可以看到这个绘制的过程:\n\n1. 通过SurfaceHolder．getSurface可以获取到Surface\n2. 通过Surface.lockCanvas可以获取到Surface的Canvas\n3. 使用Canvas去绘制图像\n4. 使用Surface.unlockCanvasAndPost可以释放Canvas\n\n相信这个Demo代码不用再多说,大家都可以很快理解．从中我们可以看到,SurfaceView最大的特点就是可以在子线程中绘制图像．\n\n在子线程中绘制图像有什么好处呢？\n\n我们都知道一般情况下View都是在主线程中绘制的,而且需要通过measure、layout、draw三个步骤．当布局越复杂,绘制的效率就越低,而且主线程中的一些耗时操作也会进一步降低效率．\n\n如果使用SurfaceView的话我们就能越过measure、layout操作,而且不会被主线程的运算减低绘制性能．这样的特性十分适合于一些频繁更新且对刷新率有一定要求的程序,如相机的预览、画笔书写等．\n\n# GLSurfaceView\n\n而GLSurfaceView继承自SurfaceView,其实是对SurfaceView再做了一次封装,方便我们在安卓中使用OpenGL.\n\n我们都知道OpenGL是一个跨平台的图形库.它提供了一些全平台统一的图形接口.但是各个平台其实都有一些很难统一的差异,所以为了跨平台的兼容性,OpenGL不负责窗口管理及上下文管理.这部分由各个平台自己实现．EGL就是安卓平台上的实现它是 OpenGL ES 和底层 Native 平台视窗系统之间的接口．\n\n所以在安卓上使用OpenGL,都需要先用EGL进行一些初始化操作,结束的时候再用EGL做一些清理工作．\n\nGLSurfaceView已经帮我们用SurfaceHolder做了EGL的初始化和清理操作,所以我们不需要再去关心EGL．\n\n和我们上面写的SurfaceView的Demo一样,GLSurface的绘制也是在子线程中进行的,它为我们开启了一个GLThread，对一些处理事件进行了处理.我们只需要实现Renderer接口进行绘制即可,GLSurfaceView就会在GLThread中调用我们的Renderer进行绘制:\n\n```\npublic class GLSurfaceView extends SurfaceView implements SurfaceHolder.Callback2 {\n  ...\n  private Renderer mRenderer\n  ...\n  static class GLThread extends Thread {\n    ...\n    @Override\n    public void run() {\n      ...\n      guardedRun();\n      ...\n    }\n    ...\n    private void guardedRun() throws InterruptedException {\n      ...\n      while(true){\n        ...\n        view.mRenderer.onSurfaceCreated(gl, mEglHelper.mEglConfig);\n        ...\n        view.mRenderer.onSurfaceChanged(gl, w, h);\n        ...\n        view.mRenderer.onDrawFrame(gl);\n        ...\n      }\n      ...\n    }\n    ...\n  }\n  ...\n}\n```\n\n一个简单的Demo如下:\n\n```\npublic class MyGLSurfaceView extends GLSurfaceView {\n    public MyGLSurfaceView(Context context) {\n        this(context, null);\n    }\n\n    public MyGLSurfaceView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n\n        setRenderer(new MyRender());\n    }\n\n    private static class MyRender implements Renderer {\n        private FloatBuffer mVB;\n\n        MyRender() {\n            float coords[] = {\n                    -0.5f, 0.5f, 0.0f,\n                    -0.5f, -0.5f, 0.0f,\n                    0.5f, -0.5f, 0.0f,\n                    0.5f, -0.5f, 0.0f,\n                    0.5f, 0.5f, 0.0f,\n                    -0.5f, 0.5f, 0.0f\n            };\n\n            ByteBuffer vbb = ByteBuffer.allocateDirect(coords.length * 4);\n            vbb.order(ByteOrder.nativeOrder());\n            mVB = vbb.asFloatBuffer();\n            mVB.put(coords);\n            mVB.position(0);\n        }\n\n        @Override\n        public void onSurfaceCreated(GL10 gl, EGLConfig config) {\n            gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);\n        }\n\n        @Override\n        public void onSurfaceChanged(GL10 gl, int width, int height) {\n            gl.glViewport(0, 0, width, height);\n        }\n\n        @Override\n        public void onDrawFrame(GL10 gl) {\n            gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);\n            gl.glClearColor(1.0f, 1.0f, 1.0f, 1.0f);\n            gl.glColor4f(1.0f, 0.0f, 0.0f, 1.0f);\n            gl.glVertexPointer(3, GL10.GL_FLOAT, 0, mVB);\n            gl.glDrawArrays(GL10.GL_TRIANGLES, 0, 6);\n        }\n    }\n}\n```\n\n可以看到,我们实现了Renderer去画一个红色矩形,然后使用setRenderer设置给GLSurfaceView就可以了,运行效果如下:\n\n{% img /浅谈SurfaceView与GLSurfaceView/2.jpg %}\n\n","source":"_posts/浅谈SurfaceView与GLSurfaceView.md","raw":"title: 浅谈SurfaceView与GLSurfaceView\ndate: 2018-09-21 00:10:51\ntags:\n\t- 技术相关\n  - Android\n---\n\n#　什么是Surface\n\n让我们看看Surface的官方介绍:\n\n> Handle onto a raw buffer that is being managed by the screen compositor.\n\nSurface是一个raw buffer的句柄,我们可以通过它在raw buffer上进行绘制．\n\n对应到代码其实就是可以通过Surface获得一个Canvas:\n\n```\nCanvas canvas = mSurface.lockCanvas(null);\n//使用Canvas进行绘制\nmSurface.unlockCanvasAndPost(canvas);\n```\n\nSurface其实是安卓中专门用来画图的地方.\n\n# SurfaceView\n\nSurface可能大家比较陌生,但是SurfaceView和GLSurfaceView相信大家或多或少都会听说过．\n\nSurfaceView其实就是对Surface进行了一次封装,它内部帮我们管理了一个Surface．我们使用SurfaceView其实最终都是获取到这个Surface去绘制．\n\n这里开门见山,直接抛出一个简单的SurfaceView的用法,下面的Demo用SurfaceView画了一个１００*１００的红色矩形\n\n```\npublic class MySurfaceView extends SurfaceView implements SurfaceHolder.Callback {\n    private DrawThread mDrawThread;\n\n    public MySurfaceView(Context context) {\n        this(context, null);\n    }\n\n    public MySurfaceView(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public MySurfaceView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        getHolder().addCallback(this);\n    }\n\n    @Override\n    public void surfaceCreated(SurfaceHolder holder) {\n        mDrawThread = new DrawThread(holder.getSurface());\n        mDrawThread.start();\n    }\n\n    @Override\n    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {\n\n    }\n\n    @Override\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        mDrawThread.stopDraw();\n        try {\n            mDrawThread.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static class DrawThread extends Thread {\n        private Surface mSurface;\n        private boolean mRunning = true;\n        private Paint mPaint = new Paint();\n\n        DrawThread(Surface surface) {\n            mSurface = surface;\n            mPaint.setColor(Color.RED);\n        }\n\n        void stopDraw() {\n            mRunning = false;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n\n            while (mRunning) {\n                Canvas canvas = mSurface.lockCanvas(null);\n                canvas.drawColor(Color.WHITE);\n                canvas.drawRect(0, 0, 100, 100, mPaint);\n                mSurface.unlockCanvasAndPost(canvas);\n\n                try {\n                    Thread.sleep(50);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n运行效果如下:\n\n{% img /浅谈SurfaceView与GLSurfaceView/1.jpg %}\n\n这个Demo有几个关键代码,第一个是在构造函数里面使用getHolder()获取到SurfaceHolder,然后使用addCallback注册了个监听．这样就能监听SurfaceView内部Surface的生命周期．\n\n接着我们在surfaceCreated回调里面开启了一个DrawThread线程．它的主要工作就是在一个while循环里面不停的绘制．\n\n通过代码我们可以看到这个绘制的过程:\n\n1. 通过SurfaceHolder．getSurface可以获取到Surface\n2. 通过Surface.lockCanvas可以获取到Surface的Canvas\n3. 使用Canvas去绘制图像\n4. 使用Surface.unlockCanvasAndPost可以释放Canvas\n\n相信这个Demo代码不用再多说,大家都可以很快理解．从中我们可以看到,SurfaceView最大的特点就是可以在子线程中绘制图像．\n\n在子线程中绘制图像有什么好处呢？\n\n我们都知道一般情况下View都是在主线程中绘制的,而且需要通过measure、layout、draw三个步骤．当布局越复杂,绘制的效率就越低,而且主线程中的一些耗时操作也会进一步降低效率．\n\n如果使用SurfaceView的话我们就能越过measure、layout操作,而且不会被主线程的运算减低绘制性能．这样的特性十分适合于一些频繁更新且对刷新率有一定要求的程序,如相机的预览、画笔书写等．\n\n# GLSurfaceView\n\n而GLSurfaceView继承自SurfaceView,其实是对SurfaceView再做了一次封装,方便我们在安卓中使用OpenGL.\n\n我们都知道OpenGL是一个跨平台的图形库.它提供了一些全平台统一的图形接口.但是各个平台其实都有一些很难统一的差异,所以为了跨平台的兼容性,OpenGL不负责窗口管理及上下文管理.这部分由各个平台自己实现．EGL就是安卓平台上的实现它是 OpenGL ES 和底层 Native 平台视窗系统之间的接口．\n\n所以在安卓上使用OpenGL,都需要先用EGL进行一些初始化操作,结束的时候再用EGL做一些清理工作．\n\nGLSurfaceView已经帮我们用SurfaceHolder做了EGL的初始化和清理操作,所以我们不需要再去关心EGL．\n\n和我们上面写的SurfaceView的Demo一样,GLSurface的绘制也是在子线程中进行的,它为我们开启了一个GLThread，对一些处理事件进行了处理.我们只需要实现Renderer接口进行绘制即可,GLSurfaceView就会在GLThread中调用我们的Renderer进行绘制:\n\n```\npublic class GLSurfaceView extends SurfaceView implements SurfaceHolder.Callback2 {\n  ...\n  private Renderer mRenderer\n  ...\n  static class GLThread extends Thread {\n    ...\n    @Override\n    public void run() {\n      ...\n      guardedRun();\n      ...\n    }\n    ...\n    private void guardedRun() throws InterruptedException {\n      ...\n      while(true){\n        ...\n        view.mRenderer.onSurfaceCreated(gl, mEglHelper.mEglConfig);\n        ...\n        view.mRenderer.onSurfaceChanged(gl, w, h);\n        ...\n        view.mRenderer.onDrawFrame(gl);\n        ...\n      }\n      ...\n    }\n    ...\n  }\n  ...\n}\n```\n\n一个简单的Demo如下:\n\n```\npublic class MyGLSurfaceView extends GLSurfaceView {\n    public MyGLSurfaceView(Context context) {\n        this(context, null);\n    }\n\n    public MyGLSurfaceView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n\n        setRenderer(new MyRender());\n    }\n\n    private static class MyRender implements Renderer {\n        private FloatBuffer mVB;\n\n        MyRender() {\n            float coords[] = {\n                    -0.5f, 0.5f, 0.0f,\n                    -0.5f, -0.5f, 0.0f,\n                    0.5f, -0.5f, 0.0f,\n                    0.5f, -0.5f, 0.0f,\n                    0.5f, 0.5f, 0.0f,\n                    -0.5f, 0.5f, 0.0f\n            };\n\n            ByteBuffer vbb = ByteBuffer.allocateDirect(coords.length * 4);\n            vbb.order(ByteOrder.nativeOrder());\n            mVB = vbb.asFloatBuffer();\n            mVB.put(coords);\n            mVB.position(0);\n        }\n\n        @Override\n        public void onSurfaceCreated(GL10 gl, EGLConfig config) {\n            gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);\n        }\n\n        @Override\n        public void onSurfaceChanged(GL10 gl, int width, int height) {\n            gl.glViewport(0, 0, width, height);\n        }\n\n        @Override\n        public void onDrawFrame(GL10 gl) {\n            gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);\n            gl.glClearColor(1.0f, 1.0f, 1.0f, 1.0f);\n            gl.glColor4f(1.0f, 0.0f, 0.0f, 1.0f);\n            gl.glVertexPointer(3, GL10.GL_FLOAT, 0, mVB);\n            gl.glDrawArrays(GL10.GL_TRIANGLES, 0, 6);\n        }\n    }\n}\n```\n\n可以看到,我们实现了Renderer去画一个红色矩形,然后使用setRenderer设置给GLSurfaceView就可以了,运行效果如下:\n\n{% img /浅谈SurfaceView与GLSurfaceView/2.jpg %}\n\n","slug":"浅谈SurfaceView与GLSurfaceView","published":1,"updated":"2018-09-21T11:23:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2umd000nw3fy4povqv3c"},{"title":"我也来谈一谈Java GC","date":"2017-11-10T14:51:26.000Z","_content":"\n以前写c/c++的时候虽然也有shared_ptr这样的自动内存管理机制,但是它内部其实是通过引用计数的原理进行内存管理的,容易产生循环应用的问题,也没有什么实际意义上的内存收集器。和java的内存收集机制差别很大,所以一直对java的内存收集机制抱有很强的好奇心。\n\n最近在看《深入理解 Java 虚拟机-Jvm 高级特性与最佳实践》,里面对java垃圾收集讲的挺不错的。然后再将书中没有讲透的知识在网上搜索了下,整理成了这篇博客,哪天一时半会记不起来的时候还能回来瞧一瞧。\n\n# GC Roots\n\n在Java虚拟机中，存在自动内存管理和垃圾回收机制,能自动回收没有用的对象的内存。\n\n那怎么去判定一个对象是否还有用呢？java中是通过可达性分析来判定的。\n\n具体的做法就是从__一系列__被称作\"GC Roots\"的对象作为起始点,从这些对象开始通过引用关系进行搜索。当GC Roots到某个对象没有任何引用链相连,则证明此对象是不可用的,是不需要存活,可以被清理的。\n\n例如下图的object1、object2、object3、object4就是从GC Roots可达的,不能被回收。而object5、object6、object7虽然相互引用,但从GC Roots不可达,证明程序中无法访问到它们,所以它们是无用的,可以被回收。\n\n{% img /我也来谈一谈Java-GC/1.png %}\n\n在Java中,可以作为GC Roots的对象包括下面几种:\n\n- 虚拟机栈(栈帧中的本地变量表)中引用的对象\n- 方法区中类静态属性引用的对象\n- 方法去中常量引用的对象\n- 本地方法栈中JNI引用的对象\n\n# Java 堆中的内存分配与回收\n\n对于大多数应用来说,Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域,在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例,几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是:所有的对象实例以及数组都要在堆上分配。\n\n由于现在收集器基本都是采用的分代收集算法,所以Java堆中还可以细分为新生代和老年代。\n\n## 新生代中的Minor GC\n\n大部分对象被创建时,内存的分配首先发生在年轻代(占用内存比较大的对象如数组,会被直接分配到老年带)。大部分的对象在创建之后很快就不再使用了,因此很快变成不可达的状态,于是被新生代的GC机制清理掉。这个GC机制被称为Minor GC或叫Young GC。\n\n新生代可以分为3个区域:一个Eden区和两个Survivor区。两个Survivor中总有一个是空的,我们叫他Survivor To区,还有一个非空的,我们叫他Survivor From区。Eden区和两个Survivor区的大小为8:1:1。\n\n对象被创建的时候,绝大部分都是被分配在Eden区。Eden区是连续的内存空间，因此在其上分配内存极快。__当Eden区满的时候,就会执行Minor GC__。\n\n### 复制算法\nMinor GC时Eden区和Survivor From区还存活着的对象会一次性被复制到Survivor To区。然后Eden区和Survivor From区的内存会被清空。\n\n之后原来的Survivor From区就空了,而原来的Survivor To区就非空。这个时候它们的角色就调换了,空的叫做Survivor To区,非空的叫做Survivor From区。\n\n这种垃圾收集算法叫做__复制算法__,整个过程如下图所示:\n\n{% img /我也来谈一谈Java-GC/2.png %}\n\n### 为什么需要两个Survivor区\n\n复制算法的优点在于,gc完成之后占用的内存会被整理到一个连续的空间中。而空闲的内存也是连续的区域,不会造成内存碎片。\n\n如果只有一个Eden区和一个Survivor区,在Minor GC的时候,Eden区的存活对象可以被复制到Survivor区,这样Eden区可以被清空出一个完整的空闲内存区域。\n\n而Survivor区存活的对象要怎么办呢:\n\n- 如果直接进入老年代。可能有些对象经过少数的几次GC就能被释放。但在老年代中GC发生的频率比新生代低很多。这样的话就会导致老年代的内存很快被占满。\n\n- 如果不管存活的对象,只是简单的清除不可达的对象。那么Survivor区就会产生内存碎片\n\n- 如果进行压缩整理,与从新生代复制过来的存活对象一起整理到Survivor中某个连续的区域的话,消耗的计算资源会比较高。\n\n所以最简单的做法就是拿多一个Survivor To区出来,Eden区和Survivor From区存活的对象会被连续的复制到Survivor To区的一个连续区域中。然后将Eden区和Survivor From区清空就好。\n\n由于新生代大部分的对象生命周期都很短,所以需要复制的对象的数目也不会很多,所以这是比较高效的做法。\n\n### 对象进入老年代\n\n对象在下面三种情况下,对象进入到老年代:\n\n- 占用内存比较大的对象如数组,在创建的时候不会分配到Eden区,而会被直接分配到老年代\n\n- 当Minor GC时Survivor To区已经放不下还存活的对象的时候,这些对象就会被放到老年代中。\n\n- 每经历一次Minor GC,对象的年龄会大一岁。当对象的年龄到达某一个值,Minor GC的时候就不会去到Survivor To区,而会进入老年代。\n\n## 老年代\n\n在新生代中经历了N次垃圾回收后仍然存活的对象,就会被放到年老代中。因此,可以认为年老代中存放的都是一些生命周期较长的对象。\n\n在新生代中,每次垃圾收集时都发现有大批对象死去,只有少量存活,所以选用复制算法,只需要付出少量对象的复制成本就能完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保,就需要使用\"标记-清理\"或者\"标记-整理\"算法来进行回收。\n\n### 标记-清理算法\n\n标记-清除算法顾名思义,主要就是两个动作,一个是标记,另一个就是清除。首先标记出所有需要回收的对象,在标记完成后统一回收所有被标记的对象。\n\n它的缺点有两个\n\n1. 标记与清除的效率都比较低\n2. 标记清除之后会产生大量不连续的内存碎片\n\n它的执行过程如下图所示:\n\n{% img /我也来谈一谈Java-GC/3.png %}\n\n发生在老年代的GC叫做Major GC,通常当Minor GC晋升到老年代的大小大于老年代的剩余空间时,Major GC就会被触发。\n\n出现了Major GC,通常会伴随着至少一次的Minor GC(不是绝对的,有些收集器有直接进行Major GC的策略)。Major GC的速度一般会比Minor GC慢10倍以上。\n\n\n除了Minor GC和Major GC之外,还有一个Full GC的概念,它们的区别如下:\n\n1. Minor GC : 回收新生代的垃圾\n2. Major GC : 回收老年代的垃圾\n3. Full GC : 回收整个堆的垃圾,包括新生代、老年代、持久代等\n\n### 标记-整理算法\n\n标记过程仍和标记-清理算法一样,但是后续的步骤不是直接对可回收的对象进行清理,而是让所有存活的对象往一端移动,然后再清理掉边界以外的内存。它的过程如下图所示:\n\n{% img /我也来谈一谈Java-GC/4.png %}\n\n# 垃圾搜集器\n\n如果说收集算法是内存回收的方法论,那么垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定,所以不同的厂商、不同版本的虚拟机提供的垃圾收集器都可能有很大差别。\n\n下面这张图列出了JDK1.7 Update 14之后HotSpot虚拟机所包含的垃圾收集器:\n\n{% img /我也来谈一谈Java-GC/5.png %}\n\n每种收集器具体的实现方法这里我就不罗列了,感兴趣的同学可以自行搜索。\n\n# finalize方法\n\n即使在可达性分析中不可达的对象,也并非是\"非死不可\"的。这时它们只是处于\"缓刑\"阶段,要宣布一个对象死亡,至少要经历两次标记过程:\n\n1. 第一次可达性分析之后,不可达的对象会被标记出来放到一个\"即将回收\"的集合中。\n\n2. 被标记的对象会进行一次筛选,__覆盖了finalize方法__并且__finalize方法没有被调用过__的对象会放到一个叫做F-Queue的队列中。虚拟机会创建一个低优先级的Finalizer线程去执行它。如果一个对象想逃脱死亡的命运,只需要在finalize方法中将自己重新连接上引用链就可以了,例如将自己赋给某个类变量或对象的成员变量。\n\n3. 第二次可达性分析会将被重新连接上引用链的对象移出\"即将回收\"的集合。\n\n4. 最后将不可达的对象内存回收\n\n\n这里有两点需要注意的是:\n\n- \"执行\"finalize方法指的是虚拟机会触发这个方法,但不承诺等待它运行结束,这样做的原因是防止某个对象的finalize方法运行缓慢或者发生死循环,导致F-Queue的队列其他对象永久等待甚至导致内存回收系统崩溃。\n\n- finalize只有一次被调用的机会。如果在finalize中将对象重新连接上引用链,只有在对象在第一次即将被回收的时候,finalize方法会被调用。在下一次GC的标记过程中,因为finalize方法已经被调用过了,所以就不会被放到F-Queue的队列中。","source":"_posts/我也来谈一谈Java-GC.md","raw":"title: 我也来谈一谈Java GC\ndate: 2017-11-10 22:51:26\ntags:\n\t- 技术相关\n\t- java\n---\n\n以前写c/c++的时候虽然也有shared_ptr这样的自动内存管理机制,但是它内部其实是通过引用计数的原理进行内存管理的,容易产生循环应用的问题,也没有什么实际意义上的内存收集器。和java的内存收集机制差别很大,所以一直对java的内存收集机制抱有很强的好奇心。\n\n最近在看《深入理解 Java 虚拟机-Jvm 高级特性与最佳实践》,里面对java垃圾收集讲的挺不错的。然后再将书中没有讲透的知识在网上搜索了下,整理成了这篇博客,哪天一时半会记不起来的时候还能回来瞧一瞧。\n\n# GC Roots\n\n在Java虚拟机中，存在自动内存管理和垃圾回收机制,能自动回收没有用的对象的内存。\n\n那怎么去判定一个对象是否还有用呢？java中是通过可达性分析来判定的。\n\n具体的做法就是从__一系列__被称作\"GC Roots\"的对象作为起始点,从这些对象开始通过引用关系进行搜索。当GC Roots到某个对象没有任何引用链相连,则证明此对象是不可用的,是不需要存活,可以被清理的。\n\n例如下图的object1、object2、object3、object4就是从GC Roots可达的,不能被回收。而object5、object6、object7虽然相互引用,但从GC Roots不可达,证明程序中无法访问到它们,所以它们是无用的,可以被回收。\n\n{% img /我也来谈一谈Java-GC/1.png %}\n\n在Java中,可以作为GC Roots的对象包括下面几种:\n\n- 虚拟机栈(栈帧中的本地变量表)中引用的对象\n- 方法区中类静态属性引用的对象\n- 方法去中常量引用的对象\n- 本地方法栈中JNI引用的对象\n\n# Java 堆中的内存分配与回收\n\n对于大多数应用来说,Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域,在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例,几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是:所有的对象实例以及数组都要在堆上分配。\n\n由于现在收集器基本都是采用的分代收集算法,所以Java堆中还可以细分为新生代和老年代。\n\n## 新生代中的Minor GC\n\n大部分对象被创建时,内存的分配首先发生在年轻代(占用内存比较大的对象如数组,会被直接分配到老年带)。大部分的对象在创建之后很快就不再使用了,因此很快变成不可达的状态,于是被新生代的GC机制清理掉。这个GC机制被称为Minor GC或叫Young GC。\n\n新生代可以分为3个区域:一个Eden区和两个Survivor区。两个Survivor中总有一个是空的,我们叫他Survivor To区,还有一个非空的,我们叫他Survivor From区。Eden区和两个Survivor区的大小为8:1:1。\n\n对象被创建的时候,绝大部分都是被分配在Eden区。Eden区是连续的内存空间，因此在其上分配内存极快。__当Eden区满的时候,就会执行Minor GC__。\n\n### 复制算法\nMinor GC时Eden区和Survivor From区还存活着的对象会一次性被复制到Survivor To区。然后Eden区和Survivor From区的内存会被清空。\n\n之后原来的Survivor From区就空了,而原来的Survivor To区就非空。这个时候它们的角色就调换了,空的叫做Survivor To区,非空的叫做Survivor From区。\n\n这种垃圾收集算法叫做__复制算法__,整个过程如下图所示:\n\n{% img /我也来谈一谈Java-GC/2.png %}\n\n### 为什么需要两个Survivor区\n\n复制算法的优点在于,gc完成之后占用的内存会被整理到一个连续的空间中。而空闲的内存也是连续的区域,不会造成内存碎片。\n\n如果只有一个Eden区和一个Survivor区,在Minor GC的时候,Eden区的存活对象可以被复制到Survivor区,这样Eden区可以被清空出一个完整的空闲内存区域。\n\n而Survivor区存活的对象要怎么办呢:\n\n- 如果直接进入老年代。可能有些对象经过少数的几次GC就能被释放。但在老年代中GC发生的频率比新生代低很多。这样的话就会导致老年代的内存很快被占满。\n\n- 如果不管存活的对象,只是简单的清除不可达的对象。那么Survivor区就会产生内存碎片\n\n- 如果进行压缩整理,与从新生代复制过来的存活对象一起整理到Survivor中某个连续的区域的话,消耗的计算资源会比较高。\n\n所以最简单的做法就是拿多一个Survivor To区出来,Eden区和Survivor From区存活的对象会被连续的复制到Survivor To区的一个连续区域中。然后将Eden区和Survivor From区清空就好。\n\n由于新生代大部分的对象生命周期都很短,所以需要复制的对象的数目也不会很多,所以这是比较高效的做法。\n\n### 对象进入老年代\n\n对象在下面三种情况下,对象进入到老年代:\n\n- 占用内存比较大的对象如数组,在创建的时候不会分配到Eden区,而会被直接分配到老年代\n\n- 当Minor GC时Survivor To区已经放不下还存活的对象的时候,这些对象就会被放到老年代中。\n\n- 每经历一次Minor GC,对象的年龄会大一岁。当对象的年龄到达某一个值,Minor GC的时候就不会去到Survivor To区,而会进入老年代。\n\n## 老年代\n\n在新生代中经历了N次垃圾回收后仍然存活的对象,就会被放到年老代中。因此,可以认为年老代中存放的都是一些生命周期较长的对象。\n\n在新生代中,每次垃圾收集时都发现有大批对象死去,只有少量存活,所以选用复制算法,只需要付出少量对象的复制成本就能完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保,就需要使用\"标记-清理\"或者\"标记-整理\"算法来进行回收。\n\n### 标记-清理算法\n\n标记-清除算法顾名思义,主要就是两个动作,一个是标记,另一个就是清除。首先标记出所有需要回收的对象,在标记完成后统一回收所有被标记的对象。\n\n它的缺点有两个\n\n1. 标记与清除的效率都比较低\n2. 标记清除之后会产生大量不连续的内存碎片\n\n它的执行过程如下图所示:\n\n{% img /我也来谈一谈Java-GC/3.png %}\n\n发生在老年代的GC叫做Major GC,通常当Minor GC晋升到老年代的大小大于老年代的剩余空间时,Major GC就会被触发。\n\n出现了Major GC,通常会伴随着至少一次的Minor GC(不是绝对的,有些收集器有直接进行Major GC的策略)。Major GC的速度一般会比Minor GC慢10倍以上。\n\n\n除了Minor GC和Major GC之外,还有一个Full GC的概念,它们的区别如下:\n\n1. Minor GC : 回收新生代的垃圾\n2. Major GC : 回收老年代的垃圾\n3. Full GC : 回收整个堆的垃圾,包括新生代、老年代、持久代等\n\n### 标记-整理算法\n\n标记过程仍和标记-清理算法一样,但是后续的步骤不是直接对可回收的对象进行清理,而是让所有存活的对象往一端移动,然后再清理掉边界以外的内存。它的过程如下图所示:\n\n{% img /我也来谈一谈Java-GC/4.png %}\n\n# 垃圾搜集器\n\n如果说收集算法是内存回收的方法论,那么垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定,所以不同的厂商、不同版本的虚拟机提供的垃圾收集器都可能有很大差别。\n\n下面这张图列出了JDK1.7 Update 14之后HotSpot虚拟机所包含的垃圾收集器:\n\n{% img /我也来谈一谈Java-GC/5.png %}\n\n每种收集器具体的实现方法这里我就不罗列了,感兴趣的同学可以自行搜索。\n\n# finalize方法\n\n即使在可达性分析中不可达的对象,也并非是\"非死不可\"的。这时它们只是处于\"缓刑\"阶段,要宣布一个对象死亡,至少要经历两次标记过程:\n\n1. 第一次可达性分析之后,不可达的对象会被标记出来放到一个\"即将回收\"的集合中。\n\n2. 被标记的对象会进行一次筛选,__覆盖了finalize方法__并且__finalize方法没有被调用过__的对象会放到一个叫做F-Queue的队列中。虚拟机会创建一个低优先级的Finalizer线程去执行它。如果一个对象想逃脱死亡的命运,只需要在finalize方法中将自己重新连接上引用链就可以了,例如将自己赋给某个类变量或对象的成员变量。\n\n3. 第二次可达性分析会将被重新连接上引用链的对象移出\"即将回收\"的集合。\n\n4. 最后将不可达的对象内存回收\n\n\n这里有两点需要注意的是:\n\n- \"执行\"finalize方法指的是虚拟机会触发这个方法,但不承诺等待它运行结束,这样做的原因是防止某个对象的finalize方法运行缓慢或者发生死循环,导致F-Queue的队列其他对象永久等待甚至导致内存回收系统崩溃。\n\n- finalize只有一次被调用的机会。如果在finalize中将对象重新连接上引用链,只有在对象在第一次即将被回收的时候,finalize方法会被调用。在下一次GC的标记过程中,因为finalize方法已经被调用过了,所以就不会被放到F-Queue的队列中。","slug":"我也来谈一谈Java-GC","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2umg000qw3fyc72htxei"},{"title":"小米笔记本pro 15.6寸安装ubuntu16.04无法使用wifi的解决方法","date":"2018-01-06T07:21:58.000Z","_content":"\n\n前不久买了台15.6寸的小米pro,顺利安装win10、ubuntu 16.04双系统之后发现ubuntu的wifi一直不能启动。\n\n在小米社区上搜索找到的解决方法基本都是在/etc/modprobe.d/blacklist.conf文件后面加上acer-wmi或者在/etc/modprobe.d/ 下创建文件 xiaomi.conf并写入blacklist acer_wmi。\n\n据说在小米13.3上面是可行的。但是我这边一直失败。而且也找不到15.6寸的小米pro解决方法。难道是还没有人用15.6寸的小米笔记本去装ubuntu 16.04吗？\n\n# 原因\n\n折腾了好几天,终于在ubuntu社区上找到解决方法。这里做下笔记,希望可以让有需要的人看到。\n\n社区上具体的回答可以在[这里](https://askubuntu.com/questions/910934/intel-wifi-card-not-recognised-in-ubuntu-16-04)查看。\n\n\n# 解决方法\n\nchili555大神给出的解释是Ubuntu 16.04没有覆盖8086:24fd这个wifi设备的驱动,需要自己安装。或者直接安装Ubuntu 17.04,这个版本的ubuntu已经覆盖了这个驱动。\n\n\n自己安装wifi驱动的方法也很简单,首先下载下面链接的软件:\n\n```\nhttp://kernel.ubuntu.com/~kernel-ppa/mainline/v4.10.14/linux-headers-4.10.14-041014_4.10.14-041014.201705031501_all.deb\n\nhttp://kernel.ubuntu.com/~kernel-ppa/mainline/v4.10.14/linux-headers-4.10.14-041014-generic_4.10.14-041014.201705031501_amd64.deb\n\nhttp://kernel.ubuntu.com/~kernel-ppa/mainline/v4.10.14/linux-image-4.10.14-041014-generic_4.10.14-041014.201705031501_amd64.deb\n\nhttp://mirrors.kernel.org/ubuntu/pool/main/l/linux-firmware/linux-firmware_1.164_all.deb\n```\n\n多谢[@oO小智星Oo_d182](https://www.jianshu.com/u/68a7ecdf1bb1)的提醒，上面的最后一个包已经不存在了,会报404。请用[http://mirrors.kernel.org/ubuntu/pool/main/l/linux-firmware/linux-firmware_1.169.1_all.deb](http://mirrors.kernel.org/ubuntu/pool/main/l/linux-firmware/linux-firmware_1.169.1_all.deb)这个版本。\n\n\n然后执行命令将它们全部安装,接着重启电脑就可以了:\n\n```\nsudo dpkg -i *.deb\n```\n\n## 关闭secure boot\n\n这个步骤可能不需要。因为我之前在搜索其他解决方式的时候就已经将它关闭了\n\n如果你按照我上面的方法安装驱动之后还是不能使用wifi的话。进入bois查看是否位于UEFI且开启了secure boot,是的话将它关闭。\n\n小米笔记本进入bois的方法是开机的时候狂按F2。进入之后找到secure boot关闭它就可以了。\n","source":"_posts/小米笔记本pro 15.6寸安装ubuntu16.04无法使用wifi的解决方法.md","raw":"title: 小米笔记本pro 15.6寸安装ubuntu16.04无法使用wifi的解决方法\ndate: 2018-01-06 15:21:58\ntags:\n\t- 技术相关\n---\n\n\n前不久买了台15.6寸的小米pro,顺利安装win10、ubuntu 16.04双系统之后发现ubuntu的wifi一直不能启动。\n\n在小米社区上搜索找到的解决方法基本都是在/etc/modprobe.d/blacklist.conf文件后面加上acer-wmi或者在/etc/modprobe.d/ 下创建文件 xiaomi.conf并写入blacklist acer_wmi。\n\n据说在小米13.3上面是可行的。但是我这边一直失败。而且也找不到15.6寸的小米pro解决方法。难道是还没有人用15.6寸的小米笔记本去装ubuntu 16.04吗？\n\n# 原因\n\n折腾了好几天,终于在ubuntu社区上找到解决方法。这里做下笔记,希望可以让有需要的人看到。\n\n社区上具体的回答可以在[这里](https://askubuntu.com/questions/910934/intel-wifi-card-not-recognised-in-ubuntu-16-04)查看。\n\n\n# 解决方法\n\nchili555大神给出的解释是Ubuntu 16.04没有覆盖8086:24fd这个wifi设备的驱动,需要自己安装。或者直接安装Ubuntu 17.04,这个版本的ubuntu已经覆盖了这个驱动。\n\n\n自己安装wifi驱动的方法也很简单,首先下载下面链接的软件:\n\n```\nhttp://kernel.ubuntu.com/~kernel-ppa/mainline/v4.10.14/linux-headers-4.10.14-041014_4.10.14-041014.201705031501_all.deb\n\nhttp://kernel.ubuntu.com/~kernel-ppa/mainline/v4.10.14/linux-headers-4.10.14-041014-generic_4.10.14-041014.201705031501_amd64.deb\n\nhttp://kernel.ubuntu.com/~kernel-ppa/mainline/v4.10.14/linux-image-4.10.14-041014-generic_4.10.14-041014.201705031501_amd64.deb\n\nhttp://mirrors.kernel.org/ubuntu/pool/main/l/linux-firmware/linux-firmware_1.164_all.deb\n```\n\n多谢[@oO小智星Oo_d182](https://www.jianshu.com/u/68a7ecdf1bb1)的提醒，上面的最后一个包已经不存在了,会报404。请用[http://mirrors.kernel.org/ubuntu/pool/main/l/linux-firmware/linux-firmware_1.169.1_all.deb](http://mirrors.kernel.org/ubuntu/pool/main/l/linux-firmware/linux-firmware_1.169.1_all.deb)这个版本。\n\n\n然后执行命令将它们全部安装,接着重启电脑就可以了:\n\n```\nsudo dpkg -i *.deb\n```\n\n## 关闭secure boot\n\n这个步骤可能不需要。因为我之前在搜索其他解决方式的时候就已经将它关闭了\n\n如果你按照我上面的方法安装驱动之后还是不能使用wifi的话。进入bois查看是否位于UEFI且开启了secure boot,是的话将它关闭。\n\n小米笔记本进入bois的方法是开机的时候狂按F2。进入之后找到secure boot关闭它就可以了。\n","slug":"小米笔记本pro 15.6寸安装ubuntu16.04无法使用wifi的解决方法","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2umi000uw3fymzm5tc7v"},{"title":"安卓皮肤包机制的原理","date":"2017-07-31T18:13:01.000Z","_content":"\n许多常见的应用都有换肤的功能,甚至支持用户自定义皮肤。如果将所有皮肤用到的资源都打包到apk里面不仅会使得apk的大小急剧上升,也会大大增加维护的难度。所以大部分的开发者都会选择将这些资源从apk中剥离出来放到其他地方。\n\n一种常用的方案就是将使用到的字符串、图片等资源打包到一个皮肤apk中，这个皮肤apk中只包含资源，没有任何的代码。主apk在启动之后从这个皮肤apk中加载资源，从而减少主apk的大小，同时也将不同皮肤的资源分别放到不同项目中，提高可维护性。\n\n# 获取皮肤apk的Resources\n\n我们都知道安卓应用的资源是通过Resources去管理的,只要能获取到皮肤apk的Resources,那么就能够读取到皮肤apk中的资源文件。\n\n## 方法一\n\n第一种获取Resources的方式是通过皮肤apk的Context去获取:\n\n\n```\nprivate Resources getResourcesByContext(Context context, String skinApkPackage) {\n        try {\n            return context.createPackageContext(skinApkPackage, Context.CONTEXT_IGNORE_SECURITY)\n                    .getResources();\n\n        } catch (PackageManager.NameNotFoundException e) {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n```\n\n这种方式很简单,但是却有一定的局限性。因为要使用这种方式去获取Resources,必须将皮肤apk也安装到系统。\n\n## 方法二\n\n第二种方法是通过获取皮肤apk的AssetManager,直接new一个Resources出来:\n\n\n```\nprivate Resources getResourcesByAssetManager(Context context, String skinApkPath) {\n        try {\n            Method method = AssetManager.class.getDeclaredMethod(\"addAssetPath\", String.class);\n            AssetManager assetManager = AssetManager.class.newInstance();\n            method.invoke(assetManager, skinApkPath);\n\n            return new Resources(\n                    assetManager,\n                    context.getResources().getDisplayMetrics(),\n                    context.getResources().getConfiguration()\n            );\n        } catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n```\n\n这种方向需要用到反射去调用AssetManager.addAssetPath,但是只需要将皮肤apk下载下来,并不需要安装也能读取到里面的资源。\n\n# 加载资源\n\n一般我们都是通过资源的id从Resources中加载资源的,但是当资源在其他apk里面的时候,我们没有办法直接通过R类知道资源的id,所以需要使用Resources的getIdentifier方法去获取id:\n\n```\npublic int getIdentifier(String name, String defType, String defPackage) {\n        return mResourcesImpl.getIdentifier(name, defType, defPackage);\n    }\n```\n\n获取到id之后就能直接加载资源了:\n\n```\npublic String getString(String name) {\n        int id = mResources.getIdentifier(name, \"string\", SKIN_APK_PACKAGE);\n        if (id == 0) {\n            return null;\n        }\n        return mResources.getString(id);\n    }\n\n\n    public Drawable getDrawable(String name) {\n        int id = mResources.getIdentifier(name, \"drawable\", SKIN_APK_PACKAGE);\n        if (id == 0) {\n            return null;\n        }\n        return mResources.getDrawable(id);\n    }\n```\n\n# Demo\n\n这个demo很简单\n\n首先新建一个皮肤应用项目,在皮肤应用项目中放入img.png和创建一个字符串:\n\n```\n<resources>\n    <string name=\"app_name\">Skin</string>\n    <string name=\"label\">hello world</string>\n</resources>\n```\n\n然后创建一个主应用项目在MainActivity中从皮肤apk加载图片和字符串显示出来\n\n```\npublic class MainActivity extends AppCompatActivity {\n    private final static String SKIN_APK_PACKAGE = \"demo.linjw.skin\";\n    private final static String SKIN_APK = \"skin-debug.apk\";\n\n    private SkinHelper mSkinHelper;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        //需要将皮肤apk安装到系统\n        mSkinHelper = new SkinHelper(this, SKIN_APK_PACKAGE);\n\n        //需要将皮肤apk放到存储卡根目录\n        //File skinApk = new File(Environment.getExternalStorageDirectory().getPath(), SKIN_APK);\n        //mSkinHelper = new SkinHelper(this, SKIN_APK_PACKAGE, skinApk);\n\n        TextView textView = (TextView) findViewById(R.id.textView);\n        textView.setText(mSkinHelper.getString(\"label\"));\n\n        ImageView imageView = (ImageView) findViewById(R.id.imageView);\n        imageView.setImageDrawable(mSkinHelper.getDrawable(\"img\"));\n    }\n}\n```\n\nSkinHelper代码如下:\n\n```\npublic class SkinHelper {\n    private final Resources mResources;\n    private final String mSkinApkPackage;\n\n    public SkinHelper(Context context, String skinApkPackage) {\n        mSkinApkPackage = skinApkPackage;\n        mResources = getResourcesByContext(context, skinApkPackage);\n    }\n\n    public SkinHelper(Context context, String skinApkPackage, File skinApk) {\n        mSkinApkPackage = skinApkPackage;\n        mResources = getResourcesByAssetManager(context, skinApk.getPath());\n    }\n\n    /**\n     * 使用Context.createPackageContext加载Resource\n     *\n     * @param context\n     * @return\n     */\n    private Resources getResourcesByContext(Context context, String skinApkPackage) {\n        try {\n            return context.createPackageContext(skinApkPackage, Context.CONTEXT_IGNORE_SECURITY)\n                    .getResources();\n\n        } catch (PackageManager.NameNotFoundException e) {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n\n    /**\n     * 使用反射创建AssertManager加载Resource\n     *\n     * @param context\n     * @return\n     */\n    private Resources getResourcesByAssetManager(Context context, String skinApkPath) {\n        try {\n            Method method = AssetManager.class.getDeclaredMethod(\"addAssetPath\", String.class);\n            AssetManager assetManager = AssetManager.class.newInstance();\n            method.invoke(assetManager, skinApkPath);\n\n            return new Resources(\n                    assetManager,\n                    context.getResources().getDisplayMetrics(),\n                    context.getResources().getConfiguration()\n            );\n        } catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public String getString(String name) {\n        int id = mResources.getIdentifier(name, \"string\", mSkinApkPackage);\n        if (id == 0) {\n            return null;\n        }\n        return mResources.getString(id);\n    }\n\n\n    public Drawable getDrawable(String name) {\n        int id = mResources.getIdentifier(name, \"drawable\", mSkinApkPackage);\n        if (id == 0) {\n            return null;\n        }\n        return mResources.getDrawable(id);\n    }\n}\n```\n\n效果如下:\n\n{% img /安卓皮肤包机制的原理/image.jpeg %}\n\n# 完整代码\n\n完整代码可以在[这里](https://github.com/bluesky466/SkinDemo)获取","source":"_posts/安卓皮肤包机制的原理.md","raw":"title: 安卓皮肤包机制的原理\ndate: 2017-08-01 02:13:01\ntags:\n    - 技术相关\n    - Android\n---\n\n许多常见的应用都有换肤的功能,甚至支持用户自定义皮肤。如果将所有皮肤用到的资源都打包到apk里面不仅会使得apk的大小急剧上升,也会大大增加维护的难度。所以大部分的开发者都会选择将这些资源从apk中剥离出来放到其他地方。\n\n一种常用的方案就是将使用到的字符串、图片等资源打包到一个皮肤apk中，这个皮肤apk中只包含资源，没有任何的代码。主apk在启动之后从这个皮肤apk中加载资源，从而减少主apk的大小，同时也将不同皮肤的资源分别放到不同项目中，提高可维护性。\n\n# 获取皮肤apk的Resources\n\n我们都知道安卓应用的资源是通过Resources去管理的,只要能获取到皮肤apk的Resources,那么就能够读取到皮肤apk中的资源文件。\n\n## 方法一\n\n第一种获取Resources的方式是通过皮肤apk的Context去获取:\n\n\n```\nprivate Resources getResourcesByContext(Context context, String skinApkPackage) {\n        try {\n            return context.createPackageContext(skinApkPackage, Context.CONTEXT_IGNORE_SECURITY)\n                    .getResources();\n\n        } catch (PackageManager.NameNotFoundException e) {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n```\n\n这种方式很简单,但是却有一定的局限性。因为要使用这种方式去获取Resources,必须将皮肤apk也安装到系统。\n\n## 方法二\n\n第二种方法是通过获取皮肤apk的AssetManager,直接new一个Resources出来:\n\n\n```\nprivate Resources getResourcesByAssetManager(Context context, String skinApkPath) {\n        try {\n            Method method = AssetManager.class.getDeclaredMethod(\"addAssetPath\", String.class);\n            AssetManager assetManager = AssetManager.class.newInstance();\n            method.invoke(assetManager, skinApkPath);\n\n            return new Resources(\n                    assetManager,\n                    context.getResources().getDisplayMetrics(),\n                    context.getResources().getConfiguration()\n            );\n        } catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n```\n\n这种方向需要用到反射去调用AssetManager.addAssetPath,但是只需要将皮肤apk下载下来,并不需要安装也能读取到里面的资源。\n\n# 加载资源\n\n一般我们都是通过资源的id从Resources中加载资源的,但是当资源在其他apk里面的时候,我们没有办法直接通过R类知道资源的id,所以需要使用Resources的getIdentifier方法去获取id:\n\n```\npublic int getIdentifier(String name, String defType, String defPackage) {\n        return mResourcesImpl.getIdentifier(name, defType, defPackage);\n    }\n```\n\n获取到id之后就能直接加载资源了:\n\n```\npublic String getString(String name) {\n        int id = mResources.getIdentifier(name, \"string\", SKIN_APK_PACKAGE);\n        if (id == 0) {\n            return null;\n        }\n        return mResources.getString(id);\n    }\n\n\n    public Drawable getDrawable(String name) {\n        int id = mResources.getIdentifier(name, \"drawable\", SKIN_APK_PACKAGE);\n        if (id == 0) {\n            return null;\n        }\n        return mResources.getDrawable(id);\n    }\n```\n\n# Demo\n\n这个demo很简单\n\n首先新建一个皮肤应用项目,在皮肤应用项目中放入img.png和创建一个字符串:\n\n```\n<resources>\n    <string name=\"app_name\">Skin</string>\n    <string name=\"label\">hello world</string>\n</resources>\n```\n\n然后创建一个主应用项目在MainActivity中从皮肤apk加载图片和字符串显示出来\n\n```\npublic class MainActivity extends AppCompatActivity {\n    private final static String SKIN_APK_PACKAGE = \"demo.linjw.skin\";\n    private final static String SKIN_APK = \"skin-debug.apk\";\n\n    private SkinHelper mSkinHelper;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        //需要将皮肤apk安装到系统\n        mSkinHelper = new SkinHelper(this, SKIN_APK_PACKAGE);\n\n        //需要将皮肤apk放到存储卡根目录\n        //File skinApk = new File(Environment.getExternalStorageDirectory().getPath(), SKIN_APK);\n        //mSkinHelper = new SkinHelper(this, SKIN_APK_PACKAGE, skinApk);\n\n        TextView textView = (TextView) findViewById(R.id.textView);\n        textView.setText(mSkinHelper.getString(\"label\"));\n\n        ImageView imageView = (ImageView) findViewById(R.id.imageView);\n        imageView.setImageDrawable(mSkinHelper.getDrawable(\"img\"));\n    }\n}\n```\n\nSkinHelper代码如下:\n\n```\npublic class SkinHelper {\n    private final Resources mResources;\n    private final String mSkinApkPackage;\n\n    public SkinHelper(Context context, String skinApkPackage) {\n        mSkinApkPackage = skinApkPackage;\n        mResources = getResourcesByContext(context, skinApkPackage);\n    }\n\n    public SkinHelper(Context context, String skinApkPackage, File skinApk) {\n        mSkinApkPackage = skinApkPackage;\n        mResources = getResourcesByAssetManager(context, skinApk.getPath());\n    }\n\n    /**\n     * 使用Context.createPackageContext加载Resource\n     *\n     * @param context\n     * @return\n     */\n    private Resources getResourcesByContext(Context context, String skinApkPackage) {\n        try {\n            return context.createPackageContext(skinApkPackage, Context.CONTEXT_IGNORE_SECURITY)\n                    .getResources();\n\n        } catch (PackageManager.NameNotFoundException e) {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n\n    /**\n     * 使用反射创建AssertManager加载Resource\n     *\n     * @param context\n     * @return\n     */\n    private Resources getResourcesByAssetManager(Context context, String skinApkPath) {\n        try {\n            Method method = AssetManager.class.getDeclaredMethod(\"addAssetPath\", String.class);\n            AssetManager assetManager = AssetManager.class.newInstance();\n            method.invoke(assetManager, skinApkPath);\n\n            return new Resources(\n                    assetManager,\n                    context.getResources().getDisplayMetrics(),\n                    context.getResources().getConfiguration()\n            );\n        } catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public String getString(String name) {\n        int id = mResources.getIdentifier(name, \"string\", mSkinApkPackage);\n        if (id == 0) {\n            return null;\n        }\n        return mResources.getString(id);\n    }\n\n\n    public Drawable getDrawable(String name) {\n        int id = mResources.getIdentifier(name, \"drawable\", mSkinApkPackage);\n        if (id == 0) {\n            return null;\n        }\n        return mResources.getDrawable(id);\n    }\n}\n```\n\n效果如下:\n\n{% img /安卓皮肤包机制的原理/image.jpeg %}\n\n# 完整代码\n\n完整代码可以在[这里](https://github.com/bluesky466/SkinDemo)获取","slug":"安卓皮肤包机制的原理","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2umj000ww3fy76qe8x7c"},{"title":"安卓广播的底层实现原理","date":"2018-02-09T17:36:16.000Z","_content":"\n\n相信广播大家都有用过,也知道安卓广播的一些基础知识,如静态广播、动态广播、粘性广播等等,但相信很多人都不知道系统层面是怎样实现这些广播特性的,这篇文章就让我们来聊一聊安卓广播机制的系统实现原理.\n\n# 静态广播的注册\n\n静态广播是通过PackageManagerService在启动的时候扫描已安装的应用去注册的.\n\n在PackageManagerService的构造方法中,会去扫描应用安装目录,顺序是先扫描系统应用安装目录再扫描第三方应用安装目录.\n\nPackageManagerService.scanDirLI就是用于扫描目录的方法,由于代码比较少,这里我们直接把它贴了上来:\n\n```\nprivate void scanDirLI(File dir, int flags, int scanMode, long currentTime) {\n   String[] files = dir.list();\n   if (files == null) {\n       return;\n   }\n\n   int i;\n   for (i=0; i<files.length; i++) {\n       File file = new File(dir, files[i]);\n       if (!isPackageFilename(files[i])) {\n           continue;\n       }\n       PackageParser.Package pkg = scanPackageLI(file,\n               flags|PackageParser.PARSE_MUST_BE_APK, scanMode, currentTime, null);\n       if (pkg == null && (flags & PackageParser.PARSE_IS_SYSTEM) == 0 &&\n               mLastScanError == PackageManager.INSTALL_FAILED_INVALID_APK) {\n           file.delete();\n       }\n   }\n}\n\nprivate static final boolean isPackageFilename(String name) {\n   return name != null && name.endsWith(\".apk\");\n}\n```\n\n可以看到,它通过File.list方法列出目录下的所有后缀为\".apk\"的文件传给scanPackageLI去处理.\n而scanPackageLI(File scanFile,int parseFlags, int scanMode, long currentTime, UserHandle user)内部会调用它的重载方法scanPackageLI(PackageParser.Package pkg,int parseFlags, int scanMode, long currentTime, UserHandle user):\n\n```\nprivate PackageParser.Package scanPackageLI(File scanFile,int parseFlags, int scanMode, long currentTime, UserHandle user) {\n  ...\n  final PackageParser.Package pkg = pp.parsePackage(scanFile,scanPath, mMetrics, parseFlags);\n  ...\n  PackageParser.Package scannedPkg = scanPackageLI(pkg, parseFlags, scanMode | SCAN_UPDATE_SIGNATURE, currentTime, user);\n  ...\n}\n```\n\n\n在这个scanPackageLIl里面会解析Package并且将AndroidManifest.xml中注册的BroadcastReceiver保存下来:\n\n```\n...\nN = pkg.receivers.size();\nr = null;\nfor (i=0; i<N; i++) {\n   PackageParser.Activity a = pkg.receivers.get(i);\n   a.info.processName = fixProcessName(pkg.applicationInfo.processName,\n           a.info.processName, pkg.applicationInfo.uid);\n   mReceivers.addActivity(a, \"receiver\");\n   ...\n}\n...\n```\n\n所以从上面获取静态广播的流程可以看出来:系统应用的广播先于第三方应用的广播注册,而安装在同一个目录下的应用的静态广播的注册顺序是按照File.list列出来的apk的顺序注册的.他们的注册顺序就决定了它们接收广播的顺序.\n\n通过静态广播的注册流程,我们已经将静态广播注册到了PackageManagerService的mReceivers中,而我们可以使用PackageManagerService.queryIntentReceivers方法查询intent对应的静态广播\n\n```\npublic List<ResolveInfo> queryIntentReceivers(Intent intent, String resolvedType, int flags, int userId) {\n   if (!sUserManager.exists(userId)) return Collections.emptyList();\n   ComponentName comp = intent.getComponent();\n   if (comp == null) {\n       if (intent.getSelector() != null) {\n           intent = intent.getSelector();\n           comp = intent.getComponent();\n       }\n   }\n   if (comp != null) {\n       List<ResolveInfo> list = new ArrayList<ResolveInfo>(1);\n       ActivityInfo ai = getReceiverInfo(comp, flags, userId);\n       if (ai != null) {\n           ResolveInfo ri = new ResolveInfo();\n           ri.activityInfo = ai;\n           list.add(ri);\n       }\n       return list;\n   }\n\n   synchronized (mPackages) {\n       String pkgName = intent.getPackage();\n       if (pkgName == null) {\n           return mReceivers.queryIntent(intent, resolvedType, flags, userId);\n       }\n       final PackageParser.Package pkg = mPackages.get(pkgName);\n       if (pkg != null) {\n           return mReceivers.queryIntentForPackage(intent, resolvedType, flags, pkg.receivers,\n                   userId);\n       }\n       return null;\n   }\n}\n```\n\n# 动态广播的注册\n\n我们调用Context.registerReceiver最后会调到ActivityManagerService.registerReceiver:\n\n```\npublic Intent registerReceiver(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, int userId) {\n  ...\n  ReceiverList rl = (ReceiverList)mRegisteredReceivers.get(receiver.asBinder());\n  ...\n  BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage, permission, callingUid, userId);\n  ...\n  mReceiverResolver.addFilter(bf);\n  ...\n}\n```\n\n所以通过mReceiverResolver.queryIntent就能获得intent对应的动态广播了.\n\n# 发送广播\n\nContextImpl.sendBroadcast中会调用ActivityManagerNative.getDefault().broadcastIntent()\n\n\n```\npublic void sendBroadcast(Intent intent) {\n    warnIfCallingFromSystemProcess();\n    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());\n    try {\n        intent.prepareToLeaveProcess();\n        ActivityManagerNative.getDefault().broadcastIntent(\n            mMainThread.getApplicationThread(), intent, resolvedType, null,\n            Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, false, false,getUserId());\n    } catch (RemoteException e) {\n    }\n}\n```\n\n实际是调用ActivityManagerService.broadcastIntent:\n\n```\npublic final int broadcastIntent(IApplicationThread caller,\n        Intent intent, String resolvedType, IIntentReceiver resultTo,\n        int resultCode, String resultData, Bundle map,\n        String requiredPermission, int appOp, boolean serialized, boolean sticky, int userId) {\n    enforceNotIsolatedCaller(\"broadcastIntent\");\n    synchronized(this) {\n        intent = verifyBroadcastLocked(intent);\n        final ProcessRecord callerApp = getRecordForAppLocked(caller);\n        final int callingPid = Binder.getCallingPid();\n        final int callingUid = Binder.getCallingUid();\n        final long origId = Binder.clearCallingIdentity();\n        int res = broadcastIntentLocked(callerApp,\n                callerApp != null ? callerApp.info.packageName : null,\n                intent, resolvedType, resultTo,\n                resultCode, resultData, map, requiredPermission, appOp, serialized, sticky,\n                callingPid, callingUid, userId);\n        Binder.restoreCallingIdentity(origId);\n        return res;\n    }\n}\n```\n\nActivityManagerService.broadcastIntent中又会调用ActivityManagerService.broadcastIntentLocked,而broadcastIntentLocked中的关键代码如下:\n\n```\n// 静态广播\nList receivers = null;\n// 动态广播\nList<BroadcastFilter> registeredReceivers = null;\nif ((intent.getFlags()&Intent.FLAG_RECEIVER_REGISTERED_ONLY)\n      == 0) {\n   // 查询静态广播\n   receivers = collectReceiverComponents(intent, resolvedType, users);\n}\nif (intent.getComponent() == null) {\n   // 查询动态广播\n   registeredReceivers = mReceiverResolver.queryIntent(intent,\n           resolvedType, false, userId);\n}\n\nfinal boolean replacePending =\n       (intent.getFlags()&Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;\n\nint NR = registeredReceivers != null ? registeredReceivers.size() : 0;\nif (!ordered && NR > 0) {\n   final BroadcastQueue queue = broadcastQueueForIntent(intent);\n   BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,\n           callerPackage, callingPid, callingUid, resolvedType, requiredPermission,\n           appOp, registeredReceivers, resultTo, resultCode, resultData, map,\n           ordered, sticky, false, userId);\n   final boolean replaced = replacePending && queue.replaceParallelBroadcastLocked(r);\n   if (!replaced) {\n       // 发送动态广播\n       queue.enqueueParallelBroadcastLocked(r);\n       queue.scheduleBroadcastsLocked();\n   }\n   registeredReceivers = null;\n   NR = 0;\n}\n...\nif ((receivers != null && receivers.size() > 0)\n    || resultTo != null) {\n   BroadcastQueue queue = broadcastQueueForIntent(intent);\n   BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,\n           callerPackage, callingPid, callingUid, resolvedType,\n           requiredPermission, appOp, receivers, resultTo, resultCode,\n           resultData, map, ordered, sticky, false, userId);\n   boolean replaced = replacePending && queue.replaceOrderedBroadcastLocked(r);\n   if (!replaced) {\n       // 发送静态广播\n       queue.enqueueOrderedBroadcastLocked(r);\n       queue.scheduleBroadcastsLocked();\n   }\n}\n```\n\n大家应该都有听说过动态广播会优先于静态广播,从上面的代码我们可以看到,这实际是因为安卓的源代码就是按这个顺序写的...\n\n最后我们来看一下ActivityManagerService.collectReceiverComponents方法,实际上静态广播静态就是从PackageManagerService中查询的:\n\n```\nprivate List<ResolveInfo> collectReceiverComponents(Intent intent, String resolvedType,\n            int[] users) {\n    ...\n    List<ResolveInfo> newReceivers = AppGlobals.getPackageManager()\n                        .queryIntentReceivers(intent, resolvedType, STOCK_PM_FLAGS, user);\n    ...\n```\n\n# 粘性广播的实现原理\n\nActivityManagerService.broadcastIntentLocked有下面这样一段代码,它将粘性广播存到了mStickyBroadcasts中。\n\n```\nif (sticky) {\n    ...\n    ArrayMap<String, ArrayList<Intent>> stickies = mStickyBroadcasts.get(userId);\n    if (stickies == null) {\n        stickies = new ArrayMap<String, ArrayList<Intent>>();\n        mStickyBroadcasts.put(userId, stickies);\n    }\n    ArrayList<Intent> list = stickies.get(intent.getAction());\n    if (list == null) {\n        list = new ArrayList<Intent>();\n        stickies.put(intent.getAction(), list);\n    }\n    int N = list.size();\n    int i;\n    for (i=0; i<N; i++) {\n        if (intent.filterEquals(list.get(i))) {\n            // This sticky already exists, replace it.\n            list.set(i, new Intent(intent));\n            break;\n        }\n    }\n    if (i >= N) {\n        list.add(new Intent(intent));\n    }\n}\n```\n\n而ManagerService.registerReceiver会获取之前发送的粘性广播,再次发送给刚刚注册的receiver:\n\n```\n...\nList allSticky = null;\n\n// 获取符合的粘性广播\nIterator actions = filter.actionsIterator();\nif (actions != null) {\n    while (actions.hasNext()) {\n        String action = (String)actions.next();\n        allSticky = getStickiesLocked(action, filter, allSticky,\n                UserHandle.USER_ALL);\n        allSticky = getStickiesLocked(action, filter, allSticky,\n                UserHandle.getUserId(callingUid));\n    }\n} else {\n    allSticky = getStickiesLocked(null, filter, allSticky,\n            UserHandle.USER_ALL);\n    allSticky = getStickiesLocked(null, filter, allSticky,\n            UserHandle.getUserId(callingUid));\n}\n...\n//向新注册的receiver发送粘性广播\nif (allSticky != null) {\n    ArrayList receivers = new ArrayList();\n    receivers.add(bf);\n\n    int N = allSticky.size();\n    for (int i=0; i<N; i++) {\n        Intent intent = (Intent)allSticky.get(i);\n        BroadcastQueue queue = broadcastQueueForIntent(intent);\n        BroadcastRecord r = new BroadcastRecord(queue, intent, null,\n                null, -1, -1, null, null, AppOpsManager.OP_NONE, receivers, null, 0,\n                null, null, false, true, true, -1);\n        queue.enqueueParallelBroadcastLocked(r);\n        queue.scheduleBroadcastsLocked();\n    }\n}\n...\n```\n\ngetStickiesLocked即从mStickyBroadcasts中查询之前发送过的粘性广播\n\n```\nprivate final List getStickiesLocked(String action, IntentFilter filter,\n        List cur, int userId) {\n    final ContentResolver resolver = mContext.getContentResolver();\n    ArrayMap<String, ArrayList<Intent>> stickies = mStickyBroadcasts.get(userId);\n    if (stickies == null) {\n        return cur;\n    }\n    final ArrayList<Intent> list = stickies.get(action);\n    if (list == null) {\n        return cur;\n    }\n    int N = list.size();\n    for (int i=0; i<N; i++) {\n        Intent intent = list.get(i);\n        if (filter.match(resolver, intent, true, TAG) >= 0) {\n            if (cur == null) {\n                cur = new ArrayList<Intent>();\n            }\n            cur.add(intent);\n        }\n    }\n    return cur;\n}\n```\n\n# 广播队列\n\n\n从ActivityManagerService.broadcastIntentLocked中我们可以看到,实际上它不是直接将广播发送到BroadcastReceiver中的.\n\n而是将他包装到BroadcastRecord中,再放进BroadcastQueue:\n\n```\nBroadcastQueue queue = broadcastQueueForIntent(intent);\nBroadcastRecord r = new BroadcastRecord(queue, intent, null,\n        null, -1, -1, null, null, AppOpsManager.OP_NONE, receivers, null, 0,\n        null, null, false, true, true, -1);\nqueue.enqueueParallelBroadcastLocked(r);\nqueue.scheduleBroadcastsLocked();\n```\n\nenqueueParallelBroadcastLocked方法用于并发执行广播的发送.它很简单,就是将BroadcastRecord放到了mParallelBroadcasts中:\n\n```\npublic void enqueueParallelBroadcastLocked(BroadcastRecord r) {\n    mParallelBroadcasts.add(r);\n}\n```\n\nscheduleBroadcastsLocked方法同样很简单,就是向mHandler发送了个BROADCAST_INTENT_MSG消息:\n```\npublic void scheduleBroadcastsLocked() {\n   if (mBroadcastsScheduled) {\n       return;\n   }\n   mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));\n   mBroadcastsScheduled = true;\n}\n```\n\n这个时候我们就需要再去看看mHandler在接收到BROADCAST_INTENT_MSG消息的时候会做些什么:\n\n```\nfinal Handler mHandler = new Handler() {\n   public void handleMessage(Message msg) {\n       switch (msg.what) {\n           case BROADCAST_INTENT_MSG: {\n               processNextBroadcast(true);\n           } break;\n           case BROADCAST_TIMEOUT_MSG: {\n               synchronized (mService) {\n                   broadcastTimeoutLocked(true);\n               }\n           } break;\n       }\n   }\n};\n\n```\n\nprocessNextBroadcast方法用于从队列中获取广播消息并发送给BroadcastReceiver,它内部有两个分支,并行处理和串行处理.\n\n## 普通广播并行处理\n\n我们先看看并行处理的分支:\n\n```\n\nfinal void processNextBroadcast(boolean fromMsg) {\n  synchronized(mService) {\n      BroadcastRecord r;\n      mService.updateCpuStats();\n      if (fromMsg) {\n         mBroadcastsScheduled = false;\n      }\n      while (mParallelBroadcasts.size() > 0) {\n         r = mParallelBroadcasts.remove(0);\n         r.dispatchTime = SystemClock.uptimeMillis();\n         r.dispatchClockTime = System.currentTimeMillis();\n         final int N = r.receivers.size();\n         for (int i=0; i<N; i++) {\n             Object target = r.receivers.get(i);\n             // 发送消息给Receiver\n             deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false);\n         }\n         addBroadcastToHistoryLocked(r);\n      }\n      ...\n   }\n   ...\n}\n\nprivate final void deliverToRegisteredReceiverLocked(BroadcastRecord r,\n            BroadcastFilter filter, boolean ordered) {\n    ...\n    // 获取BroadcastReceiver的Binder\n    r.receiver = filter.receiverList.receiver.asBinder();\n    ...\n    // 使用Binder机制将消息传递给BroadcastReceiver\n    performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver,\n                    new Intent(r.intent), r.resultCode, r.resultData,\n                    r.resultExtras, r.ordered, r.initialSticky, r.userId);\n    ...\n}\n\nvoid performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,\n        Intent intent, int resultCode, String data, Bundle extras,\n        boolean ordered, boolean sticky, int sendingUser) throws RemoteException {\n    ......\n        //通过Binder将消息处理传到应用进程,应用进程内部再使用Handler机制,将消息处理放到主线程中\n        app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,\n                        data, extras, ordered, sticky, sendingUser, app.repProcState);\n    ......\n    }\n}\n```\n\n## 有序广播串行处理\n\n例如有序广播,会通过enqueueOrderedBroadcastLocked传给BroadcastQueue:\n\n```\npublic void enqueueOrderedBroadcastLocked(BroadcastRecord r) {\n   mOrderedBroadcasts.add(r);\n}\n```\n\n然后在processNextBroadcast里面会对mOrderedBroadcasts进行特殊处理,但是恕我愚钝,这部分代码比较复杂,我现在还没有搞懂它实际的怎么运行的.这块就留下来之后再讲了.\n\n\n# 总结\n\n广播队列传送广播给Receiver的原理其实就是将BroadcastReceiver和消息都放到BroadcastRecord里面,然后通过Handler机制遍历BroadcastQueue里面的BroadcastRecord,将消息发送给BroadcastReceiver:\n\n\n\n{% img /安卓广播的底层实现原理/1.png %}\n\n所以整个广播的机制可以总结成下面这张图:\n\n{% img /安卓广播的底层实现原理/2.png %}\n","source":"_posts/安卓广播的底层实现原理.md","raw":"title: 安卓广播的底层实现原理\ndate: 2018-02-10 01:36:16\ntags:\n    - 技术相关\n    - Android\n---\n\n\n相信广播大家都有用过,也知道安卓广播的一些基础知识,如静态广播、动态广播、粘性广播等等,但相信很多人都不知道系统层面是怎样实现这些广播特性的,这篇文章就让我们来聊一聊安卓广播机制的系统实现原理.\n\n# 静态广播的注册\n\n静态广播是通过PackageManagerService在启动的时候扫描已安装的应用去注册的.\n\n在PackageManagerService的构造方法中,会去扫描应用安装目录,顺序是先扫描系统应用安装目录再扫描第三方应用安装目录.\n\nPackageManagerService.scanDirLI就是用于扫描目录的方法,由于代码比较少,这里我们直接把它贴了上来:\n\n```\nprivate void scanDirLI(File dir, int flags, int scanMode, long currentTime) {\n   String[] files = dir.list();\n   if (files == null) {\n       return;\n   }\n\n   int i;\n   for (i=0; i<files.length; i++) {\n       File file = new File(dir, files[i]);\n       if (!isPackageFilename(files[i])) {\n           continue;\n       }\n       PackageParser.Package pkg = scanPackageLI(file,\n               flags|PackageParser.PARSE_MUST_BE_APK, scanMode, currentTime, null);\n       if (pkg == null && (flags & PackageParser.PARSE_IS_SYSTEM) == 0 &&\n               mLastScanError == PackageManager.INSTALL_FAILED_INVALID_APK) {\n           file.delete();\n       }\n   }\n}\n\nprivate static final boolean isPackageFilename(String name) {\n   return name != null && name.endsWith(\".apk\");\n}\n```\n\n可以看到,它通过File.list方法列出目录下的所有后缀为\".apk\"的文件传给scanPackageLI去处理.\n而scanPackageLI(File scanFile,int parseFlags, int scanMode, long currentTime, UserHandle user)内部会调用它的重载方法scanPackageLI(PackageParser.Package pkg,int parseFlags, int scanMode, long currentTime, UserHandle user):\n\n```\nprivate PackageParser.Package scanPackageLI(File scanFile,int parseFlags, int scanMode, long currentTime, UserHandle user) {\n  ...\n  final PackageParser.Package pkg = pp.parsePackage(scanFile,scanPath, mMetrics, parseFlags);\n  ...\n  PackageParser.Package scannedPkg = scanPackageLI(pkg, parseFlags, scanMode | SCAN_UPDATE_SIGNATURE, currentTime, user);\n  ...\n}\n```\n\n\n在这个scanPackageLIl里面会解析Package并且将AndroidManifest.xml中注册的BroadcastReceiver保存下来:\n\n```\n...\nN = pkg.receivers.size();\nr = null;\nfor (i=0; i<N; i++) {\n   PackageParser.Activity a = pkg.receivers.get(i);\n   a.info.processName = fixProcessName(pkg.applicationInfo.processName,\n           a.info.processName, pkg.applicationInfo.uid);\n   mReceivers.addActivity(a, \"receiver\");\n   ...\n}\n...\n```\n\n所以从上面获取静态广播的流程可以看出来:系统应用的广播先于第三方应用的广播注册,而安装在同一个目录下的应用的静态广播的注册顺序是按照File.list列出来的apk的顺序注册的.他们的注册顺序就决定了它们接收广播的顺序.\n\n通过静态广播的注册流程,我们已经将静态广播注册到了PackageManagerService的mReceivers中,而我们可以使用PackageManagerService.queryIntentReceivers方法查询intent对应的静态广播\n\n```\npublic List<ResolveInfo> queryIntentReceivers(Intent intent, String resolvedType, int flags, int userId) {\n   if (!sUserManager.exists(userId)) return Collections.emptyList();\n   ComponentName comp = intent.getComponent();\n   if (comp == null) {\n       if (intent.getSelector() != null) {\n           intent = intent.getSelector();\n           comp = intent.getComponent();\n       }\n   }\n   if (comp != null) {\n       List<ResolveInfo> list = new ArrayList<ResolveInfo>(1);\n       ActivityInfo ai = getReceiverInfo(comp, flags, userId);\n       if (ai != null) {\n           ResolveInfo ri = new ResolveInfo();\n           ri.activityInfo = ai;\n           list.add(ri);\n       }\n       return list;\n   }\n\n   synchronized (mPackages) {\n       String pkgName = intent.getPackage();\n       if (pkgName == null) {\n           return mReceivers.queryIntent(intent, resolvedType, flags, userId);\n       }\n       final PackageParser.Package pkg = mPackages.get(pkgName);\n       if (pkg != null) {\n           return mReceivers.queryIntentForPackage(intent, resolvedType, flags, pkg.receivers,\n                   userId);\n       }\n       return null;\n   }\n}\n```\n\n# 动态广播的注册\n\n我们调用Context.registerReceiver最后会调到ActivityManagerService.registerReceiver:\n\n```\npublic Intent registerReceiver(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, int userId) {\n  ...\n  ReceiverList rl = (ReceiverList)mRegisteredReceivers.get(receiver.asBinder());\n  ...\n  BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage, permission, callingUid, userId);\n  ...\n  mReceiverResolver.addFilter(bf);\n  ...\n}\n```\n\n所以通过mReceiverResolver.queryIntent就能获得intent对应的动态广播了.\n\n# 发送广播\n\nContextImpl.sendBroadcast中会调用ActivityManagerNative.getDefault().broadcastIntent()\n\n\n```\npublic void sendBroadcast(Intent intent) {\n    warnIfCallingFromSystemProcess();\n    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());\n    try {\n        intent.prepareToLeaveProcess();\n        ActivityManagerNative.getDefault().broadcastIntent(\n            mMainThread.getApplicationThread(), intent, resolvedType, null,\n            Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, false, false,getUserId());\n    } catch (RemoteException e) {\n    }\n}\n```\n\n实际是调用ActivityManagerService.broadcastIntent:\n\n```\npublic final int broadcastIntent(IApplicationThread caller,\n        Intent intent, String resolvedType, IIntentReceiver resultTo,\n        int resultCode, String resultData, Bundle map,\n        String requiredPermission, int appOp, boolean serialized, boolean sticky, int userId) {\n    enforceNotIsolatedCaller(\"broadcastIntent\");\n    synchronized(this) {\n        intent = verifyBroadcastLocked(intent);\n        final ProcessRecord callerApp = getRecordForAppLocked(caller);\n        final int callingPid = Binder.getCallingPid();\n        final int callingUid = Binder.getCallingUid();\n        final long origId = Binder.clearCallingIdentity();\n        int res = broadcastIntentLocked(callerApp,\n                callerApp != null ? callerApp.info.packageName : null,\n                intent, resolvedType, resultTo,\n                resultCode, resultData, map, requiredPermission, appOp, serialized, sticky,\n                callingPid, callingUid, userId);\n        Binder.restoreCallingIdentity(origId);\n        return res;\n    }\n}\n```\n\nActivityManagerService.broadcastIntent中又会调用ActivityManagerService.broadcastIntentLocked,而broadcastIntentLocked中的关键代码如下:\n\n```\n// 静态广播\nList receivers = null;\n// 动态广播\nList<BroadcastFilter> registeredReceivers = null;\nif ((intent.getFlags()&Intent.FLAG_RECEIVER_REGISTERED_ONLY)\n      == 0) {\n   // 查询静态广播\n   receivers = collectReceiverComponents(intent, resolvedType, users);\n}\nif (intent.getComponent() == null) {\n   // 查询动态广播\n   registeredReceivers = mReceiverResolver.queryIntent(intent,\n           resolvedType, false, userId);\n}\n\nfinal boolean replacePending =\n       (intent.getFlags()&Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;\n\nint NR = registeredReceivers != null ? registeredReceivers.size() : 0;\nif (!ordered && NR > 0) {\n   final BroadcastQueue queue = broadcastQueueForIntent(intent);\n   BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,\n           callerPackage, callingPid, callingUid, resolvedType, requiredPermission,\n           appOp, registeredReceivers, resultTo, resultCode, resultData, map,\n           ordered, sticky, false, userId);\n   final boolean replaced = replacePending && queue.replaceParallelBroadcastLocked(r);\n   if (!replaced) {\n       // 发送动态广播\n       queue.enqueueParallelBroadcastLocked(r);\n       queue.scheduleBroadcastsLocked();\n   }\n   registeredReceivers = null;\n   NR = 0;\n}\n...\nif ((receivers != null && receivers.size() > 0)\n    || resultTo != null) {\n   BroadcastQueue queue = broadcastQueueForIntent(intent);\n   BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,\n           callerPackage, callingPid, callingUid, resolvedType,\n           requiredPermission, appOp, receivers, resultTo, resultCode,\n           resultData, map, ordered, sticky, false, userId);\n   boolean replaced = replacePending && queue.replaceOrderedBroadcastLocked(r);\n   if (!replaced) {\n       // 发送静态广播\n       queue.enqueueOrderedBroadcastLocked(r);\n       queue.scheduleBroadcastsLocked();\n   }\n}\n```\n\n大家应该都有听说过动态广播会优先于静态广播,从上面的代码我们可以看到,这实际是因为安卓的源代码就是按这个顺序写的...\n\n最后我们来看一下ActivityManagerService.collectReceiverComponents方法,实际上静态广播静态就是从PackageManagerService中查询的:\n\n```\nprivate List<ResolveInfo> collectReceiverComponents(Intent intent, String resolvedType,\n            int[] users) {\n    ...\n    List<ResolveInfo> newReceivers = AppGlobals.getPackageManager()\n                        .queryIntentReceivers(intent, resolvedType, STOCK_PM_FLAGS, user);\n    ...\n```\n\n# 粘性广播的实现原理\n\nActivityManagerService.broadcastIntentLocked有下面这样一段代码,它将粘性广播存到了mStickyBroadcasts中。\n\n```\nif (sticky) {\n    ...\n    ArrayMap<String, ArrayList<Intent>> stickies = mStickyBroadcasts.get(userId);\n    if (stickies == null) {\n        stickies = new ArrayMap<String, ArrayList<Intent>>();\n        mStickyBroadcasts.put(userId, stickies);\n    }\n    ArrayList<Intent> list = stickies.get(intent.getAction());\n    if (list == null) {\n        list = new ArrayList<Intent>();\n        stickies.put(intent.getAction(), list);\n    }\n    int N = list.size();\n    int i;\n    for (i=0; i<N; i++) {\n        if (intent.filterEquals(list.get(i))) {\n            // This sticky already exists, replace it.\n            list.set(i, new Intent(intent));\n            break;\n        }\n    }\n    if (i >= N) {\n        list.add(new Intent(intent));\n    }\n}\n```\n\n而ManagerService.registerReceiver会获取之前发送的粘性广播,再次发送给刚刚注册的receiver:\n\n```\n...\nList allSticky = null;\n\n// 获取符合的粘性广播\nIterator actions = filter.actionsIterator();\nif (actions != null) {\n    while (actions.hasNext()) {\n        String action = (String)actions.next();\n        allSticky = getStickiesLocked(action, filter, allSticky,\n                UserHandle.USER_ALL);\n        allSticky = getStickiesLocked(action, filter, allSticky,\n                UserHandle.getUserId(callingUid));\n    }\n} else {\n    allSticky = getStickiesLocked(null, filter, allSticky,\n            UserHandle.USER_ALL);\n    allSticky = getStickiesLocked(null, filter, allSticky,\n            UserHandle.getUserId(callingUid));\n}\n...\n//向新注册的receiver发送粘性广播\nif (allSticky != null) {\n    ArrayList receivers = new ArrayList();\n    receivers.add(bf);\n\n    int N = allSticky.size();\n    for (int i=0; i<N; i++) {\n        Intent intent = (Intent)allSticky.get(i);\n        BroadcastQueue queue = broadcastQueueForIntent(intent);\n        BroadcastRecord r = new BroadcastRecord(queue, intent, null,\n                null, -1, -1, null, null, AppOpsManager.OP_NONE, receivers, null, 0,\n                null, null, false, true, true, -1);\n        queue.enqueueParallelBroadcastLocked(r);\n        queue.scheduleBroadcastsLocked();\n    }\n}\n...\n```\n\ngetStickiesLocked即从mStickyBroadcasts中查询之前发送过的粘性广播\n\n```\nprivate final List getStickiesLocked(String action, IntentFilter filter,\n        List cur, int userId) {\n    final ContentResolver resolver = mContext.getContentResolver();\n    ArrayMap<String, ArrayList<Intent>> stickies = mStickyBroadcasts.get(userId);\n    if (stickies == null) {\n        return cur;\n    }\n    final ArrayList<Intent> list = stickies.get(action);\n    if (list == null) {\n        return cur;\n    }\n    int N = list.size();\n    for (int i=0; i<N; i++) {\n        Intent intent = list.get(i);\n        if (filter.match(resolver, intent, true, TAG) >= 0) {\n            if (cur == null) {\n                cur = new ArrayList<Intent>();\n            }\n            cur.add(intent);\n        }\n    }\n    return cur;\n}\n```\n\n# 广播队列\n\n\n从ActivityManagerService.broadcastIntentLocked中我们可以看到,实际上它不是直接将广播发送到BroadcastReceiver中的.\n\n而是将他包装到BroadcastRecord中,再放进BroadcastQueue:\n\n```\nBroadcastQueue queue = broadcastQueueForIntent(intent);\nBroadcastRecord r = new BroadcastRecord(queue, intent, null,\n        null, -1, -1, null, null, AppOpsManager.OP_NONE, receivers, null, 0,\n        null, null, false, true, true, -1);\nqueue.enqueueParallelBroadcastLocked(r);\nqueue.scheduleBroadcastsLocked();\n```\n\nenqueueParallelBroadcastLocked方法用于并发执行广播的发送.它很简单,就是将BroadcastRecord放到了mParallelBroadcasts中:\n\n```\npublic void enqueueParallelBroadcastLocked(BroadcastRecord r) {\n    mParallelBroadcasts.add(r);\n}\n```\n\nscheduleBroadcastsLocked方法同样很简单,就是向mHandler发送了个BROADCAST_INTENT_MSG消息:\n```\npublic void scheduleBroadcastsLocked() {\n   if (mBroadcastsScheduled) {\n       return;\n   }\n   mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));\n   mBroadcastsScheduled = true;\n}\n```\n\n这个时候我们就需要再去看看mHandler在接收到BROADCAST_INTENT_MSG消息的时候会做些什么:\n\n```\nfinal Handler mHandler = new Handler() {\n   public void handleMessage(Message msg) {\n       switch (msg.what) {\n           case BROADCAST_INTENT_MSG: {\n               processNextBroadcast(true);\n           } break;\n           case BROADCAST_TIMEOUT_MSG: {\n               synchronized (mService) {\n                   broadcastTimeoutLocked(true);\n               }\n           } break;\n       }\n   }\n};\n\n```\n\nprocessNextBroadcast方法用于从队列中获取广播消息并发送给BroadcastReceiver,它内部有两个分支,并行处理和串行处理.\n\n## 普通广播并行处理\n\n我们先看看并行处理的分支:\n\n```\n\nfinal void processNextBroadcast(boolean fromMsg) {\n  synchronized(mService) {\n      BroadcastRecord r;\n      mService.updateCpuStats();\n      if (fromMsg) {\n         mBroadcastsScheduled = false;\n      }\n      while (mParallelBroadcasts.size() > 0) {\n         r = mParallelBroadcasts.remove(0);\n         r.dispatchTime = SystemClock.uptimeMillis();\n         r.dispatchClockTime = System.currentTimeMillis();\n         final int N = r.receivers.size();\n         for (int i=0; i<N; i++) {\n             Object target = r.receivers.get(i);\n             // 发送消息给Receiver\n             deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false);\n         }\n         addBroadcastToHistoryLocked(r);\n      }\n      ...\n   }\n   ...\n}\n\nprivate final void deliverToRegisteredReceiverLocked(BroadcastRecord r,\n            BroadcastFilter filter, boolean ordered) {\n    ...\n    // 获取BroadcastReceiver的Binder\n    r.receiver = filter.receiverList.receiver.asBinder();\n    ...\n    // 使用Binder机制将消息传递给BroadcastReceiver\n    performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver,\n                    new Intent(r.intent), r.resultCode, r.resultData,\n                    r.resultExtras, r.ordered, r.initialSticky, r.userId);\n    ...\n}\n\nvoid performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,\n        Intent intent, int resultCode, String data, Bundle extras,\n        boolean ordered, boolean sticky, int sendingUser) throws RemoteException {\n    ......\n        //通过Binder将消息处理传到应用进程,应用进程内部再使用Handler机制,将消息处理放到主线程中\n        app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,\n                        data, extras, ordered, sticky, sendingUser, app.repProcState);\n    ......\n    }\n}\n```\n\n## 有序广播串行处理\n\n例如有序广播,会通过enqueueOrderedBroadcastLocked传给BroadcastQueue:\n\n```\npublic void enqueueOrderedBroadcastLocked(BroadcastRecord r) {\n   mOrderedBroadcasts.add(r);\n}\n```\n\n然后在processNextBroadcast里面会对mOrderedBroadcasts进行特殊处理,但是恕我愚钝,这部分代码比较复杂,我现在还没有搞懂它实际的怎么运行的.这块就留下来之后再讲了.\n\n\n# 总结\n\n广播队列传送广播给Receiver的原理其实就是将BroadcastReceiver和消息都放到BroadcastRecord里面,然后通过Handler机制遍历BroadcastQueue里面的BroadcastRecord,将消息发送给BroadcastReceiver:\n\n\n\n{% img /安卓广播的底层实现原理/1.png %}\n\n所以整个广播的机制可以总结成下面这张图:\n\n{% img /安卓广播的底层实现原理/2.png %}\n","slug":"安卓广播的底层实现原理","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2uml000zw3fymd9mgtnf"},{"title":"安卓嵌套滚动NestedScroll了解一下","date":"2018-06-04T00:07:50.000Z","_content":"\n\n其实嵌套滚动已经算一个比较常见的特效了,下面这个动图就是嵌套滚动的一个例子:\n\n{% img /安卓嵌套滚动NestedScroll了解一下/1.gif %}\n\n看到这个动效,大家可能都知道可以用CoordinatorLayout去实现.其实CoordinatorLayout是基于NestedScroll机制去实现的,而我们直接通过NestedScroll机制也能很方便的实现这个动效.\n\n\n# 原理\n\nNestedScroll的其实很简单.\n\n一般的触摸消息的分发都是从外向内的,由外层的ViewGroup的dispatchTouchEvent方法调用到内层的View的dispatchTouchEvent方法.\n\n而NestedScroll提供了一个反向的机制,内层的view在接收到ACTION_MOVE的时候,将滚动消息先传回给外层的ViewGroup,看外层的ViewGroup是不是需要消耗一部分的移动,然后内层的View再去消耗剩下的移动.内层view可以消耗剩下的滚动的一部分,如果还没有消耗完,外层的view可以再选择把最后剩下的滚动消耗掉.\n\n上面的描述可能有点绕,可以看下面的图来帮助理解:\n\n{% img /安卓嵌套滚动NestedScroll了解一下/2.png %}\n\n# 具体实现\n\nNestedScroll机制会涉及到四个类:\n\nNestedScrollingChild， NestedScrollingChildHelper 和 NestedScrollingParent ， NestedScrollingParentHelper\n\nNestedScrollingChild和NestedScrollingParent是两个接口,我们先看看他们的声明:\n\n```\npublic interface NestedScrollingChild {\n    public void setNestedScrollingEnabled(boolean enabled);\n\n    public boolean isNestedScrollingEnabled();\n\n    public boolean startNestedScroll(int axes);\n\n    public void stopNestedScroll();\n\n    public boolean hasNestedScrollingParent();\n\n    public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed,\n            int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow);\n\n    public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow);\n\n    public boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed);\n\n    public boolean dispatchNestedPreFling(float velocityX, float velocityY);\n}\n\npublic interface NestedScrollingParent {\n    public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes);\n\n    public void onNestedScrollAccepted(View child, View target, int nestedScrollAxes);\n\n    public void onStopNestedScroll(View target);\n\n    public void onNestedScroll(View target, int dxConsumed, int dyConsumed,\n            int dxUnconsumed, int dyUnconsumed);\n\n    public void onNestedPreScroll(View target, int dx, int dy, int[] consumed);\n\n    public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed);\n\n    public boolean onNestedPreFling(View target, float velocityX, float velocityY);\n\n    public int getNestedScrollAxes();\n}\n```\n\n这里真正重要的其实是NestedScrollingParent的几个方法,因为其他方法都能直接让NestedScrollingChildHelper或者NestedScrollingParentHelper去代理:\n\n- onStartNestedScroll 是否接受嵌套滚动,只有它返回true,后面的其他方法才会被调用\n- onNestedPreScroll 在内层view处理滚动事件前先被调用,可以让外层view先消耗部分滚动\n- onNestedScroll 在内层view将剩下的滚动消耗完之后调用,可以在这里处理最后剩下的滚动\n- onNestedPreFling 在内层view的Fling事件处理之前被调用\n- onNestedFling 在内层view的Fling事件处理完之后调用\n\n我们只要让子view和父view分别实现NestedScrollingChild和NestedScrollingParent接口,然后分别调用NestedScrollingChildHelper和NestedScrollingParentHelper的对应方法去代理一些具体功能,然后在NestedScrollingChild的onTouchEvent那里根据需求调用startNestedScroll/dispatchNestedPreScroll/stopNestedScroll就能实现嵌套滚动了:\n\n```\n//NestedScrollingChild\nprivate NestedScrollingChildHelper mHelper = new NestedScrollingChildHelper(this);\n\npublic boolean startNestedScroll(int axes) {\n  return mHelper.startNestedScroll(axes);\n}\npublic boolean dispatchNestedScroll(int dxConsumed, int dyConsumed,\n            int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow) {\n  return mHelper.dispatchNestedScroll(dxConsumed,  dyConsumed,\n             dxUnconsumed,  dyUnconsumed, offsetInWindow);\n}\n...\n```\n\n```\n//NestedScrollingParent\nprivate NestedScrollingParentHelper mHelper = new NestedScrollingParentHelper(this);\n\npublic void onNestedScrollAccepted(View child, View target, int axes) {\n  mHelper.onNestedScrollAccepted(child, target, axes);\n}\n\npublic int getNestedScrollAxes() {\n  return mHelper.getNestedScrollAxes();\n}\n...\n```\n\n但是如果你使用sdk21及以上的版本,NestedScroll机制已经直接集成到了View中了,你只需要直接重写View的对应方法就好\n\n## 布局\n\n我们先看布局文件\n\n```\n<me.linjw.nestedscrolldemo.NestedScrollParentView xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\">\n\n    <FrameLayout\n        android:id=\"@+id/header\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\">\n\n        <ImageView\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"200dp\"\n            android:src=\"@mipmap/ic_launcher\" />\n    </FrameLayout>\n\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:background=\"@color/colorAccent\"\n        android:text=\"Title\"\n        android:textAlignment=\"center\"\n        android:textSize=\"20dp\" />\n\n    <android.support.v7.widget.RecyclerView\n        android:id=\"@+id/list\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\" />\n</me.linjw.nestedscrolldemo.NestedScrollParentView>\n```\n\n最外层是我们自定义的NestedScrollParentView,其实它是一个LinearLayout,内部竖直排列了三个子view:\n\n- 一个由FrameLayout包裹的ImageView\n- 一个TextView\n- 一个RecyclerView\n\n## 代码\n\n为了简便起见,我们先直接用sdk22的版本用重写View方法的方式去实现它.\n\nNestedScrollParentView中有两个方法比较重要,嵌套滚动基本上就是由这两个方法实现的:\n\n```\n  @Override\n    public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes) {\n        return true;\n    }\n\n    @Override\n    public void onNestedPreScroll(View target, int dx, int dy, int[] consumed) {\n        super.onNestedPreScroll(target, dx, dy, consumed);\n\n        boolean headerScrollUp = dy > 0 && getScrollY() < mHeaderHeight;\n        boolean headerScrollDown = dy < 0 && getScrollY() > 0 && !target.canScrollVertically(-1);\n        if (headerScrollUp || headerScrollDown) {\n            scrollBy(0, dy);\n            consumed[1] = dy;\n        }\n    }\n```\n\n- onStartNestedScroll 这个方法如果返回true的话代表接受由内层传来的滚动消息,我们直接返回true就好,否则后面的消息都接受不到\n\n- onNestedPreScroll 这个方法用于消耗内层view的一部分滚动.我们需要将消耗掉的滚动存到counsumed中让consumed知道.例如我们这里在顶部的FrameLayout需要移动的情况下会消耗掉所有的dy,这样内层的view(即RecyclerView)就不会滚动了.\n\n这里的mHeaderHeight保存的是顶部的FrameLayout的高度:\n\n```\n @Override\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        super.onSizeChanged(w, h, oldw, oldh);\n        mHeaderHeight = mHeader.getMeasuredHeight();\n    }\n```\n\n到这里基本上就实现了动图的效果,是不是很简单?\n\n完整代码可以参考 https://github.com/bluesky466/NestedScrollDemo/tree/sdk22\n","source":"_posts/安卓嵌套滚动NestedScroll了解一下.md","raw":"title: 安卓嵌套滚动NestedScroll了解一下\ndate: 2018-06-04 08:07:50\ntags:\n    - 技术相关\n    - Android\n---\n\n\n其实嵌套滚动已经算一个比较常见的特效了,下面这个动图就是嵌套滚动的一个例子:\n\n{% img /安卓嵌套滚动NestedScroll了解一下/1.gif %}\n\n看到这个动效,大家可能都知道可以用CoordinatorLayout去实现.其实CoordinatorLayout是基于NestedScroll机制去实现的,而我们直接通过NestedScroll机制也能很方便的实现这个动效.\n\n\n# 原理\n\nNestedScroll的其实很简单.\n\n一般的触摸消息的分发都是从外向内的,由外层的ViewGroup的dispatchTouchEvent方法调用到内层的View的dispatchTouchEvent方法.\n\n而NestedScroll提供了一个反向的机制,内层的view在接收到ACTION_MOVE的时候,将滚动消息先传回给外层的ViewGroup,看外层的ViewGroup是不是需要消耗一部分的移动,然后内层的View再去消耗剩下的移动.内层view可以消耗剩下的滚动的一部分,如果还没有消耗完,外层的view可以再选择把最后剩下的滚动消耗掉.\n\n上面的描述可能有点绕,可以看下面的图来帮助理解:\n\n{% img /安卓嵌套滚动NestedScroll了解一下/2.png %}\n\n# 具体实现\n\nNestedScroll机制会涉及到四个类:\n\nNestedScrollingChild， NestedScrollingChildHelper 和 NestedScrollingParent ， NestedScrollingParentHelper\n\nNestedScrollingChild和NestedScrollingParent是两个接口,我们先看看他们的声明:\n\n```\npublic interface NestedScrollingChild {\n    public void setNestedScrollingEnabled(boolean enabled);\n\n    public boolean isNestedScrollingEnabled();\n\n    public boolean startNestedScroll(int axes);\n\n    public void stopNestedScroll();\n\n    public boolean hasNestedScrollingParent();\n\n    public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed,\n            int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow);\n\n    public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow);\n\n    public boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed);\n\n    public boolean dispatchNestedPreFling(float velocityX, float velocityY);\n}\n\npublic interface NestedScrollingParent {\n    public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes);\n\n    public void onNestedScrollAccepted(View child, View target, int nestedScrollAxes);\n\n    public void onStopNestedScroll(View target);\n\n    public void onNestedScroll(View target, int dxConsumed, int dyConsumed,\n            int dxUnconsumed, int dyUnconsumed);\n\n    public void onNestedPreScroll(View target, int dx, int dy, int[] consumed);\n\n    public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed);\n\n    public boolean onNestedPreFling(View target, float velocityX, float velocityY);\n\n    public int getNestedScrollAxes();\n}\n```\n\n这里真正重要的其实是NestedScrollingParent的几个方法,因为其他方法都能直接让NestedScrollingChildHelper或者NestedScrollingParentHelper去代理:\n\n- onStartNestedScroll 是否接受嵌套滚动,只有它返回true,后面的其他方法才会被调用\n- onNestedPreScroll 在内层view处理滚动事件前先被调用,可以让外层view先消耗部分滚动\n- onNestedScroll 在内层view将剩下的滚动消耗完之后调用,可以在这里处理最后剩下的滚动\n- onNestedPreFling 在内层view的Fling事件处理之前被调用\n- onNestedFling 在内层view的Fling事件处理完之后调用\n\n我们只要让子view和父view分别实现NestedScrollingChild和NestedScrollingParent接口,然后分别调用NestedScrollingChildHelper和NestedScrollingParentHelper的对应方法去代理一些具体功能,然后在NestedScrollingChild的onTouchEvent那里根据需求调用startNestedScroll/dispatchNestedPreScroll/stopNestedScroll就能实现嵌套滚动了:\n\n```\n//NestedScrollingChild\nprivate NestedScrollingChildHelper mHelper = new NestedScrollingChildHelper(this);\n\npublic boolean startNestedScroll(int axes) {\n  return mHelper.startNestedScroll(axes);\n}\npublic boolean dispatchNestedScroll(int dxConsumed, int dyConsumed,\n            int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow) {\n  return mHelper.dispatchNestedScroll(dxConsumed,  dyConsumed,\n             dxUnconsumed,  dyUnconsumed, offsetInWindow);\n}\n...\n```\n\n```\n//NestedScrollingParent\nprivate NestedScrollingParentHelper mHelper = new NestedScrollingParentHelper(this);\n\npublic void onNestedScrollAccepted(View child, View target, int axes) {\n  mHelper.onNestedScrollAccepted(child, target, axes);\n}\n\npublic int getNestedScrollAxes() {\n  return mHelper.getNestedScrollAxes();\n}\n...\n```\n\n但是如果你使用sdk21及以上的版本,NestedScroll机制已经直接集成到了View中了,你只需要直接重写View的对应方法就好\n\n## 布局\n\n我们先看布局文件\n\n```\n<me.linjw.nestedscrolldemo.NestedScrollParentView xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\">\n\n    <FrameLayout\n        android:id=\"@+id/header\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\">\n\n        <ImageView\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"200dp\"\n            android:src=\"@mipmap/ic_launcher\" />\n    </FrameLayout>\n\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:background=\"@color/colorAccent\"\n        android:text=\"Title\"\n        android:textAlignment=\"center\"\n        android:textSize=\"20dp\" />\n\n    <android.support.v7.widget.RecyclerView\n        android:id=\"@+id/list\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\" />\n</me.linjw.nestedscrolldemo.NestedScrollParentView>\n```\n\n最外层是我们自定义的NestedScrollParentView,其实它是一个LinearLayout,内部竖直排列了三个子view:\n\n- 一个由FrameLayout包裹的ImageView\n- 一个TextView\n- 一个RecyclerView\n\n## 代码\n\n为了简便起见,我们先直接用sdk22的版本用重写View方法的方式去实现它.\n\nNestedScrollParentView中有两个方法比较重要,嵌套滚动基本上就是由这两个方法实现的:\n\n```\n  @Override\n    public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes) {\n        return true;\n    }\n\n    @Override\n    public void onNestedPreScroll(View target, int dx, int dy, int[] consumed) {\n        super.onNestedPreScroll(target, dx, dy, consumed);\n\n        boolean headerScrollUp = dy > 0 && getScrollY() < mHeaderHeight;\n        boolean headerScrollDown = dy < 0 && getScrollY() > 0 && !target.canScrollVertically(-1);\n        if (headerScrollUp || headerScrollDown) {\n            scrollBy(0, dy);\n            consumed[1] = dy;\n        }\n    }\n```\n\n- onStartNestedScroll 这个方法如果返回true的话代表接受由内层传来的滚动消息,我们直接返回true就好,否则后面的消息都接受不到\n\n- onNestedPreScroll 这个方法用于消耗内层view的一部分滚动.我们需要将消耗掉的滚动存到counsumed中让consumed知道.例如我们这里在顶部的FrameLayout需要移动的情况下会消耗掉所有的dy,这样内层的view(即RecyclerView)就不会滚动了.\n\n这里的mHeaderHeight保存的是顶部的FrameLayout的高度:\n\n```\n @Override\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        super.onSizeChanged(w, h, oldw, oldh);\n        mHeaderHeight = mHeader.getMeasuredHeight();\n    }\n```\n\n到这里基本上就实现了动图的效果,是不是很简单?\n\n完整代码可以参考 https://github.com/bluesky466/NestedScrollDemo/tree/sdk22\n","slug":"安卓嵌套滚动NestedScroll了解一下","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2umm0012w3fytll975ee"},{"title":"学习HTTP协议-用socket实现http访问","date":"2016-03-04T14:16:30.000Z","_content":"\n相信大家都知道 http 报文这东西吧？http 报文分两种，请求报文和响应报文。\n\n## __请求报文__\n\n客户端向服务端发送的就是请求报文，它可告诉服务端自己需要什么样的资源，也可以将一些文件或者数据上传给服务端。\n\n请求报文格式如下：\n\n{% img /学习HTTP协议-用socket实现http访问/1.jpg %}\n\n请求报文分为三个部分：\n\n- 请求行，如：\n\n> GET / HTTP/1.1\n\n这个请求行表明了这次请求使用的是 GET 方法，访问的是网站的根目录，使用的 HTTP 协议版本是 1.1。\n\n- 请求头部，如：\n\n> Host: www.baidu.com\n> Connection: keep-alive\n\n- 请求包体\n\n用来携带数据\n\n### _GET 方法_\n\nGET 方法是 HTTP 中最基础的方法，我们在浏览器地址栏输入网站浏览网页使用的都是 GET 方法：\n\n> http://www.islinjw.cn/okhttp_cookie_demo/checkverifycode.php\n\n当然有时候服务器需要根据用户传递的信息去返回对应的数据，GET 方法用下面的形式传递信息给服务器：\n\n> http://www.islinjw.cn/okhttp_cookie_demo/checkverifycode.php?verifycode=qwjuy&format=json\n\n这里告诉给服务器 verifycode=qwjuy 和 format=json ，服务器会根据用户传过来的信息返回不同的数据。\n\n这个时候的请求行长这个样子，URL 上就携带了 GET 传递的数据：\n\n> GET /okhttp_cookie_demo/checkverifycode.php?verifycode=qwjuy&format=json HTTP/1.1\n\n这里再说一句题外话，并不是说如果在 URL 里面没有见到 “?” 这个符号，客户端就没有传递数据给服务器。有一种叫做网页伪静态化的技术可以实现不带问号的 URL 使用 GET 方法传递数据。\n\n### _POST 方法_\n\nGET 方法的参数都显示在 URl 上，这样对于诸如账户密码的敏感信息来说太不安全，而且也很难传递想图片这样的数据。所以就有了 POST 方法。\n\n使用 POST 方法传递的数据并不会显示在 URL 上，而是保存在请求包体中，当然 HTTP 协议是明文传输的，所以把账户密码直接用 POST 传递也是不安全的，需要程序员自己进行加密处理。\n\n### _HTTP 协议方法列表_\n\n|序号 |方法 |描述|\n|---|---|---|\n|1 |GET |请求指定的页面信息，并返回实体主体。|\n|2 |HEAD |类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头|\n|3 |POST |向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。|\n|4 |PUT |从客户端向服务器传送的数据取代指定的文档的内容。|\n|5 |DELETE |请求服务器删除指定的页面。|\n|6 |CONNECT |HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。|\n|7 |OPTIONS\t|允许客户端查看服务器的性能。|\n|8 |TRACE |回显服务器收到的请求，主要用于测试或诊断。|\n|9 |PATCH |实体中包含一个表，表中说明与该URI所表示的原内容的区别。|\n|10 |MOVE |请求服务器将指定的页面移至另一个网络地址。|\n|11\t|COPY |请求服务器将指定的页面拷贝至另一个网络地址。|\n|12\t|LINK |请求服务器建立链接关系。|\n|13\t|UNLINK |断开链接关系。|\n|14\t|WRAPPED |允许客户端发送经过封装的请求。|\n|15\t|Extension-mothed |在不改动协议的前提下，可增加另外的方法。|\n\n## __响应报文__\n\n服务端接收到请求报文之后，了解到客户端需要什么样的服务之后就会返回响应报文给客户端。\n\n响应报文格式如下：\n\n{% img /学习HTTP协议-用socket实现http访问/2.jpg %}\n\n- 状态行，如：\n\n> HTTP/1.1 200 OK\n\n- 响应头部，如：\n\n> Date: Fri, 04 Mar 2016 11:04:01 GMT\n> Server: Apache/2.4.7 (Ubuntu)\n> X-Powered-By: PHP/5.5.9-1ubuntu4.14\n> Expires: Thu, 19 Nov 1981 08:52:00 GMT\n> Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0\n> Pragma: no-cache\n> Content-Length: 20\n> Keep-Alive: timeout=5, max=100\n> Connection: Keep-Alive\n> Content-Type: text/html\n\n- 响应包体，即页面显示的内容，如：\n\n> {\"result\":\"success\"}\n\n### _状态码_\n\n状态码由三位数字组成，第一位数字表示响应的类型，常用的状态码有五大类如下所示：\n\n　　1xx：表示服务器已接收了客户端请求，客户端可继续发送请求;\n\n　　2xx：表示服务器已成功接收到请求并进行处理;\n\n　　3xx：表示服务器要求客户端重定向;\n\n　　4xx：表示客户端的请求有非法内容;\n\n　　5xx：表示服务器未能正常处理客户端的请求而出现意外错误;\n\n## __使用 Socket 发送 HTTP 请求报文__\n\n我们知道 HTTP 协议是基于 TCP 的，而我们可以使用 Socket 进行 TCP 连接，所以在充分理解 HTTP 报文之后我们就可以用 socket 实现自己的 HTTP 访问了。\n\n### _访问网页_\n\n首先我们看看怎样用 socket 实现 http 访问网页,这里我们尝试使用 GET 方法访问 [www.islinjw.cn](http://www.islinjw.cn)。\n\n流程如下：\n1. 使用 socket 连接服务器\n2. 发送请求报文\n3. 接收响应报文\n4. 断开 socket 连接\n\n重点在于发送请求报文，其他步骤和一般的 socket 程序是没有什么区别的。\n\n请求报文分为三个部分还记得吗？\n\n- 请求行\n使用 HTTP/1.1 协议的 GET 方法访问网站的根目录：\n\n> GET / HTTP/1.1\n\n- 请求头部\nHost 是请求头部唯一必须携带的数据，要不然能接收到数据，但服务器返回302、400这样的错误代码。原因是服务器可能使用了虚拟服务器技术，一台服务器托管了多个网站，即多个网站通过dns解析到同样的ip地址。像这里我们访问 www.islinjw.cn 主机：\n\n> Host: www.islinjw.cn\n\n- 请求实体：\n但我们这里因为只是单纯的获取页面，并没有传递数据给服务器，所以报文实体为空。\n\n每个部分之间使用 \"\\\\r\\\\n\" 分割。但需要在请求报文的最后加多一个 \"\\\\n\"。为什么？还记得请求头部和请求实体之间有一个什么东西吗？对，空行！因为这里没有请求实体，所以报文最后就是一个空行。如果没有它，服务器不会返回响应报文，程序就会一直阻塞在那里。\n\n所以最终发送的报文就是:\n\n> GET / HTTP/1.1\\r\\nHost: www.islinjw.cn\\r\\n\\n\n\n代码如下：\n\n```cpp\n    void TestRequest(){\n        void TestRequest(){\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string data = \"\";\n\n        //请求行\n        data += \"GET / HTTP/1.1\\r\\n\";\n\n        //请求头部\n        data += \"Host: www.islinjw.cn\\r\\n\\n\";\n\n        send(sock_client,data.c_str(),data.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n```\n\n服务器返回的响应报文如下（对，这个网站就是一个 hello world 在那里而已）：\n\n{% img /学习HTTP协议-用socket实现http访问/3.jpg %}\n\n### _使用 GET 方法_\n\n为了验证是否真的传送了数据给服务器，我写了一个 demo 页面 [www.islinjw.cn/http_packet_demo/demo.php](http://www.islinjw.cn/http_packet_demo/demo.php)。这个页面的功能很简单，就是把接收到的 GET 数据和 POST 数据通过 json 格式打印出而已：\n\n{% img /学习HTTP协议-用socket实现http访问/4.jpg %}\n\n我们首先写一个函数用来把 map 转化成 GET 方法的参数格式：\n\n```cpp\n    string MsgToString(const map<string,string>& msg){\n        string result = \"\";\n        map<string,string>::const_iterator i = msg.begin();\n        while(i!=msg.end()){\n            result += i->first + \"=\" + i->second;\n            i++;\n            if(i!=msg.end()){\n                result += \"&\";\n            }\n        }\n        return result;\n    }\n```\n\n之前提到，GET 方法的数据是通过 URL 来传递的，所以只需要把得到的 GET 方法参数拼接到请求行的 URL 后面就行了：\n\n```cpp\n\tstring url = \"/http_packet_demo/demo.php\";\n\turl += \"?\" + MsgToString(msg);\n    cout<<\"url : \"<<url<<endl;\n\n\tstring packet = \"\";\n\n\t//请求行\n\tpacket += \"GET \" + url + \" HTTP/1.1\\r\\n\";\n```\n\n其他的和刚刚讲的访问网页的方式一模一样：\n\n```cpp\n\tvoid TestGet(const map<string,string>& msg){\n        //连接服务器主机\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string url = \"/http_packet_demo/demo.php\";\n        url += \"?\" + MsgToString(msg);\n\n        cout<<\"url : \"<<url<<endl;\n\n        string packet = \"\";\n\n        //请求行\n        packet += \"GET \" + url + \" HTTP/1.1\\r\\n\";\n\n        //请求头部\n        packet += \"Host: www.baidu.com\\r\\n\";\n\n        //空行\n        packet += \"\\n\";\n\n        send(sock_client, packet.c_str(), packet.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n```\n\n我们这样调用:\n\n```cpp\n\tmap<string,string> msg;\n\tmsg[\"abc\"] = \"123\";\n\tmsg[\"def\"] = \"456\";\n\n\tTestGet(msg);\n```\n\nURL 长这个样子：\n\n{% img /学习HTTP协议-用socket实现http访问/5.jpg %}\n\n服务器返回的响应报文如下：：\n\n{% img /学习HTTP协议-用socket实现http访问/6.jpg %}\n\n### _使用 POST 方法_\n\n使用 POST 方法会复杂那么一点点。首先请求行没有什么特别的，就是指定了 POST 方法和我们的页面，而且 URL 没有带数据:\n\n```cpp\n\tstring url = \"/http_packet_demo/demo.php\";\n\n\tstring packet = \"\";\n\n\t//请求行\n\tpacket += \"POST \" + url + \" HTTP/1.1\\r\\n\";\n```\n\n但因为 POST 携带的数据不一定是字符串，有可能是图片等二进制图片，所以就需要在请求头部告诉服务器携带的数据的类型和数据的长度:\n\n```cpp\n\t//请求头部\n\tpacket += \"Host: www.islinjw.cn\\r\\n\";\n\tpacket += \"Content-Type:application/x-www-form-urlencoded\\r\\n\"; //指定post传递的数据类型\n\tpacket += \"Content-Length: \" + ss.str() + \"\\r\\n\"; //标记post传递的数据的长度\n```\n\n之后就是一个空行和携带了数据的请求实体了：\n\n```cpp\n\t//空行\n\tpacket += \"\\n\";\n\n\t//post数据\n\tpacket += data;\n```\n\n所以整个方法长这个样子:\n\n```cpp\n    void TestPost(const map<string,string>& msg){\n        string data = MsgToString(msg);\n\n        stringstream ss;\n        ss<<data.length();\n\n        //连接服务器主机\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string url = \"/http_packet_demo/demo.php\";\n\n        string packet = \"\";\n\n        //请求行\n        packet += \"POST \" + url + \" HTTP/1.1\\r\\n\";\n\n        //请求头部\n        packet += \"Host: www.islinjw.cn\\r\\n\";\n        packet += \"Content-Type:application/x-www-form-urlencoded\\r\\n\"; //指定post传递的数据类型\n        packet += \"Content-Length: \" + ss.str() + \"\\r\\n\"; //标记post传递的数据的长度\n\n        //空行\n        packet += \"\\n\";\n\n        //post数据\n        packet += data;\n\n        send(sock_client, packet.c_str(), packet.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n```\n\n发送的数据如下：\n\n```cpp\n\tmap<string,string> msg;\n\tmsg[\"abc\"] = \"123\";\n\tmsg[\"def\"] = \"456\";\n\n\tTestPost(msg);\n```\n\n服务器返回的响应实体如下：\n\n{% img /学习HTTP协议-用socket实现http访问/7.jpg %}\n\n## __demo 完整代码__\n\n```cpp\n    #include \"stdafx.h\"\n\n    #include <Winsock2.h>\n    #include <iostream>\n    #include <map>\n    #include <string>\n    #include <sstream>\n\n    #pragma comment( lib, \"ws2_32.lib\" )\n\n    using namespace std;\n\n    const string SERVER_IP = \"182.254.231.66\";\n\n    SOCKET Connect(const char* ip){\n\n        //固定格式\n        WORD wVersionRequested;\n        WSADATA wsaData;\n        int err;\n\n        wVersionRequested = MAKEWORD( 1, 1 );\n\n        err = WSAStartup( wVersionRequested, &wsaData );\n        if ( err != 0 ) {\n            return INVALID_SOCKET;\n        }\n\n\n        if ( LOBYTE( wsaData.wVersion ) != 1 ||\n            HIBYTE( wsaData.wVersion ) != 1 ) {\n            WSACleanup( );\n            return INVALID_SOCKET;\n        }\n\n        SOCKET sock_client=socket(AF_INET,SOCK_STREAM,0);\n\n        SOCKADDR_IN addrSrv;\n        addrSrv.sin_addr.S_un.S_addr=inet_addr(ip);\n        addrSrv.sin_family=AF_INET;\n        addrSrv.sin_port=htons(80);//http端口为80\n        connect(sock_client,(SOCKADDR*)&addrSrv,sizeof(SOCKADDR));\n\n        return sock_client;\n    }\n\n    void Disconnect(SOCKET sock_client){\n        closesocket(sock_client);\n        WSACleanup();\n    }\n\n    void PrintRecvData(SOCKET sock_client){\n        cout<<\"Recv data :\"<<endl;\n\n        int len = 0;\n        char recvBuf[1024];\n        while((len = recv(sock_client,recvBuf,1023,0))>0){\n            recvBuf[len] = '\\0';\n            cout<<recvBuf;\n        }\n        cout<<endl;\n    }\n\n    void TestRequest(){\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        //最后必须多一个空行（\\n），要不然会阻塞住\n        //这个空行其实是报文首部和报文主体的分割符号，但这里请求不需要报文主体，所以是请求报文的结束\n        //string data = \"GET / HTTP/1.1\\r\\nHost: www.islinjw.cn\\r\\n\";\n\n        //HOST也是必须的，要不然能接收到数据，但服务器返回302、400这样的错误代码\n        //原因是服务器可能使用了虚拟服务器技术，一台服务器托管了多个网站，即多个网站通过dns解析到同样的ip地址\n        //所以在发送http请求时必须带上HOST\n        //string data = \"GET / HTTP/1.1\\r\\n\\n\";\n\n        string data = \"\";\n\n        //请求行\n        data += \"GET / HTTP/1.1\\r\\n\";\n\n        //请求头部\n        data += \"Host: www.islinjw.cn\\r\\n\\n\";\n\n        send(sock_client,data.c_str(),data.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n\n    string MsgToString(const map<string,string>& msg){\n        string result = \"\";\n        map<string,string>::const_iterator i = msg.begin();\n        while(i!=msg.end()){\n            result += i->first + \"=\" + i->second;\n            i++;\n            if(i!=msg.end()){\n                result += \"&\";\n            }\n        }\n        return result;\n    }\n\n    void TestGet(const map<string,string>& msg){\n        //连接服务器主机\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string url = \"/http_packet_demo/demo.php\";\n        url += \"?\" + MsgToString(msg);\n\n        cout<<\"url : \"<<url<<endl;\n\n        string packet = \"\";\n\n        //请求行\n        packet += \"GET \" + url + \" HTTP/1.1\\r\\n\";\n\n        //请求头部\n        packet += \"Host: www.baidu.com\\r\\n\";\n\n        //空行\n        packet += \"\\n\";\n\n        send(sock_client, packet.c_str(), packet.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n\n    void TestPost(const map<string,string>& msg){\n        string data = MsgToString(msg);\n\n        stringstream ss;\n        ss<<data.length();\n\n        //连接服务器主机\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string url = \"/http_packet_demo/demo.php\";\n\n        string packet = \"\";\n\n        //请求行\n        packet += \"POST \" + url + \" HTTP/1.1\\r\\n\";\n\n        //请求头部\n        packet += \"Host: www.islinjw.cn\\r\\n\";\n        packet += \"Content-Type:application/x-www-form-urlencoded\\r\\n\"; //指定post传递的数据类型\n        packet += \"Content-Length: \" + ss.str() + \"\\r\\n\"; //标记post传递的数据的长度\n\n        //空行\n        packet += \"\\n\";\n\n        //post数据\n        packet += data;\n\n        send(sock_client, packet.c_str(), packet.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n\n    int main(int argc, char* argv[])\n    {\n        map<string,string> msg;\n        msg[\"abc\"] = \"123\";\n        msg[\"def\"] = \"456\";\n\n        TestRequest();\n        cout<<\"\\n\\n\\n\"<<endl;\n        TestGet(msg);\n        cout<<\"\\n\\n\\n\"<<endl;\n        TestPost(msg);\n\n        return 0;\n    }\n\n\n\n```\n","source":"_posts/学习HTTP协议-用socket实现http访问.md","raw":"title: 学习HTTP协议-用socket实现http访问\ndate: 2016-03-04 22:16:30\ntags:\n\t- 技术相关\n\t- Http协议\n---\n\n相信大家都知道 http 报文这东西吧？http 报文分两种，请求报文和响应报文。\n\n## __请求报文__\n\n客户端向服务端发送的就是请求报文，它可告诉服务端自己需要什么样的资源，也可以将一些文件或者数据上传给服务端。\n\n请求报文格式如下：\n\n{% img /学习HTTP协议-用socket实现http访问/1.jpg %}\n\n请求报文分为三个部分：\n\n- 请求行，如：\n\n> GET / HTTP/1.1\n\n这个请求行表明了这次请求使用的是 GET 方法，访问的是网站的根目录，使用的 HTTP 协议版本是 1.1。\n\n- 请求头部，如：\n\n> Host: www.baidu.com\n> Connection: keep-alive\n\n- 请求包体\n\n用来携带数据\n\n### _GET 方法_\n\nGET 方法是 HTTP 中最基础的方法，我们在浏览器地址栏输入网站浏览网页使用的都是 GET 方法：\n\n> http://www.islinjw.cn/okhttp_cookie_demo/checkverifycode.php\n\n当然有时候服务器需要根据用户传递的信息去返回对应的数据，GET 方法用下面的形式传递信息给服务器：\n\n> http://www.islinjw.cn/okhttp_cookie_demo/checkverifycode.php?verifycode=qwjuy&format=json\n\n这里告诉给服务器 verifycode=qwjuy 和 format=json ，服务器会根据用户传过来的信息返回不同的数据。\n\n这个时候的请求行长这个样子，URL 上就携带了 GET 传递的数据：\n\n> GET /okhttp_cookie_demo/checkverifycode.php?verifycode=qwjuy&format=json HTTP/1.1\n\n这里再说一句题外话，并不是说如果在 URL 里面没有见到 “?” 这个符号，客户端就没有传递数据给服务器。有一种叫做网页伪静态化的技术可以实现不带问号的 URL 使用 GET 方法传递数据。\n\n### _POST 方法_\n\nGET 方法的参数都显示在 URl 上，这样对于诸如账户密码的敏感信息来说太不安全，而且也很难传递想图片这样的数据。所以就有了 POST 方法。\n\n使用 POST 方法传递的数据并不会显示在 URL 上，而是保存在请求包体中，当然 HTTP 协议是明文传输的，所以把账户密码直接用 POST 传递也是不安全的，需要程序员自己进行加密处理。\n\n### _HTTP 协议方法列表_\n\n|序号 |方法 |描述|\n|---|---|---|\n|1 |GET |请求指定的页面信息，并返回实体主体。|\n|2 |HEAD |类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头|\n|3 |POST |向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。|\n|4 |PUT |从客户端向服务器传送的数据取代指定的文档的内容。|\n|5 |DELETE |请求服务器删除指定的页面。|\n|6 |CONNECT |HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。|\n|7 |OPTIONS\t|允许客户端查看服务器的性能。|\n|8 |TRACE |回显服务器收到的请求，主要用于测试或诊断。|\n|9 |PATCH |实体中包含一个表，表中说明与该URI所表示的原内容的区别。|\n|10 |MOVE |请求服务器将指定的页面移至另一个网络地址。|\n|11\t|COPY |请求服务器将指定的页面拷贝至另一个网络地址。|\n|12\t|LINK |请求服务器建立链接关系。|\n|13\t|UNLINK |断开链接关系。|\n|14\t|WRAPPED |允许客户端发送经过封装的请求。|\n|15\t|Extension-mothed |在不改动协议的前提下，可增加另外的方法。|\n\n## __响应报文__\n\n服务端接收到请求报文之后，了解到客户端需要什么样的服务之后就会返回响应报文给客户端。\n\n响应报文格式如下：\n\n{% img /学习HTTP协议-用socket实现http访问/2.jpg %}\n\n- 状态行，如：\n\n> HTTP/1.1 200 OK\n\n- 响应头部，如：\n\n> Date: Fri, 04 Mar 2016 11:04:01 GMT\n> Server: Apache/2.4.7 (Ubuntu)\n> X-Powered-By: PHP/5.5.9-1ubuntu4.14\n> Expires: Thu, 19 Nov 1981 08:52:00 GMT\n> Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0\n> Pragma: no-cache\n> Content-Length: 20\n> Keep-Alive: timeout=5, max=100\n> Connection: Keep-Alive\n> Content-Type: text/html\n\n- 响应包体，即页面显示的内容，如：\n\n> {\"result\":\"success\"}\n\n### _状态码_\n\n状态码由三位数字组成，第一位数字表示响应的类型，常用的状态码有五大类如下所示：\n\n　　1xx：表示服务器已接收了客户端请求，客户端可继续发送请求;\n\n　　2xx：表示服务器已成功接收到请求并进行处理;\n\n　　3xx：表示服务器要求客户端重定向;\n\n　　4xx：表示客户端的请求有非法内容;\n\n　　5xx：表示服务器未能正常处理客户端的请求而出现意外错误;\n\n## __使用 Socket 发送 HTTP 请求报文__\n\n我们知道 HTTP 协议是基于 TCP 的，而我们可以使用 Socket 进行 TCP 连接，所以在充分理解 HTTP 报文之后我们就可以用 socket 实现自己的 HTTP 访问了。\n\n### _访问网页_\n\n首先我们看看怎样用 socket 实现 http 访问网页,这里我们尝试使用 GET 方法访问 [www.islinjw.cn](http://www.islinjw.cn)。\n\n流程如下：\n1. 使用 socket 连接服务器\n2. 发送请求报文\n3. 接收响应报文\n4. 断开 socket 连接\n\n重点在于发送请求报文，其他步骤和一般的 socket 程序是没有什么区别的。\n\n请求报文分为三个部分还记得吗？\n\n- 请求行\n使用 HTTP/1.1 协议的 GET 方法访问网站的根目录：\n\n> GET / HTTP/1.1\n\n- 请求头部\nHost 是请求头部唯一必须携带的数据，要不然能接收到数据，但服务器返回302、400这样的错误代码。原因是服务器可能使用了虚拟服务器技术，一台服务器托管了多个网站，即多个网站通过dns解析到同样的ip地址。像这里我们访问 www.islinjw.cn 主机：\n\n> Host: www.islinjw.cn\n\n- 请求实体：\n但我们这里因为只是单纯的获取页面，并没有传递数据给服务器，所以报文实体为空。\n\n每个部分之间使用 \"\\\\r\\\\n\" 分割。但需要在请求报文的最后加多一个 \"\\\\n\"。为什么？还记得请求头部和请求实体之间有一个什么东西吗？对，空行！因为这里没有请求实体，所以报文最后就是一个空行。如果没有它，服务器不会返回响应报文，程序就会一直阻塞在那里。\n\n所以最终发送的报文就是:\n\n> GET / HTTP/1.1\\r\\nHost: www.islinjw.cn\\r\\n\\n\n\n代码如下：\n\n```cpp\n    void TestRequest(){\n        void TestRequest(){\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string data = \"\";\n\n        //请求行\n        data += \"GET / HTTP/1.1\\r\\n\";\n\n        //请求头部\n        data += \"Host: www.islinjw.cn\\r\\n\\n\";\n\n        send(sock_client,data.c_str(),data.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n```\n\n服务器返回的响应报文如下（对，这个网站就是一个 hello world 在那里而已）：\n\n{% img /学习HTTP协议-用socket实现http访问/3.jpg %}\n\n### _使用 GET 方法_\n\n为了验证是否真的传送了数据给服务器，我写了一个 demo 页面 [www.islinjw.cn/http_packet_demo/demo.php](http://www.islinjw.cn/http_packet_demo/demo.php)。这个页面的功能很简单，就是把接收到的 GET 数据和 POST 数据通过 json 格式打印出而已：\n\n{% img /学习HTTP协议-用socket实现http访问/4.jpg %}\n\n我们首先写一个函数用来把 map 转化成 GET 方法的参数格式：\n\n```cpp\n    string MsgToString(const map<string,string>& msg){\n        string result = \"\";\n        map<string,string>::const_iterator i = msg.begin();\n        while(i!=msg.end()){\n            result += i->first + \"=\" + i->second;\n            i++;\n            if(i!=msg.end()){\n                result += \"&\";\n            }\n        }\n        return result;\n    }\n```\n\n之前提到，GET 方法的数据是通过 URL 来传递的，所以只需要把得到的 GET 方法参数拼接到请求行的 URL 后面就行了：\n\n```cpp\n\tstring url = \"/http_packet_demo/demo.php\";\n\turl += \"?\" + MsgToString(msg);\n    cout<<\"url : \"<<url<<endl;\n\n\tstring packet = \"\";\n\n\t//请求行\n\tpacket += \"GET \" + url + \" HTTP/1.1\\r\\n\";\n```\n\n其他的和刚刚讲的访问网页的方式一模一样：\n\n```cpp\n\tvoid TestGet(const map<string,string>& msg){\n        //连接服务器主机\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string url = \"/http_packet_demo/demo.php\";\n        url += \"?\" + MsgToString(msg);\n\n        cout<<\"url : \"<<url<<endl;\n\n        string packet = \"\";\n\n        //请求行\n        packet += \"GET \" + url + \" HTTP/1.1\\r\\n\";\n\n        //请求头部\n        packet += \"Host: www.baidu.com\\r\\n\";\n\n        //空行\n        packet += \"\\n\";\n\n        send(sock_client, packet.c_str(), packet.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n```\n\n我们这样调用:\n\n```cpp\n\tmap<string,string> msg;\n\tmsg[\"abc\"] = \"123\";\n\tmsg[\"def\"] = \"456\";\n\n\tTestGet(msg);\n```\n\nURL 长这个样子：\n\n{% img /学习HTTP协议-用socket实现http访问/5.jpg %}\n\n服务器返回的响应报文如下：：\n\n{% img /学习HTTP协议-用socket实现http访问/6.jpg %}\n\n### _使用 POST 方法_\n\n使用 POST 方法会复杂那么一点点。首先请求行没有什么特别的，就是指定了 POST 方法和我们的页面，而且 URL 没有带数据:\n\n```cpp\n\tstring url = \"/http_packet_demo/demo.php\";\n\n\tstring packet = \"\";\n\n\t//请求行\n\tpacket += \"POST \" + url + \" HTTP/1.1\\r\\n\";\n```\n\n但因为 POST 携带的数据不一定是字符串，有可能是图片等二进制图片，所以就需要在请求头部告诉服务器携带的数据的类型和数据的长度:\n\n```cpp\n\t//请求头部\n\tpacket += \"Host: www.islinjw.cn\\r\\n\";\n\tpacket += \"Content-Type:application/x-www-form-urlencoded\\r\\n\"; //指定post传递的数据类型\n\tpacket += \"Content-Length: \" + ss.str() + \"\\r\\n\"; //标记post传递的数据的长度\n```\n\n之后就是一个空行和携带了数据的请求实体了：\n\n```cpp\n\t//空行\n\tpacket += \"\\n\";\n\n\t//post数据\n\tpacket += data;\n```\n\n所以整个方法长这个样子:\n\n```cpp\n    void TestPost(const map<string,string>& msg){\n        string data = MsgToString(msg);\n\n        stringstream ss;\n        ss<<data.length();\n\n        //连接服务器主机\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string url = \"/http_packet_demo/demo.php\";\n\n        string packet = \"\";\n\n        //请求行\n        packet += \"POST \" + url + \" HTTP/1.1\\r\\n\";\n\n        //请求头部\n        packet += \"Host: www.islinjw.cn\\r\\n\";\n        packet += \"Content-Type:application/x-www-form-urlencoded\\r\\n\"; //指定post传递的数据类型\n        packet += \"Content-Length: \" + ss.str() + \"\\r\\n\"; //标记post传递的数据的长度\n\n        //空行\n        packet += \"\\n\";\n\n        //post数据\n        packet += data;\n\n        send(sock_client, packet.c_str(), packet.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n```\n\n发送的数据如下：\n\n```cpp\n\tmap<string,string> msg;\n\tmsg[\"abc\"] = \"123\";\n\tmsg[\"def\"] = \"456\";\n\n\tTestPost(msg);\n```\n\n服务器返回的响应实体如下：\n\n{% img /学习HTTP协议-用socket实现http访问/7.jpg %}\n\n## __demo 完整代码__\n\n```cpp\n    #include \"stdafx.h\"\n\n    #include <Winsock2.h>\n    #include <iostream>\n    #include <map>\n    #include <string>\n    #include <sstream>\n\n    #pragma comment( lib, \"ws2_32.lib\" )\n\n    using namespace std;\n\n    const string SERVER_IP = \"182.254.231.66\";\n\n    SOCKET Connect(const char* ip){\n\n        //固定格式\n        WORD wVersionRequested;\n        WSADATA wsaData;\n        int err;\n\n        wVersionRequested = MAKEWORD( 1, 1 );\n\n        err = WSAStartup( wVersionRequested, &wsaData );\n        if ( err != 0 ) {\n            return INVALID_SOCKET;\n        }\n\n\n        if ( LOBYTE( wsaData.wVersion ) != 1 ||\n            HIBYTE( wsaData.wVersion ) != 1 ) {\n            WSACleanup( );\n            return INVALID_SOCKET;\n        }\n\n        SOCKET sock_client=socket(AF_INET,SOCK_STREAM,0);\n\n        SOCKADDR_IN addrSrv;\n        addrSrv.sin_addr.S_un.S_addr=inet_addr(ip);\n        addrSrv.sin_family=AF_INET;\n        addrSrv.sin_port=htons(80);//http端口为80\n        connect(sock_client,(SOCKADDR*)&addrSrv,sizeof(SOCKADDR));\n\n        return sock_client;\n    }\n\n    void Disconnect(SOCKET sock_client){\n        closesocket(sock_client);\n        WSACleanup();\n    }\n\n    void PrintRecvData(SOCKET sock_client){\n        cout<<\"Recv data :\"<<endl;\n\n        int len = 0;\n        char recvBuf[1024];\n        while((len = recv(sock_client,recvBuf,1023,0))>0){\n            recvBuf[len] = '\\0';\n            cout<<recvBuf;\n        }\n        cout<<endl;\n    }\n\n    void TestRequest(){\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        //最后必须多一个空行（\\n），要不然会阻塞住\n        //这个空行其实是报文首部和报文主体的分割符号，但这里请求不需要报文主体，所以是请求报文的结束\n        //string data = \"GET / HTTP/1.1\\r\\nHost: www.islinjw.cn\\r\\n\";\n\n        //HOST也是必须的，要不然能接收到数据，但服务器返回302、400这样的错误代码\n        //原因是服务器可能使用了虚拟服务器技术，一台服务器托管了多个网站，即多个网站通过dns解析到同样的ip地址\n        //所以在发送http请求时必须带上HOST\n        //string data = \"GET / HTTP/1.1\\r\\n\\n\";\n\n        string data = \"\";\n\n        //请求行\n        data += \"GET / HTTP/1.1\\r\\n\";\n\n        //请求头部\n        data += \"Host: www.islinjw.cn\\r\\n\\n\";\n\n        send(sock_client,data.c_str(),data.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n\n    string MsgToString(const map<string,string>& msg){\n        string result = \"\";\n        map<string,string>::const_iterator i = msg.begin();\n        while(i!=msg.end()){\n            result += i->first + \"=\" + i->second;\n            i++;\n            if(i!=msg.end()){\n                result += \"&\";\n            }\n        }\n        return result;\n    }\n\n    void TestGet(const map<string,string>& msg){\n        //连接服务器主机\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string url = \"/http_packet_demo/demo.php\";\n        url += \"?\" + MsgToString(msg);\n\n        cout<<\"url : \"<<url<<endl;\n\n        string packet = \"\";\n\n        //请求行\n        packet += \"GET \" + url + \" HTTP/1.1\\r\\n\";\n\n        //请求头部\n        packet += \"Host: www.baidu.com\\r\\n\";\n\n        //空行\n        packet += \"\\n\";\n\n        send(sock_client, packet.c_str(), packet.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n\n    void TestPost(const map<string,string>& msg){\n        string data = MsgToString(msg);\n\n        stringstream ss;\n        ss<<data.length();\n\n        //连接服务器主机\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string url = \"/http_packet_demo/demo.php\";\n\n        string packet = \"\";\n\n        //请求行\n        packet += \"POST \" + url + \" HTTP/1.1\\r\\n\";\n\n        //请求头部\n        packet += \"Host: www.islinjw.cn\\r\\n\";\n        packet += \"Content-Type:application/x-www-form-urlencoded\\r\\n\"; //指定post传递的数据类型\n        packet += \"Content-Length: \" + ss.str() + \"\\r\\n\"; //标记post传递的数据的长度\n\n        //空行\n        packet += \"\\n\";\n\n        //post数据\n        packet += data;\n\n        send(sock_client, packet.c_str(), packet.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n\n    int main(int argc, char* argv[])\n    {\n        map<string,string> msg;\n        msg[\"abc\"] = \"123\";\n        msg[\"def\"] = \"456\";\n\n        TestRequest();\n        cout<<\"\\n\\n\\n\"<<endl;\n        TestGet(msg);\n        cout<<\"\\n\\n\\n\"<<endl;\n        TestPost(msg);\n\n        return 0;\n    }\n\n\n\n```\n","slug":"学习HTTP协议-用socket实现http访问","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2umo0015w3fye3gp7fm7"},{"title":"学习HTTP协议-在安卓上的使用Cookie与Session","date":"2016-03-03T12:43:26.000Z","_content":"\n大三的时候写过一段时间的 php ，那时候已经对 html、css、js、cookie、session 这些东西了一点认知，但基本都是浮于表面，知其然而不知其所以然。于是这几天翻了翻《图解http》，书上的知识和自己的以前的理解结合起来，感觉对于 http 协议有了一些比较深刻的理解。\n\n在这里把那些知识点整理记录一下，而因为 HTTP 协议的知识点较多，所以会有一个系列的博客去介绍。这篇文章就先讲一下 Cookie 和 Session 吧。\n\n## __Cookie & Session__\n\n毕业设计有个功能是实现用户的注册登录，而注册账号的时候需要有输入验证码的功能。\n\n众所周知，HTTP 协议是无状态协议，即协议对于事务处理没有记忆能力。但就像这里，我们需要实现一个验证码功能，我们从服务器获取验证码的图片，然后再将用户输入的验证码传回服务器进行对比，这就要求服务器记录之前随机生成的验证码了。于是，两种用于保持HTTP连接状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session。\n\n### _Cookie_\n\nCookie 是由服务器端生成，发送给 User-Agent（一般是浏览器），浏览器会将 Cookie 的 key/value 保存到某个目录下的文本文件内，下次请求同一网站时就发送该 Cookie 给服务器（前提是浏览器设置为启用 cookie ）。\n\n我们可以在 chrome 浏览器页面按 F12 打开控制台，选择 Network 标签查看与网站进行 HTTP 协议交流的数据。\n\n这里我们看看登录[B站](http://www.bilibili.tv)的时候究竟发生了什么事情：\n\n首先我们输入账号密码和验证码之后点击登陆，浏览器会发生账号密码等数据给服务器,之后服务器返回数据。我们查看返回报文的 header 可以看到一堆的 Set-Cookie 字段：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/1.jpg %}\n\n客户端会把这些 cookie 记录下来，在下次访问服务器的时候就会把它们传回给服务器，这样就能实现数据的保持：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/2.jpg %}\n\n### _Session_\n\n但 Cookie 的数据都是保存在客户端的，客户端很容易就能查看和修改 cookie，十分不安全。例如 chrome 有一个 EditThisCookie 插件，就能直接查看修改网页的 cookie：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/3.jpg %}\n\n所以就有了存放在服务器端的内存中的 sessio，session可以看作一个存放在服务器的键值对集。\n\n当服务器创建一个 session 对象的时候，就会对应的生成一个sessionId，服务器可以在 session 中写入数据，但它不会将session 的内容告诉客户端，它只会将生成的 sessionId 以 cookie 的方式传给客户端，而客户端在下次访问服务器的时候把 sessionId 又传回给服务器，这样服务器就能找到之前保存的数据了。\n\n在 php 中这个 sessionid 的名字默认叫做 PHPSESSID，当然也能在php.ini中修改。\n\n因为 session 保存在服务器中，所以安全性比 cookie 高的多。\n\n关于 Cookie 和 Session，各位有兴趣的话可以自己去网上搜索一下，或者希望对 HTTP 协议有更深入的理解的话可以去读一下《图解http》。最近就在读这本书，等读完我会写一篇博客，介绍一些 HTTP 协议的重点知识，这里就不再多说了。\n\n## __okHttp3 使用 Cookie__\n\nokHttp3 的 cookie 管理方式对比 okHttp2 有了很大的变化，这里有一篇博客专门介绍[OkHttp3实现Cookies管理及持久化](http://www.codeceo.com/article/okhttp3-cookies-manage.html)。希望各位在读我这篇博客之前先浏览一下。\n\nokHttp3 使用 CookieJar 接口来管理 Cookie：\n\n```java\n\tpublic interface CookieJar {\n  \t/** A cookie jar that never accepts any cookies. */\n  \tCookieJar NO_COOKIES = new CookieJar() {\n    @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {\n    }\n\n    @Override public List<Cookie> loadForRequest(HttpUrl url) {\n      return Collections.emptyList();\n    }\n  \t};\n```\n\n我们只要在创建 OkHttpClient 的时候指定我们自己的 CookieJar 就能让 OkHttpClient 实现 Cookie 的自动管理：\n\n```java\n\tpublic class MainActivity extends AppCompatActivity {\n    \tprivate Map<String, List<Cookie>> mCookieStore;\n        ...\n        private OkHttpClient createHttpClient() {\n            CookieJar cookieJar = new CookieJar() {\n                @Override\n                public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {\n                    mCookieStore.put(url.host(), cookies);\n                }\n\n                @Override\n                public List<Cookie> loadForRequest(HttpUrl url) {\n                    List list = mCookieStore.get(url.host());\n                    return list != null ? list : new ArrayList<Cookie>();\n                }\n            };\n            return new OkHttpClient.Builder()\n                    .cookieJar(cookieJar)\n                    .build();\n        }\n        ...\n\t}\n```\n\n这里有点要注意，我们是拿 host 作 map 的 key 值，[《OkHttp3实现Cookies管理及持久化》](http://www.codeceo.com/article/okhttp3-cookies-manage.html)这篇博文直接用 url 当 key 值，这样的话该 Cookie 就只能在当前页面可用了，而我们是整个网站可用。\n\n## __Retrofit 使用 Cookie__\n\n在 Retrofit 中使用 Cookie 就更加简单了，因为它内部使用 OkHttp3，只要把之前设置了 CookieJar 的 OkHttpClient 设置给它就可以了：\n\n```java\n\tHttpService service = new Retrofit.Builder()\n                .client(mHttpClient) //OkHttpClient 指定了 CookieJar，这样 Retrofit 也能使用 Cookie 了\n                .baseUrl(mBaseUrl)\n                .addConverterFactory(GsonConverterFactory.create())\n                .build()\n                .create(HttpService.class);\n```\n\n## __验证码小 Demo__\n\n现状我们用一个实现了验证码功能的小 Demo 来更加深刻的理解之前所讲的知识。\n\n首先我写了两个页面：\n\n- 生成验证码的页面 ： http://www.islinjw.cn/okhttp_cookie_demo/verifycode.php\n- 检查验证码的页面 ： http://www.islinjw.cn/okhttp_cookie_demo/checkverifycode.php\n\n访问第一个页面能获得一张随机的验证码图片，而第二个页面使用 GET 方法来检测验证码（键值为 verifycode）。\n\n### _获取验证码图片_\n\n首先我们使用 OkHttp3 访问第一个页面，下载一张验证码图片，将它显示在 ImageView 中：\n\n```java\n\tprivate void loadVerifyCode(final ImageView imageView, final HttpUrl url) {\n        final Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    okhttp3.Response response = mHttpClient.newCall(request).execute();\n\n                    //创建bitmap\n                    InputStream is = response.body().byteStream();\n                    final Bitmap bm = BitmapFactory.decodeStream(is);\n\n                    //加载到ImageView中\n                    runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            imageView.setImageBitmap(bm);\n                        }\n                    });\n\n                    //打印cookie信息\n                    List<Cookie> cookies = Cookie.parseAll(request.url(), response.headers());\n                    for (int i = 0; i < cookies.size(); i++) {\n                        Log.d(\"cookie\", \"request headers: \" + cookies.get(i).toString());\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n```\n\n运行程序可以看到验证码被显示出来：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/5.jpg %}\n\n我们还能能看到服务器返回的 Cookie 信息，因为我的网页使用 php 写的，所以它返回了一个 PHPSESSID ，用来标记服务器保存的 Session 对象。服务器的 Session 对象里面就保存了验证码的值。之后我们把用户输入的验证码传会服务器的时候只要把这个 PHPSESSID 一同传过去，服务器就能找到之前生成的验证码的值，并和用户所输入的进行对比了:\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/6.jpg %}\n\n### _发送用户输入的验证码_\n\n这里我们直接使用 Retrofit 将用户输入的验证码传给服务器：\n\n```java\n\tpublic void onClick(View v) {\n        HttpService service = new Retrofit.Builder()\n                .client(mHttpClient)  //OkHttpClient 指定了 CookieJar，这样 Retrofit 也能使用 Cookie 了\n                .baseUrl(mBaseUrl)\n                .addConverterFactory(GsonConverterFactory.create())\n                .build()\n                .create(HttpService.class);\n\n        String verifyCode = mEditText.getText().toString();\n        if (verifyCode == null) {\n            return;\n        }\n\n        Call<VerifyCodeResult> call = service.getResult(verifyCode);\n        call.enqueue(new Callback<VerifyCodeResult>() {\n            @Override\n            public void onResponse(Call<VerifyCodeResult> call, Response<VerifyCodeResult> response) {\n                Log.d(\"cookie\", \"request headers: \" + call.request().headers().toString());\n                Toast.makeText(MainActivity.this, response.body().getResult(), Toast.LENGTH_SHORT).show();\n            }\n\n            @Override\n            public void onFailure(Call<VerifyCodeResult> call, Throwable t) {\n            }\n        });\n```\n\n```java\n    public interface HttpService {\n        @GET(\"okhttp_cookie_demo/checkverifycode.php\")\n        Call<VerifyCodeResult> getResult(@Query(\"verifycode\") String yam);\n    }\n```\n\n```java\n    public class VerifyCodeResult {\n        private String result;\n\n        public String getResult() {\n            return result;\n        }\n\n        public void setResult(String result) {\n            this.result = result;\n        }\n    }\n```\n\n运行程序，输入验证码可以看到结果：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/7.jpg %}\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/8.jpg %}\n\n程序正常运行，但看 log 输出，Request 并没有把 PHPSESSID 传过去。这是怎么回事？没有传 PHPSESSID，服务器又怎么能知道之前生成的验证码是什么？\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/9.jpg %}\n\n在 CookieJar 的 loadForRequest 方法设置断点，可以发现在发送验证码的时候确实有调用，随之运行到 HttpEngine 的源码，发现原来框架创建了个新的 Resquest 副本，将 Cookie 传入这个新的副本中去连接服务器：\n\n```java\n    public void sendRequest() throws RequestException, RouteException, IOException {\n        ...\n        Request request = networkRequest(userRequest);\n\t\t...\n    }\n\t...\n    private Request networkRequest(Request request) throws IOException {\n        Request.Builder result = request.newBuilder();\n\n        if (request.header(\"Host\") == null) {\n          result.header(\"Host\", hostHeader(request.url()));\n        }\n\n        if (request.header(\"Connection\") == null) {\n          result.header(\"Connection\", \"Keep-Alive\");\n        }\n\n        if (request.header(\"Accept-Encoding\") == null) {\n          transparentGzip = true;\n          result.header(\"Accept-Encoding\", \"gzip\");\n        }\n\n\t\t//看这里，其实是有设置 CookieJar 中的 Cookie 的\n        //也就是说 PHPSESSID 有传回去给服务器\n        List<Cookie> cookies = client.cookieJar().loadForRequest(request.url());\n        if (!cookies.isEmpty()) {\n          result.header(\"Cookie\", cookieHeader(cookies));\n        }\n\n        if (request.header(\"User-Agent\") == null) {\n          result.header(\"User-Agent\", Version.userAgent());\n        }\n\n        return result.build();\n      }\n```\n\n原来如此，操作都使用了副本 Request 去执行，怪不得我们直接用下面的代码输出，请求头部不能看到 PHPSESSID 的 Cookie 值：\n\n```java\n\t@Override\n    public void onResponse(Call<VerifyCodeResult> call, Response<VerifyCodeResult> response) {\n        Log.d(\"cookie\", \"request headers: \" + call.request().headers().toString());\n        Toast.makeText(MainActivity.this, response.body().getResult(), Toast.LENGTH_SHORT).show();\n    }\n```\n\n## __Glide 使用 Cookie__\n\nGlide 是Google推荐的图片加载库，用来加载图片十分之方便，最少只需要三行代码就能将网络图片加载到 ImageView 上。\n\n我有在 Glide 的文档上看到它也能使用 OkHttp3，理论上应该也能使用设置 OkHttpClient 的方法使用 Cookie。\n\n但弄了很久还是没有搞定，等以后有时间找到实现方法再把这一节补全。\n\n## __Demo 完整代码__\n\nMainActivity:\n\n```java\n\tpublic class MainActivity extends AppCompatActivity {\n    private static final String mBaseUrl = \"http://www.islinjw.cn\";\n    private static final String mVerifyCideUrl = \"http://www.islinjw.cn/okhttp_cookie_demo/verifycode.php\";\n\n    private OkHttpClient mHttpClient;\n    private EditText mEditText;\n    private ImageView mImageView;\n    private Map<String, List<Cookie>> mCookieStore;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mEditText = (EditText) findViewById(R.id.input);\n        mImageView = (ImageView) findViewById(R.id.yzm);\n        mCookieStore = new HashMap<>();\n        mHttpClient = createHttpClient();\n\n        loadVerifyCode(mImageView, HttpUrl.parse(mVerifyCideUrl));\n    }\n\n    private OkHttpClient createHttpClient() {\n        CookieJar cookieJar = new CookieJar() {\n            @Override\n            public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {\n                mCookieStore.put(url.host(), cookies);\n            }\n\n            @Override\n            public List<Cookie> loadForRequest(HttpUrl url) {\n                List list = mCookieStore.get(url.host());\n                return list != null ? list : new ArrayList<Cookie>();\n            }\n        };\n        return new OkHttpClient.Builder()\n                .cookieJar(cookieJar)\n                .build();\n    }\n\n    private void loadVerifyCode(final ImageView imageView, final HttpUrl url) {\n        final Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    okhttp3.Response response = mHttpClient.newCall(request).execute();\n\n                    //创建bitmap\n                    InputStream is = response.body().byteStream();\n                    final Bitmap bm = BitmapFactory.decodeStream(is);\n\n                    //加载到ImageView中\n                    runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            imageView.setImageBitmap(bm);\n                        }\n                    });\n\n                    //打印cookie信息\n                    List<Cookie> cookies = Cookie.parseAll(request.url(), response.headers());\n                    for (int i = 0; i < cookies.size(); i++) {\n                        Log.d(\"cookie\", \"response headers: \" + cookies.get(i).toString());\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n\n    public void onClick(View v) {\n        HttpService service = new Retrofit.Builder()\n                .client(mHttpClient)  //OkHttpClient 指定了 CookieJar，这样 Retrofit 也能使用 Cookie 了\n                .baseUrl(mBaseUrl)\n                .addConverterFactory(GsonConverterFactory.create())\n                .build()\n                .create(HttpService.class);\n\n        String verifyCode = mEditText.getText().toString();\n        if (verifyCode == null) {\n            return;\n        }\n\n        Call<VerifyCodeResult> call = service.getResult(verifyCode);\n        call.enqueue(new Callback<VerifyCodeResult>() {\n            @Override\n            public void onResponse(Call<VerifyCodeResult> call, Response<VerifyCodeResult> response) {\n                Log.d(\"cookie\", \"request headers: \" + call.request().headers().toString());\n                Toast.makeText(MainActivity.this, response.body().getResult(), Toast.LENGTH_SHORT).show();\n            }\n\n            @Override\n            public void onFailure(Call<VerifyCodeResult> call, Throwable t) {\n            }\n        });\n    }\n}\n```\n\nHttpService:\n\n```java\n\tpublic interface HttpService {\n        @GET(\"okhttp_cookie_demo/checkverifycode.php\")\n        Call<VerifyCodeResult> getResult(@Query(\"verifycode\") String yam);\n    }\n```\n\n```java\n\tpublic class VerifyCodeResult {\n        private String result;\n\n        public String getResult() {\n            return result;\n        }\n\n        public void setResult(String result) {\n            this.result = result;\n        }\n    }\n```\n","source":"_posts/学习HTTP协议-在安卓上的使用Cookie与Session.md","raw":"title: 学习HTTP协议-在安卓上的使用Cookie与Session\ndate: 2016-03-03 20:43:26\ntags:\n\t- 技术相关\n\t- Http协议\n---\n\n大三的时候写过一段时间的 php ，那时候已经对 html、css、js、cookie、session 这些东西了一点认知，但基本都是浮于表面，知其然而不知其所以然。于是这几天翻了翻《图解http》，书上的知识和自己的以前的理解结合起来，感觉对于 http 协议有了一些比较深刻的理解。\n\n在这里把那些知识点整理记录一下，而因为 HTTP 协议的知识点较多，所以会有一个系列的博客去介绍。这篇文章就先讲一下 Cookie 和 Session 吧。\n\n## __Cookie & Session__\n\n毕业设计有个功能是实现用户的注册登录，而注册账号的时候需要有输入验证码的功能。\n\n众所周知，HTTP 协议是无状态协议，即协议对于事务处理没有记忆能力。但就像这里，我们需要实现一个验证码功能，我们从服务器获取验证码的图片，然后再将用户输入的验证码传回服务器进行对比，这就要求服务器记录之前随机生成的验证码了。于是，两种用于保持HTTP连接状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session。\n\n### _Cookie_\n\nCookie 是由服务器端生成，发送给 User-Agent（一般是浏览器），浏览器会将 Cookie 的 key/value 保存到某个目录下的文本文件内，下次请求同一网站时就发送该 Cookie 给服务器（前提是浏览器设置为启用 cookie ）。\n\n我们可以在 chrome 浏览器页面按 F12 打开控制台，选择 Network 标签查看与网站进行 HTTP 协议交流的数据。\n\n这里我们看看登录[B站](http://www.bilibili.tv)的时候究竟发生了什么事情：\n\n首先我们输入账号密码和验证码之后点击登陆，浏览器会发生账号密码等数据给服务器,之后服务器返回数据。我们查看返回报文的 header 可以看到一堆的 Set-Cookie 字段：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/1.jpg %}\n\n客户端会把这些 cookie 记录下来，在下次访问服务器的时候就会把它们传回给服务器，这样就能实现数据的保持：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/2.jpg %}\n\n### _Session_\n\n但 Cookie 的数据都是保存在客户端的，客户端很容易就能查看和修改 cookie，十分不安全。例如 chrome 有一个 EditThisCookie 插件，就能直接查看修改网页的 cookie：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/3.jpg %}\n\n所以就有了存放在服务器端的内存中的 sessio，session可以看作一个存放在服务器的键值对集。\n\n当服务器创建一个 session 对象的时候，就会对应的生成一个sessionId，服务器可以在 session 中写入数据，但它不会将session 的内容告诉客户端，它只会将生成的 sessionId 以 cookie 的方式传给客户端，而客户端在下次访问服务器的时候把 sessionId 又传回给服务器，这样服务器就能找到之前保存的数据了。\n\n在 php 中这个 sessionid 的名字默认叫做 PHPSESSID，当然也能在php.ini中修改。\n\n因为 session 保存在服务器中，所以安全性比 cookie 高的多。\n\n关于 Cookie 和 Session，各位有兴趣的话可以自己去网上搜索一下，或者希望对 HTTP 协议有更深入的理解的话可以去读一下《图解http》。最近就在读这本书，等读完我会写一篇博客，介绍一些 HTTP 协议的重点知识，这里就不再多说了。\n\n## __okHttp3 使用 Cookie__\n\nokHttp3 的 cookie 管理方式对比 okHttp2 有了很大的变化，这里有一篇博客专门介绍[OkHttp3实现Cookies管理及持久化](http://www.codeceo.com/article/okhttp3-cookies-manage.html)。希望各位在读我这篇博客之前先浏览一下。\n\nokHttp3 使用 CookieJar 接口来管理 Cookie：\n\n```java\n\tpublic interface CookieJar {\n  \t/** A cookie jar that never accepts any cookies. */\n  \tCookieJar NO_COOKIES = new CookieJar() {\n    @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {\n    }\n\n    @Override public List<Cookie> loadForRequest(HttpUrl url) {\n      return Collections.emptyList();\n    }\n  \t};\n```\n\n我们只要在创建 OkHttpClient 的时候指定我们自己的 CookieJar 就能让 OkHttpClient 实现 Cookie 的自动管理：\n\n```java\n\tpublic class MainActivity extends AppCompatActivity {\n    \tprivate Map<String, List<Cookie>> mCookieStore;\n        ...\n        private OkHttpClient createHttpClient() {\n            CookieJar cookieJar = new CookieJar() {\n                @Override\n                public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {\n                    mCookieStore.put(url.host(), cookies);\n                }\n\n                @Override\n                public List<Cookie> loadForRequest(HttpUrl url) {\n                    List list = mCookieStore.get(url.host());\n                    return list != null ? list : new ArrayList<Cookie>();\n                }\n            };\n            return new OkHttpClient.Builder()\n                    .cookieJar(cookieJar)\n                    .build();\n        }\n        ...\n\t}\n```\n\n这里有点要注意，我们是拿 host 作 map 的 key 值，[《OkHttp3实现Cookies管理及持久化》](http://www.codeceo.com/article/okhttp3-cookies-manage.html)这篇博文直接用 url 当 key 值，这样的话该 Cookie 就只能在当前页面可用了，而我们是整个网站可用。\n\n## __Retrofit 使用 Cookie__\n\n在 Retrofit 中使用 Cookie 就更加简单了，因为它内部使用 OkHttp3，只要把之前设置了 CookieJar 的 OkHttpClient 设置给它就可以了：\n\n```java\n\tHttpService service = new Retrofit.Builder()\n                .client(mHttpClient) //OkHttpClient 指定了 CookieJar，这样 Retrofit 也能使用 Cookie 了\n                .baseUrl(mBaseUrl)\n                .addConverterFactory(GsonConverterFactory.create())\n                .build()\n                .create(HttpService.class);\n```\n\n## __验证码小 Demo__\n\n现状我们用一个实现了验证码功能的小 Demo 来更加深刻的理解之前所讲的知识。\n\n首先我写了两个页面：\n\n- 生成验证码的页面 ： http://www.islinjw.cn/okhttp_cookie_demo/verifycode.php\n- 检查验证码的页面 ： http://www.islinjw.cn/okhttp_cookie_demo/checkverifycode.php\n\n访问第一个页面能获得一张随机的验证码图片，而第二个页面使用 GET 方法来检测验证码（键值为 verifycode）。\n\n### _获取验证码图片_\n\n首先我们使用 OkHttp3 访问第一个页面，下载一张验证码图片，将它显示在 ImageView 中：\n\n```java\n\tprivate void loadVerifyCode(final ImageView imageView, final HttpUrl url) {\n        final Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    okhttp3.Response response = mHttpClient.newCall(request).execute();\n\n                    //创建bitmap\n                    InputStream is = response.body().byteStream();\n                    final Bitmap bm = BitmapFactory.decodeStream(is);\n\n                    //加载到ImageView中\n                    runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            imageView.setImageBitmap(bm);\n                        }\n                    });\n\n                    //打印cookie信息\n                    List<Cookie> cookies = Cookie.parseAll(request.url(), response.headers());\n                    for (int i = 0; i < cookies.size(); i++) {\n                        Log.d(\"cookie\", \"request headers: \" + cookies.get(i).toString());\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n```\n\n运行程序可以看到验证码被显示出来：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/5.jpg %}\n\n我们还能能看到服务器返回的 Cookie 信息，因为我的网页使用 php 写的，所以它返回了一个 PHPSESSID ，用来标记服务器保存的 Session 对象。服务器的 Session 对象里面就保存了验证码的值。之后我们把用户输入的验证码传会服务器的时候只要把这个 PHPSESSID 一同传过去，服务器就能找到之前生成的验证码的值，并和用户所输入的进行对比了:\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/6.jpg %}\n\n### _发送用户输入的验证码_\n\n这里我们直接使用 Retrofit 将用户输入的验证码传给服务器：\n\n```java\n\tpublic void onClick(View v) {\n        HttpService service = new Retrofit.Builder()\n                .client(mHttpClient)  //OkHttpClient 指定了 CookieJar，这样 Retrofit 也能使用 Cookie 了\n                .baseUrl(mBaseUrl)\n                .addConverterFactory(GsonConverterFactory.create())\n                .build()\n                .create(HttpService.class);\n\n        String verifyCode = mEditText.getText().toString();\n        if (verifyCode == null) {\n            return;\n        }\n\n        Call<VerifyCodeResult> call = service.getResult(verifyCode);\n        call.enqueue(new Callback<VerifyCodeResult>() {\n            @Override\n            public void onResponse(Call<VerifyCodeResult> call, Response<VerifyCodeResult> response) {\n                Log.d(\"cookie\", \"request headers: \" + call.request().headers().toString());\n                Toast.makeText(MainActivity.this, response.body().getResult(), Toast.LENGTH_SHORT).show();\n            }\n\n            @Override\n            public void onFailure(Call<VerifyCodeResult> call, Throwable t) {\n            }\n        });\n```\n\n```java\n    public interface HttpService {\n        @GET(\"okhttp_cookie_demo/checkverifycode.php\")\n        Call<VerifyCodeResult> getResult(@Query(\"verifycode\") String yam);\n    }\n```\n\n```java\n    public class VerifyCodeResult {\n        private String result;\n\n        public String getResult() {\n            return result;\n        }\n\n        public void setResult(String result) {\n            this.result = result;\n        }\n    }\n```\n\n运行程序，输入验证码可以看到结果：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/7.jpg %}\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/8.jpg %}\n\n程序正常运行，但看 log 输出，Request 并没有把 PHPSESSID 传过去。这是怎么回事？没有传 PHPSESSID，服务器又怎么能知道之前生成的验证码是什么？\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/9.jpg %}\n\n在 CookieJar 的 loadForRequest 方法设置断点，可以发现在发送验证码的时候确实有调用，随之运行到 HttpEngine 的源码，发现原来框架创建了个新的 Resquest 副本，将 Cookie 传入这个新的副本中去连接服务器：\n\n```java\n    public void sendRequest() throws RequestException, RouteException, IOException {\n        ...\n        Request request = networkRequest(userRequest);\n\t\t...\n    }\n\t...\n    private Request networkRequest(Request request) throws IOException {\n        Request.Builder result = request.newBuilder();\n\n        if (request.header(\"Host\") == null) {\n          result.header(\"Host\", hostHeader(request.url()));\n        }\n\n        if (request.header(\"Connection\") == null) {\n          result.header(\"Connection\", \"Keep-Alive\");\n        }\n\n        if (request.header(\"Accept-Encoding\") == null) {\n          transparentGzip = true;\n          result.header(\"Accept-Encoding\", \"gzip\");\n        }\n\n\t\t//看这里，其实是有设置 CookieJar 中的 Cookie 的\n        //也就是说 PHPSESSID 有传回去给服务器\n        List<Cookie> cookies = client.cookieJar().loadForRequest(request.url());\n        if (!cookies.isEmpty()) {\n          result.header(\"Cookie\", cookieHeader(cookies));\n        }\n\n        if (request.header(\"User-Agent\") == null) {\n          result.header(\"User-Agent\", Version.userAgent());\n        }\n\n        return result.build();\n      }\n```\n\n原来如此，操作都使用了副本 Request 去执行，怪不得我们直接用下面的代码输出，请求头部不能看到 PHPSESSID 的 Cookie 值：\n\n```java\n\t@Override\n    public void onResponse(Call<VerifyCodeResult> call, Response<VerifyCodeResult> response) {\n        Log.d(\"cookie\", \"request headers: \" + call.request().headers().toString());\n        Toast.makeText(MainActivity.this, response.body().getResult(), Toast.LENGTH_SHORT).show();\n    }\n```\n\n## __Glide 使用 Cookie__\n\nGlide 是Google推荐的图片加载库，用来加载图片十分之方便，最少只需要三行代码就能将网络图片加载到 ImageView 上。\n\n我有在 Glide 的文档上看到它也能使用 OkHttp3，理论上应该也能使用设置 OkHttpClient 的方法使用 Cookie。\n\n但弄了很久还是没有搞定，等以后有时间找到实现方法再把这一节补全。\n\n## __Demo 完整代码__\n\nMainActivity:\n\n```java\n\tpublic class MainActivity extends AppCompatActivity {\n    private static final String mBaseUrl = \"http://www.islinjw.cn\";\n    private static final String mVerifyCideUrl = \"http://www.islinjw.cn/okhttp_cookie_demo/verifycode.php\";\n\n    private OkHttpClient mHttpClient;\n    private EditText mEditText;\n    private ImageView mImageView;\n    private Map<String, List<Cookie>> mCookieStore;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mEditText = (EditText) findViewById(R.id.input);\n        mImageView = (ImageView) findViewById(R.id.yzm);\n        mCookieStore = new HashMap<>();\n        mHttpClient = createHttpClient();\n\n        loadVerifyCode(mImageView, HttpUrl.parse(mVerifyCideUrl));\n    }\n\n    private OkHttpClient createHttpClient() {\n        CookieJar cookieJar = new CookieJar() {\n            @Override\n            public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {\n                mCookieStore.put(url.host(), cookies);\n            }\n\n            @Override\n            public List<Cookie> loadForRequest(HttpUrl url) {\n                List list = mCookieStore.get(url.host());\n                return list != null ? list : new ArrayList<Cookie>();\n            }\n        };\n        return new OkHttpClient.Builder()\n                .cookieJar(cookieJar)\n                .build();\n    }\n\n    private void loadVerifyCode(final ImageView imageView, final HttpUrl url) {\n        final Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    okhttp3.Response response = mHttpClient.newCall(request).execute();\n\n                    //创建bitmap\n                    InputStream is = response.body().byteStream();\n                    final Bitmap bm = BitmapFactory.decodeStream(is);\n\n                    //加载到ImageView中\n                    runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            imageView.setImageBitmap(bm);\n                        }\n                    });\n\n                    //打印cookie信息\n                    List<Cookie> cookies = Cookie.parseAll(request.url(), response.headers());\n                    for (int i = 0; i < cookies.size(); i++) {\n                        Log.d(\"cookie\", \"response headers: \" + cookies.get(i).toString());\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n\n    public void onClick(View v) {\n        HttpService service = new Retrofit.Builder()\n                .client(mHttpClient)  //OkHttpClient 指定了 CookieJar，这样 Retrofit 也能使用 Cookie 了\n                .baseUrl(mBaseUrl)\n                .addConverterFactory(GsonConverterFactory.create())\n                .build()\n                .create(HttpService.class);\n\n        String verifyCode = mEditText.getText().toString();\n        if (verifyCode == null) {\n            return;\n        }\n\n        Call<VerifyCodeResult> call = service.getResult(verifyCode);\n        call.enqueue(new Callback<VerifyCodeResult>() {\n            @Override\n            public void onResponse(Call<VerifyCodeResult> call, Response<VerifyCodeResult> response) {\n                Log.d(\"cookie\", \"request headers: \" + call.request().headers().toString());\n                Toast.makeText(MainActivity.this, response.body().getResult(), Toast.LENGTH_SHORT).show();\n            }\n\n            @Override\n            public void onFailure(Call<VerifyCodeResult> call, Throwable t) {\n            }\n        });\n    }\n}\n```\n\nHttpService:\n\n```java\n\tpublic interface HttpService {\n        @GET(\"okhttp_cookie_demo/checkverifycode.php\")\n        Call<VerifyCodeResult> getResult(@Query(\"verifycode\") String yam);\n    }\n```\n\n```java\n\tpublic class VerifyCodeResult {\n        private String result;\n\n        public String getResult() {\n            return result;\n        }\n\n        public void setResult(String result) {\n            this.result = result;\n        }\n    }\n```\n","slug":"学习HTTP协议-在安卓上的使用Cookie与Session","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2umr0019w3fyrompof00"},{"title":"如何实现安卓消息推送","date":"2017-12-14T15:24:33.000Z","_content":"\n最近突然对安卓消息推送的原理感兴趣,找了不少资料,实现了一个包括服务端和客户端的简单Demo。\n\n在具体实现的时候踩了不少坑,这里做一下笔记,防止以后忘记。\n\n安卓消息推送的实现方案有下面几种:\n\n- MQTT协议实现\n- XMPP协议实现\n- C2DM云端推送功能(google官方提供,系统内置,但是国内用不了......)\n- [中国统一推送](http://www.chinaupa.com/)(工信部牵头成立,但是目前只是开了几次会议,并没有什么实际的接口出来,不过以后应该会是中国境内的首选方案)\n\n我这里选择了MQTT协议去实现。\n\n# MQTT协议\n\nMQTT是一个客户端服务端架构的发布/订阅模式的消息传输协议。它的设计思想是轻巧、开放、简单、规范，因此易于实现。这些特点使得它对很多场景来说都是很好的选择，包括受限的环境如机器与机器的通信（M2M）以及物联网环境（IoT），这些场景要求很小的代码封装或者网络带宽非常昂贵。\n\n本协议运行在TCP/IP，或其它提供了有序、可靠、双向连接的网络连接上。它有以下特点：\n\n使用发布/订阅消息模式，提供了一对多的消息分发和应用之间的解耦。\n\n消息传输不需要知道负载内容。\n\n提供三种等级的服务质量：.\n\n“最多一次”，尽操作环境所能提供的最大努力分发消息。消息可能会丢失。例如，这个等级可用于环境传感器数据，单次的数据丢失没关系，因为不久之后会再次发送。\n“至少一次”，保证消息可以到达，但是可能会重复。\n“仅一次”，保证消息只到达一次。例如，这个等级可用在一个计费系统中，这里如果消息重复或丢失会导致不正确的收费。\n很小的传输消耗和协议数据交换，最大限度减少网络流量\n\n异常连接断开发生时，能通知到相关各方。\n\n上面这一段话是从网友翻译的MQTT中文文档直接复制的。有兴趣的同学可以直接访问[MQTT协议中文版](https://github.com/mcxiaoke/mqtt)查看具体的协议细节。\n\n## MQTT原理\n\nMQTT协议原理的原理简单说来就是客户端与服务端通过心跳包来保持连接。客户接收端向服务端订阅消息,客户发布端向服务端发布消息。服务端再将消息分发给订阅了该消息的客户接收端。\n\n原理图如下:\n\n{% img /如何实现安卓消息推送/1.png %}\n\n# 实现库的选择\n\n因为[MQTT协议中文版](https://github.com/mcxiaoke/mqtt)上面已经有了整个QMTT的协议细节,所以理论上如果你够厉害的话,完全可以自己从零开始实现服务端和客户端。\n\n但是从实际项目中,我还是倾向选择官方提供或者第三方开源的项目直接使用。\n\n其实官方已经给我们提供了一些推荐实现:\n\n[https://github.com/mqtt/mqtt.github.io/wiki/software?id=software](https://github.com/mqtt/mqtt.github.io/wiki/software?id=software)\n\n# MQTT 服务器搭建\n\n我这边选择使用[apache-apollo](http://activemq.apache.org/apollo/)这个开源的MQTT服务器。\n\n网上有不少的博客都有讲它的配置方法的,但是我按着做之后都出现了一些问题。\n\n## 1、安装jdk\n\n首先需要去安装jdk:\n\n```\nsudo apt-get install default-jdk\n```\n\n## 2、下载apache-apollo\n\n然后到[官网](http://www.apache.org/dyn/closer.cgi?path=activemq/activemq-apollo/1.7.1/apache-apollo-1.7.1-windows-distro.zip)下载最新的软件。我这边使用的是腾讯云的ubuntu服务器,所以就下载了linux的版本。\n\n下载完之后解压到/opt目录下(其实任意目录均可,只不过我用linux习惯放这里):\n\n> /opt/apache-apollo-1.7.1\n\n\n## 3、创建项目\n\n然后进入任意目录使用下面命令创建一个项目(官方管它叫broker):\n\n```\n/opt/apache-apollo-1.7.1/bin/apollo create mybroker\n```\n\n它会在当前目录创建一个mybroker目录,里面就是你的项目。\n\n## 4、编辑admin ip配置\n\n可以编辑mybroker/etc/apollo.xml进行一些配置。\n\nadmin后台会默认被绑定到127.0.0.1,这样你是不能通过你电脑的浏览器去访问服务器的admin后台的:\n\n```\n<web_admin bind=\"http://127.0.0.1:61680\"/>\n<web_admin bind=\"https://127.0.0.1:61681\"/>\n```\n\n我们将它改成0.0.0.0:\n\n```\n<web_admin bind=\"http://0.0.0.0:61680\"/>\n<web_admin bind=\"https://0.0.0.0:61681\"/>\n```\n注意这里的61680和61681端口,之后需要访问该端口去登陆admin后台\n\n## 5、启动MQTT服务\n\n你可以进到mybroker/bin/目录中使用下面两种方式中的一种去启动服务:\n\n- 当前进程阻塞启动:\n\n```\n./apollo-broker run\n```\n\n- 启动后台服务:\n\n```\n./apollo-broker-service start\n```\n\n然后你就可以在你的电脑打开浏览器输入网址访问MQTT后台了:\n\n- 如果你的服务是跑在阿里云、腾讯云这样的服务器上:\n\n```\nhttp://服务器ip:61680\n```\n\n- 如果你的服务就是跑在你自己的电脑上:\n\n```\nhttp://0.0.0.0:61680\n```\n\n它的需要输入账号密码才能登陆。默认账号是admin、密码是password\n\n\n{% img /如何实现安卓消息推送/2.png %}\n\n\n{% img /如何实现安卓消息推送/3.png %}\n\n# Python paho-mqtt\n\n我们可以用python写一个客户端去验证搭建的mqtt服务器是否可用。\n\n首先需要下载paho-mqtt:\n\n```\npip install paho-mqtt\n```\n\n## Python paho-mqtt 简单收发端Demo\n\n接收端代码:\n\n```\nimport paho.mqtt.client as mqtt                                                  \n\ndef on_connect(client, userdata, flags, rc):                                     \n    print(\"Connected with result code \"+str(rc))                                 \n    client.subscribe(\"topic/test\")                                               \n\ndef on_message(client, userdata, msg):                                           \n    print(\"on_message \"+msg.topic+\" \"+str(msg.payload))                          \n\nclient = mqtt.Client(client_id=\"\", clean_session=True, userdata=None, protocol=mqtt.MQTTv31, transport=\"tcp\")\nclient.username_pw_set(\"admin\", \"password\")                                      \nclient.on_connect = on_connect                                                   \nclient.on_message = on_message                                                   \n\nclient.connect(\"www.islinjw.cn\", 61613, 60)                                      \nclient.loop_forever()\n```\n\n发送端代码:\n\n```\nimport paho.mqtt.client as mqtt                                                  \n\ndef on_connect(client, userdata, flags, rc):                                     \n    print(\"Connected with result code \"+str(rc))                                 \n\nclient = mqtt.Client(client_id=\"\", clean_session=True, userdata=None, protocol=mqtt.MQTTv31, transport=\"tcp\")\nclient.username_pw_set(\"admin\", \"password\")                                      \nclient.on_connect = on_connect                                                         \n\nclient.connect(\"www.islinjw.cn\", 61613, 60)                                                                     \nclient.publish(\"topic/test\", \"hello world\")\n```\n\n我们先运行接收端,再运行发送端,就可以在接收端看到\"hello world\"的打印\n\n## 常见错误\n\n这里需要注意的是一定要配置协议版本为MQTTv31,网上的demo代码都没有配置,没有的话python这就会报错:\n\n> [Errno 104] Connection reset by peer\n\n服务器则会报空指针,我们可以在mybroker/log/stacktrace.log中看到:\n\n```\njava.lang.NullPointerException\n        at org.apache.activemq.apollo.mqtt.MqttProtocolHandler.on_mqtt_connect(MqttProtocolHandler.java:443)\n        at org.apache.activemq.apollo.mqtt.MqttProtocolHandler$9.call(MqttProtocolHandler.java:410)\n        at org.apache.activemq.apollo.util.UnitFn1.apply(Scala2JavaHelper.scala:41)\n        at org.apache.activemq.apollo.mqtt.MqttProtocolHandler.on_transport_command(MqttProtocolHandler.java:377)\n        at org.apache.activemq.apollo.broker.BrokerConnection.on_transport_command(Connection.scala:144)\n        at org.apache.activemq.apollo.broker.Connection$$anon$1.onTransportCommand(Connection.scala:71)\n        at org.fusesource.hawtdispatch.transport.TcpTransport.drainInbound(TcpTransport.java:709)\n        at org.fusesource.hawtdispatch.transport.TcpTransport$9.run(TcpTransport.java:770)\n        at org.fusesource.hawtdispatch.internal.SerialDispatchQueue.run(SerialDispatchQueue.java:100)\n        at org.fusesource.hawtdispatch.internal.pool.SimpleThread.run(SimpleThread.java:77)\n```\n\n而如果没有设置账号密码的话就收到result code 4:\n\n> Connected with result code 4\n\n我们可以从[官方文档](https://pypi.python.org/pypi/paho-mqtt/#single)看到result code 4代表用户名或者密码错误:\n\n> 0: Connection successful  \n> 1: Connection refused - incorrect protocol version  \n> 2: Connection refused - invalid client identifier  \n> 3: Connection refused - server unavailable  \n> 4: Connection refused - bad username or password  \n> 5: Connection refused - not authorised 6-255: Currently unused.\n\n# 权限配置\n\n我们设想一下,如果没有账户系统,那么只要知道服务器的ip和端口,就能随便发送消息了,这样谁都能给你的应用推送消息,十分危险。\n\n所以mqtt是需要用账户密码去建权的,有些账户只能发送,有些账户只能接收,而有些账户全部都能做。\n\n## 创建用户\n\n我们可以编辑mybroker/etc/users.properties添加user1和user2:\n\n```\nadmin=password\nuser1=123456\nuser2=654321\n```\n\n等号的左边是账户,右边是密码。所以我们也能在这里改admin的密码\n\n## 创建用户组\n\n创建完用用户,我们还需要编辑mybroker/etc/groups.properties给用户指定用户组:\n\n```\nadmins=admin\ngroupsend=user1\ngrouprecv=user2\n\n# 还可以用下面的方式将多个用户指定到一个用户组\n# groupdemo = user1|user2\n```\n\n## 设置用户组权限\n\n最后我们就能在mybroker/etc/apollo.xml设置用户组权限了:\n\n```\n<access_rule allow=\"admins\" action=\"*\"/>\n<access_rule allow=\"*\" action=\"connect\" kind=\"connector\"/>\n<access_rule allow=\"groupsend\" action=\"connect create send\"/>\n<access_rule allow=\"grouprecv\" action=\"connect receive\"/>\n```\n\n可以给一个用户组设置多个权限,多个权限之间用空格分割。从[官方文档](http://activemq.apache.org/apollo/versions/1.7.1/website/documentation/user-manual.html#Resource_Actions)可以看到权限有下面的类别:\n\n- admin : use of the administrative web interface\n- monitor : read only use of the administrative web interface\n- config : use of the administrative web interface to  access and change the broker configuration.\n- connect : allows connections to the connector or virtual host\n- create : allows creation\n- destroy : allows destruction\n- send : allows the user to send to the destination\n- receive : allows the user to send to do non-destructive reads from the destination\n- consume : allows the user to do destructive reads against a destination\n-  \\* : All actions\n\n配置好之后我们的user1就只能发送消息,user2就只能接收消息了。\n\n# 安卓端实现\n\n官方推荐的qatja-android我看了一下，它的实现太挫了,所以在github上搜索了下,发现了个不错的库[mqtt-client](https://github.com/fusesource/mqtt-client)。\n\n添加依赖：\n\n> compile 'org.fusesource.mqtt-client:mqtt-client:1.14'\n\n因为代码比较简单,所以我就直接贴上来了:\n\n```\npublic class MainActivity extends AppCompatActivity {\n    public static final String TAG = \"MainActivity\";\n    public static final String TOPIC = \"topic/test\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        try {\n            testMqtt();\n        } catch (URISyntaxException e) {\n            Log.e(TAG, \"testMqtt failed\", e);\n        }\n    }\n\n    private void testMqtt() throws URISyntaxException {\n        MQTT mqtt = new MQTT();\n        mqtt.setHost(\"www.islinjw.cn\", 61613);\n        mqtt.setVersion(\"3.1\");\n        mqtt.setUserName(\"admin\");\n        mqtt.setPassword(\"password\");\n\n        final CallbackConnection connection = mqtt.callbackConnection();\n\n        //设置监听\n        connection.listener(new ExtendedListener() {\n            @Override\n            public void onPublish(UTF8Buffer topic, Buffer body, Callback<Callback<Void>> ack) {\n                Log.d(TAG, \"onPublish \" + topic.toString() + \" \" + body.toString());\n\n                NotificationManager notifyManager\n                        = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n                NotificationCompat.Builder builder = new NotificationCompat\n                        .Builder(MainActivity.this)\n                        .setSmallIcon(R.mipmap.ic_launcher)\n                        .setContentTitle(topic.toString())\n                        .setContentText(body.ascii().toString());\n                notifyManager.notify(1, builder.build());\n            }\n\n            @Override\n            public void onConnected() {\n                Log.d(TAG, \"onConnected\");\n            }\n\n            @Override\n            public void onDisconnected() {\n                Log.d(TAG, \"onDisconnected\");\n            }\n\n            @Override\n            public void onPublish(UTF8Buffer topic, Buffer body, Runnable ack) {\n                Log.d(TAG, \"onPublish \" + topic.toString() + \" \" + body);\n                ack.run();\n            }\n\n            @Override\n            public void onFailure(Throwable value) {\n                Log.d(TAG, \"onFailure\");\n            }\n        });\n\n        //连接服务器\n        connection.connect(new Callback<Void>() {\n            public void onFailure(Throwable value) {\n                Log.d(TAG, \"connect failure\");\n            }\n\n            public void onSuccess(Void v) {\n                //订阅消息\n                Topic[] topics = {new Topic(TOPIC, QoS.AT_LEAST_ONCE)};\n                connection.subscribe(topics, new Callback<byte[]>() {\n                    public void onSuccess(byte[] qoses) {\n                        Log.d(TAG, \"subscribe success\");\n                    }\n\n                    public void onFailure(Throwable value) {\n                        Log.e(TAG, \"subscribe failure\", value);\n                        connection.disconnect(null); //断开连接\n                    }\n                });\n\n                //发布一个消息\n                byte[] payload = \"hello world\".getBytes();\n                connection.publish(TOPIC, payload, QoS.AT_LEAST_ONCE, false, new Callback<Void>() {\n                    public void onSuccess(Void v) {\n                        Log.d(TAG, \"publish success\");\n                    }\n\n                    public void onFailure(Throwable value) {\n                        Log.e(TAG, \"publish failure\", value);\n                        connection.disconnect(null); //断开连接\n                    }\n                });\n\n//                //断开连接\n//                connection.disconnect(new Callback<Void>() {\n//                    public void onSuccess(Void v) {\n//                        Log.d(TAG, \"disconnect success\");\n//                    }\n//\n//                    public void onFailure(Throwable value) {\n//                        Log.d(TAG, \"disconnect failure\");\n//                        // disconnects是不会失败的,也就是这里永远不会被调到\n//                    }\n//                });\n            }\n        });\n    }\n}\n```\n\n然后我们就可以用发送端的py脚本将消息推送给安卓客户端了。\n\n{% img /如何实现安卓消息推送/4.png %}\n\n# 主题名和主题通配符\n\n发布的消息都有一个主题名,例如我们之前作为例子的\"topic/test\"。客户端向服务端订阅感兴趣的主题。当有某主题的消息被发布的时候,服务端就会将消息分发给订阅了该主题的客户端。\n\n主题名可以用分割符\"/\"如果存在的话就会将主题分割为多个主题层级。\n\n有了主题层级的概念之后我们就可以用主题通配符去过滤不同的主题。\n\n我这里只做简单介绍,详细的信息可以参考[文档](https://github.com/mcxiaoke/mqtt/blob/master/mqtt/04-OperationalBehavior.md)\n\n\n## 多层通配符\n\n数字标志（\"#\"）是用于匹配主题中任意层级的通配符。多层通配符表示它的父级和任意数量的子层级。多层通配符必须位于它自己的层级或者跟在主题层级分隔符后面。不管哪种情况，它都必须是主题过滤器的最后一个字符。\n\n例如，如果客户端订阅主题 \"sport/tennis/player1/#\"，它会收到使用下列主题名发布的消息：\n\n- \"sport/tennis/player1\"\n- \"sport/tennis/player1/ranking\"\n- \"sport/tennis/player1/score/wimbledon\"\n- \"sport/#\"也匹配单独的 \"sport\" ，因为 # 包括它的父级。\n- \"#\"也是有效的，会收到所有的应用消息。\n\n\n多层通配符用法举例:\n\n- \"sport/tennis/#\"也是有效的。\n- \"sport/tennis#\"是无效的。\n- \"sport/tennis/#/ranking\"是无效的。\n\n## 单层通配符\n\n加号 (\"+\") 是只能用于单个主题层级匹配的通配符。在主题过滤器的任意层级都可以使用单层通配符，包括第一个和最后一个层级。然而它必须占据过滤器的整个层级。可以在主题过滤器中的多个层级中使用它，也可以和多层通配符一起使用。\n\n例如， \"sport/tennis/+\" 匹配 \"sport/tennis/player1\" 和 \"sport/tennis/player2\",但是不匹配 \"sport/tennis/player1/ranking\" 。同时，由于单层通配符只能匹配一个层级， \"sport/+\" 不匹配 \"sport\" 但是却匹配 \"sport/\"。\n\n单层通配符的一些使用情况:\n\n- \"+\" 是有效的。\n- \"+/tennis/#\" 是有效的。\n- \"sport+\" 是无效的。\n- \"sport/+/player1\" 也是有效的。\n- \"/finance\" 匹配 \"+/+\" 和 \"/+\" ，但是不匹配 \"+\"。\n\n## 开始通配符\n\n美元符号(\"$\") 用于匹配起始主题,如\"$SYS/\" 被广泛用作包含服务器特定信息或控制接口的主题的前缀。\n\n开始通配符的一些用法:\n\n- 订阅 \"#\" 的客户端不会收到任何发布到以 \"$\" 开头主题的消息。\n- 订阅 \"+/monitor/Clients\" 的客户端不会收到任何发布到 \"$SYS/monitor/Clients\" 的消息。\n- 订阅 \"$SYS/#\" 的客户端会收到发布到以 “$SYS/” 开头主题的消息。\n- 订阅 \"$SYS/monitor/+\" 的客户端会收到发布到 \"$SYS/monitor/Clients\" 主题的消息。\n- 如果客户端想同时接受以 \"$SYS/\" 开头主题的消息和不以 \"$\" 开头主题的消息，它需要同时订阅 \"#\" 和 \"$SYS/#\"。\n","source":"_posts/如何实现安卓消息推送.md","raw":"title: 如何实现安卓消息推送\ndate: 2017-12-14 23:24:33\ntags:\n\t- 技术相关\n\t- Android\n---\n\n最近突然对安卓消息推送的原理感兴趣,找了不少资料,实现了一个包括服务端和客户端的简单Demo。\n\n在具体实现的时候踩了不少坑,这里做一下笔记,防止以后忘记。\n\n安卓消息推送的实现方案有下面几种:\n\n- MQTT协议实现\n- XMPP协议实现\n- C2DM云端推送功能(google官方提供,系统内置,但是国内用不了......)\n- [中国统一推送](http://www.chinaupa.com/)(工信部牵头成立,但是目前只是开了几次会议,并没有什么实际的接口出来,不过以后应该会是中国境内的首选方案)\n\n我这里选择了MQTT协议去实现。\n\n# MQTT协议\n\nMQTT是一个客户端服务端架构的发布/订阅模式的消息传输协议。它的设计思想是轻巧、开放、简单、规范，因此易于实现。这些特点使得它对很多场景来说都是很好的选择，包括受限的环境如机器与机器的通信（M2M）以及物联网环境（IoT），这些场景要求很小的代码封装或者网络带宽非常昂贵。\n\n本协议运行在TCP/IP，或其它提供了有序、可靠、双向连接的网络连接上。它有以下特点：\n\n使用发布/订阅消息模式，提供了一对多的消息分发和应用之间的解耦。\n\n消息传输不需要知道负载内容。\n\n提供三种等级的服务质量：.\n\n“最多一次”，尽操作环境所能提供的最大努力分发消息。消息可能会丢失。例如，这个等级可用于环境传感器数据，单次的数据丢失没关系，因为不久之后会再次发送。\n“至少一次”，保证消息可以到达，但是可能会重复。\n“仅一次”，保证消息只到达一次。例如，这个等级可用在一个计费系统中，这里如果消息重复或丢失会导致不正确的收费。\n很小的传输消耗和协议数据交换，最大限度减少网络流量\n\n异常连接断开发生时，能通知到相关各方。\n\n上面这一段话是从网友翻译的MQTT中文文档直接复制的。有兴趣的同学可以直接访问[MQTT协议中文版](https://github.com/mcxiaoke/mqtt)查看具体的协议细节。\n\n## MQTT原理\n\nMQTT协议原理的原理简单说来就是客户端与服务端通过心跳包来保持连接。客户接收端向服务端订阅消息,客户发布端向服务端发布消息。服务端再将消息分发给订阅了该消息的客户接收端。\n\n原理图如下:\n\n{% img /如何实现安卓消息推送/1.png %}\n\n# 实现库的选择\n\n因为[MQTT协议中文版](https://github.com/mcxiaoke/mqtt)上面已经有了整个QMTT的协议细节,所以理论上如果你够厉害的话,完全可以自己从零开始实现服务端和客户端。\n\n但是从实际项目中,我还是倾向选择官方提供或者第三方开源的项目直接使用。\n\n其实官方已经给我们提供了一些推荐实现:\n\n[https://github.com/mqtt/mqtt.github.io/wiki/software?id=software](https://github.com/mqtt/mqtt.github.io/wiki/software?id=software)\n\n# MQTT 服务器搭建\n\n我这边选择使用[apache-apollo](http://activemq.apache.org/apollo/)这个开源的MQTT服务器。\n\n网上有不少的博客都有讲它的配置方法的,但是我按着做之后都出现了一些问题。\n\n## 1、安装jdk\n\n首先需要去安装jdk:\n\n```\nsudo apt-get install default-jdk\n```\n\n## 2、下载apache-apollo\n\n然后到[官网](http://www.apache.org/dyn/closer.cgi?path=activemq/activemq-apollo/1.7.1/apache-apollo-1.7.1-windows-distro.zip)下载最新的软件。我这边使用的是腾讯云的ubuntu服务器,所以就下载了linux的版本。\n\n下载完之后解压到/opt目录下(其实任意目录均可,只不过我用linux习惯放这里):\n\n> /opt/apache-apollo-1.7.1\n\n\n## 3、创建项目\n\n然后进入任意目录使用下面命令创建一个项目(官方管它叫broker):\n\n```\n/opt/apache-apollo-1.7.1/bin/apollo create mybroker\n```\n\n它会在当前目录创建一个mybroker目录,里面就是你的项目。\n\n## 4、编辑admin ip配置\n\n可以编辑mybroker/etc/apollo.xml进行一些配置。\n\nadmin后台会默认被绑定到127.0.0.1,这样你是不能通过你电脑的浏览器去访问服务器的admin后台的:\n\n```\n<web_admin bind=\"http://127.0.0.1:61680\"/>\n<web_admin bind=\"https://127.0.0.1:61681\"/>\n```\n\n我们将它改成0.0.0.0:\n\n```\n<web_admin bind=\"http://0.0.0.0:61680\"/>\n<web_admin bind=\"https://0.0.0.0:61681\"/>\n```\n注意这里的61680和61681端口,之后需要访问该端口去登陆admin后台\n\n## 5、启动MQTT服务\n\n你可以进到mybroker/bin/目录中使用下面两种方式中的一种去启动服务:\n\n- 当前进程阻塞启动:\n\n```\n./apollo-broker run\n```\n\n- 启动后台服务:\n\n```\n./apollo-broker-service start\n```\n\n然后你就可以在你的电脑打开浏览器输入网址访问MQTT后台了:\n\n- 如果你的服务是跑在阿里云、腾讯云这样的服务器上:\n\n```\nhttp://服务器ip:61680\n```\n\n- 如果你的服务就是跑在你自己的电脑上:\n\n```\nhttp://0.0.0.0:61680\n```\n\n它的需要输入账号密码才能登陆。默认账号是admin、密码是password\n\n\n{% img /如何实现安卓消息推送/2.png %}\n\n\n{% img /如何实现安卓消息推送/3.png %}\n\n# Python paho-mqtt\n\n我们可以用python写一个客户端去验证搭建的mqtt服务器是否可用。\n\n首先需要下载paho-mqtt:\n\n```\npip install paho-mqtt\n```\n\n## Python paho-mqtt 简单收发端Demo\n\n接收端代码:\n\n```\nimport paho.mqtt.client as mqtt                                                  \n\ndef on_connect(client, userdata, flags, rc):                                     \n    print(\"Connected with result code \"+str(rc))                                 \n    client.subscribe(\"topic/test\")                                               \n\ndef on_message(client, userdata, msg):                                           \n    print(\"on_message \"+msg.topic+\" \"+str(msg.payload))                          \n\nclient = mqtt.Client(client_id=\"\", clean_session=True, userdata=None, protocol=mqtt.MQTTv31, transport=\"tcp\")\nclient.username_pw_set(\"admin\", \"password\")                                      \nclient.on_connect = on_connect                                                   \nclient.on_message = on_message                                                   \n\nclient.connect(\"www.islinjw.cn\", 61613, 60)                                      \nclient.loop_forever()\n```\n\n发送端代码:\n\n```\nimport paho.mqtt.client as mqtt                                                  \n\ndef on_connect(client, userdata, flags, rc):                                     \n    print(\"Connected with result code \"+str(rc))                                 \n\nclient = mqtt.Client(client_id=\"\", clean_session=True, userdata=None, protocol=mqtt.MQTTv31, transport=\"tcp\")\nclient.username_pw_set(\"admin\", \"password\")                                      \nclient.on_connect = on_connect                                                         \n\nclient.connect(\"www.islinjw.cn\", 61613, 60)                                                                     \nclient.publish(\"topic/test\", \"hello world\")\n```\n\n我们先运行接收端,再运行发送端,就可以在接收端看到\"hello world\"的打印\n\n## 常见错误\n\n这里需要注意的是一定要配置协议版本为MQTTv31,网上的demo代码都没有配置,没有的话python这就会报错:\n\n> [Errno 104] Connection reset by peer\n\n服务器则会报空指针,我们可以在mybroker/log/stacktrace.log中看到:\n\n```\njava.lang.NullPointerException\n        at org.apache.activemq.apollo.mqtt.MqttProtocolHandler.on_mqtt_connect(MqttProtocolHandler.java:443)\n        at org.apache.activemq.apollo.mqtt.MqttProtocolHandler$9.call(MqttProtocolHandler.java:410)\n        at org.apache.activemq.apollo.util.UnitFn1.apply(Scala2JavaHelper.scala:41)\n        at org.apache.activemq.apollo.mqtt.MqttProtocolHandler.on_transport_command(MqttProtocolHandler.java:377)\n        at org.apache.activemq.apollo.broker.BrokerConnection.on_transport_command(Connection.scala:144)\n        at org.apache.activemq.apollo.broker.Connection$$anon$1.onTransportCommand(Connection.scala:71)\n        at org.fusesource.hawtdispatch.transport.TcpTransport.drainInbound(TcpTransport.java:709)\n        at org.fusesource.hawtdispatch.transport.TcpTransport$9.run(TcpTransport.java:770)\n        at org.fusesource.hawtdispatch.internal.SerialDispatchQueue.run(SerialDispatchQueue.java:100)\n        at org.fusesource.hawtdispatch.internal.pool.SimpleThread.run(SimpleThread.java:77)\n```\n\n而如果没有设置账号密码的话就收到result code 4:\n\n> Connected with result code 4\n\n我们可以从[官方文档](https://pypi.python.org/pypi/paho-mqtt/#single)看到result code 4代表用户名或者密码错误:\n\n> 0: Connection successful  \n> 1: Connection refused - incorrect protocol version  \n> 2: Connection refused - invalid client identifier  \n> 3: Connection refused - server unavailable  \n> 4: Connection refused - bad username or password  \n> 5: Connection refused - not authorised 6-255: Currently unused.\n\n# 权限配置\n\n我们设想一下,如果没有账户系统,那么只要知道服务器的ip和端口,就能随便发送消息了,这样谁都能给你的应用推送消息,十分危险。\n\n所以mqtt是需要用账户密码去建权的,有些账户只能发送,有些账户只能接收,而有些账户全部都能做。\n\n## 创建用户\n\n我们可以编辑mybroker/etc/users.properties添加user1和user2:\n\n```\nadmin=password\nuser1=123456\nuser2=654321\n```\n\n等号的左边是账户,右边是密码。所以我们也能在这里改admin的密码\n\n## 创建用户组\n\n创建完用用户,我们还需要编辑mybroker/etc/groups.properties给用户指定用户组:\n\n```\nadmins=admin\ngroupsend=user1\ngrouprecv=user2\n\n# 还可以用下面的方式将多个用户指定到一个用户组\n# groupdemo = user1|user2\n```\n\n## 设置用户组权限\n\n最后我们就能在mybroker/etc/apollo.xml设置用户组权限了:\n\n```\n<access_rule allow=\"admins\" action=\"*\"/>\n<access_rule allow=\"*\" action=\"connect\" kind=\"connector\"/>\n<access_rule allow=\"groupsend\" action=\"connect create send\"/>\n<access_rule allow=\"grouprecv\" action=\"connect receive\"/>\n```\n\n可以给一个用户组设置多个权限,多个权限之间用空格分割。从[官方文档](http://activemq.apache.org/apollo/versions/1.7.1/website/documentation/user-manual.html#Resource_Actions)可以看到权限有下面的类别:\n\n- admin : use of the administrative web interface\n- monitor : read only use of the administrative web interface\n- config : use of the administrative web interface to  access and change the broker configuration.\n- connect : allows connections to the connector or virtual host\n- create : allows creation\n- destroy : allows destruction\n- send : allows the user to send to the destination\n- receive : allows the user to send to do non-destructive reads from the destination\n- consume : allows the user to do destructive reads against a destination\n-  \\* : All actions\n\n配置好之后我们的user1就只能发送消息,user2就只能接收消息了。\n\n# 安卓端实现\n\n官方推荐的qatja-android我看了一下，它的实现太挫了,所以在github上搜索了下,发现了个不错的库[mqtt-client](https://github.com/fusesource/mqtt-client)。\n\n添加依赖：\n\n> compile 'org.fusesource.mqtt-client:mqtt-client:1.14'\n\n因为代码比较简单,所以我就直接贴上来了:\n\n```\npublic class MainActivity extends AppCompatActivity {\n    public static final String TAG = \"MainActivity\";\n    public static final String TOPIC = \"topic/test\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        try {\n            testMqtt();\n        } catch (URISyntaxException e) {\n            Log.e(TAG, \"testMqtt failed\", e);\n        }\n    }\n\n    private void testMqtt() throws URISyntaxException {\n        MQTT mqtt = new MQTT();\n        mqtt.setHost(\"www.islinjw.cn\", 61613);\n        mqtt.setVersion(\"3.1\");\n        mqtt.setUserName(\"admin\");\n        mqtt.setPassword(\"password\");\n\n        final CallbackConnection connection = mqtt.callbackConnection();\n\n        //设置监听\n        connection.listener(new ExtendedListener() {\n            @Override\n            public void onPublish(UTF8Buffer topic, Buffer body, Callback<Callback<Void>> ack) {\n                Log.d(TAG, \"onPublish \" + topic.toString() + \" \" + body.toString());\n\n                NotificationManager notifyManager\n                        = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n                NotificationCompat.Builder builder = new NotificationCompat\n                        .Builder(MainActivity.this)\n                        .setSmallIcon(R.mipmap.ic_launcher)\n                        .setContentTitle(topic.toString())\n                        .setContentText(body.ascii().toString());\n                notifyManager.notify(1, builder.build());\n            }\n\n            @Override\n            public void onConnected() {\n                Log.d(TAG, \"onConnected\");\n            }\n\n            @Override\n            public void onDisconnected() {\n                Log.d(TAG, \"onDisconnected\");\n            }\n\n            @Override\n            public void onPublish(UTF8Buffer topic, Buffer body, Runnable ack) {\n                Log.d(TAG, \"onPublish \" + topic.toString() + \" \" + body);\n                ack.run();\n            }\n\n            @Override\n            public void onFailure(Throwable value) {\n                Log.d(TAG, \"onFailure\");\n            }\n        });\n\n        //连接服务器\n        connection.connect(new Callback<Void>() {\n            public void onFailure(Throwable value) {\n                Log.d(TAG, \"connect failure\");\n            }\n\n            public void onSuccess(Void v) {\n                //订阅消息\n                Topic[] topics = {new Topic(TOPIC, QoS.AT_LEAST_ONCE)};\n                connection.subscribe(topics, new Callback<byte[]>() {\n                    public void onSuccess(byte[] qoses) {\n                        Log.d(TAG, \"subscribe success\");\n                    }\n\n                    public void onFailure(Throwable value) {\n                        Log.e(TAG, \"subscribe failure\", value);\n                        connection.disconnect(null); //断开连接\n                    }\n                });\n\n                //发布一个消息\n                byte[] payload = \"hello world\".getBytes();\n                connection.publish(TOPIC, payload, QoS.AT_LEAST_ONCE, false, new Callback<Void>() {\n                    public void onSuccess(Void v) {\n                        Log.d(TAG, \"publish success\");\n                    }\n\n                    public void onFailure(Throwable value) {\n                        Log.e(TAG, \"publish failure\", value);\n                        connection.disconnect(null); //断开连接\n                    }\n                });\n\n//                //断开连接\n//                connection.disconnect(new Callback<Void>() {\n//                    public void onSuccess(Void v) {\n//                        Log.d(TAG, \"disconnect success\");\n//                    }\n//\n//                    public void onFailure(Throwable value) {\n//                        Log.d(TAG, \"disconnect failure\");\n//                        // disconnects是不会失败的,也就是这里永远不会被调到\n//                    }\n//                });\n            }\n        });\n    }\n}\n```\n\n然后我们就可以用发送端的py脚本将消息推送给安卓客户端了。\n\n{% img /如何实现安卓消息推送/4.png %}\n\n# 主题名和主题通配符\n\n发布的消息都有一个主题名,例如我们之前作为例子的\"topic/test\"。客户端向服务端订阅感兴趣的主题。当有某主题的消息被发布的时候,服务端就会将消息分发给订阅了该主题的客户端。\n\n主题名可以用分割符\"/\"如果存在的话就会将主题分割为多个主题层级。\n\n有了主题层级的概念之后我们就可以用主题通配符去过滤不同的主题。\n\n我这里只做简单介绍,详细的信息可以参考[文档](https://github.com/mcxiaoke/mqtt/blob/master/mqtt/04-OperationalBehavior.md)\n\n\n## 多层通配符\n\n数字标志（\"#\"）是用于匹配主题中任意层级的通配符。多层通配符表示它的父级和任意数量的子层级。多层通配符必须位于它自己的层级或者跟在主题层级分隔符后面。不管哪种情况，它都必须是主题过滤器的最后一个字符。\n\n例如，如果客户端订阅主题 \"sport/tennis/player1/#\"，它会收到使用下列主题名发布的消息：\n\n- \"sport/tennis/player1\"\n- \"sport/tennis/player1/ranking\"\n- \"sport/tennis/player1/score/wimbledon\"\n- \"sport/#\"也匹配单独的 \"sport\" ，因为 # 包括它的父级。\n- \"#\"也是有效的，会收到所有的应用消息。\n\n\n多层通配符用法举例:\n\n- \"sport/tennis/#\"也是有效的。\n- \"sport/tennis#\"是无效的。\n- \"sport/tennis/#/ranking\"是无效的。\n\n## 单层通配符\n\n加号 (\"+\") 是只能用于单个主题层级匹配的通配符。在主题过滤器的任意层级都可以使用单层通配符，包括第一个和最后一个层级。然而它必须占据过滤器的整个层级。可以在主题过滤器中的多个层级中使用它，也可以和多层通配符一起使用。\n\n例如， \"sport/tennis/+\" 匹配 \"sport/tennis/player1\" 和 \"sport/tennis/player2\",但是不匹配 \"sport/tennis/player1/ranking\" 。同时，由于单层通配符只能匹配一个层级， \"sport/+\" 不匹配 \"sport\" 但是却匹配 \"sport/\"。\n\n单层通配符的一些使用情况:\n\n- \"+\" 是有效的。\n- \"+/tennis/#\" 是有效的。\n- \"sport+\" 是无效的。\n- \"sport/+/player1\" 也是有效的。\n- \"/finance\" 匹配 \"+/+\" 和 \"/+\" ，但是不匹配 \"+\"。\n\n## 开始通配符\n\n美元符号(\"$\") 用于匹配起始主题,如\"$SYS/\" 被广泛用作包含服务器特定信息或控制接口的主题的前缀。\n\n开始通配符的一些用法:\n\n- 订阅 \"#\" 的客户端不会收到任何发布到以 \"$\" 开头主题的消息。\n- 订阅 \"+/monitor/Clients\" 的客户端不会收到任何发布到 \"$SYS/monitor/Clients\" 的消息。\n- 订阅 \"$SYS/#\" 的客户端会收到发布到以 “$SYS/” 开头主题的消息。\n- 订阅 \"$SYS/monitor/+\" 的客户端会收到发布到 \"$SYS/monitor/Clients\" 主题的消息。\n- 如果客户端想同时接受以 \"$SYS/\" 开头主题的消息和不以 \"$\" 开头主题的消息，它需要同时订阅 \"#\" 和 \"$SYS/#\"。\n","slug":"如何实现安卓消息推送","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2ums001cw3fynglhhp7s"},{"title":"在android上使用grpc","date":"2017-03-03T01:49:37.000Z","_content":"\n最近的一个项目使用到了grpc实现跨平台的远程调用，在安卓端使用的时候遇到了一些坑，这里记录一下。\n\n首先根据grpc android的[官方Demo](https://github.com/grpc/grpc-java/tree/v1.0.0/examples/android)配置grpc依赖，测试它的hello world工程。\n\n# 编译谷歌官方的helloworld工程\n\n### 添加rotobuf-gradle-plugin插件\n首先添加rotobuf-gradle-plugin插件，他是用来从proto文件自动生成java代码的:\n\n```\n//Project的build.gradle中添加rotobuf-gradle-plugin插件\nbuildscript {\n    ...\n    dependencies {\n        ...\n        classpath \"com.google.protobuf:protobuf-gradle-plugin:0.8.0\"\n        ...\n    }\n    ...\n}\n```\n\n```\n//App的build.gradle中添加下面配置\napply plugin: 'com.google.protobuf'\n\nprotobuf {\n    protoc {\n        artifact = 'com.google.protobuf:protoc:3.0.0'\n    }\n    plugins {\n        javalite {\n            artifact = \"com.google.protobuf:protoc-gen-javalite:3.0.0\"\n        }\n        grpc {\n            artifact = 'io.grpc:protoc-gen-grpc-java:1.0.0' // CURRENT_GRPC_VERSION\n        }\n    }\n    generateProtoTasks {\n        all().each { task ->\n            task.plugins {\n                javalite {}\n                grpc {\n                    // Options added to --grpc_out\n                    option 'lite'\n                }\n            }\n        }\n    }\n}\n```\n\n### 添加proto文件并自动生成java代码\n\n在src/main/目录下创建一个proto目录，并将官方的[helloworld.proto](https://github.com/grpc/grpc-java/blob/v1.0.0/examples/android/helloworld/app/src/main/proto/helloworld.proto)放到proto目录下\n\n之后只需要rebuild一下就能看到build/generated/source/proto/目录下根据helloworld.proto生成了几个Java类\n\n\n{% img /在android上使用grpc/proto_gen.jpeg %}\n\n### 添加安卓端grpc的依赖\n\n```\n//App的build.gradle中添加下面配置\n dependencies {\n    ...\n    compile 'io.grpc:grpc-okhttp:1.1.2'\n    compile 'io.grpc:grpc-protobuf-lite:1.1.2'\n    compile 'io.grpc:grpc-stub:1.1.2'\n    compile 'javax.annotation:javax.annotation-api:1.2'\n    ...\n}\n```\n\n```\nconfigurations.all {\n        resolutionStrategy.force 'com.google.code.findbugs:jsr305:3.0.1'\n    }\n```\n\n我这个时候报了这个错误\n\n> Warning:Conflict with dependency 'com.google.code.findbugs:jsr305'. Resolved versions for app (3.0.0) and test app (2.0.1) differ. See http://g.co/androidstudio/app-test-app-conflict for details.\n\n这是因为com.google.code.findbugs:jsr305的版本不一致导致的\n\n可以在App的build.gradle的android标签中配置一下解决\n\n```\nandroid {\n    ...\n    configurations.all {\n        resolutionStrategy.force 'com.google.code.findbugs:jsr305:3.0.1'\n    }\n    ...\n}\n```\n\n### 编写demo代码\n\n```\npublic class MainActivity extends AppCompatActivity {\n    private static final String TAG = \"GrpcDemo\";\n\n    private static final int PROT = 55055;\n    private static final String NAME = \"linjw\";\n    private static final String HOST = \"localhost\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        startServer(PROT);\n        startClient(HOST, PROT, NAME);\n    }\n\n    private void startServer(int port){\n        try {\n            Server server = ServerBuilder.forPort(port)\n                    .addService(new GreeterImpl())\n                    .build()\n                    .start();\n        } catch (IOException e) {\n            e.printStackTrace();\n            Log.d(TAG, e.getMessage());\n        }\n    }\n\n    private void startClient(String host, int port, String name){\n        new GrpcTask(host, port, name).execute();\n    }\n\n    private class GreeterImpl extends GreeterGrpc.GreeterImplBase {\n        public void sayHello(HelloRequest request, StreamObserver<HelloReply> responseObserver) {\n            responseObserver.onNext(sayHello(request));\n            responseObserver.onCompleted();\n        }\n\n        private HelloReply sayHello(HelloRequest request) {\n            return HelloReply.newBuilder()\n                    .setMessage(\"hello \"+ request.getName())\n                    .build();\n        }\n    }\n\n    private class GrpcTask extends AsyncTask<Void, Void, String> {\n        private String mHost;\n        private String mName;\n        private int mPort;\n        private ManagedChannel mChannel;\n\n        public GrpcTask(String host, int port, String name) {\n            this.mHost = host;\n            this.mName = name;\n            this.mPort = port;\n        }\n\n        @Override\n        protected void onPreExecute() {\n        }\n\n        @Override\n        protected String doInBackground(Void... nothing) {\n            try {\n                mChannel = ManagedChannelBuilder.forAddress(mHost, mPort)\n                        .usePlaintext(true)\n                        .build();\n                GreeterGrpc.GreeterBlockingStub stub = GreeterGrpc.newBlockingStub(mChannel);\n                HelloRequest message = HelloRequest.newBuilder().setName(mName).build();\n                HelloReply reply = stub.sayHello(message);\n                return reply.getMessage();\n            } catch (Exception e) {\n                StringWriter sw = new StringWriter();\n                PrintWriter pw = new PrintWriter(sw);\n                e.printStackTrace(pw);\n                pw.flush();\n                return \"Failed... : \" + System.lineSeparator() + sw;\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            try {\n                mChannel.shutdown().awaitTermination(1, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            Log.d(TAG, result);\n        }\n    }\n}\n\n```\n\n这段代码运行会崩溃:\n\n> Caused by: io.grpc.ManagedChannelProvider$ProviderNotFoundException: No functional server found. Try adding a dependency on the grpc-netty artifact\n\n猜测google使用netty替代了okhttp，尝试换成grpc-netty的依赖:\n\n```\ndependencies {\n    ...\n    compile 'io.grpc:grpc-netty:1.1.2'\n    compile 'io.grpc:grpc-protobuf-lite:1.1.2'\n    compile 'io.grpc:grpc-stub:1.1.2'\n    compile 'javax.annotation:javax.annotation-api:1.2'\n    ...\n}\n```\n\n这么编译会报错\n\n> com.android.build.api.transform.TransformException: com.android.builder.packaging.DuplicateFileException: Duplicate files copied in APK META-INF/INDEX.LIST\n\n需要加上下面的配置解决\n\n```\nandroid {\n    ...\n    packagingOptions {\n        pickFirst 'META-INF/INDEX.LIST'\n        pickFirst 'META-INF/LICENSE'\n        pickFirst 'META-INF/io.netty.versions.properties'\n    }\n    ...\n}\n```\n\n当然，还需要加上INTERNET权限，要不然运行的时候还是会崩溃。\n\n最终就能看的下面的打印，这样安卓grpc的helloworld就成功了。\n\n> 03-03 00:04:20.000 6137-6137/linjw.com.grpcdemo D/GrpcDemo: hello linjw\n\n# 使用com.google.protobuf.Any\n\nAny可以携带任意类型的数据，用法相当于c语言的void指针。在项目中是很常用的，但是谷歌在javalite的版本不支持Any。\n\n如果在proto文件中使用了Any的话生成java代码就会有报错，例如将helloworld的proto文件改成下面的样子:\n\n```\n// Copyright 2015, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\noption java_multiple_files = true;\noption java_package = \"io.grpc.examples.helloworld\";\noption java_outer_classname = \"HelloWorldProto\";\noption objc_class_prefix = \"HLW\";\n\npackage helloworld;\n\nimport \"google/protobuf/any.proto\";\n\n// The greeting service definition.\nservice Greeter {\n  // Sends a greeting\n  rpc SayHello (google.protobuf.Any) returns (HelloReply) {}\n}\n\n// The request message containing the user's name.\nmessage HelloRequest {\n  string name = 1;\n}\n\n// The response message containing the greetings\nmessage HelloReply {\n  string message = 1;\n}\n```\n\n报错如下\n\n> google/protobuf/any.proto: File not found.\n  helloworld.proto: Import \"google/protobuf/any.proto\" was not found or had errors.\n  helloworld.proto:44:17: \"google.protobuf.Any\" is not defined.\n\n### 使用grpc-jave代替grpc-javalite\n\n但是现在做的这个项目的linux端实现已经用了Any，要改的话需要耗费比较大的精力。幸好尝试了下，发现安卓上也能跑支持Any的grpc-java。\n\n首先我们要使用grpc-protobuf依赖替换grpc-protobuf-lite依赖\n\n```\ndependencies {\n    ...\n    compile 'io.grpc:grpc-netty:1.1.2'\n    compile 'io.grpc:grpc-protobuf:1.1.2'\n    compile 'io.grpc:grpc-stub:1.1.2'\n    compile 'javax.annotation:javax.annotation-api:1.2'\n    ...\n}\n```\n\n接着修改protobuf-gradle-plugin配置使得自动生成java的代码而不是javalite的代码\n\n```\nprotobuf {\n    protoc {\n        artifact = 'com.google.protobuf:protoc:3.0.0'\n    }\n    plugins {\n        grpc {\n            artifact = 'io.grpc:protoc-gen-grpc-java:1.0.0' // CURRENT_GRPC_VERSION\n        }\n    }\n    generateProtoTasks {\n        all().each { task ->\n            task.builtins {\n                java {}\n            }\n            task.plugins {\n                grpc {}\n            }\n        }\n    }\n}\n```\n\n对应的修改helloworld的代码就能运行了\n\n```\n\npublic class MainActivity extends AppCompatActivity {\n    private static final String TAG = \"GrpcDemo\";\n\n    private static final int PROT = 55055;\n    private static final String NAME = \"linjw\";\n    private static final String HOST = \"localhost\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        startServer(PROT);\n        startClient(HOST, PROT, NAME);\n    }\n\n    private void startServer(int port){\n        try {\n            Server server = ServerBuilder.forPort(port)\n                    .addService(new GreeterImpl())\n                    .build()\n                    .start();\n        } catch (IOException e) {\n            e.printStackTrace();\n            Log.d(TAG, e.getMessage());\n        }\n    }\n\n    private void startClient(String host, int port, String name){\n        new GrpcTask(host, port, name).execute();\n    }\n\n    private class GreeterImpl extends GreeterGrpc.GreeterImplBase {\n        public void sayHello(Any request, StreamObserver<HelloReply> responseObserver) {\n            try {\n                responseObserver.onNext(sayHello(request.unpack(HelloRequest.class)));\n                responseObserver.onCompleted();\n            } catch (InvalidProtocolBufferException e) {\n                e.printStackTrace();\n            }\n        }\n\n        private HelloReply sayHello(HelloRequest request) {\n            return HelloReply.newBuilder()\n                    .setMessage(\"hello \"+ request.getName())\n                    .build();\n        }\n    }\n\n    private class GrpcTask extends AsyncTask<Void, Void, String> {\n        private String mHost;\n        private String mName;\n        private int mPort;\n        private ManagedChannel mChannel;\n\n        public GrpcTask(String host, int port, String name) {\n            this.mHost = host;\n            this.mName = name;\n            this.mPort = port;\n        }\n\n        @Override\n        protected void onPreExecute() {\n        }\n\n        @Override\n        protected String doInBackground(Void... nothing) {\n            try {\n                mChannel = ManagedChannelBuilder.forAddress(mHost, mPort)\n                        .usePlaintext(true)\n                        .build();\n                GreeterGrpc.GreeterBlockingStub stub = GreeterGrpc.newBlockingStub(mChannel);\n                HelloRequest message = HelloRequest.newBuilder().setName(mName).build();\n                HelloReply reply = stub.sayHello(Any.pack(message));\n                return reply.getMessage();\n            } catch (Exception e) {\n                StringWriter sw = new StringWriter();\n                PrintWriter pw = new PrintWriter(sw);\n                e.printStackTrace(pw);\n                pw.flush();\n                return \"Failed... : \" + System.lineSeparator() + sw;\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            try {\n                mChannel.shutdown().awaitTermination(1, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            Log.d(TAG, result);\n        }\n    }\n}\n\n```\n\n完整的demo代码可以点[这里](https://github.com/bluesky466/grpc-android-demo)在我的github中查看\n\n# Android方法数不能超过65535的问题\n\n最后使用grpc，方法数会超过65535，可以使用com.android.support:multidex去解决\n","source":"_posts/在android上使用grpc.md","raw":"title: 在android上使用grpc\ndate: 2017-03-03 09:49:37\ntags:\n\t- 技术相关\n\t- Android\n---\n\n最近的一个项目使用到了grpc实现跨平台的远程调用，在安卓端使用的时候遇到了一些坑，这里记录一下。\n\n首先根据grpc android的[官方Demo](https://github.com/grpc/grpc-java/tree/v1.0.0/examples/android)配置grpc依赖，测试它的hello world工程。\n\n# 编译谷歌官方的helloworld工程\n\n### 添加rotobuf-gradle-plugin插件\n首先添加rotobuf-gradle-plugin插件，他是用来从proto文件自动生成java代码的:\n\n```\n//Project的build.gradle中添加rotobuf-gradle-plugin插件\nbuildscript {\n    ...\n    dependencies {\n        ...\n        classpath \"com.google.protobuf:protobuf-gradle-plugin:0.8.0\"\n        ...\n    }\n    ...\n}\n```\n\n```\n//App的build.gradle中添加下面配置\napply plugin: 'com.google.protobuf'\n\nprotobuf {\n    protoc {\n        artifact = 'com.google.protobuf:protoc:3.0.0'\n    }\n    plugins {\n        javalite {\n            artifact = \"com.google.protobuf:protoc-gen-javalite:3.0.0\"\n        }\n        grpc {\n            artifact = 'io.grpc:protoc-gen-grpc-java:1.0.0' // CURRENT_GRPC_VERSION\n        }\n    }\n    generateProtoTasks {\n        all().each { task ->\n            task.plugins {\n                javalite {}\n                grpc {\n                    // Options added to --grpc_out\n                    option 'lite'\n                }\n            }\n        }\n    }\n}\n```\n\n### 添加proto文件并自动生成java代码\n\n在src/main/目录下创建一个proto目录，并将官方的[helloworld.proto](https://github.com/grpc/grpc-java/blob/v1.0.0/examples/android/helloworld/app/src/main/proto/helloworld.proto)放到proto目录下\n\n之后只需要rebuild一下就能看到build/generated/source/proto/目录下根据helloworld.proto生成了几个Java类\n\n\n{% img /在android上使用grpc/proto_gen.jpeg %}\n\n### 添加安卓端grpc的依赖\n\n```\n//App的build.gradle中添加下面配置\n dependencies {\n    ...\n    compile 'io.grpc:grpc-okhttp:1.1.2'\n    compile 'io.grpc:grpc-protobuf-lite:1.1.2'\n    compile 'io.grpc:grpc-stub:1.1.2'\n    compile 'javax.annotation:javax.annotation-api:1.2'\n    ...\n}\n```\n\n```\nconfigurations.all {\n        resolutionStrategy.force 'com.google.code.findbugs:jsr305:3.0.1'\n    }\n```\n\n我这个时候报了这个错误\n\n> Warning:Conflict with dependency 'com.google.code.findbugs:jsr305'. Resolved versions for app (3.0.0) and test app (2.0.1) differ. See http://g.co/androidstudio/app-test-app-conflict for details.\n\n这是因为com.google.code.findbugs:jsr305的版本不一致导致的\n\n可以在App的build.gradle的android标签中配置一下解决\n\n```\nandroid {\n    ...\n    configurations.all {\n        resolutionStrategy.force 'com.google.code.findbugs:jsr305:3.0.1'\n    }\n    ...\n}\n```\n\n### 编写demo代码\n\n```\npublic class MainActivity extends AppCompatActivity {\n    private static final String TAG = \"GrpcDemo\";\n\n    private static final int PROT = 55055;\n    private static final String NAME = \"linjw\";\n    private static final String HOST = \"localhost\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        startServer(PROT);\n        startClient(HOST, PROT, NAME);\n    }\n\n    private void startServer(int port){\n        try {\n            Server server = ServerBuilder.forPort(port)\n                    .addService(new GreeterImpl())\n                    .build()\n                    .start();\n        } catch (IOException e) {\n            e.printStackTrace();\n            Log.d(TAG, e.getMessage());\n        }\n    }\n\n    private void startClient(String host, int port, String name){\n        new GrpcTask(host, port, name).execute();\n    }\n\n    private class GreeterImpl extends GreeterGrpc.GreeterImplBase {\n        public void sayHello(HelloRequest request, StreamObserver<HelloReply> responseObserver) {\n            responseObserver.onNext(sayHello(request));\n            responseObserver.onCompleted();\n        }\n\n        private HelloReply sayHello(HelloRequest request) {\n            return HelloReply.newBuilder()\n                    .setMessage(\"hello \"+ request.getName())\n                    .build();\n        }\n    }\n\n    private class GrpcTask extends AsyncTask<Void, Void, String> {\n        private String mHost;\n        private String mName;\n        private int mPort;\n        private ManagedChannel mChannel;\n\n        public GrpcTask(String host, int port, String name) {\n            this.mHost = host;\n            this.mName = name;\n            this.mPort = port;\n        }\n\n        @Override\n        protected void onPreExecute() {\n        }\n\n        @Override\n        protected String doInBackground(Void... nothing) {\n            try {\n                mChannel = ManagedChannelBuilder.forAddress(mHost, mPort)\n                        .usePlaintext(true)\n                        .build();\n                GreeterGrpc.GreeterBlockingStub stub = GreeterGrpc.newBlockingStub(mChannel);\n                HelloRequest message = HelloRequest.newBuilder().setName(mName).build();\n                HelloReply reply = stub.sayHello(message);\n                return reply.getMessage();\n            } catch (Exception e) {\n                StringWriter sw = new StringWriter();\n                PrintWriter pw = new PrintWriter(sw);\n                e.printStackTrace(pw);\n                pw.flush();\n                return \"Failed... : \" + System.lineSeparator() + sw;\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            try {\n                mChannel.shutdown().awaitTermination(1, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            Log.d(TAG, result);\n        }\n    }\n}\n\n```\n\n这段代码运行会崩溃:\n\n> Caused by: io.grpc.ManagedChannelProvider$ProviderNotFoundException: No functional server found. Try adding a dependency on the grpc-netty artifact\n\n猜测google使用netty替代了okhttp，尝试换成grpc-netty的依赖:\n\n```\ndependencies {\n    ...\n    compile 'io.grpc:grpc-netty:1.1.2'\n    compile 'io.grpc:grpc-protobuf-lite:1.1.2'\n    compile 'io.grpc:grpc-stub:1.1.2'\n    compile 'javax.annotation:javax.annotation-api:1.2'\n    ...\n}\n```\n\n这么编译会报错\n\n> com.android.build.api.transform.TransformException: com.android.builder.packaging.DuplicateFileException: Duplicate files copied in APK META-INF/INDEX.LIST\n\n需要加上下面的配置解决\n\n```\nandroid {\n    ...\n    packagingOptions {\n        pickFirst 'META-INF/INDEX.LIST'\n        pickFirst 'META-INF/LICENSE'\n        pickFirst 'META-INF/io.netty.versions.properties'\n    }\n    ...\n}\n```\n\n当然，还需要加上INTERNET权限，要不然运行的时候还是会崩溃。\n\n最终就能看的下面的打印，这样安卓grpc的helloworld就成功了。\n\n> 03-03 00:04:20.000 6137-6137/linjw.com.grpcdemo D/GrpcDemo: hello linjw\n\n# 使用com.google.protobuf.Any\n\nAny可以携带任意类型的数据，用法相当于c语言的void指针。在项目中是很常用的，但是谷歌在javalite的版本不支持Any。\n\n如果在proto文件中使用了Any的话生成java代码就会有报错，例如将helloworld的proto文件改成下面的样子:\n\n```\n// Copyright 2015, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\noption java_multiple_files = true;\noption java_package = \"io.grpc.examples.helloworld\";\noption java_outer_classname = \"HelloWorldProto\";\noption objc_class_prefix = \"HLW\";\n\npackage helloworld;\n\nimport \"google/protobuf/any.proto\";\n\n// The greeting service definition.\nservice Greeter {\n  // Sends a greeting\n  rpc SayHello (google.protobuf.Any) returns (HelloReply) {}\n}\n\n// The request message containing the user's name.\nmessage HelloRequest {\n  string name = 1;\n}\n\n// The response message containing the greetings\nmessage HelloReply {\n  string message = 1;\n}\n```\n\n报错如下\n\n> google/protobuf/any.proto: File not found.\n  helloworld.proto: Import \"google/protobuf/any.proto\" was not found or had errors.\n  helloworld.proto:44:17: \"google.protobuf.Any\" is not defined.\n\n### 使用grpc-jave代替grpc-javalite\n\n但是现在做的这个项目的linux端实现已经用了Any，要改的话需要耗费比较大的精力。幸好尝试了下，发现安卓上也能跑支持Any的grpc-java。\n\n首先我们要使用grpc-protobuf依赖替换grpc-protobuf-lite依赖\n\n```\ndependencies {\n    ...\n    compile 'io.grpc:grpc-netty:1.1.2'\n    compile 'io.grpc:grpc-protobuf:1.1.2'\n    compile 'io.grpc:grpc-stub:1.1.2'\n    compile 'javax.annotation:javax.annotation-api:1.2'\n    ...\n}\n```\n\n接着修改protobuf-gradle-plugin配置使得自动生成java的代码而不是javalite的代码\n\n```\nprotobuf {\n    protoc {\n        artifact = 'com.google.protobuf:protoc:3.0.0'\n    }\n    plugins {\n        grpc {\n            artifact = 'io.grpc:protoc-gen-grpc-java:1.0.0' // CURRENT_GRPC_VERSION\n        }\n    }\n    generateProtoTasks {\n        all().each { task ->\n            task.builtins {\n                java {}\n            }\n            task.plugins {\n                grpc {}\n            }\n        }\n    }\n}\n```\n\n对应的修改helloworld的代码就能运行了\n\n```\n\npublic class MainActivity extends AppCompatActivity {\n    private static final String TAG = \"GrpcDemo\";\n\n    private static final int PROT = 55055;\n    private static final String NAME = \"linjw\";\n    private static final String HOST = \"localhost\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        startServer(PROT);\n        startClient(HOST, PROT, NAME);\n    }\n\n    private void startServer(int port){\n        try {\n            Server server = ServerBuilder.forPort(port)\n                    .addService(new GreeterImpl())\n                    .build()\n                    .start();\n        } catch (IOException e) {\n            e.printStackTrace();\n            Log.d(TAG, e.getMessage());\n        }\n    }\n\n    private void startClient(String host, int port, String name){\n        new GrpcTask(host, port, name).execute();\n    }\n\n    private class GreeterImpl extends GreeterGrpc.GreeterImplBase {\n        public void sayHello(Any request, StreamObserver<HelloReply> responseObserver) {\n            try {\n                responseObserver.onNext(sayHello(request.unpack(HelloRequest.class)));\n                responseObserver.onCompleted();\n            } catch (InvalidProtocolBufferException e) {\n                e.printStackTrace();\n            }\n        }\n\n        private HelloReply sayHello(HelloRequest request) {\n            return HelloReply.newBuilder()\n                    .setMessage(\"hello \"+ request.getName())\n                    .build();\n        }\n    }\n\n    private class GrpcTask extends AsyncTask<Void, Void, String> {\n        private String mHost;\n        private String mName;\n        private int mPort;\n        private ManagedChannel mChannel;\n\n        public GrpcTask(String host, int port, String name) {\n            this.mHost = host;\n            this.mName = name;\n            this.mPort = port;\n        }\n\n        @Override\n        protected void onPreExecute() {\n        }\n\n        @Override\n        protected String doInBackground(Void... nothing) {\n            try {\n                mChannel = ManagedChannelBuilder.forAddress(mHost, mPort)\n                        .usePlaintext(true)\n                        .build();\n                GreeterGrpc.GreeterBlockingStub stub = GreeterGrpc.newBlockingStub(mChannel);\n                HelloRequest message = HelloRequest.newBuilder().setName(mName).build();\n                HelloReply reply = stub.sayHello(Any.pack(message));\n                return reply.getMessage();\n            } catch (Exception e) {\n                StringWriter sw = new StringWriter();\n                PrintWriter pw = new PrintWriter(sw);\n                e.printStackTrace(pw);\n                pw.flush();\n                return \"Failed... : \" + System.lineSeparator() + sw;\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            try {\n                mChannel.shutdown().awaitTermination(1, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            Log.d(TAG, result);\n        }\n    }\n}\n\n```\n\n完整的demo代码可以点[这里](https://github.com/bluesky466/grpc-android-demo)在我的github中查看\n\n# Android方法数不能超过65535的问题\n\n最后使用grpc，方法数会超过65535，可以使用com.android.support:multidex去解决\n","slug":"在android上使用grpc","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2umv001fw3fyjlbscvp1"},{"title":"在Android中使用注解生成Java代码 AbstractProcessor","date":"2017-06-02T22:51:26.000Z","_content":"前段时间在学习Dagger2,对它生成代码的原理充满了好奇。google了之后发现原来java原生就是支持代码生成的。\n\n通过Annotation Processor可以在编译的时候处理注解,生成我们自定义的代码,这些生成的代码会和其他手写的代码一样被javac编译。注意Annotation Processor只能用来生成代码,而不能对原来的代码进行修改。\n\n实现的原理是通过继承AbstractProcessor,实现我们自己的Processor,然后把它注册给java编译器,编译器在编译之前使用我们定义的Processor去处理注解。\n\n# AbstractProcessor\n\nAbstractProcessor是一个抽象类,我们继承它需要实现一个抽象方法process,在这个方法里面去处理注解。然后它还有几个方法需要我们去重写。\n\n```\npublic class MyProcessor extends AbstractProcessor {\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnvironment) {...}\n    \n    @Override\n    public Set<String> getSupportedAnnotationTypes() {...}\n    \n    \n    @Override\n    public SourceVersion getSupportedSourceVersion() {...}\n    \n    \n    @Override\n    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {...}\n}\n```\n\n- init方法是初始化的地方,我们可以通过ProcessingEnvironment获取到很多有用的工具类\n\n- getSupportedAnnotationTypes 这个方法指定处理的注解,需要将要处理的注解的全名放到Set中返回\n\n- getSupportedSourceVersion 这个方法用来指定支持的java版本\n\n- process 是实际处理注解的地方\n\n在Java 7后多了 SupportedAnnotationTypes 和 SupportedSourceVersion 这个两个注解用来简化指定注解和java版本的操作:\n\n```\n@SupportedAnnotationTypes({\"linjw.demo.injector.InjectView\"})\n@SupportedSourceVersion(SourceVersion.RELEASE_7)\npublic class InjectorProcessor extends AbstractProcessor {\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnvironment) {...}\n        \n    @Override\n    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {...}\n```\n\n# 注册Processor\n\n编写完我们的Processor之后需要将它注册给java编译器\n\n1. 在src/main目录下创建resources/META-INF/services/javax.annotation.processing.Processor文件(即创建resources目录,在resources目录下创建META-INF目录,继续在META-INF目录下创建services目录,最后在services目录下创建javax.annotation.processing.Processor文件)。\n\n2. 在javax.annotation.processing.Processor中写入自定义的Processor的全名,如果有多个Processor的话,每一行写一个。\n\n完成后 javax.annotation.processing.Processor 内容如下\n\n>$ cat javax.annotation.processing.Processor  \n>linjw.demo.injector.InjectorProcessor\n\n# 在安卓中自定义Processor\n\n我以前在学习Java自定义注解的时候写过一个[小例子](http://blog.islinjw.cn/2016/05/27/Java%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/#u53E6_u5916_u7684_u4E00_u4E2A_u5B9E_u7528_u7684_u5C0F_u4F8B_u5B50),它是用运行时注解通过反射简化findViewById操作的。但是这种使用运行时注解的方法在效率上是有缺陷的,因为反射的效率很低。\n\n基本上学安卓的人都知道有个很火的开源库[ButterKnife](https://github.com/JakeWharton/butterknife),它也能简化findViewById操作,但它是通过编译时注解生成代码去实现的,效率比我们使用反射实现要高很多很多。\n\n其实我对ButterKnife的原理也一直很好奇,下面就让我们也用生成代码的方式高效的简化findViewById操作。\n\n## 创建配置工程\n\n首先在android项目中是找不到AbstractProcessor的,需要新建一个Java Library Module。\n\nAndroid Studio中按File -> New -> New Module... 然后选择新建Java Library, Module的名字改为libinjector。\n\n同时在安卓中使用AbstractProcessor需要apt的支持,所以需要配置一下gradle:\n\n1.在 project 的 build.gradle 的 dependencies 下加上 android-apt 支持\n\n```\n...\ndependencies {\n        classpath 'com.android.tools.build:gradle:2.2.2'\n        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'\n}\n...\n```\n\n2.在 app 的 build.gradle 的开头加上 \"apply plugin: 'com.neenbedankt.android-apt'\"\n\n```\napply plugin: 'com.android.application'\napply plugin: 'com.neenbedankt.android-apt'\n...\n```\n\n## 创建注解\n\n我们在libinjector中创建注解InjectView\n\n```\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface InjectView {\n    int value();\n}\n```\n\n这个是个修饰Field且作用于源码的自定义注解。关于自定义注解的知识可以看看我以前写的一篇文章[《Java自定义注解和动态代理》](http://blog.islinjw.cn/2016/05/27/Java%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/)。我们用它来修饰View成员变量并保持View的resource id,生成的代码通过resource id使用findViewById注入成员变量。\n\n## 创建InjectorProcessor\n\n在libinjector中创建InjectorProcessor实现代码的生成\n\n```\n@SupportedAnnotationTypes({\"linjw.demo.injector.InjectView\"})\n@SupportedSourceVersion(SourceVersion.RELEASE_7)\npublic class InjectorProcessor extends AbstractProcessor {\n    private static final String GEN_CLASS_SUFFIX = \"Injector\";\n    private static final String INJECTOR_NAME = \"ViewInjector\";\n\n    private Types mTypeUtils;\n    private Elements mElementUtils;\n    private Filer mFiler;\n    private Messager mMessager;\n\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnvironment) {\n        super.init(processingEnvironment);\n\n        mTypeUtils = processingEnv.getTypeUtils();\n        mElementUtils = processingEnv.getElementUtils();\n        mFiler = processingEnv.getFiler();\n        mMessager = processingEnv.getMessager();\n    }\n\n    @Override\n    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {\n        Set<? extends Element> elements = roundEnvironment.getElementsAnnotatedWith(InjectView.class);\n\n        //process会被调用三次，只有一次是可以处理InjectView注解的，原因不明\n        if (elements.size() == 0) {\n            return true;\n        }\n\n        Map<Element, List<Element>> elementMap = new HashMap<>();\n\n        StringBuffer buffer = new StringBuffer();\n        buffer.append(\"package linjw.demo.injector;\\n\")\n                .append(\"public class \" + INJECTOR_NAME + \" {\\n\");\n\n        //遍历所有被InjectView注释的元素\n        for (Element element : elements) {\n            //如果标注的对象不是FIELD则报错,这个错误其实不会发生因为InjectView的Target已经声明为ElementType.FIELD了\n            if (element.getKind()!= ElementKind.FIELD) {\n                mMessager.printMessage(Diagnostic.Kind.ERROR, \"is not a FIELD\", element);\n            }\n\n            //这里可以先将element转换为VariableElement,但我们这里不需要\n            //VariableElement variableElement = (VariableElement) element;\n\n            //如果不是View的子类则报错\n            if (!isView(element.asType())){\n                mMessager.printMessage(Diagnostic.Kind.ERROR, \"is not a View\", element);\n            }\n\n            //获取所在类的信息\n            Element clazz = element.getEnclosingElement();\n\n            //按类存入map中\n            addElement(elementMap, clazz, element);\n        }\n\n        for (Map.Entry<Element, List<Element>> entry : elementMap.entrySet()) {\n            Element clazz = entry.getKey();\n\n            //获取类名\n            String className = clazz.getSimpleName().toString();\n\n            //获取所在的包名\n            String packageName = mElementUtils.getPackageOf(clazz).asType().toString();\n\n            //生成注入代码\n            generateInjectorCode(packageName, className, entry.getValue());\n\n            //完整类名\n            String fullName = clazz.asType().toString();\n\n            buffer.append(\"\\tpublic static void inject(\" + fullName + \" arg) {\\n\")\n                    .append(\"\\t\\t\" + fullName + GEN_CLASS_SUFFIX + \".inject(arg);\\n\")\n                    .append(\"\\t}\\n\");\n        }\n\n        buffer.append(\"}\");\n\n        generateCode(INJECTOR_NAME, buffer.toString());\n\n        return true;\n    }\n\n    //递归判断android.view.View是不是其父类\n    private boolean isView(TypeMirror type) {\n        List<? extends TypeMirror> supers = mTypeUtils.directSupertypes(type);\n        if (supers.size() == 0) {\n            return false;\n        }\n        for (TypeMirror superType : supers) {\n            if (superType.toString().equals(\"android.view.View\") || isView(superType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void addElement(Map<Element, List<Element>> map, Element clazz, Element field) {\n        List<Element> list = map.get(clazz);\n        if (list == null) {\n            list = new ArrayList<>();\n            map.put(clazz, list);\n        }\n        list.add(field);\n    }\n\n    private void generateCode(String className, String code) {\n        try {\n            JavaFileObject file = mFiler.createSourceFile(className);\n            Writer writer = file.openWriter();\n            writer.write(code);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 生成注入代码\n     *\n     * @param packageName 包名\n     * @param className   类名\n     * @param views       需要注入的成员变量\n     */\n    private void generateInjectorCode(String packageName, String className, List<Element> views) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"package \" + packageName + \";\\n\\n\")\n                .append(\"public class \" + className + GEN_CLASS_SUFFIX + \" {\\n\")\n                .append(\"\\tpublic static void inject(\" + className + \" arg) {\\n\");\n\n        for (Element element : views) {\n            //获取变量类型\n            String type = element.asType().toString();\n\n            //获取变量名\n            String name = element.getSimpleName().toString();\n\n            //id\n            int resourceId = element.getAnnotation(InjectView.class).value();\n\n            builder.append(\"\\t\\targ.\" + name + \"=(\" + type + \")arg.findViewById(\" + resourceId + \");\\n\");\n        }\n\n        builder.append(\"\\t}\\n\")\n                .append(\"}\");\n\n        //生成代码\n        generateCode(className + GEN_CLASS_SUFFIX, builder.toString());\n    }\n}\n```\n\n## 注册InjectorProcessor\n\n在libinjector的src/main目录下创建resources/META-INF/services/javax.annotation.processing.Processor文件注册InjectorProcessor:\n\n```\n# 注册InjectorProcessor\nlinjw.demo.injector.InjectorProcessor\n```\n\n## 使用InjectView注解\n\n我们在Activity中使用InjectView修饰需要赋值的View变量并且用ViewInjector.inject(this);调用生成的掉初始化修饰的成员变量。这里有两个Activity都使用了InjectView去简化findViewById操作:\n\n```\npublic class MainActivity extends AppCompatActivity {\n    @InjectView(R.id.label)\n    TextView mLabel;\n\n    @InjectView(R.id.button)\n    Button mButton;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        //使用findViewById注入被InjectView修饰的成员变量\n        ViewInjector.inject(this);\n\n        // ViewInjector.inject(this) 已经将mLabel和mButton赋值了,可以直接使用\n        mLabel.setText(\"MainActivity\");\n\n        mButton.setText(\"jump to SecondActivity\");\n        mButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Intent intent  = new Intent(MainActivity.this, SecondActivity.class);\n                startActivity(intent);\n            }\n        });\n    }\n}\n```\n\n```\npublic class SecondActivity extends Activity {\n    @InjectView(R.id.label)\n    TextView mLabel;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_second);\n\n        //使用findViewById注入被InjectView修饰的成员变量\n        ViewInjector.inject(this);\n\n        // ViewInjector.inject(this) 已经将mLabel赋值了,可以直接使用\n        mLabel.setText(\"SecondActivity\");\n    }\n}\n```\n\n# 工具类\n\n在 AbstractProcessor.init 方法中我们可以获得几个很有用的工具类:\n\n```\nmTypeUtils = processingEnv.getTypeUtils();\nmElementUtils = processingEnv.getElementUtils();\nmFiler = processingEnv.getFiler();\nmMessager = processingEnv.getMessager();\n```\n\n它们的作用如下:\n\n## Types \n\nTypes提供了和类型相关的一些操作，如获取父类、判断两个类是不是父子关系等，我们在isView中就用它去获取父类\n\n```\n    //递归判断android.view.View是不是其父类   \n    private boolean isView(TypeMirror type) {\n        List<? extends TypeMirror> supers = mTypeUtils.directSupertypes(type);\n        if (supers.size() == 0) {\n            return false;\n        }\n        for (TypeMirror superType : supers) {\n            if (superType.toString().equals(\"android.view.View\") || isView(superType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n```\n\n## Elements\n\nElements提供了一些和元素相关的操作，如获取所在包的包名等:\n\n```\n//获取所在的包名\nString packageName = mElementUtils.getPackageOf(clazz).asType().toString();\n```\n\n## Filer\n\nFiler用于文件操作,我们用它去创建生成的代码文件\n\n```\n\tprivate void generateCode(String className, String code) {\n        try {\n            JavaFileObject file = mFiler.createSourceFile(className);\n            Writer writer = file.openWriter();\n            writer.write(code);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n## Messager\n\nMessager 顾名思义就是用于打印的,它会打印出Element所在的源代码，它还会抛出异常。靠默认的错误打印有时很难找出错误的地方,我们可以用它去添加更直观的日志打印\n\n当用InjectView标注了非View的成员变量我们就会打印错误并抛出异常(这里我们使用Diagnostic.Kind.ERROR,这个打印会抛出异常终止Processor):\n\n```\n//如果不是View的子类则报错\nif (!isView(element.asType())){\n\tmMessager.printMessage(Diagnostic.Kind.ERROR, \"is not a View\", element);\n}\n```\n\n例如我们如果在MainActivity中为一个String变量标注InjectView:\n\n```\n//在非View上使用InjectView就会报错\n@InjectView(R.id.button)\nString x;\n```\n\n则会报错:\n\n```\n  符号:   类 ViewInjector\n  位置: 程序包 linjw.demo.injector\n/Users/linjw/workspace/ProcessorDemo/app/src/main/java/linjw/demo/processordemo/MainActivity.java:22: 错误: is not a View\n    String x;\n           ^\n```\n\n如果我们不用Messager去打印,生成的代码之后也会有打印,但是就不是那么清晰了:\n\n```\n/Users/linjw/workspace/ProcessorDemo/app/build/generated/source/apt/debug/MainActivityInjector.java:7: 错误: 不兼容的类型: View无法转换为String\n                arg.x=(java.lang.String)arg.findViewById(2131427415);\n```\n\n# Element的子接口\n\n我们在process方法中使用getElementsAnnotatedWith获取到的都是Element接口,其实我们用Element.getKind获取到类型之后可以将他们强转成对应的子接口,这些子接口提供了一些针对性的操作。\n\n这些子接口有:\n\n- TypeElement：表示一个类或接口程序元素。\n- PackageElement：表示一个包程序元素。\n- VariableElement：表示一个属性、enum 常量、方法或构造方法参数、局部变量或异常参数。\n- ExecutableElement：表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注释类型元素。\n\n对应关系如下\n\n```\npackage linjw.demo;  // PackageElement\npublic class Person {  // TypeElement\n    private String mName;  // VariableElement\n    public Person () {}  // ExecutableElement\n    public void setName (String name) {mName=name;}  // ExecutableElement\n}\n```\n\n# Element的一些常用操作\n\n获取类名:\n\n- Element.getSimpleName().toString(); // 获取类名\n- Element.asType().toString(); //获取类的全名\n\n获取所在的包名:\n\n- Elements.getPackageOf(Element).asType().toString();\n\n获取所在的类:\n\n- Element.getEnclosingElement();\n\n获取父类:\n\n- Types.directSupertypes(Element.asType())\n\n获取标注对象的类型:\n\n- Element.getKind()\n\n# Demo地址\n\n可以在[这里](https://github.com/bluesky466/ProcessorDemo)查看完整代码\n","source":"_posts/在Android中使用注解生成Java代码-AbstractProcessor.md","raw":"title: 在Android中使用注解生成Java代码 AbstractProcessor\ndate: 2017-06-03 06:51:26\ntags:\n    - 技术相关\n    - Android\n---\n前段时间在学习Dagger2,对它生成代码的原理充满了好奇。google了之后发现原来java原生就是支持代码生成的。\n\n通过Annotation Processor可以在编译的时候处理注解,生成我们自定义的代码,这些生成的代码会和其他手写的代码一样被javac编译。注意Annotation Processor只能用来生成代码,而不能对原来的代码进行修改。\n\n实现的原理是通过继承AbstractProcessor,实现我们自己的Processor,然后把它注册给java编译器,编译器在编译之前使用我们定义的Processor去处理注解。\n\n# AbstractProcessor\n\nAbstractProcessor是一个抽象类,我们继承它需要实现一个抽象方法process,在这个方法里面去处理注解。然后它还有几个方法需要我们去重写。\n\n```\npublic class MyProcessor extends AbstractProcessor {\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnvironment) {...}\n    \n    @Override\n    public Set<String> getSupportedAnnotationTypes() {...}\n    \n    \n    @Override\n    public SourceVersion getSupportedSourceVersion() {...}\n    \n    \n    @Override\n    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {...}\n}\n```\n\n- init方法是初始化的地方,我们可以通过ProcessingEnvironment获取到很多有用的工具类\n\n- getSupportedAnnotationTypes 这个方法指定处理的注解,需要将要处理的注解的全名放到Set中返回\n\n- getSupportedSourceVersion 这个方法用来指定支持的java版本\n\n- process 是实际处理注解的地方\n\n在Java 7后多了 SupportedAnnotationTypes 和 SupportedSourceVersion 这个两个注解用来简化指定注解和java版本的操作:\n\n```\n@SupportedAnnotationTypes({\"linjw.demo.injector.InjectView\"})\n@SupportedSourceVersion(SourceVersion.RELEASE_7)\npublic class InjectorProcessor extends AbstractProcessor {\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnvironment) {...}\n        \n    @Override\n    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {...}\n```\n\n# 注册Processor\n\n编写完我们的Processor之后需要将它注册给java编译器\n\n1. 在src/main目录下创建resources/META-INF/services/javax.annotation.processing.Processor文件(即创建resources目录,在resources目录下创建META-INF目录,继续在META-INF目录下创建services目录,最后在services目录下创建javax.annotation.processing.Processor文件)。\n\n2. 在javax.annotation.processing.Processor中写入自定义的Processor的全名,如果有多个Processor的话,每一行写一个。\n\n完成后 javax.annotation.processing.Processor 内容如下\n\n>$ cat javax.annotation.processing.Processor  \n>linjw.demo.injector.InjectorProcessor\n\n# 在安卓中自定义Processor\n\n我以前在学习Java自定义注解的时候写过一个[小例子](http://blog.islinjw.cn/2016/05/27/Java%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/#u53E6_u5916_u7684_u4E00_u4E2A_u5B9E_u7528_u7684_u5C0F_u4F8B_u5B50),它是用运行时注解通过反射简化findViewById操作的。但是这种使用运行时注解的方法在效率上是有缺陷的,因为反射的效率很低。\n\n基本上学安卓的人都知道有个很火的开源库[ButterKnife](https://github.com/JakeWharton/butterknife),它也能简化findViewById操作,但它是通过编译时注解生成代码去实现的,效率比我们使用反射实现要高很多很多。\n\n其实我对ButterKnife的原理也一直很好奇,下面就让我们也用生成代码的方式高效的简化findViewById操作。\n\n## 创建配置工程\n\n首先在android项目中是找不到AbstractProcessor的,需要新建一个Java Library Module。\n\nAndroid Studio中按File -> New -> New Module... 然后选择新建Java Library, Module的名字改为libinjector。\n\n同时在安卓中使用AbstractProcessor需要apt的支持,所以需要配置一下gradle:\n\n1.在 project 的 build.gradle 的 dependencies 下加上 android-apt 支持\n\n```\n...\ndependencies {\n        classpath 'com.android.tools.build:gradle:2.2.2'\n        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'\n}\n...\n```\n\n2.在 app 的 build.gradle 的开头加上 \"apply plugin: 'com.neenbedankt.android-apt'\"\n\n```\napply plugin: 'com.android.application'\napply plugin: 'com.neenbedankt.android-apt'\n...\n```\n\n## 创建注解\n\n我们在libinjector中创建注解InjectView\n\n```\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface InjectView {\n    int value();\n}\n```\n\n这个是个修饰Field且作用于源码的自定义注解。关于自定义注解的知识可以看看我以前写的一篇文章[《Java自定义注解和动态代理》](http://blog.islinjw.cn/2016/05/27/Java%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/)。我们用它来修饰View成员变量并保持View的resource id,生成的代码通过resource id使用findViewById注入成员变量。\n\n## 创建InjectorProcessor\n\n在libinjector中创建InjectorProcessor实现代码的生成\n\n```\n@SupportedAnnotationTypes({\"linjw.demo.injector.InjectView\"})\n@SupportedSourceVersion(SourceVersion.RELEASE_7)\npublic class InjectorProcessor extends AbstractProcessor {\n    private static final String GEN_CLASS_SUFFIX = \"Injector\";\n    private static final String INJECTOR_NAME = \"ViewInjector\";\n\n    private Types mTypeUtils;\n    private Elements mElementUtils;\n    private Filer mFiler;\n    private Messager mMessager;\n\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnvironment) {\n        super.init(processingEnvironment);\n\n        mTypeUtils = processingEnv.getTypeUtils();\n        mElementUtils = processingEnv.getElementUtils();\n        mFiler = processingEnv.getFiler();\n        mMessager = processingEnv.getMessager();\n    }\n\n    @Override\n    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {\n        Set<? extends Element> elements = roundEnvironment.getElementsAnnotatedWith(InjectView.class);\n\n        //process会被调用三次，只有一次是可以处理InjectView注解的，原因不明\n        if (elements.size() == 0) {\n            return true;\n        }\n\n        Map<Element, List<Element>> elementMap = new HashMap<>();\n\n        StringBuffer buffer = new StringBuffer();\n        buffer.append(\"package linjw.demo.injector;\\n\")\n                .append(\"public class \" + INJECTOR_NAME + \" {\\n\");\n\n        //遍历所有被InjectView注释的元素\n        for (Element element : elements) {\n            //如果标注的对象不是FIELD则报错,这个错误其实不会发生因为InjectView的Target已经声明为ElementType.FIELD了\n            if (element.getKind()!= ElementKind.FIELD) {\n                mMessager.printMessage(Diagnostic.Kind.ERROR, \"is not a FIELD\", element);\n            }\n\n            //这里可以先将element转换为VariableElement,但我们这里不需要\n            //VariableElement variableElement = (VariableElement) element;\n\n            //如果不是View的子类则报错\n            if (!isView(element.asType())){\n                mMessager.printMessage(Diagnostic.Kind.ERROR, \"is not a View\", element);\n            }\n\n            //获取所在类的信息\n            Element clazz = element.getEnclosingElement();\n\n            //按类存入map中\n            addElement(elementMap, clazz, element);\n        }\n\n        for (Map.Entry<Element, List<Element>> entry : elementMap.entrySet()) {\n            Element clazz = entry.getKey();\n\n            //获取类名\n            String className = clazz.getSimpleName().toString();\n\n            //获取所在的包名\n            String packageName = mElementUtils.getPackageOf(clazz).asType().toString();\n\n            //生成注入代码\n            generateInjectorCode(packageName, className, entry.getValue());\n\n            //完整类名\n            String fullName = clazz.asType().toString();\n\n            buffer.append(\"\\tpublic static void inject(\" + fullName + \" arg) {\\n\")\n                    .append(\"\\t\\t\" + fullName + GEN_CLASS_SUFFIX + \".inject(arg);\\n\")\n                    .append(\"\\t}\\n\");\n        }\n\n        buffer.append(\"}\");\n\n        generateCode(INJECTOR_NAME, buffer.toString());\n\n        return true;\n    }\n\n    //递归判断android.view.View是不是其父类\n    private boolean isView(TypeMirror type) {\n        List<? extends TypeMirror> supers = mTypeUtils.directSupertypes(type);\n        if (supers.size() == 0) {\n            return false;\n        }\n        for (TypeMirror superType : supers) {\n            if (superType.toString().equals(\"android.view.View\") || isView(superType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void addElement(Map<Element, List<Element>> map, Element clazz, Element field) {\n        List<Element> list = map.get(clazz);\n        if (list == null) {\n            list = new ArrayList<>();\n            map.put(clazz, list);\n        }\n        list.add(field);\n    }\n\n    private void generateCode(String className, String code) {\n        try {\n            JavaFileObject file = mFiler.createSourceFile(className);\n            Writer writer = file.openWriter();\n            writer.write(code);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 生成注入代码\n     *\n     * @param packageName 包名\n     * @param className   类名\n     * @param views       需要注入的成员变量\n     */\n    private void generateInjectorCode(String packageName, String className, List<Element> views) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"package \" + packageName + \";\\n\\n\")\n                .append(\"public class \" + className + GEN_CLASS_SUFFIX + \" {\\n\")\n                .append(\"\\tpublic static void inject(\" + className + \" arg) {\\n\");\n\n        for (Element element : views) {\n            //获取变量类型\n            String type = element.asType().toString();\n\n            //获取变量名\n            String name = element.getSimpleName().toString();\n\n            //id\n            int resourceId = element.getAnnotation(InjectView.class).value();\n\n            builder.append(\"\\t\\targ.\" + name + \"=(\" + type + \")arg.findViewById(\" + resourceId + \");\\n\");\n        }\n\n        builder.append(\"\\t}\\n\")\n                .append(\"}\");\n\n        //生成代码\n        generateCode(className + GEN_CLASS_SUFFIX, builder.toString());\n    }\n}\n```\n\n## 注册InjectorProcessor\n\n在libinjector的src/main目录下创建resources/META-INF/services/javax.annotation.processing.Processor文件注册InjectorProcessor:\n\n```\n# 注册InjectorProcessor\nlinjw.demo.injector.InjectorProcessor\n```\n\n## 使用InjectView注解\n\n我们在Activity中使用InjectView修饰需要赋值的View变量并且用ViewInjector.inject(this);调用生成的掉初始化修饰的成员变量。这里有两个Activity都使用了InjectView去简化findViewById操作:\n\n```\npublic class MainActivity extends AppCompatActivity {\n    @InjectView(R.id.label)\n    TextView mLabel;\n\n    @InjectView(R.id.button)\n    Button mButton;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        //使用findViewById注入被InjectView修饰的成员变量\n        ViewInjector.inject(this);\n\n        // ViewInjector.inject(this) 已经将mLabel和mButton赋值了,可以直接使用\n        mLabel.setText(\"MainActivity\");\n\n        mButton.setText(\"jump to SecondActivity\");\n        mButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Intent intent  = new Intent(MainActivity.this, SecondActivity.class);\n                startActivity(intent);\n            }\n        });\n    }\n}\n```\n\n```\npublic class SecondActivity extends Activity {\n    @InjectView(R.id.label)\n    TextView mLabel;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_second);\n\n        //使用findViewById注入被InjectView修饰的成员变量\n        ViewInjector.inject(this);\n\n        // ViewInjector.inject(this) 已经将mLabel赋值了,可以直接使用\n        mLabel.setText(\"SecondActivity\");\n    }\n}\n```\n\n# 工具类\n\n在 AbstractProcessor.init 方法中我们可以获得几个很有用的工具类:\n\n```\nmTypeUtils = processingEnv.getTypeUtils();\nmElementUtils = processingEnv.getElementUtils();\nmFiler = processingEnv.getFiler();\nmMessager = processingEnv.getMessager();\n```\n\n它们的作用如下:\n\n## Types \n\nTypes提供了和类型相关的一些操作，如获取父类、判断两个类是不是父子关系等，我们在isView中就用它去获取父类\n\n```\n    //递归判断android.view.View是不是其父类   \n    private boolean isView(TypeMirror type) {\n        List<? extends TypeMirror> supers = mTypeUtils.directSupertypes(type);\n        if (supers.size() == 0) {\n            return false;\n        }\n        for (TypeMirror superType : supers) {\n            if (superType.toString().equals(\"android.view.View\") || isView(superType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n```\n\n## Elements\n\nElements提供了一些和元素相关的操作，如获取所在包的包名等:\n\n```\n//获取所在的包名\nString packageName = mElementUtils.getPackageOf(clazz).asType().toString();\n```\n\n## Filer\n\nFiler用于文件操作,我们用它去创建生成的代码文件\n\n```\n\tprivate void generateCode(String className, String code) {\n        try {\n            JavaFileObject file = mFiler.createSourceFile(className);\n            Writer writer = file.openWriter();\n            writer.write(code);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n## Messager\n\nMessager 顾名思义就是用于打印的,它会打印出Element所在的源代码，它还会抛出异常。靠默认的错误打印有时很难找出错误的地方,我们可以用它去添加更直观的日志打印\n\n当用InjectView标注了非View的成员变量我们就会打印错误并抛出异常(这里我们使用Diagnostic.Kind.ERROR,这个打印会抛出异常终止Processor):\n\n```\n//如果不是View的子类则报错\nif (!isView(element.asType())){\n\tmMessager.printMessage(Diagnostic.Kind.ERROR, \"is not a View\", element);\n}\n```\n\n例如我们如果在MainActivity中为一个String变量标注InjectView:\n\n```\n//在非View上使用InjectView就会报错\n@InjectView(R.id.button)\nString x;\n```\n\n则会报错:\n\n```\n  符号:   类 ViewInjector\n  位置: 程序包 linjw.demo.injector\n/Users/linjw/workspace/ProcessorDemo/app/src/main/java/linjw/demo/processordemo/MainActivity.java:22: 错误: is not a View\n    String x;\n           ^\n```\n\n如果我们不用Messager去打印,生成的代码之后也会有打印,但是就不是那么清晰了:\n\n```\n/Users/linjw/workspace/ProcessorDemo/app/build/generated/source/apt/debug/MainActivityInjector.java:7: 错误: 不兼容的类型: View无法转换为String\n                arg.x=(java.lang.String)arg.findViewById(2131427415);\n```\n\n# Element的子接口\n\n我们在process方法中使用getElementsAnnotatedWith获取到的都是Element接口,其实我们用Element.getKind获取到类型之后可以将他们强转成对应的子接口,这些子接口提供了一些针对性的操作。\n\n这些子接口有:\n\n- TypeElement：表示一个类或接口程序元素。\n- PackageElement：表示一个包程序元素。\n- VariableElement：表示一个属性、enum 常量、方法或构造方法参数、局部变量或异常参数。\n- ExecutableElement：表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注释类型元素。\n\n对应关系如下\n\n```\npackage linjw.demo;  // PackageElement\npublic class Person {  // TypeElement\n    private String mName;  // VariableElement\n    public Person () {}  // ExecutableElement\n    public void setName (String name) {mName=name;}  // ExecutableElement\n}\n```\n\n# Element的一些常用操作\n\n获取类名:\n\n- Element.getSimpleName().toString(); // 获取类名\n- Element.asType().toString(); //获取类的全名\n\n获取所在的包名:\n\n- Elements.getPackageOf(Element).asType().toString();\n\n获取所在的类:\n\n- Element.getEnclosingElement();\n\n获取父类:\n\n- Types.directSupertypes(Element.asType())\n\n获取标注对象的类型:\n\n- Element.getKind()\n\n# Demo地址\n\n可以在[这里](https://github.com/bluesky466/ProcessorDemo)查看完整代码\n","slug":"在Android中使用注解生成Java代码-AbstractProcessor","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2umx001iw3fyrsv8a321"},{"title":"写给安卓程序员的C/C++编译入门","date":"2018-07-29T11:01:45.000Z","_content":"\n最近部门新入职了几个小鲜肉,打算给他们分享下一些C/C++编译的基础知识,于是整理了一些资料写了这篇博客.由于已经有差不多一年没有写c++了,可能会有一些不太正确的地方,希望哪位同学看到能够帮忙指出,免得误人子弟.\n\n首先需要声明的是,我用的是Ubuntu系统,也是基于Linux去讲的,当然大家如果是用的Mac系统,其实可以无缝切换,用几乎完全一样的命令去跑.但是如果是Windows的同学,可能就不太适用了.\n\n不过其实我还是鼓励大家用Linux系统或者Mac系统去编译C/C++程序.因为大多数流行库都是在linux下面写的,使用Linux或者Mac交叉编译出安卓的可用程序都比较方便.\n\n# 为什么要学C/C++编译\n\n很多的安卓程序员可能都会用Android Studio写一些简单的C/C++代码,然后通过jni去调用,但是对C/C++是如何编译的其实并没有什么概念.有人可能会问,为什么安卓程序员会需要了解C/C++是如何编译的呢?我一直都认为,要成为一个真正的高级安卓应用开发工程师,安卓源码和C/C++是两座绕不过的大山.安卓源码自然不必多说,而C/C++流行了几十年,存在着许多优秀的开源项目,我们在处理一些特定的需求的时候,可能会需要使用到它们.如脚本语言Lua,计算机视觉库OpenCV,音视频编解码库ffmpeg,谷歌的gRPC,国产游戏引擎Cocos2dx...有些库提供了完整的安卓接口,有些提供了部分安卓接口,有些则没有.在做一些高级功能时,我们常常需要使用源码,通过裁剪和交叉编译,才能编译出可以在安卓上使用的so库.总之,安卓做深做精总避不开C/C++交叉编译.\n\n# C/C++编译器\n\n类似java编译器javac可以将java代码编译成class文件,C/C++也有gcc、g++、clang等多种编译器可以用于编译C/C++代码.这里我们用gcc来举例.\n\ngcc原名为GNU C 语言编译器(GNU C Compiler),因为它原本只能处理C语言.但GCC很快地扩展,变得可处理C++。后来又扩展能够支持更多编程语言,如Fortran、Pascal、Objective-C、Java、Ada、Go以及各类处理器架构上的汇编语言等,所以改名GNU编译器套件(GNU Compiler Collection).\n\n我这篇文章的例子都是Ubuntu上编译的.使用Ubuntu系统的同学可以使用下面命令安装gcc:\n\n> sudo apt-get install gcc\n\n如果是CentOS使用yum去安装:\n\n> yum install gcc\n\nMac系统的话可以用HomeBrew来安装,HomeBrew的安装方法我就不说了,大家可以自己搜索:\n\n> brew install gcc\n\n而使用Windows的同学,需要自己搜索下MinGw是如何安装的,MinGw 是 Minimal GNU on Windows 的缩写.\n\n使用gcc其实只需要一个命令就能将一个c文件编译成可运行程序了:\n\n> gcc test.c -o test\n\n通过上面这条命令可以将test.c编译成可运行程序test.但是其实C/C++的编译是经过了好几个步骤的,我这边先给大家大概的讲一讲.\n\n# C/C++的编译流程\n\nC/C++的编译可以分为下面几个步骤:\n\n{% img /写给安卓程序员的cc-编译入门/1.png %}\n\n## 预处理\n\n相信学过C/C++的同学都知道\"宏\"这个东西,它在编译的时候会被展开替换成实际的代码,这个展开的步骤就是在预处理的时候进行的.当然,预处理并不仅仅只是做宏的展开,它还做了类似头文件插入、删除注释等操作.\n\n预处理之后的产品依然还是C/C++代码,它在代码的逻辑上和输入的C/C++源代码是完全一样的.\n\n我们来举一个简单的例子,写一个test.h文件和一个test.c文件:\n\n```\n//test.h\n#ifndef TEST_H            \n#define TEST_H\n\n#define A 1     \n#define B 2        \n\n/**\n * add 方法的声明\n */               \nint add(int a, int b);\n\n#endif\n```\n\n```\n//test.c\n#include \"test.h\"\n\n/**\n * add 方法定义\n */\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint main(int argc,char* argv[]) {\n    add(A, B);\n    return 0;                 \n}\n```\n\n然后可以通过下面这个gcc命令预处理test.c文件,并且把预处理结果写到test.i:\n\n> gcc -E test.c -o test.i\n\n然后就能看到预处理之后的test.c到底长什么样子了:\n\n```\n# 1 \"test.c\"\n# 1 \"<built-in>\"\n# 1 \"<command-line>\"\n# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n# 1 \"<command-line>\" 2\n# 1 \"test.c\"\n# 1 \"test.h\" 1\n# 11 \"test.h\"\nint add(int a, int b);\n# 2 \"test.c\" 2\n\nint add(int a, int b){\n return a + b;\n}\n\nint main(int argc,char* argv[]) {\n add(1, 2);\n return 0;\n}\n```\n\n可以看到这里它把test.h的内容(add方法的声明)插入到了test.c的代码中,然后将A、B两个宏展开成了1和2,将注释去掉了,还在头部加上了一些信息.\n\n但是光看代码逻辑,和之前我们写的代码是完全一样的.\n\n## 汇编\n\n可能大家都听过汇编语言这个东西,但是年轻一点的同学不一定真正见过.简单来说汇编语言是将机器语言符号化了的语言,是机器不能直接识别的低级语言.我们可以通过下面的命令,将预处理后的代码编译成汇编语言:\n\n> gcc -S test.i -o test.s\n\n然后就能看到生成的test.s文件了,里面就是我们写的c语言代码翻译而成的汇编代码:\n\n```\n        .file   \"test.c\"\n        .text\n        .globl  add\n        .type   add, @function\nadd:\n.LFB0:\n        .cfi_startproc\n        pushq   %rbp\n        .cfi_def_cfa_offset 16\n        .cfi_offset 6, -16\n        movq    %rsp, %rbp\n        .cfi_def_cfa_register 6\n        movl    %edi, -4(%rbp)\n        movl    %esi, -8(%rbp)\n        movl    -4(%rbp), %edx\n        movl    -8(%rbp), %eax\n        addl    %edx, %eax\n        popq    %rbp\n        .cfi_def_cfa 7, 8\n        ret\n        .cfi_endproc\n.LFE0:\n        .size   add, .-add\n        .globl  main\n        .type   main, @function\nmain:\n.LFB1:\n        .cfi_startproc\n        pushq   %rbp\n        .cfi_def_cfa_offset 16\n        .cfi_offset 6, -16\n        movq    %rsp, %rbp\n        .cfi_def_cfa_register 6\n        subq    $16, %rsp\n        movl    %edi, -4(%rbp)\n        movq    %rsi, -16(%rbp)\n        movl    $2, %esi\n        movl    $1, %edi\n        call    add\n        movl    $0, %eax\n        leave\n        .cfi_def_cfa 7, 8\n        ret\n        .cfi_endproc\n.LFE1:\n        .size   main, .-main\n        .ident  \"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.10) 5.4.0 20160609\"\n        .section        .note.GNU-stack,\"\",@progbits\n```\n\n## 汇编\n\n汇编这一步是将汇编代码编译成机器语言:\n\n> gcc -c test.s -o test.o\n\n生成的test.o文件里面就是机器代码了,我们可以通过nm命令来列出test.o里面的符号:\n\n> nm test.o\n\n得到的结果如下:\n\n```\n0000000000000000 T add\n0000000000000014 T main\n```\n\n## 链接\n\n由于我们的例子代码比较简单只有一个test.h和test.h,所以只生成了一个.o文件,其实一般的程序都是由多个模块组合成的.链接这一步就是将多个模块的代码组合成一个可执行程序.我们可以用gcc命令将多个.o文件或者静态库、动态库链接成一个可执行文件:\n\n> gcc test.o -o test\n\n得到的就是可执行文件test了,可以直接用下面命令运行\n\n> ./test\n\n当然是没有任何输出的,因为我们就没有做任何的打印\n\n## 编译so库\n\n当然,在安卓中我们一般不会直接使用C/C++编译出来的可运行文件.用的更多的应该是so库.那要如何编译so库呢?\n\n首先我们需要将test.c中的main函数去掉,因为so库中是不会带有main函数的:\n\n```\n#include \"test.h\"\n\n/**\n * add 方法定义\n */\nint add(int a, int b){\n        return a + b;\n}\n```\n\n然后可以使用下面命令将test.c编译成test.so:\n\n> gcc -shared test.c -o test.so\n\n其实也就是多了个-shared参数,指定编译的结果为动态链接库.\n\n这里是直接将.c文件编译成so,当然也能像之前的例子一样先编译出.o文件再通过链接生成so文件.\n\n当然一般编译动态链接库,我们还会带上-fPIC参数.\n\nfPIC (Position-Independent Code)告诉编译器产生与位置无关代码,即产生的代码中没有绝对地址,全部使用相对地址.故而代码可以被加载器加载到内存的任意位置,都可以正确的执行.不加fPIC编译出来的so,是要再加载时根据加载到的位置再次重定位的.因为它里面的代码并不是位置无关代码.如果被多个应用程序共同使用,那么它们必须每个程序维护一份.so的代码副本了.因为.so被每个程序加载的位置都不同,显然这些重定位后的代码也不同,当然不能共享.\n\n# 交叉编译\n\n通过上面的例子,我们知道了一个C/C++程序是怎么从源代码一步步编译成可运行程序或者so库的.但是我们编译出来的程序或者so库只能在相同系统的电脑上使用.\n\n例如我使用的电脑是Linux系统的,那它编译出来的程序也就只能在Linux上运行,不能在安卓或者Windows上运行.\n\n当然正常情况下不会有人专门去到android系统下编译出程序来给安卓去用.一般我们都是在PC上编译出安卓可用的程序,在给到安卓去跑的.这种是在一个平台上生成另一个平台上的可执行代码的编译方式就叫做交叉编译.\n\n交叉编译有是三个比较重要的概念要先说明一下:\n\n- build : 当前你使用的计算机\n- host : 你的目的是编译出来的程序可以在host上运行\n- target : 普通程序没有这个概念。对于想编译出编译器的人来说此属性决定了新编译器编译出的程序可以运行在哪\n\n如果我们想要交叉编译出安卓可运行的程序或者库的话就不能直接使用gcc去编译了.而需要使用Android NDK提供了的一套交叉编译工具链.\n\n我们首先要下载Android NDK,然后配置好环境变量NDK_ROOT指向NDK的根目录.\n\n然后可以通过下面命令安装交叉编译工具链:\n\n> $NDK_ROOT/build/tools/make-standalone-toolchain.sh \\\n\t--platform=android-19 \\\n\t--install-dir=$HOME/Android/standalone-toolchains/android-toolchain-arm \\\n\t--toolchain=arm-linux-androideabi-4.9 \\\n\t--stl=gnustl\n\n然后我们就能在$HOME/Android/目录下看到安装好的工具链了.进到$HOME/Android/standalone-toolchains/android-toolchain-arm/bin/目录下我们可以看到有arm-linux-androideabi-gcc这个程序.\n\n它就是gcc的安卓交叉编译版本.我们将之前使用gcc去编译的例子全部换成使用它去编译就能编译出运行在安卓上的程序了:\n\n如下面命令生成的so库就能在安卓上通过jni调用了:\n\n>  $HOME/Android/standalone-toolchains/android-toolchain-arm/bin/arm-linux-androideabi-gcc -shared -fPIC test.c -o test.so\n\n我们会将定义下面几个环境变量,将$HOME/Android/standalone-toolchains/放到PATH变量中,这样就可以直接使用arm-linux-androideabi-gcc命令,而不需要输入它的全路径去使用了:\n\n```\nexport TOOLCHAIN_HOME=$HOME/Android/standalone-toolchains/android-toolchain-arm\nexport TOOLCHAIN_SYSROOT=$TOOLCHAIN_HOME/sysroot\nexport PATH=$PATH:$TOOLCHAIN_HOME/bin\n```\n\n设定好之后可以直接用下面命令去编译:\n\n```\narm-linux-androideabi-gcc -shared -fPIC test.c -o test.so\n```\n\n## 不同CPU架构的编译方式\n\n当然安卓也有很多不同的CPU架构,不同CPU架构的程序也是不一定兼容的,相信大家之前在使用Android Studio去编译so的时候也有看到编译出来的库有很多个版本像armeabi、armeabi-v7a、mips、x86等.\n\n那这些不同CPU架构的程序又要如何编译了.\n\n我们可以在$NDK_ROOT/toolchains目录下看到者几个目录:\n\n```\narm-linux-androideabi-4.9\naarch64-linux-android-4.9\nmipsel-linux-android-4.9\nmips64el-linux-android-4.9\nx86-4.9\nx86_64-4.9\n```\n\n这就是不同CPU架构的交叉编译工具链了.还记得我们安装工具链的命令吗?\n\n> $NDK_ROOT/build/tools/make-standalone-toolchain.sh \\\n\t--platform=android-19 \\\n\t--install-dir=$HOME/Android/standalone-toolchains/android-toolchain-arm \\\n\t--toolchain=arm-linux-androideabi-4.9 \\\n\t--stl=gnustl\n\ntoolchain参数就能指定使用哪个工具链,然后就能使用该工具链去编译该架构版本的程序了.\n\n但是,我们看到这下面并没有armeabi-v7a的工具链,那armeabi-v7a的程序要如何编译呢?\n\n其实armeabi-v7a的程序也是用arm-linux-androideabi-4.9去编译的,只不过在编译的时候可以带上-march=armv7-a:\n\n> arm-linux-androideabi-gcc -march=armv7-a -shared -fPIC test.c -o test.so\n\n## 官方文档\n\n我这边其实只是简要的介绍了下NDK的基本用法而已,更多的用法大家可以到[官方文档](https://developer.android.com/ndk/guides/standalone_toolchain?hl=zh-cn)上查找.\n\n# Makefile\n\n理解完C/C++编译的原理之后,还有个十分重要的东西还要了解,这个东西就是Makefile.\n\n我们前面的例子都是直接用gcc或着各个交叉编译的版本的gcc去编译C/C++代码的.在代码量不多的时候这么做还是可行的,但是如果软件一旦复杂一些,代码量一多,那么编译的命令就会十分的复杂,而且还需要考虑到多个模块之间的依赖关系.\n\nMakefile就是一个帮助我们解决这些问题的工具.它的基本原理十分简单,先让我们看看它最最基本的用法:\n\n```\n目标文件 : 依赖文件\n\t命令1\n  命令2\n  命令3\n  ...\n```\n\n还是举我们的例子代码,首先创建一个文件,名字叫Makefile,然后写上:\n\n```\ntest.so : test.c test.h                                                          \n    arm-linux-androideabi-gcc -march=armv7-a -shared -fPIC test.c -o test.so\n```\n\n然后就可以用make命令去编译了.make命令会找到当前目录下的Makefile,然后比较目标文件文件和依赖文件的修改时间,如果依赖文件的修改时间比较晚,或者干脆就还没有目标文件.就会执行命令.\n\n如我们的例子,如果还没有test.so,或者test.c、test.h的修改时间比test.so要晚,那么就会执行arm-linux-androideabi-gcc -march=armv7-a -shared -fPIC test.c -o test.so,然后生成test.so文件.\n\n而如果是目标文件比较新,就不会执行,它会告诉你目标文件已经是最新的了:\n\n```\nmake: 'test.so' is up to date.\n```\n\n## 没有依赖的目标文件\n\n然后可能有同学还有见过make clean,make install,make uninstall...这些命令,它们又是怎么一回事呢?\n\n这里以make clean举例,我们在Makefile中加入目标文件clean:\n\n```\ntest.so : test.c test.h\n    arm-linux-androideabi-gcc -march=armv7-a -shared -fPIC test.c -o test.so\n\nclean :\n    rm test.so\n```\n\n现在除了test.so这个目标文件之后,还多了个目标文件clean,它下面的命令是tm test.so.而且特殊的是clean这个目标文件,它没有任何的依赖文件.\n\n然后我们就能使用make clean命令了,因为clean文件不存在,所以就会执行下面的rm test.so.所以就会将test.so删除了.\n\n刚刚我们说的时候clean存在的时候会执行命令,那如果我们自己创建了个文件名字叫做clean又会发生什么事情?\n\n```\nmake: 'clean' is up to date.\n```\n\n由于没有依赖文件,所以不用比较时间,它会直接告诉你clean文件已经是最新的了,而不会执行命令.\n\n那要如果规避这个问题呢?例如当前目录下的确需要有个clean文件,但是我又需要make clean这个功能.方法很简单,只需要加上\".PHONY : clean\"就可以了:\n\n```\ntest.so : test.c test.h\n    arm-linux-androideabi-gcc -march=armv7-a -shared -fPIC test.c -o test.so\n\nclean :\n    rm test.so\n\n.PHONY : clean\n```\n\n## Makefile自动生成工具\n\nMakefile,这里我也只是简单代过,其实它还有许多强大的功能,感兴趣的同学可以自行搜索.\n\n但是如果我们的项目都是手动去写makefile的话也会十分的麻烦,那有没有办法可以根据我们的代码,自动生成makefile呢?\n\n答案肯定是有的.比如现在安卓使用的CMake还有经典的AutoMake工具.\n\n相信大家在用JNI的时候肯定都有配过CMakeLists.txt这个文件,CMake就是通过读取这个文件的配置去生成代码的.\n\n而一些比较早期的库如ffmpeg,就是用automake去生成Makefile的,我之前写过四篇博客专门将如何使用AutoMake,如果感兴趣可以去看看.\n\n- [automake学习笔记 - helloworld](http://blog.islinjw.cn/2017/03/17/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-helloworld/)\n- [automake学习笔记 - 模块化编译](http://blog.islinjw.cn/2017/03/21/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E8%AF%91/)\n- [automake学习笔记 - 安装与发布](http://blog.islinjw.cn/2017/03/26/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8F%91%E5%B8%83/)\n- [automake学习笔记 - 交叉编译](http://blog.islinjw.cn/2017/04/02/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/)\n\n自动生成工具这块内容比较多我就不详细讲了,它们其实并不是很难,大家自行找资料学习就好.\n","source":"_posts/写给安卓程序员的cc-编译入门.md","raw":"title: 写给安卓程序员的C/C++编译入门\ndate: 2018-07-29 19:01:45\ntags:\n    - 技术相关\n    - Android\n    - C/C++\n---\n\n最近部门新入职了几个小鲜肉,打算给他们分享下一些C/C++编译的基础知识,于是整理了一些资料写了这篇博客.由于已经有差不多一年没有写c++了,可能会有一些不太正确的地方,希望哪位同学看到能够帮忙指出,免得误人子弟.\n\n首先需要声明的是,我用的是Ubuntu系统,也是基于Linux去讲的,当然大家如果是用的Mac系统,其实可以无缝切换,用几乎完全一样的命令去跑.但是如果是Windows的同学,可能就不太适用了.\n\n不过其实我还是鼓励大家用Linux系统或者Mac系统去编译C/C++程序.因为大多数流行库都是在linux下面写的,使用Linux或者Mac交叉编译出安卓的可用程序都比较方便.\n\n# 为什么要学C/C++编译\n\n很多的安卓程序员可能都会用Android Studio写一些简单的C/C++代码,然后通过jni去调用,但是对C/C++是如何编译的其实并没有什么概念.有人可能会问,为什么安卓程序员会需要了解C/C++是如何编译的呢?我一直都认为,要成为一个真正的高级安卓应用开发工程师,安卓源码和C/C++是两座绕不过的大山.安卓源码自然不必多说,而C/C++流行了几十年,存在着许多优秀的开源项目,我们在处理一些特定的需求的时候,可能会需要使用到它们.如脚本语言Lua,计算机视觉库OpenCV,音视频编解码库ffmpeg,谷歌的gRPC,国产游戏引擎Cocos2dx...有些库提供了完整的安卓接口,有些提供了部分安卓接口,有些则没有.在做一些高级功能时,我们常常需要使用源码,通过裁剪和交叉编译,才能编译出可以在安卓上使用的so库.总之,安卓做深做精总避不开C/C++交叉编译.\n\n# C/C++编译器\n\n类似java编译器javac可以将java代码编译成class文件,C/C++也有gcc、g++、clang等多种编译器可以用于编译C/C++代码.这里我们用gcc来举例.\n\ngcc原名为GNU C 语言编译器(GNU C Compiler),因为它原本只能处理C语言.但GCC很快地扩展,变得可处理C++。后来又扩展能够支持更多编程语言,如Fortran、Pascal、Objective-C、Java、Ada、Go以及各类处理器架构上的汇编语言等,所以改名GNU编译器套件(GNU Compiler Collection).\n\n我这篇文章的例子都是Ubuntu上编译的.使用Ubuntu系统的同学可以使用下面命令安装gcc:\n\n> sudo apt-get install gcc\n\n如果是CentOS使用yum去安装:\n\n> yum install gcc\n\nMac系统的话可以用HomeBrew来安装,HomeBrew的安装方法我就不说了,大家可以自己搜索:\n\n> brew install gcc\n\n而使用Windows的同学,需要自己搜索下MinGw是如何安装的,MinGw 是 Minimal GNU on Windows 的缩写.\n\n使用gcc其实只需要一个命令就能将一个c文件编译成可运行程序了:\n\n> gcc test.c -o test\n\n通过上面这条命令可以将test.c编译成可运行程序test.但是其实C/C++的编译是经过了好几个步骤的,我这边先给大家大概的讲一讲.\n\n# C/C++的编译流程\n\nC/C++的编译可以分为下面几个步骤:\n\n{% img /写给安卓程序员的cc-编译入门/1.png %}\n\n## 预处理\n\n相信学过C/C++的同学都知道\"宏\"这个东西,它在编译的时候会被展开替换成实际的代码,这个展开的步骤就是在预处理的时候进行的.当然,预处理并不仅仅只是做宏的展开,它还做了类似头文件插入、删除注释等操作.\n\n预处理之后的产品依然还是C/C++代码,它在代码的逻辑上和输入的C/C++源代码是完全一样的.\n\n我们来举一个简单的例子,写一个test.h文件和一个test.c文件:\n\n```\n//test.h\n#ifndef TEST_H            \n#define TEST_H\n\n#define A 1     \n#define B 2        \n\n/**\n * add 方法的声明\n */               \nint add(int a, int b);\n\n#endif\n```\n\n```\n//test.c\n#include \"test.h\"\n\n/**\n * add 方法定义\n */\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint main(int argc,char* argv[]) {\n    add(A, B);\n    return 0;                 \n}\n```\n\n然后可以通过下面这个gcc命令预处理test.c文件,并且把预处理结果写到test.i:\n\n> gcc -E test.c -o test.i\n\n然后就能看到预处理之后的test.c到底长什么样子了:\n\n```\n# 1 \"test.c\"\n# 1 \"<built-in>\"\n# 1 \"<command-line>\"\n# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n# 1 \"<command-line>\" 2\n# 1 \"test.c\"\n# 1 \"test.h\" 1\n# 11 \"test.h\"\nint add(int a, int b);\n# 2 \"test.c\" 2\n\nint add(int a, int b){\n return a + b;\n}\n\nint main(int argc,char* argv[]) {\n add(1, 2);\n return 0;\n}\n```\n\n可以看到这里它把test.h的内容(add方法的声明)插入到了test.c的代码中,然后将A、B两个宏展开成了1和2,将注释去掉了,还在头部加上了一些信息.\n\n但是光看代码逻辑,和之前我们写的代码是完全一样的.\n\n## 汇编\n\n可能大家都听过汇编语言这个东西,但是年轻一点的同学不一定真正见过.简单来说汇编语言是将机器语言符号化了的语言,是机器不能直接识别的低级语言.我们可以通过下面的命令,将预处理后的代码编译成汇编语言:\n\n> gcc -S test.i -o test.s\n\n然后就能看到生成的test.s文件了,里面就是我们写的c语言代码翻译而成的汇编代码:\n\n```\n        .file   \"test.c\"\n        .text\n        .globl  add\n        .type   add, @function\nadd:\n.LFB0:\n        .cfi_startproc\n        pushq   %rbp\n        .cfi_def_cfa_offset 16\n        .cfi_offset 6, -16\n        movq    %rsp, %rbp\n        .cfi_def_cfa_register 6\n        movl    %edi, -4(%rbp)\n        movl    %esi, -8(%rbp)\n        movl    -4(%rbp), %edx\n        movl    -8(%rbp), %eax\n        addl    %edx, %eax\n        popq    %rbp\n        .cfi_def_cfa 7, 8\n        ret\n        .cfi_endproc\n.LFE0:\n        .size   add, .-add\n        .globl  main\n        .type   main, @function\nmain:\n.LFB1:\n        .cfi_startproc\n        pushq   %rbp\n        .cfi_def_cfa_offset 16\n        .cfi_offset 6, -16\n        movq    %rsp, %rbp\n        .cfi_def_cfa_register 6\n        subq    $16, %rsp\n        movl    %edi, -4(%rbp)\n        movq    %rsi, -16(%rbp)\n        movl    $2, %esi\n        movl    $1, %edi\n        call    add\n        movl    $0, %eax\n        leave\n        .cfi_def_cfa 7, 8\n        ret\n        .cfi_endproc\n.LFE1:\n        .size   main, .-main\n        .ident  \"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.10) 5.4.0 20160609\"\n        .section        .note.GNU-stack,\"\",@progbits\n```\n\n## 汇编\n\n汇编这一步是将汇编代码编译成机器语言:\n\n> gcc -c test.s -o test.o\n\n生成的test.o文件里面就是机器代码了,我们可以通过nm命令来列出test.o里面的符号:\n\n> nm test.o\n\n得到的结果如下:\n\n```\n0000000000000000 T add\n0000000000000014 T main\n```\n\n## 链接\n\n由于我们的例子代码比较简单只有一个test.h和test.h,所以只生成了一个.o文件,其实一般的程序都是由多个模块组合成的.链接这一步就是将多个模块的代码组合成一个可执行程序.我们可以用gcc命令将多个.o文件或者静态库、动态库链接成一个可执行文件:\n\n> gcc test.o -o test\n\n得到的就是可执行文件test了,可以直接用下面命令运行\n\n> ./test\n\n当然是没有任何输出的,因为我们就没有做任何的打印\n\n## 编译so库\n\n当然,在安卓中我们一般不会直接使用C/C++编译出来的可运行文件.用的更多的应该是so库.那要如何编译so库呢?\n\n首先我们需要将test.c中的main函数去掉,因为so库中是不会带有main函数的:\n\n```\n#include \"test.h\"\n\n/**\n * add 方法定义\n */\nint add(int a, int b){\n        return a + b;\n}\n```\n\n然后可以使用下面命令将test.c编译成test.so:\n\n> gcc -shared test.c -o test.so\n\n其实也就是多了个-shared参数,指定编译的结果为动态链接库.\n\n这里是直接将.c文件编译成so,当然也能像之前的例子一样先编译出.o文件再通过链接生成so文件.\n\n当然一般编译动态链接库,我们还会带上-fPIC参数.\n\nfPIC (Position-Independent Code)告诉编译器产生与位置无关代码,即产生的代码中没有绝对地址,全部使用相对地址.故而代码可以被加载器加载到内存的任意位置,都可以正确的执行.不加fPIC编译出来的so,是要再加载时根据加载到的位置再次重定位的.因为它里面的代码并不是位置无关代码.如果被多个应用程序共同使用,那么它们必须每个程序维护一份.so的代码副本了.因为.so被每个程序加载的位置都不同,显然这些重定位后的代码也不同,当然不能共享.\n\n# 交叉编译\n\n通过上面的例子,我们知道了一个C/C++程序是怎么从源代码一步步编译成可运行程序或者so库的.但是我们编译出来的程序或者so库只能在相同系统的电脑上使用.\n\n例如我使用的电脑是Linux系统的,那它编译出来的程序也就只能在Linux上运行,不能在安卓或者Windows上运行.\n\n当然正常情况下不会有人专门去到android系统下编译出程序来给安卓去用.一般我们都是在PC上编译出安卓可用的程序,在给到安卓去跑的.这种是在一个平台上生成另一个平台上的可执行代码的编译方式就叫做交叉编译.\n\n交叉编译有是三个比较重要的概念要先说明一下:\n\n- build : 当前你使用的计算机\n- host : 你的目的是编译出来的程序可以在host上运行\n- target : 普通程序没有这个概念。对于想编译出编译器的人来说此属性决定了新编译器编译出的程序可以运行在哪\n\n如果我们想要交叉编译出安卓可运行的程序或者库的话就不能直接使用gcc去编译了.而需要使用Android NDK提供了的一套交叉编译工具链.\n\n我们首先要下载Android NDK,然后配置好环境变量NDK_ROOT指向NDK的根目录.\n\n然后可以通过下面命令安装交叉编译工具链:\n\n> $NDK_ROOT/build/tools/make-standalone-toolchain.sh \\\n\t--platform=android-19 \\\n\t--install-dir=$HOME/Android/standalone-toolchains/android-toolchain-arm \\\n\t--toolchain=arm-linux-androideabi-4.9 \\\n\t--stl=gnustl\n\n然后我们就能在$HOME/Android/目录下看到安装好的工具链了.进到$HOME/Android/standalone-toolchains/android-toolchain-arm/bin/目录下我们可以看到有arm-linux-androideabi-gcc这个程序.\n\n它就是gcc的安卓交叉编译版本.我们将之前使用gcc去编译的例子全部换成使用它去编译就能编译出运行在安卓上的程序了:\n\n如下面命令生成的so库就能在安卓上通过jni调用了:\n\n>  $HOME/Android/standalone-toolchains/android-toolchain-arm/bin/arm-linux-androideabi-gcc -shared -fPIC test.c -o test.so\n\n我们会将定义下面几个环境变量,将$HOME/Android/standalone-toolchains/放到PATH变量中,这样就可以直接使用arm-linux-androideabi-gcc命令,而不需要输入它的全路径去使用了:\n\n```\nexport TOOLCHAIN_HOME=$HOME/Android/standalone-toolchains/android-toolchain-arm\nexport TOOLCHAIN_SYSROOT=$TOOLCHAIN_HOME/sysroot\nexport PATH=$PATH:$TOOLCHAIN_HOME/bin\n```\n\n设定好之后可以直接用下面命令去编译:\n\n```\narm-linux-androideabi-gcc -shared -fPIC test.c -o test.so\n```\n\n## 不同CPU架构的编译方式\n\n当然安卓也有很多不同的CPU架构,不同CPU架构的程序也是不一定兼容的,相信大家之前在使用Android Studio去编译so的时候也有看到编译出来的库有很多个版本像armeabi、armeabi-v7a、mips、x86等.\n\n那这些不同CPU架构的程序又要如何编译了.\n\n我们可以在$NDK_ROOT/toolchains目录下看到者几个目录:\n\n```\narm-linux-androideabi-4.9\naarch64-linux-android-4.9\nmipsel-linux-android-4.9\nmips64el-linux-android-4.9\nx86-4.9\nx86_64-4.9\n```\n\n这就是不同CPU架构的交叉编译工具链了.还记得我们安装工具链的命令吗?\n\n> $NDK_ROOT/build/tools/make-standalone-toolchain.sh \\\n\t--platform=android-19 \\\n\t--install-dir=$HOME/Android/standalone-toolchains/android-toolchain-arm \\\n\t--toolchain=arm-linux-androideabi-4.9 \\\n\t--stl=gnustl\n\ntoolchain参数就能指定使用哪个工具链,然后就能使用该工具链去编译该架构版本的程序了.\n\n但是,我们看到这下面并没有armeabi-v7a的工具链,那armeabi-v7a的程序要如何编译呢?\n\n其实armeabi-v7a的程序也是用arm-linux-androideabi-4.9去编译的,只不过在编译的时候可以带上-march=armv7-a:\n\n> arm-linux-androideabi-gcc -march=armv7-a -shared -fPIC test.c -o test.so\n\n## 官方文档\n\n我这边其实只是简要的介绍了下NDK的基本用法而已,更多的用法大家可以到[官方文档](https://developer.android.com/ndk/guides/standalone_toolchain?hl=zh-cn)上查找.\n\n# Makefile\n\n理解完C/C++编译的原理之后,还有个十分重要的东西还要了解,这个东西就是Makefile.\n\n我们前面的例子都是直接用gcc或着各个交叉编译的版本的gcc去编译C/C++代码的.在代码量不多的时候这么做还是可行的,但是如果软件一旦复杂一些,代码量一多,那么编译的命令就会十分的复杂,而且还需要考虑到多个模块之间的依赖关系.\n\nMakefile就是一个帮助我们解决这些问题的工具.它的基本原理十分简单,先让我们看看它最最基本的用法:\n\n```\n目标文件 : 依赖文件\n\t命令1\n  命令2\n  命令3\n  ...\n```\n\n还是举我们的例子代码,首先创建一个文件,名字叫Makefile,然后写上:\n\n```\ntest.so : test.c test.h                                                          \n    arm-linux-androideabi-gcc -march=armv7-a -shared -fPIC test.c -o test.so\n```\n\n然后就可以用make命令去编译了.make命令会找到当前目录下的Makefile,然后比较目标文件文件和依赖文件的修改时间,如果依赖文件的修改时间比较晚,或者干脆就还没有目标文件.就会执行命令.\n\n如我们的例子,如果还没有test.so,或者test.c、test.h的修改时间比test.so要晚,那么就会执行arm-linux-androideabi-gcc -march=armv7-a -shared -fPIC test.c -o test.so,然后生成test.so文件.\n\n而如果是目标文件比较新,就不会执行,它会告诉你目标文件已经是最新的了:\n\n```\nmake: 'test.so' is up to date.\n```\n\n## 没有依赖的目标文件\n\n然后可能有同学还有见过make clean,make install,make uninstall...这些命令,它们又是怎么一回事呢?\n\n这里以make clean举例,我们在Makefile中加入目标文件clean:\n\n```\ntest.so : test.c test.h\n    arm-linux-androideabi-gcc -march=armv7-a -shared -fPIC test.c -o test.so\n\nclean :\n    rm test.so\n```\n\n现在除了test.so这个目标文件之后,还多了个目标文件clean,它下面的命令是tm test.so.而且特殊的是clean这个目标文件,它没有任何的依赖文件.\n\n然后我们就能使用make clean命令了,因为clean文件不存在,所以就会执行下面的rm test.so.所以就会将test.so删除了.\n\n刚刚我们说的时候clean存在的时候会执行命令,那如果我们自己创建了个文件名字叫做clean又会发生什么事情?\n\n```\nmake: 'clean' is up to date.\n```\n\n由于没有依赖文件,所以不用比较时间,它会直接告诉你clean文件已经是最新的了,而不会执行命令.\n\n那要如果规避这个问题呢?例如当前目录下的确需要有个clean文件,但是我又需要make clean这个功能.方法很简单,只需要加上\".PHONY : clean\"就可以了:\n\n```\ntest.so : test.c test.h\n    arm-linux-androideabi-gcc -march=armv7-a -shared -fPIC test.c -o test.so\n\nclean :\n    rm test.so\n\n.PHONY : clean\n```\n\n## Makefile自动生成工具\n\nMakefile,这里我也只是简单代过,其实它还有许多强大的功能,感兴趣的同学可以自行搜索.\n\n但是如果我们的项目都是手动去写makefile的话也会十分的麻烦,那有没有办法可以根据我们的代码,自动生成makefile呢?\n\n答案肯定是有的.比如现在安卓使用的CMake还有经典的AutoMake工具.\n\n相信大家在用JNI的时候肯定都有配过CMakeLists.txt这个文件,CMake就是通过读取这个文件的配置去生成代码的.\n\n而一些比较早期的库如ffmpeg,就是用automake去生成Makefile的,我之前写过四篇博客专门将如何使用AutoMake,如果感兴趣可以去看看.\n\n- [automake学习笔记 - helloworld](http://blog.islinjw.cn/2017/03/17/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-helloworld/)\n- [automake学习笔记 - 模块化编译](http://blog.islinjw.cn/2017/03/21/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E8%AF%91/)\n- [automake学习笔记 - 安装与发布](http://blog.islinjw.cn/2017/03/26/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8F%91%E5%B8%83/)\n- [automake学习笔记 - 交叉编译](http://blog.islinjw.cn/2017/04/02/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/)\n\n自动生成工具这块内容比较多我就不详细讲了,它们其实并不是很难,大家自行找资料学习就好.\n","slug":"写给安卓程序员的cc-编译入门","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2umz001lw3fyp86migbh"},{"title":"再谈Java泛型","date":"2018-02-04T09:37:01.000Z","_content":"\n\n之前其实已经写过一篇泛型的文章[《java泛型那些事》](http://blog.islinjw.cn/2018/01/06/java%E6%B3%9B%E5%9E%8B%E9%82%A3%E4%BA%9B%E4%BA%8B/),但是最近在看《Kotlin极简教程》泛型部分拿java和Kotlin对比泛型机制异同的时候,又发现了一些关于java泛型的,我之前不知道的知识。这里再把它们记录下来。\n\n# 关于泛型通配符\n\n## 关于<? extends T>\n\n首先假设有下面的一个list:\n\n```\nList<? extends Number> list = new ArrayList<>();\n```\n\n我们是不能向它添加除null以外的任意对象的,即使是Number的子类:\n\n```\nlist.add(null); // ok\nlist.add(new Integer(1)); // error\nlist.add(new Float(1.0f)); // error\n```\n\n这是为什么呢?我们来再来看下面的代码:\n\n```\nList<Integer> listOri = new ArrayList<>();\nList<? extends Number> list = listOri;\n```\n\nlistOri中只能存放Integer。\n\n但是假设我们能向List<? extends Number>中添加Number的子类,那么我们就能将Float、Double这样的非Integer的类放到list中。\n\n这样的话我们就会打破listOri中的类型一致性。而只有将null,放到list中不会打破listOri的类型一致性。\n\n## 关于<? super T>\n\n和上面的<? extends T>不同,我们可以向List<? super Number>中加入null和Number的任意子对象:\n\n```\nList<? super Number> list = listOri;\nlist.add(null); // ok\nlist.add(new Integer(1)); // ok\nlist.add(new Float(1.0f)); // ok\nlist.add(new Object()); // error\n```\n\n因为List<? super Number>中存放的都是Number的父类,而Number的子类都可以转化成Number,也就可以转化成Number的这个父类。所以就能保证list中类型的一致性。\n\n# Collection方法中的Object参数\n\n我有注意到Map的一些方法的参数并不是泛型参数,而是Object：\n\n```\nboolean containsKey(Object key);\nboolean containsValue(Object value);\nV get(Object key);\nV remove(Object key);\n...\n```\n\n其实不止Map包括其他的容器其实都是一样的,我们能在Collectiond接口中看到下面的方法:\n\n```\nboolean remove(Object o);\nboolean contains(Object o);\n...\n```\n\n它们都不是用泛型参数,而是直接用的Object,这是为什么呢?\n\nJava 集合框架创办人，Josh Bloch 是这么说的:\n\n> Josh Bloch says (6:41) that they attempted to generify the get method of Map, remove method and some other, but \"it simply didn't work\". There are too many reasonable programs that could not be generified if you only allow the generic type of the collection as parameter type. The example given by him is an intersection of a List of Numbers and a List of Longs.\n\n他们其实有想过用泛型参数去实现Map的get方法,但是出现了一些状况导致它出问题了,比如说用List<Number>做Key,但却想用List<Long>来get。\n\nstackoverflow上也有大神这么说:\n\n```\nActually, it's very simple! If add() took a wrong object, it would break the collection. It would contain things it's not supposed to! That is not the case for remove(), or contains(). – Kevin Bourrillion Nov 7 '09 at 3:46\n\nIncidentally, that basic rule -- using type parameters to prevent actual damage to the collection only -- is followed absolutely consistently in the whole library.  – Kevin Bourrillion Nov 7 '09 at 3:49\n```\n\n因为像add方法这样的往集合中添加元素的方法,如果用Object参数的话,会破坏集合中的类型安全性。但是像remove(),contains()这些方法其实只需要equals成立即可,不需要限制类型。java库的原则就是只用类型参数去保护集合的类型安全性不会被破坏,不做多余的事情。\n","source":"_posts/再谈Java泛型.md","raw":"title: 再谈Java泛型\ndate: 2018-02-04 17:37:01\ntags:\n\t- 技术相关\n\t- java\n---\n\n\n之前其实已经写过一篇泛型的文章[《java泛型那些事》](http://blog.islinjw.cn/2018/01/06/java%E6%B3%9B%E5%9E%8B%E9%82%A3%E4%BA%9B%E4%BA%8B/),但是最近在看《Kotlin极简教程》泛型部分拿java和Kotlin对比泛型机制异同的时候,又发现了一些关于java泛型的,我之前不知道的知识。这里再把它们记录下来。\n\n# 关于泛型通配符\n\n## 关于<? extends T>\n\n首先假设有下面的一个list:\n\n```\nList<? extends Number> list = new ArrayList<>();\n```\n\n我们是不能向它添加除null以外的任意对象的,即使是Number的子类:\n\n```\nlist.add(null); // ok\nlist.add(new Integer(1)); // error\nlist.add(new Float(1.0f)); // error\n```\n\n这是为什么呢?我们来再来看下面的代码:\n\n```\nList<Integer> listOri = new ArrayList<>();\nList<? extends Number> list = listOri;\n```\n\nlistOri中只能存放Integer。\n\n但是假设我们能向List<? extends Number>中添加Number的子类,那么我们就能将Float、Double这样的非Integer的类放到list中。\n\n这样的话我们就会打破listOri中的类型一致性。而只有将null,放到list中不会打破listOri的类型一致性。\n\n## 关于<? super T>\n\n和上面的<? extends T>不同,我们可以向List<? super Number>中加入null和Number的任意子对象:\n\n```\nList<? super Number> list = listOri;\nlist.add(null); // ok\nlist.add(new Integer(1)); // ok\nlist.add(new Float(1.0f)); // ok\nlist.add(new Object()); // error\n```\n\n因为List<? super Number>中存放的都是Number的父类,而Number的子类都可以转化成Number,也就可以转化成Number的这个父类。所以就能保证list中类型的一致性。\n\n# Collection方法中的Object参数\n\n我有注意到Map的一些方法的参数并不是泛型参数,而是Object：\n\n```\nboolean containsKey(Object key);\nboolean containsValue(Object value);\nV get(Object key);\nV remove(Object key);\n...\n```\n\n其实不止Map包括其他的容器其实都是一样的,我们能在Collectiond接口中看到下面的方法:\n\n```\nboolean remove(Object o);\nboolean contains(Object o);\n...\n```\n\n它们都不是用泛型参数,而是直接用的Object,这是为什么呢?\n\nJava 集合框架创办人，Josh Bloch 是这么说的:\n\n> Josh Bloch says (6:41) that they attempted to generify the get method of Map, remove method and some other, but \"it simply didn't work\". There are too many reasonable programs that could not be generified if you only allow the generic type of the collection as parameter type. The example given by him is an intersection of a List of Numbers and a List of Longs.\n\n他们其实有想过用泛型参数去实现Map的get方法,但是出现了一些状况导致它出问题了,比如说用List<Number>做Key,但却想用List<Long>来get。\n\nstackoverflow上也有大神这么说:\n\n```\nActually, it's very simple! If add() took a wrong object, it would break the collection. It would contain things it's not supposed to! That is not the case for remove(), or contains(). – Kevin Bourrillion Nov 7 '09 at 3:46\n\nIncidentally, that basic rule -- using type parameters to prevent actual damage to the collection only -- is followed absolutely consistently in the whole library.  – Kevin Bourrillion Nov 7 '09 at 3:49\n```\n\n因为像add方法这样的往集合中添加元素的方法,如果用Object参数的话,会破坏集合中的类型安全性。但是像remove(),contains()这些方法其实只需要equals成立即可,不需要限制类型。java库的原则就是只用类型参数去保护集合的类型安全性不会被破坏,不做多余的事情。\n","slug":"再谈Java泛型","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2un3001qw3fy4i5wy3k6"},{"title":"使用hexo搭建个人博客","date":"2016-01-19T13:10:24.000Z","_content":"\n## 一、安装hexo\n\n**1.安装Node.js**\nhexo是一款基于Node.js的静态博客框架，所以要使用它必须先安装Node.js。网上很多教程讲的都是如何编译源码安装Node.js。但我认为应该用最简单的方式取获取和使用软件或者框架，不是每个初学者都需要从一个软件的源代码编译开始学习。当然，在日后想要更深入理解它的时候，挖出它的源代码进行分析也是一种十分有效的途径。\n下面是ubuntu下使用apt-get安装Node.js的方法（源自博客[如何在Ubuntu上安装最新版本的Node.js ](http://blog.csdn.net/chszs/article/details/37521463)）\n1. apt-get update\n2. apt-get install -y python-software-properties software-properties-common\n3. add-apt-repository ppa:chris-lea/node.js\n4. apt-get update\n5. apt-get install nodejs\n\n**2.安装hexo**\n之后安装hexo就更简单了，只需要这一行代码\n\n    npm install hexo -g\n\n**3.更新hexo**\n\n    npm update hexo -g \n    \n<br>\n\n## 二、创建和配置hexo项目\n\n**1.初始化hexo项目**\n\n    hexo init [folder]\n\n如果指定 _folder_，便会在目前的资料夹建立一个名为 _folder_ 的新资料夹，否则会在当前文件夹初始化。\n执行完这条命令，会出现如下提示:\n\n> INFO  You are almost done! Don't forget to run 'npm install' before you start blogging with Hexo!\n\n所以记得执行npm install\n\n\n**2.创建新的文章**\n\n    hexo new \"文章标题\"\n\n执行完创建命令后会生成以下文件:\n\n> source/_posts/文章标题.md\n\n之后只需要在这个markdown文件里面编写自己的博客文章就可以了\n\n**3.添加主题**\n\n有很多人为hexo编写了很多漂亮的主题，可以自己去[主题列表](https://github.com/hexojs/hexo/wiki/Themes)选择\n安装的方法也很简单，这些主题都是托管在github上的，只要把它们克隆到项目文件夹的themes目录下面就可以了。当然还需要去__config.yml修改配置，选择使用哪个主题：\n\n    theme: 主题名\n\n**4.启动服务器**\n\n编写完文章之后只需要运行下面命令就可以在浏览器地址栏输入 http://0.0.0.0:4000 查看自己的博客了\n\n    hexo server\n\n<br>\n\n## 三、配置博客信息\n\n可以在项目根目录下的_config.yml文件配置博客的标题，作者，语言等相关信息\n\n<br>\n\n## 四、部署到Github\n\ngithub提供了一个名叫Github Pages的服务，我们可以免费的用它来搭建自己的博客。\n做法很简单，首先在github建立与你用户名对应的仓库，仓库名必须为 “你的github用户名.github.io” \n\n接着执行以下命令在本机安装hexo-deployer-git\n\n    npm install hexo-deployer-git --save\n\n然后在_config.yml文件，找到下面的内容\n\n    # Deployment\n    ## Docs: http://hexo.io/docs/deployment.html\n    deploy:\n      type:\n\n将它们修改为\n\n    # Deployment\n    ## Docs: http://hexo.io/docs/deployment.html\n    deploy:\n      type: git\n      repository: git@github.com:你的github用户名/你的github用户名.github.io\n      branch: master\n\n最后执行以下三条命令即可：\n\n    hexo clean\n    hexo generate\n    hexo deploy\n\n（当然你必须为你的电脑添加github ssh key才能正常执行hexo deploy命令上传代码）\n\n<br>\n\n## 五、绑定域名\n\n按照github pages的文档，是在github项目根目录下创建CNAME文件。但因为每次使用hexo更新博客再次上传，都会清除掉之前创建的CNAME文件。所以我们把CNAME放在source目录下（想上传的文件都放在该目录下）\n\n完整步骤如下:\n\n1. 在source目录下添加一个CNAM文件，没有后缀名，里面内容为你的域名(如我的是:blog.islinjw.cn)。\n\n2. ping username.github.io记录下IP地址\n\n3. 购买域名，配置域名解析username.github.io的ip地址\n","source":"_posts/使用hexo搭建个人博客.md","raw":"title: 使用hexo搭建个人博客\ndate: 2016-01-19 21:10:24\ntags: \n    - 技术相关\n    - hexo\n---\n\n## 一、安装hexo\n\n**1.安装Node.js**\nhexo是一款基于Node.js的静态博客框架，所以要使用它必须先安装Node.js。网上很多教程讲的都是如何编译源码安装Node.js。但我认为应该用最简单的方式取获取和使用软件或者框架，不是每个初学者都需要从一个软件的源代码编译开始学习。当然，在日后想要更深入理解它的时候，挖出它的源代码进行分析也是一种十分有效的途径。\n下面是ubuntu下使用apt-get安装Node.js的方法（源自博客[如何在Ubuntu上安装最新版本的Node.js ](http://blog.csdn.net/chszs/article/details/37521463)）\n1. apt-get update\n2. apt-get install -y python-software-properties software-properties-common\n3. add-apt-repository ppa:chris-lea/node.js\n4. apt-get update\n5. apt-get install nodejs\n\n**2.安装hexo**\n之后安装hexo就更简单了，只需要这一行代码\n\n    npm install hexo -g\n\n**3.更新hexo**\n\n    npm update hexo -g \n    \n<br>\n\n## 二、创建和配置hexo项目\n\n**1.初始化hexo项目**\n\n    hexo init [folder]\n\n如果指定 _folder_，便会在目前的资料夹建立一个名为 _folder_ 的新资料夹，否则会在当前文件夹初始化。\n执行完这条命令，会出现如下提示:\n\n> INFO  You are almost done! Don't forget to run 'npm install' before you start blogging with Hexo!\n\n所以记得执行npm install\n\n\n**2.创建新的文章**\n\n    hexo new \"文章标题\"\n\n执行完创建命令后会生成以下文件:\n\n> source/_posts/文章标题.md\n\n之后只需要在这个markdown文件里面编写自己的博客文章就可以了\n\n**3.添加主题**\n\n有很多人为hexo编写了很多漂亮的主题，可以自己去[主题列表](https://github.com/hexojs/hexo/wiki/Themes)选择\n安装的方法也很简单，这些主题都是托管在github上的，只要把它们克隆到项目文件夹的themes目录下面就可以了。当然还需要去__config.yml修改配置，选择使用哪个主题：\n\n    theme: 主题名\n\n**4.启动服务器**\n\n编写完文章之后只需要运行下面命令就可以在浏览器地址栏输入 http://0.0.0.0:4000 查看自己的博客了\n\n    hexo server\n\n<br>\n\n## 三、配置博客信息\n\n可以在项目根目录下的_config.yml文件配置博客的标题，作者，语言等相关信息\n\n<br>\n\n## 四、部署到Github\n\ngithub提供了一个名叫Github Pages的服务，我们可以免费的用它来搭建自己的博客。\n做法很简单，首先在github建立与你用户名对应的仓库，仓库名必须为 “你的github用户名.github.io” \n\n接着执行以下命令在本机安装hexo-deployer-git\n\n    npm install hexo-deployer-git --save\n\n然后在_config.yml文件，找到下面的内容\n\n    # Deployment\n    ## Docs: http://hexo.io/docs/deployment.html\n    deploy:\n      type:\n\n将它们修改为\n\n    # Deployment\n    ## Docs: http://hexo.io/docs/deployment.html\n    deploy:\n      type: git\n      repository: git@github.com:你的github用户名/你的github用户名.github.io\n      branch: master\n\n最后执行以下三条命令即可：\n\n    hexo clean\n    hexo generate\n    hexo deploy\n\n（当然你必须为你的电脑添加github ssh key才能正常执行hexo deploy命令上传代码）\n\n<br>\n\n## 五、绑定域名\n\n按照github pages的文档，是在github项目根目录下创建CNAME文件。但因为每次使用hexo更新博客再次上传，都会清除掉之前创建的CNAME文件。所以我们把CNAME放在source目录下（想上传的文件都放在该目录下）\n\n完整步骤如下:\n\n1. 在source目录下添加一个CNAM文件，没有后缀名，里面内容为你的域名(如我的是:blog.islinjw.cn)。\n\n2. ping username.github.io记录下IP地址\n\n3. 购买域名，配置域名解析username.github.io的ip地址\n","slug":"使用hexo搭建个人博客","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2un5001tw3fy8yq4wjdo"},{"title":"从源码看安卓应用的启动过程","date":"2018-03-08T14:24:52.000Z","_content":"\n\n一般来讲安卓中的每个应用都是在一个单独的进程中运行的(当然也能使用android:process指定不同组件运行在不同进程中)。\n\n{% img /从源码看安卓应用的启动过程/1.png %}\n\n我们在上图中可以看到，每一个进程都有一个java虚拟机(Dalvik虚拟机/ART虚拟机)实例。如果每次启动一个应用都需要启动一个新的虚拟机，然后初始化一堆的东西，那应用的启动时间将会变得无比漫长。\n\n那有什么办法优化呢？\n\n假设我们有一个模板进程，每次不需要重新启动，只需要重这个模板进程中拷贝一份出来，是不是就能节省一部分初始化的时间了？Zygote 进程就是这个模板进程。\n\nZygote是受精卵的意思，十分形象的一个比喻。app的进程就是通过fork的方式从Zygote进程克隆出来的，而且使用了写时拷贝的方法，尽可能的复用Zygote进程的资源。fork是UNIX关于进程管理的一个术语,本质是新开一个进程,但是不从磁盘加载代码,而是从内存现有进程复制一份。而写时拷贝是一直只有在修改的时候才会拷贝的策略，这里我就不详细展开他们了，有兴趣的同学可以在网上搜索一下。\n\n说回Zygote进程，他是系统在启动的时候创建的，在启动之后会打开/dev/socket/zygote使用socket去监听启动应用进程的请求。当接收到启动请求的时候就会fork一个子进程出来：\n\n{% img /从源码看安卓应用的启动过程/2.png %}\n\n应用进程是在 ActivityManagerService.startProcessLocked方法里面启动的:\n\n```\nprivate final void startProcessLocked(ProcessRecord app,  String hostingType, String hostingNameStr) {\n    ...\n    Process.ProcessStartResult startResult = Process.start(\"android.app.ActivityThread\",\n                                                          app.processName, uid, uid, gids, debugFlags, mountExternal,\n                                                          app.info.targetSdkVersion, app.info.seinfo, null);\n    ...\n}\n```\n\n我们可以在Process里面看到，它的确是通过socket与Zygote进行交互的:\n\n```\npublic class Process {\n    ...\n    private static final String ZYGOTE_SOCKET = \"zygote\";\n    ...     \n    public static final ProcessStartResult start(final String processClass,\n                                                final String niceName,\n                                                int uid, int gid, int[] gids,\n                                                int debugFlags, int mountExternal,\n                                                int targetSdkVersion,\n                                                String seInfo,\n                                                String[] zygoteArgs) {\n        ...                                          \n        return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, zygoteArgs);\n        ...\n    }\n    ...\n    private static ProcessStartResult startViaZygote(final String processClass,\n                                                    final String niceName,\n                                                    final int uid, final int gid,\n                                                    final int[] gids,\n                                                    int debugFlags, int mountExternal,\n                                                    int targetSdkVersion,\n                                                    String seInfo,\n                                                    String[] extraArgs)\n                                                    throws ZygoteStartFailedEx {\n        ...\n        return zygoteSendArgsAndGetResult(argsForZygote);\n    }\n    ...\n    private static ProcessStartResult zygoteSendArgsAndGetResult(ArrayList<String> args) throws ZygoteStartFailedEx {\n        openZygoteSocketIfNeeded();\n        ...\n        sZygoteWriter.write(Integer.toString(args.size())); 、\n        sZygoteWriter.newLine();\n        int sz = args.size();\n        for (int i = 0; i < sz; i++) {\n            String arg = args.get(i);\n            if (arg.indexOf('\\n') >= 0) {\n                throw new ZygoteStartFailedEx(\"embedded newlines not allowed\");\n            }\n            sZygoteWriter.write(arg);\n            sZygoteWriter.newLine();\n        }\n\n        sZygoteWriter.flush();\n\n        // Should there be a timeout on this?\n        ProcessStartResult result = new ProcessStartResult();\n        result.pid = sZygoteInputStream.readInt();\n        if (result.pid < 0) {\n            throw new ZygoteStartFailedEx(\"fork() failed\");\n        }\n        result.usingWrapper = sZygoteInputStream.readBoolean();\n        ...\n    }\n    ...\n    private static void openZygoteSocketIfNeeded() throws ZygoteStartFailedEx {\n        ...\n        sZygoteSocket = new LocalSocket();\n        sZygoteSocket.connect(new LocalSocketAddress(ZYGOTE_SOCKET,\n        LocalSocketAddress.Namespace.RESERVED));\n        ...\n    }\n}\n```\n\n那zygote进程通过socket监听到请求之后又做了什么呢？ZygoteInit.runSelectLoop就是用来监听socket请求我们看看源码，其实它是在一个while死循环里不断select socket消息:\n\n```\nprivate static void runSelectLoop() throws MethodAndArgsCaller {\n    ArrayList<FileDescriptor> fds = new ArrayList<FileDescriptor>();\n    ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();\n    FileDescriptor[] fdArray = new FileDescriptor[4];\n\n    fds.add(sServerSocket.getFileDescriptor());\n    peers.add(null);\n\n    int loopCount = GC_LOOP_COUNT;\n    while (true) {\n        int index;\n\n        /*\n        * Call gc() before we block in select().\n        * It's work that has to be done anyway, and it's better\n        * to avoid making every child do it. It will also\n        * madvise() any free memory as a side-effect.\n        *\n        * Don't call it every time, because walking the entire\n        * heap is a lot of overhead to free a few hundred bytes.\n        */\n        if (loopCount <= 0) {\n            gc();\n            loopCount = GC_LOOP_COUNT;\n        } else {\n            loopCount--;   \n        }\n\n\n        try {\n            fdArray = fds.toArray(fdArray);\n            index = selectReadable(fdArray);\n        } catch (IOException ex) {\n            throw new RuntimeException(\"Error in select()\", ex);\n        }\n\n        if (index < 0) {\n            throw new RuntimeException(\"Error in select()\");\n        } else if (index == 0) {\n            ZygoteConnection newPeer = acceptCommandPeer();\n            peers.add(newPeer);\n            fds.add(newPeer.getFileDesciptor());\n        } else {\n            boolean done;\n            done = peers.get(index).runOnce();\n\n            if (done) {\n                peers.remove(index);\n                fds.remove(index);\n            }\n        }\n    }\n}\n```\n\n接收到消息之后会调ZygoteConnection.runOnce，在这个方法里面调用了Zygote.forkAndSpecialize方法去fork一个进程，这里我们就不再深入了。我们继续跟踪下去发现他又调了ZygoteInit.invokeStaticMain:\n\n```\nboolean runOnce() throws ZygoteInit.MethodAndArgsCaller {\n    ...\n    pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,\n    parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,\n    parsedArgs.niceName);\n    ...\n    handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);\n    ...\n}\n\nprivate void handleChildProc(Arguments parsedArgs,\n                            FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)\n                            throws ZygoteInit.MethodAndArgsCaller {\n    ...\n    ZygoteInit.invokeStaticMain(cloader, className, mainArgs);\n    ...\n}\n```\n\nZygoteInit.invokeStaticMain的方法比较短，我就全部复制上来了，可以看到，这里用反射的方式调用了main方法，也就是ActivityThread.main:\n\n```\nstatic void invokeStaticMain(ClassLoader loader,\n                            String className, String[] argv)\n                            throws ZygoteInit.MethodAndArgsCaller {\n    Class<?> cl;\n\n    try {\n        cl = loader.loadClass(className);\n    } catch (ClassNotFoundException ex) {\n        throw new RuntimeException(\n                          \"Missing class when invoking static main \" + className,\n                          ex);\n    }\n\n    Method m;\n    try {\n        m = cl.getMethod(\"main\", new Class[] { String[].class });\n    } catch (NoSuchMethodException ex) {\n        throw new RuntimeException(\n                          \"Missing static main on \" + className, ex);\n    } catch (SecurityException ex) {\n        throw new RuntimeException(\n                          \"Problem getting static main on \" + className, ex);\n    }\n\n    int modifiers = m.getModifiers();\n    if (! (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers))) {\n        throw new RuntimeException(\n                          \"Main method is not public and static on \" + className);\n    }\n\n    /*\n    * This throw gets caught in ZygoteInit.main(), which responds\n    * by invoking the exception's run() method. This arrangement\n    * clears up all the stack frames that were required in setting\n    * up the process.\n    */\n    throw new ZygoteInit.MethodAndArgsCaller(m, argv);\n}\n```\n\n然后就到了ActivityThread.main方法，可以看到在这个方法里面初始化了sMainThreadHandler和Looper。这个就是主线程Handler对应的Looper了:\n\n```\npublic static void main(String[] args) {\n    SamplingProfilerIntegration.start();\n\n    // CloseGuard defaults to true and can be quite spammy. We\n    // disable it here, but selectively enable it later (via\n    // StrictMode) on debug builds, but using DropBox, not logs.\n    CloseGuard.setEnabled(false);\n\n    Environment.initForCurrentUser();\n\n    // Set the reporter for event logging in libcore\n    EventLogger.setReporter(new EventLoggingReporter());\n\n    Security.addProvider(new AndroidKeyStoreProvider());\n\n    Process.setArgV0(\"<pre-initialized>\");\n\n    Looper.prepareMainLooper();\n\n    ActivityThread thread = new ActivityThread();\n    thread.attach(false);\n\n    if (sMainThreadHandler == null) {\n        sMainThreadHandler = thread.getHandler();\n    }\n\n    AsyncTask.init();\n\n    if (false) {\n        Looper.myLooper().setMessageLogging(new\n        LogPrinter(Log.DEBUG, \"ActivityThread\"));\n    }\n\n    Looper.loop();\n\n    throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n}\n```\n\n于是乎一个应用的主线程就这样启动了，接下来就是ActivityManagerService通过Binder机制去让ActivityThread用Hander同步创建主Activity，并且调用Activity生命周期了。这部分最近有写过一篇博客[《从源码看Activity生命周期》](http://blog.islinjw.cn/2018/03/07/%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9C%8BActivity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/)感兴趣的同学可以去看看。\n","source":"_posts/从源码看安卓应用的启动过程.md","raw":"title: 从源码看安卓应用的启动过程\ndate: 2018-03-08 22:24:52\ntags:\n\t- 技术相关\n  - Android\n---\n\n\n一般来讲安卓中的每个应用都是在一个单独的进程中运行的(当然也能使用android:process指定不同组件运行在不同进程中)。\n\n{% img /从源码看安卓应用的启动过程/1.png %}\n\n我们在上图中可以看到，每一个进程都有一个java虚拟机(Dalvik虚拟机/ART虚拟机)实例。如果每次启动一个应用都需要启动一个新的虚拟机，然后初始化一堆的东西，那应用的启动时间将会变得无比漫长。\n\n那有什么办法优化呢？\n\n假设我们有一个模板进程，每次不需要重新启动，只需要重这个模板进程中拷贝一份出来，是不是就能节省一部分初始化的时间了？Zygote 进程就是这个模板进程。\n\nZygote是受精卵的意思，十分形象的一个比喻。app的进程就是通过fork的方式从Zygote进程克隆出来的，而且使用了写时拷贝的方法，尽可能的复用Zygote进程的资源。fork是UNIX关于进程管理的一个术语,本质是新开一个进程,但是不从磁盘加载代码,而是从内存现有进程复制一份。而写时拷贝是一直只有在修改的时候才会拷贝的策略，这里我就不详细展开他们了，有兴趣的同学可以在网上搜索一下。\n\n说回Zygote进程，他是系统在启动的时候创建的，在启动之后会打开/dev/socket/zygote使用socket去监听启动应用进程的请求。当接收到启动请求的时候就会fork一个子进程出来：\n\n{% img /从源码看安卓应用的启动过程/2.png %}\n\n应用进程是在 ActivityManagerService.startProcessLocked方法里面启动的:\n\n```\nprivate final void startProcessLocked(ProcessRecord app,  String hostingType, String hostingNameStr) {\n    ...\n    Process.ProcessStartResult startResult = Process.start(\"android.app.ActivityThread\",\n                                                          app.processName, uid, uid, gids, debugFlags, mountExternal,\n                                                          app.info.targetSdkVersion, app.info.seinfo, null);\n    ...\n}\n```\n\n我们可以在Process里面看到，它的确是通过socket与Zygote进行交互的:\n\n```\npublic class Process {\n    ...\n    private static final String ZYGOTE_SOCKET = \"zygote\";\n    ...     \n    public static final ProcessStartResult start(final String processClass,\n                                                final String niceName,\n                                                int uid, int gid, int[] gids,\n                                                int debugFlags, int mountExternal,\n                                                int targetSdkVersion,\n                                                String seInfo,\n                                                String[] zygoteArgs) {\n        ...                                          \n        return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, zygoteArgs);\n        ...\n    }\n    ...\n    private static ProcessStartResult startViaZygote(final String processClass,\n                                                    final String niceName,\n                                                    final int uid, final int gid,\n                                                    final int[] gids,\n                                                    int debugFlags, int mountExternal,\n                                                    int targetSdkVersion,\n                                                    String seInfo,\n                                                    String[] extraArgs)\n                                                    throws ZygoteStartFailedEx {\n        ...\n        return zygoteSendArgsAndGetResult(argsForZygote);\n    }\n    ...\n    private static ProcessStartResult zygoteSendArgsAndGetResult(ArrayList<String> args) throws ZygoteStartFailedEx {\n        openZygoteSocketIfNeeded();\n        ...\n        sZygoteWriter.write(Integer.toString(args.size())); 、\n        sZygoteWriter.newLine();\n        int sz = args.size();\n        for (int i = 0; i < sz; i++) {\n            String arg = args.get(i);\n            if (arg.indexOf('\\n') >= 0) {\n                throw new ZygoteStartFailedEx(\"embedded newlines not allowed\");\n            }\n            sZygoteWriter.write(arg);\n            sZygoteWriter.newLine();\n        }\n\n        sZygoteWriter.flush();\n\n        // Should there be a timeout on this?\n        ProcessStartResult result = new ProcessStartResult();\n        result.pid = sZygoteInputStream.readInt();\n        if (result.pid < 0) {\n            throw new ZygoteStartFailedEx(\"fork() failed\");\n        }\n        result.usingWrapper = sZygoteInputStream.readBoolean();\n        ...\n    }\n    ...\n    private static void openZygoteSocketIfNeeded() throws ZygoteStartFailedEx {\n        ...\n        sZygoteSocket = new LocalSocket();\n        sZygoteSocket.connect(new LocalSocketAddress(ZYGOTE_SOCKET,\n        LocalSocketAddress.Namespace.RESERVED));\n        ...\n    }\n}\n```\n\n那zygote进程通过socket监听到请求之后又做了什么呢？ZygoteInit.runSelectLoop就是用来监听socket请求我们看看源码，其实它是在一个while死循环里不断select socket消息:\n\n```\nprivate static void runSelectLoop() throws MethodAndArgsCaller {\n    ArrayList<FileDescriptor> fds = new ArrayList<FileDescriptor>();\n    ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();\n    FileDescriptor[] fdArray = new FileDescriptor[4];\n\n    fds.add(sServerSocket.getFileDescriptor());\n    peers.add(null);\n\n    int loopCount = GC_LOOP_COUNT;\n    while (true) {\n        int index;\n\n        /*\n        * Call gc() before we block in select().\n        * It's work that has to be done anyway, and it's better\n        * to avoid making every child do it. It will also\n        * madvise() any free memory as a side-effect.\n        *\n        * Don't call it every time, because walking the entire\n        * heap is a lot of overhead to free a few hundred bytes.\n        */\n        if (loopCount <= 0) {\n            gc();\n            loopCount = GC_LOOP_COUNT;\n        } else {\n            loopCount--;   \n        }\n\n\n        try {\n            fdArray = fds.toArray(fdArray);\n            index = selectReadable(fdArray);\n        } catch (IOException ex) {\n            throw new RuntimeException(\"Error in select()\", ex);\n        }\n\n        if (index < 0) {\n            throw new RuntimeException(\"Error in select()\");\n        } else if (index == 0) {\n            ZygoteConnection newPeer = acceptCommandPeer();\n            peers.add(newPeer);\n            fds.add(newPeer.getFileDesciptor());\n        } else {\n            boolean done;\n            done = peers.get(index).runOnce();\n\n            if (done) {\n                peers.remove(index);\n                fds.remove(index);\n            }\n        }\n    }\n}\n```\n\n接收到消息之后会调ZygoteConnection.runOnce，在这个方法里面调用了Zygote.forkAndSpecialize方法去fork一个进程，这里我们就不再深入了。我们继续跟踪下去发现他又调了ZygoteInit.invokeStaticMain:\n\n```\nboolean runOnce() throws ZygoteInit.MethodAndArgsCaller {\n    ...\n    pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,\n    parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,\n    parsedArgs.niceName);\n    ...\n    handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);\n    ...\n}\n\nprivate void handleChildProc(Arguments parsedArgs,\n                            FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)\n                            throws ZygoteInit.MethodAndArgsCaller {\n    ...\n    ZygoteInit.invokeStaticMain(cloader, className, mainArgs);\n    ...\n}\n```\n\nZygoteInit.invokeStaticMain的方法比较短，我就全部复制上来了，可以看到，这里用反射的方式调用了main方法，也就是ActivityThread.main:\n\n```\nstatic void invokeStaticMain(ClassLoader loader,\n                            String className, String[] argv)\n                            throws ZygoteInit.MethodAndArgsCaller {\n    Class<?> cl;\n\n    try {\n        cl = loader.loadClass(className);\n    } catch (ClassNotFoundException ex) {\n        throw new RuntimeException(\n                          \"Missing class when invoking static main \" + className,\n                          ex);\n    }\n\n    Method m;\n    try {\n        m = cl.getMethod(\"main\", new Class[] { String[].class });\n    } catch (NoSuchMethodException ex) {\n        throw new RuntimeException(\n                          \"Missing static main on \" + className, ex);\n    } catch (SecurityException ex) {\n        throw new RuntimeException(\n                          \"Problem getting static main on \" + className, ex);\n    }\n\n    int modifiers = m.getModifiers();\n    if (! (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers))) {\n        throw new RuntimeException(\n                          \"Main method is not public and static on \" + className);\n    }\n\n    /*\n    * This throw gets caught in ZygoteInit.main(), which responds\n    * by invoking the exception's run() method. This arrangement\n    * clears up all the stack frames that were required in setting\n    * up the process.\n    */\n    throw new ZygoteInit.MethodAndArgsCaller(m, argv);\n}\n```\n\n然后就到了ActivityThread.main方法，可以看到在这个方法里面初始化了sMainThreadHandler和Looper。这个就是主线程Handler对应的Looper了:\n\n```\npublic static void main(String[] args) {\n    SamplingProfilerIntegration.start();\n\n    // CloseGuard defaults to true and can be quite spammy. We\n    // disable it here, but selectively enable it later (via\n    // StrictMode) on debug builds, but using DropBox, not logs.\n    CloseGuard.setEnabled(false);\n\n    Environment.initForCurrentUser();\n\n    // Set the reporter for event logging in libcore\n    EventLogger.setReporter(new EventLoggingReporter());\n\n    Security.addProvider(new AndroidKeyStoreProvider());\n\n    Process.setArgV0(\"<pre-initialized>\");\n\n    Looper.prepareMainLooper();\n\n    ActivityThread thread = new ActivityThread();\n    thread.attach(false);\n\n    if (sMainThreadHandler == null) {\n        sMainThreadHandler = thread.getHandler();\n    }\n\n    AsyncTask.init();\n\n    if (false) {\n        Looper.myLooper().setMessageLogging(new\n        LogPrinter(Log.DEBUG, \"ActivityThread\"));\n    }\n\n    Looper.loop();\n\n    throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n}\n```\n\n于是乎一个应用的主线程就这样启动了，接下来就是ActivityManagerService通过Binder机制去让ActivityThread用Hander同步创建主Activity，并且调用Activity生命周期了。这部分最近有写过一篇博客[《从源码看Activity生命周期》](http://blog.islinjw.cn/2018/03/07/%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9C%8BActivity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/)感兴趣的同学可以去看看。\n","slug":"从源码看安卓应用的启动过程","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2un9001xw3fyg0asrsd2"},{"title":"从源码看Activity生命周期","date":"2018-03-07T15:47:39.000Z","_content":"\n# Activity是如何创建的\n\n我们都知道在手机上点击应用的图标，系统会通过ActivityManagerService去启动它的主Activity，接下来我们就来一步步看看在它究竟是如何启动应用的。\n\n首先手机开机的时候我们看到的界面其实是Launcher应用的主Activity,Launcher其实就是一个会被系统默认启动的安卓应用。在上面点击已装应用的图标，就会调用Actvity.startActivity去启动其他的应用。而Activity实际上是继承ContextWrapper的,所以调的是ContextWrapper.startActivity方法:\n\n```\npublic class ContextWrapper extends Context {\n     ...\n     Context mBase;\n     ...\n     public ContextWrapper(Context base) {\n         mBase = base;\n     }\n     ...\n     @Override\n     public void startActivity(Intent intent) {\n         mBase.startActivity(intent);\n     }\n     ...\n}\n```\n\n可以看到这里使用了委托的方式，实际上是调了mBase.startActivity。那这个mBase到底是什么呢？让我们来看看Context的继承关系图:\n\n{% img /从源码看Activity生命周期/1.png %}\n\n\nContext只有两个直接的子类,一个ContextImpl，一个ContextWrapper。ContextWrapper类如其名仅仅是一个包装的功能，它的成员变量mBase其实就是ContextImpl，所有实际的工作都是由ContextImpl去实现的。\n\n\n于是我们就去看看ContextImpl.startActivity:\n\n\n```\nclass ContextImpl extends Context {\n    ...\n    @Override\n    public void startActivity(Intent intent) {\n        ...\n        startActivity(intent, null);\n    }\n\n    @Override\n    public void startActivity(Intent intent, Bundle options) {\n      ...\n      mMainThread.getInstrumentation().execStartActivity(\n                            getOuterContext(), mMainThread.getApplicationThread(), null,\n                            (Activity)null, intent, -1, options);\n    }\n    ...\n}\n\npublic final class ActivityThread {\n    ...\n    Instrumentation mInstrumentation;\n    ...\n    public Instrumentation getInstrumentation()  {\n        return mInstrumentation;\n    }\n    ...\n}\n```\n\n好吧，这里又将锅甩给了Instrumentation。Instrumentation其实也是一个比较偏但是很有作用的东西(通过它我们能做到很多神奇的事情，例如[Hook 应用入口 Activity](https://www.jianshu.com/p/53c9e8641e57))，主要用于监控Activity，这里我就不详细讲了，感兴趣的同学可以直接去搜索一下。我们直接看启动activity相关的代码:\n\n\n```\npublic ActivityResult execStartActivity(\n                Context who, IBinder contextThread, IBinder token, Activity target,\n                Intent intent, int requestCode, Bundle options) {\n   ...\n   int result = ActivityManagerNative.getDefault()\n                             .startActivity(whoThread, who.getBasePackageName(), intent,\n                                          intent.resolveTypeIfNeeded(who.getContentResolver()),\n                                          token, target != null ? target.mEmbeddedID : null,\n                                          requestCode, 0, null, null, options);\n   ...\n}\n```\n\n这里的ActivityManagerNative最后拿到的就是ActivtyManagerService的IBinder,所以最后会使用Binder机制调用系统端的ActivityManagerService去创建Activity。\n\n但是我们知道ActivityManagerService和我们的应用是在两个进程的，如果在ActivityManagerService中创建了Activity的话我们的应用也是获取不了的。\n\n其实ActivityManagerService主要功能不是创建Activity，而是管理Activity栈。它在创建新的Activity的时候还是会通过Binder机制调回应用进程的ActivityThread去处理。最后ActivityManagerService只保存Activity的token。由于中间代码过于曲折，我这里就不贴出来了.这里直接看ActivityThread的代码吧：\n\n\n```\npublic final class ActivityThread {\n    final ArrayMap<IBinder, ActivityClientRecord> mActivities\n                    = new ArrayMap<IBinder, ActivityClientRecord>();\n    ...\n    private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n        ...\n        Activity a = performLaunchActivity(r, customIntent);\n        ...\n    }\n    ...\n    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n        ...\n        activity = mInstrumentation.newActivity(\n                            cl, component.getClassName(), r.intent);\n        ...\n        r.activity = activity;\n        ...\n        mActivities.put(r.token, r);\n    }\n}\n```\n\n\n可以看到这里也是用Instrumentation去创建Activity的，创建完之后就将它丢到一个Map里面。而Instrumentation.newActivity则很简单，通过反射去创建Activity:\n\n```\npublic class Instrumentation {\n    ...\n    public Activity newActivity(ClassLoader cl, String className, Intent intent)\n                                throws InstantiationException, IllegalAccessException,\n                                ClassNotFoundException {\n        return (Activity)cl.loadClass(className).newInstance();\n    }\n    ...\n}\n```\n\n总结下来，上面讲的的方法的调用时序图如下:\n\n{% img /从源码看Activity生命周期/2.png %}\n\n\n# Activity的生命周期是如何被调用的\n\n这里涉及到几个类：ActivityManagerService、ActivityStackSupervisor、ActivityStack、ActivityThread。\n\nActivityManagerService负责通过binder机制接收启动应用的请求，它内部有各个ActivityStackSupervisor成员变量，用于管理Activity栈：\n\n\n```\npublic final class ActivityManagerService extends ActivityManagerNative\nimplements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {\n    ...\n    /** Run all ActivityStacks through this */\n    ActivityStackSupervisor mStackSupervisor;\n    ...\n}\n```\n\nActivityStackSupervisor管理用于Activity栈列表，它负责将Activity压入对应的Activity栈中:\n\n```\npublic final class ActivityStackSupervisor {\n    ...\n    /** All the non-launcher stacks */\n    private ArrayList<ActivityStack> mStacks = new ArrayList<ActivityStack>();\n    ...\n}\n```\n\nActivityStack用于管理Activity的生命周期，例如在新Activity被压入的时候调用旧栈顶Activity的onPasuse和onStop还有新activity的onStart和onResume。\n\n```\nfinal class ActivityStack {\n    ...\n    final void startPausingLocked(boolean userLeaving, boolean uiSleeping) {\n        ...\n        prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags);\n        ...\n    }\n    ...\n}\n```\n\nActivityStack并不会直接调用Activity的生命周期方法，而是通过ActivityThread间接调用。由于ActivityStack在系统进程中,而ActivityThread在应用进程中，所以通过Binder机制调用之后去到ActivityThread那里不是主线程，于是ActivityThread内部就使用了Handler机制同步到主线程中调用:\n\n\n```\npublic final class ActivityThread {\n    ...\n    public final void schedulePauseActivity(IBinder token, boolean finished,  boolean userLeaving, int configChanges) {\n        queueOrSendMessage(\n            finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY,\n            token,\n            (userLeaving ? 1 : 0),\n            configChanges);\n    }\n    ...\n    private void queueOrSendMessage(int what, Object obj, int arg1, int arg2) {\n        synchronized (this) {\n            Message msg = Message.obtain();\n            msg.what = what;\n            msg.obj = obj;\n            msg.arg1 = arg1;\n            msg.arg2 = arg2;\n            mH.sendMessage(msg);\n        }\n    }\n    ...\n    private class H extends Handler {\n        ...\n        public void handleMessage(Message msg) {\n            ...\n            switch (msg.what) {\n                ...\n                case PAUSE_ACTIVITY:\n                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityPause\");\n                    handlePauseActivity((IBinder)msg.obj, false, msg.arg1 != 0, msg.arg2);\n                    maybeSnapshot();\n                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                    break;\n                ...\n                case RESUME_ACTIVITY:\n                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityResume\");\n                    handleResumeActivity((IBinder)msg.obj, true,\n                    msg.arg1 != 0, true);\n                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                    break;\n                ...\n            }\n            ...\n        }\n        ...\n    }\n    ...\n    private void handlePauseActivity(IBinder token, boolean finished,boolean userLeaving, int configChanges) {\n        ActivityClientRecord r = mActivities.get(token);\n        ...\n    }\n}\n```\n\n这里需要提的一点是AcvitiyThread里面可能有不止一个activity。所以需要传一个token去指定调用哪个activity。handlePauseActivity方法最终会调用mInstrumentation.callActivityOnPause再调用到Activity.onPause。这里就不继续展示代码了。\n\n总结一下，上面讲到的这些类之间的关系是这样的:\n\n{% img /从源码看Activity生命周期/3.png %}\n\nActivityThread通过handler机制将activity的生命周期同步到主线程中调用:\n\n{% img /从源码看Activity生命周期/4.png %}\n","source":"_posts/从源码看Activity生命周期.md","raw":"title: 从源码看Activity生命周期\ndate: 2018-03-07 23:47:39\ntags:\n\t- 技术相关\n  - Android\n---\n\n# Activity是如何创建的\n\n我们都知道在手机上点击应用的图标，系统会通过ActivityManagerService去启动它的主Activity，接下来我们就来一步步看看在它究竟是如何启动应用的。\n\n首先手机开机的时候我们看到的界面其实是Launcher应用的主Activity,Launcher其实就是一个会被系统默认启动的安卓应用。在上面点击已装应用的图标，就会调用Actvity.startActivity去启动其他的应用。而Activity实际上是继承ContextWrapper的,所以调的是ContextWrapper.startActivity方法:\n\n```\npublic class ContextWrapper extends Context {\n     ...\n     Context mBase;\n     ...\n     public ContextWrapper(Context base) {\n         mBase = base;\n     }\n     ...\n     @Override\n     public void startActivity(Intent intent) {\n         mBase.startActivity(intent);\n     }\n     ...\n}\n```\n\n可以看到这里使用了委托的方式，实际上是调了mBase.startActivity。那这个mBase到底是什么呢？让我们来看看Context的继承关系图:\n\n{% img /从源码看Activity生命周期/1.png %}\n\n\nContext只有两个直接的子类,一个ContextImpl，一个ContextWrapper。ContextWrapper类如其名仅仅是一个包装的功能，它的成员变量mBase其实就是ContextImpl，所有实际的工作都是由ContextImpl去实现的。\n\n\n于是我们就去看看ContextImpl.startActivity:\n\n\n```\nclass ContextImpl extends Context {\n    ...\n    @Override\n    public void startActivity(Intent intent) {\n        ...\n        startActivity(intent, null);\n    }\n\n    @Override\n    public void startActivity(Intent intent, Bundle options) {\n      ...\n      mMainThread.getInstrumentation().execStartActivity(\n                            getOuterContext(), mMainThread.getApplicationThread(), null,\n                            (Activity)null, intent, -1, options);\n    }\n    ...\n}\n\npublic final class ActivityThread {\n    ...\n    Instrumentation mInstrumentation;\n    ...\n    public Instrumentation getInstrumentation()  {\n        return mInstrumentation;\n    }\n    ...\n}\n```\n\n好吧，这里又将锅甩给了Instrumentation。Instrumentation其实也是一个比较偏但是很有作用的东西(通过它我们能做到很多神奇的事情，例如[Hook 应用入口 Activity](https://www.jianshu.com/p/53c9e8641e57))，主要用于监控Activity，这里我就不详细讲了，感兴趣的同学可以直接去搜索一下。我们直接看启动activity相关的代码:\n\n\n```\npublic ActivityResult execStartActivity(\n                Context who, IBinder contextThread, IBinder token, Activity target,\n                Intent intent, int requestCode, Bundle options) {\n   ...\n   int result = ActivityManagerNative.getDefault()\n                             .startActivity(whoThread, who.getBasePackageName(), intent,\n                                          intent.resolveTypeIfNeeded(who.getContentResolver()),\n                                          token, target != null ? target.mEmbeddedID : null,\n                                          requestCode, 0, null, null, options);\n   ...\n}\n```\n\n这里的ActivityManagerNative最后拿到的就是ActivtyManagerService的IBinder,所以最后会使用Binder机制调用系统端的ActivityManagerService去创建Activity。\n\n但是我们知道ActivityManagerService和我们的应用是在两个进程的，如果在ActivityManagerService中创建了Activity的话我们的应用也是获取不了的。\n\n其实ActivityManagerService主要功能不是创建Activity，而是管理Activity栈。它在创建新的Activity的时候还是会通过Binder机制调回应用进程的ActivityThread去处理。最后ActivityManagerService只保存Activity的token。由于中间代码过于曲折，我这里就不贴出来了.这里直接看ActivityThread的代码吧：\n\n\n```\npublic final class ActivityThread {\n    final ArrayMap<IBinder, ActivityClientRecord> mActivities\n                    = new ArrayMap<IBinder, ActivityClientRecord>();\n    ...\n    private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n        ...\n        Activity a = performLaunchActivity(r, customIntent);\n        ...\n    }\n    ...\n    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n        ...\n        activity = mInstrumentation.newActivity(\n                            cl, component.getClassName(), r.intent);\n        ...\n        r.activity = activity;\n        ...\n        mActivities.put(r.token, r);\n    }\n}\n```\n\n\n可以看到这里也是用Instrumentation去创建Activity的，创建完之后就将它丢到一个Map里面。而Instrumentation.newActivity则很简单，通过反射去创建Activity:\n\n```\npublic class Instrumentation {\n    ...\n    public Activity newActivity(ClassLoader cl, String className, Intent intent)\n                                throws InstantiationException, IllegalAccessException,\n                                ClassNotFoundException {\n        return (Activity)cl.loadClass(className).newInstance();\n    }\n    ...\n}\n```\n\n总结下来，上面讲的的方法的调用时序图如下:\n\n{% img /从源码看Activity生命周期/2.png %}\n\n\n# Activity的生命周期是如何被调用的\n\n这里涉及到几个类：ActivityManagerService、ActivityStackSupervisor、ActivityStack、ActivityThread。\n\nActivityManagerService负责通过binder机制接收启动应用的请求，它内部有各个ActivityStackSupervisor成员变量，用于管理Activity栈：\n\n\n```\npublic final class ActivityManagerService extends ActivityManagerNative\nimplements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {\n    ...\n    /** Run all ActivityStacks through this */\n    ActivityStackSupervisor mStackSupervisor;\n    ...\n}\n```\n\nActivityStackSupervisor管理用于Activity栈列表，它负责将Activity压入对应的Activity栈中:\n\n```\npublic final class ActivityStackSupervisor {\n    ...\n    /** All the non-launcher stacks */\n    private ArrayList<ActivityStack> mStacks = new ArrayList<ActivityStack>();\n    ...\n}\n```\n\nActivityStack用于管理Activity的生命周期，例如在新Activity被压入的时候调用旧栈顶Activity的onPasuse和onStop还有新activity的onStart和onResume。\n\n```\nfinal class ActivityStack {\n    ...\n    final void startPausingLocked(boolean userLeaving, boolean uiSleeping) {\n        ...\n        prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags);\n        ...\n    }\n    ...\n}\n```\n\nActivityStack并不会直接调用Activity的生命周期方法，而是通过ActivityThread间接调用。由于ActivityStack在系统进程中,而ActivityThread在应用进程中，所以通过Binder机制调用之后去到ActivityThread那里不是主线程，于是ActivityThread内部就使用了Handler机制同步到主线程中调用:\n\n\n```\npublic final class ActivityThread {\n    ...\n    public final void schedulePauseActivity(IBinder token, boolean finished,  boolean userLeaving, int configChanges) {\n        queueOrSendMessage(\n            finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY,\n            token,\n            (userLeaving ? 1 : 0),\n            configChanges);\n    }\n    ...\n    private void queueOrSendMessage(int what, Object obj, int arg1, int arg2) {\n        synchronized (this) {\n            Message msg = Message.obtain();\n            msg.what = what;\n            msg.obj = obj;\n            msg.arg1 = arg1;\n            msg.arg2 = arg2;\n            mH.sendMessage(msg);\n        }\n    }\n    ...\n    private class H extends Handler {\n        ...\n        public void handleMessage(Message msg) {\n            ...\n            switch (msg.what) {\n                ...\n                case PAUSE_ACTIVITY:\n                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityPause\");\n                    handlePauseActivity((IBinder)msg.obj, false, msg.arg1 != 0, msg.arg2);\n                    maybeSnapshot();\n                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                    break;\n                ...\n                case RESUME_ACTIVITY:\n                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityResume\");\n                    handleResumeActivity((IBinder)msg.obj, true,\n                    msg.arg1 != 0, true);\n                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                    break;\n                ...\n            }\n            ...\n        }\n        ...\n    }\n    ...\n    private void handlePauseActivity(IBinder token, boolean finished,boolean userLeaving, int configChanges) {\n        ActivityClientRecord r = mActivities.get(token);\n        ...\n    }\n}\n```\n\n这里需要提的一点是AcvitiyThread里面可能有不止一个activity。所以需要传一个token去指定调用哪个activity。handlePauseActivity方法最终会调用mInstrumentation.callActivityOnPause再调用到Activity.onPause。这里就不继续展示代码了。\n\n总结一下，上面讲到的这些类之间的关系是这样的:\n\n{% img /从源码看Activity生命周期/3.png %}\n\nActivityThread通过handler机制将activity的生命周期同步到主线程中调用:\n\n{% img /从源码看Activity生命周期/4.png %}\n","slug":"从源码看Activity生命周期","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2una0020w3fyhiqohuu6"},{"title":"lua面向对象编程","date":"2016-11-15T16:43:45.000Z","_content":"\nlua也支持面向对象编程的,嗯对,就是用table和元表。lua可以在某种程度上实现面向对象的封装、继承和多态三大基本特性。\n\n## 封装\n\nlua实现封装的最简单方法就是将属性和方法放到table之中。首先我们声明一个类table,用来定义一些该类的类方法，其中的new方法就类似其他面向对象语言的new关键字,用来创建一个新的实例出来。同时为了模块化，将它放在一个单独的Position.lua文件中:\n\n```lua\nlocal Position = {}\n\nfunction Position.new(x,y)\n\tlocal instance = {x=x, y=y}\n\treturn instance\nend\n\nfunction Position.getLength(instance)\n\treturn (instance.x^2+instance.y^2)^0.5\nend\n\nreturn Position\n```\n\n这样就可以这样使用它:\n```lua\nlocal Position = require(\"Position\")\nlocal pos1 = Position.new(1,1)\nprint(Position.getLength(pos1))\n```\n\n输出如下:\n>1.4142135623731\n\n看看这个方法的定义:\n\n```lua\nfunction Position.getLength(instance)\n\treturn (instance.x^2+instance.y^2)^0.5\nend\n```\n\n它其实是一种语法糖,上面的写法和下面的写法是一样的\n\n```lua\nPosition.getLength = function(instance)\n\treturn (instance.x^2+instance.y^2)^0.5\nend\n```\n\n但是这样的写法是不是感觉很奇怪,和一般的面向对象的写法和用法都不一样？我们可以把Position.lua改成下面的这个样子:\n\n```lua\nlocal Position = {}\n\nfunction Position.new(x,y)\n\tlocal instance = {x=x, y=y}\n\tsetmetatable(instance, {__index=Position})\n\treturn instance\nend\n\nfunction Position.getLength(instance)\n\treturn (instance.x^2+instance.y^2)^0.5\nend\n\nreturn Position\n```\n\n于是用法就有点接近我们熟悉的面向对象语法了\n\n```lua\nlocal Position = require(\"Position\")\n\nlocal pos1 = Position.new(1,1)\nprint(pos1.getLength(pos1))\n\nlocal pos2 = Position.new(3,4)\nprint(pos2.getLength(pos2))\n```\n\n输出如下:\n\n>1.4142135623731\n>5\n\n但是每次调用类方法都需要把实例显示的当作参数传入,这样既麻烦又容易出错。有没有办法让lua解释器自动传入类实例呢？答案当然是有的,这就要看另一种语法糖了:\n\n```lua\nlocal Position = require(\"Position\")\n\nlocal pos1 = Position.new(1,1)\nprint(pos1:getLength())\n\nlocal pos2 = Position.new(3,4)\nprint(pos2:getLength())\n```\n\n对的，下面的两种写法是等价的:\n\n```lua\npos1.getLength(pos1)\npos1:getLength()\n```\n\n类似的,在Position.lua中也能这么写：\n\n```lua\nlocal Position = {}\n\nfunction Position.new(x,y)\n\tlocal instance = {x=x, y=y}\n\tsetmetatable(instance, {__index=Position})\n\treturn instance\nend\n\nfunction Position:getLength()\n\treturn (self.x^2+self.y^2)^0.5\nend\n\nreturn Position\n```\n\n下面两种写法也是等价的:\n```lua\nfunction Position.getLength(self)\n\treturn (self.x^2+self.y^2)^0.5\nend\n\nfunction Position:getLength()\n\treturn (self.x^2+self.y^2)^0.5\nend\n```\n\n这里的self就相当于c++的this\n\n我们还可以把new方法抽象出来,作为公共方法,而不用为每个类都写一个new方法:\n\n```lua\n-- function.lua\n\nfunction class(className)\n\tlocal cls = {}\n\tcls.__cname = className\n\tcls.new = function(...)\n\t\tlocal instance = {}\n\t\tsetmetatable(instance, {__index=cls})\n\t\tif cls.ctor then cls:ctor(...) end\n\t\treturn instance\n\tend\n\treturn cls\nend\n```\n\n这个new方法将类名保存了下来,方便运行时获取类的类型,同时如果这个类有定义构造函数(ctor)的话,它还会自动的调用类的构造函数。\n\n这个时候类的定义就可以变成下面这个样子了:\n\n```lua\n-- Position.lua\n\nlocal Position = class(\"Position\")\n\nfunction Position:ctor(x,y)\n\tself.x = x\n\tself.y = y\nend\n\nfunction Position:getLength()\n\treturn (self.x^2+self.y^2)^0.5\nend\n\nreturn Position\n```\n\n已经和一般的面向对象语言很接近了。当然,这个class方法我们必须在程序的一开始就加载进来作为全局方法使用。我们来看看main.lua是怎么使用它们的吧:\n\n```lua\nrequire(\"function\")\n\nlocal Position = require(\"Position\")\nprint(Position.__cname)\n\nlocal pos1 = Position.new(1,1)\nprint(pos1:getLength())\n\nlocal pos2 = Position.new(3,4)\nprint(pos2:getLength())\n```\n\n输出如下:\n>Position\n>1.4142135623731\n>5\n\n\n\n## 继承与多态\n\nlua的继承机制在上一篇博客《lua元表》中已经有提到了一些,原理就是使用元表机制,将子类元表的\\__index字段设置为父类。所以我们可以这样拓展我们的new方法:\n\n```lua\n-- function.lua\n\nfunction class(className, super)\n\tlocal cls = {}\n\n\tif super then \n\t\tcls.super = super\n\t\tsetmetatable(cls, {__index=super})\n\tend\n\t\n\tcls.__cname = className\n\n\tcls.new = function(...)\n\t\tlocal instance = {}\n\t\tsetmetatable(instance, {__index=cls})\n\t\tif cls.ctor then cls:ctor(...) end\n\t\treturn instance\n\tend\n\t\n\treturn cls\nend\n```\n这里我们将父类保存到子类的元表的\\__index字段中,同时为类添加了super字段用于保存父类\n\n于是基于new方法,我们可以定义Position的子类Position3D:\n\n```lua\n-- Position3D.lua\n\nlocal Position3D = class(\"Position3D\", require(\"Position\"))\n\nfunction Position3D:ctor(x,y,z)\n\tself.super:ctor(x, y)\n\tself.z = z\nend\n\nfunction Position3D:getLength()\n\treturn (self.x^2+self.y^2+self.z^2)^0.5\nend\n\nreturn Position3D\n```\n\n子类Position3D重写了Position的ctor方法和getLength方法。如果需要用父类的被重写的方法,就要用super字段显示调用,就如ctor方法中做的一样。\n\n来看看main.lua吧：\n\n```lua\nrequire(\"function\")\n\nlocal Position3D = require(\"Position3D\")\nprint(Position3D.__cname)\n\nlocal pos1 = Position3D.new(1,1,1)\nprint(pos1:getLength())\n\nlocal pos2 = Position3D.new(3,4,5)\nprint(pos2:getLength())\n```\n\n输出如下:\n>Position3D\n>1.7320508075689\n>7.0710678118655\n\n\n## 多继承\n\nlua同样可以实现多继承。由于一个多继承的子类有多个父类,所以我们不能简单的把父类设为元表的\\__index属性。但是我们可以将该类的父类保存在一个table里面,然后用一个函数去搜索父类的方法。这时,只有将这个函数赋值个于元表的\\__index就好了。\n\n于是我们可以将class函数拓展成下面的样子\n\n```lua\nfunction class(className, ...)\n\tlocal cls = {__cname = className}\n\n    local supers = {...}\n\tfor i,super in ipairs(supers) do\n        cls.__supers = cls.__supers or {}\n        table.insert(cls.__supers, super)\n\n        if cls.super==nil then\n            cls.super=super\n        end\n\tend\n\n    if cls.__supers==nil or  #cls.__supers==1 then\n        setmetatable(cls, {__index=cls.super})\n\telse\n\t\tlocal index = function(t,k)\n\t\t\tfor i,v in ipairs(cls.__supers) do\n\t\t\t\tif v[k] then return v[k] end\n\t\t\tend\n\t\tend\n        setmetatable(cls, {__index=index})\n\tend\t\n\n\tcls.new = function(...)\n\t    local instance = {}\n\t\tsetmetatable(instance, {__index=cls})\n\t\tif cls.ctor then cls:ctor(...) end\n\t\treturn instance\n\tend\n\n\treturn cls\nend\n```\n\n之后我们就能这样去使用多继承机制了:\n\n```lua\n--ClassA.lua\n\nlocal ClassA = class(\"ClassA\")\n\nfunction ClassA:ctor()\nend\n\nfunction ClassA:methodA()\n\tprint(\"ClassA:methodA\")\nend\n\nreturn ClassA\n```\n\n```lua\n--ClassB.lua\n\nlocal ClassB = class(\"ClassB\")\n\nfunction ClassB:ctor()\nend\n\nfunction ClassB:methodB()\n\tprint(\"ClassB:methodB\")\nend\n\nreturn ClassB\n```\n\n```lua\n--ClassC.lua\n\nlocal ClassC = class(\"ClassC\", require(\"ClassA\"), require(\"ClassB\"))\n\nfunction ClassC:ctor()\nend\n\nreturn ClassC\n```\n\n```lua\n--main.lua\n\nrequire(\"function\")\n\nlocal c = require(\"ClassC\").new()\nc:methodA()\nc:methodB()\n```\n\n执行结果如下:\n\n>ClassA:methodA\n>ClassB:methodB\n","source":"_posts/lua面向对象编程.md","raw":"title: lua面向对象编程\ndate: 2016-11-16 00:43:45\ntags:\n\t- 技术相关\n\t- lua\n---\n\nlua也支持面向对象编程的,嗯对,就是用table和元表。lua可以在某种程度上实现面向对象的封装、继承和多态三大基本特性。\n\n## 封装\n\nlua实现封装的最简单方法就是将属性和方法放到table之中。首先我们声明一个类table,用来定义一些该类的类方法，其中的new方法就类似其他面向对象语言的new关键字,用来创建一个新的实例出来。同时为了模块化，将它放在一个单独的Position.lua文件中:\n\n```lua\nlocal Position = {}\n\nfunction Position.new(x,y)\n\tlocal instance = {x=x, y=y}\n\treturn instance\nend\n\nfunction Position.getLength(instance)\n\treturn (instance.x^2+instance.y^2)^0.5\nend\n\nreturn Position\n```\n\n这样就可以这样使用它:\n```lua\nlocal Position = require(\"Position\")\nlocal pos1 = Position.new(1,1)\nprint(Position.getLength(pos1))\n```\n\n输出如下:\n>1.4142135623731\n\n看看这个方法的定义:\n\n```lua\nfunction Position.getLength(instance)\n\treturn (instance.x^2+instance.y^2)^0.5\nend\n```\n\n它其实是一种语法糖,上面的写法和下面的写法是一样的\n\n```lua\nPosition.getLength = function(instance)\n\treturn (instance.x^2+instance.y^2)^0.5\nend\n```\n\n但是这样的写法是不是感觉很奇怪,和一般的面向对象的写法和用法都不一样？我们可以把Position.lua改成下面的这个样子:\n\n```lua\nlocal Position = {}\n\nfunction Position.new(x,y)\n\tlocal instance = {x=x, y=y}\n\tsetmetatable(instance, {__index=Position})\n\treturn instance\nend\n\nfunction Position.getLength(instance)\n\treturn (instance.x^2+instance.y^2)^0.5\nend\n\nreturn Position\n```\n\n于是用法就有点接近我们熟悉的面向对象语法了\n\n```lua\nlocal Position = require(\"Position\")\n\nlocal pos1 = Position.new(1,1)\nprint(pos1.getLength(pos1))\n\nlocal pos2 = Position.new(3,4)\nprint(pos2.getLength(pos2))\n```\n\n输出如下:\n\n>1.4142135623731\n>5\n\n但是每次调用类方法都需要把实例显示的当作参数传入,这样既麻烦又容易出错。有没有办法让lua解释器自动传入类实例呢？答案当然是有的,这就要看另一种语法糖了:\n\n```lua\nlocal Position = require(\"Position\")\n\nlocal pos1 = Position.new(1,1)\nprint(pos1:getLength())\n\nlocal pos2 = Position.new(3,4)\nprint(pos2:getLength())\n```\n\n对的，下面的两种写法是等价的:\n\n```lua\npos1.getLength(pos1)\npos1:getLength()\n```\n\n类似的,在Position.lua中也能这么写：\n\n```lua\nlocal Position = {}\n\nfunction Position.new(x,y)\n\tlocal instance = {x=x, y=y}\n\tsetmetatable(instance, {__index=Position})\n\treturn instance\nend\n\nfunction Position:getLength()\n\treturn (self.x^2+self.y^2)^0.5\nend\n\nreturn Position\n```\n\n下面两种写法也是等价的:\n```lua\nfunction Position.getLength(self)\n\treturn (self.x^2+self.y^2)^0.5\nend\n\nfunction Position:getLength()\n\treturn (self.x^2+self.y^2)^0.5\nend\n```\n\n这里的self就相当于c++的this\n\n我们还可以把new方法抽象出来,作为公共方法,而不用为每个类都写一个new方法:\n\n```lua\n-- function.lua\n\nfunction class(className)\n\tlocal cls = {}\n\tcls.__cname = className\n\tcls.new = function(...)\n\t\tlocal instance = {}\n\t\tsetmetatable(instance, {__index=cls})\n\t\tif cls.ctor then cls:ctor(...) end\n\t\treturn instance\n\tend\n\treturn cls\nend\n```\n\n这个new方法将类名保存了下来,方便运行时获取类的类型,同时如果这个类有定义构造函数(ctor)的话,它还会自动的调用类的构造函数。\n\n这个时候类的定义就可以变成下面这个样子了:\n\n```lua\n-- Position.lua\n\nlocal Position = class(\"Position\")\n\nfunction Position:ctor(x,y)\n\tself.x = x\n\tself.y = y\nend\n\nfunction Position:getLength()\n\treturn (self.x^2+self.y^2)^0.5\nend\n\nreturn Position\n```\n\n已经和一般的面向对象语言很接近了。当然,这个class方法我们必须在程序的一开始就加载进来作为全局方法使用。我们来看看main.lua是怎么使用它们的吧:\n\n```lua\nrequire(\"function\")\n\nlocal Position = require(\"Position\")\nprint(Position.__cname)\n\nlocal pos1 = Position.new(1,1)\nprint(pos1:getLength())\n\nlocal pos2 = Position.new(3,4)\nprint(pos2:getLength())\n```\n\n输出如下:\n>Position\n>1.4142135623731\n>5\n\n\n\n## 继承与多态\n\nlua的继承机制在上一篇博客《lua元表》中已经有提到了一些,原理就是使用元表机制,将子类元表的\\__index字段设置为父类。所以我们可以这样拓展我们的new方法:\n\n```lua\n-- function.lua\n\nfunction class(className, super)\n\tlocal cls = {}\n\n\tif super then \n\t\tcls.super = super\n\t\tsetmetatable(cls, {__index=super})\n\tend\n\t\n\tcls.__cname = className\n\n\tcls.new = function(...)\n\t\tlocal instance = {}\n\t\tsetmetatable(instance, {__index=cls})\n\t\tif cls.ctor then cls:ctor(...) end\n\t\treturn instance\n\tend\n\t\n\treturn cls\nend\n```\n这里我们将父类保存到子类的元表的\\__index字段中,同时为类添加了super字段用于保存父类\n\n于是基于new方法,我们可以定义Position的子类Position3D:\n\n```lua\n-- Position3D.lua\n\nlocal Position3D = class(\"Position3D\", require(\"Position\"))\n\nfunction Position3D:ctor(x,y,z)\n\tself.super:ctor(x, y)\n\tself.z = z\nend\n\nfunction Position3D:getLength()\n\treturn (self.x^2+self.y^2+self.z^2)^0.5\nend\n\nreturn Position3D\n```\n\n子类Position3D重写了Position的ctor方法和getLength方法。如果需要用父类的被重写的方法,就要用super字段显示调用,就如ctor方法中做的一样。\n\n来看看main.lua吧：\n\n```lua\nrequire(\"function\")\n\nlocal Position3D = require(\"Position3D\")\nprint(Position3D.__cname)\n\nlocal pos1 = Position3D.new(1,1,1)\nprint(pos1:getLength())\n\nlocal pos2 = Position3D.new(3,4,5)\nprint(pos2:getLength())\n```\n\n输出如下:\n>Position3D\n>1.7320508075689\n>7.0710678118655\n\n\n## 多继承\n\nlua同样可以实现多继承。由于一个多继承的子类有多个父类,所以我们不能简单的把父类设为元表的\\__index属性。但是我们可以将该类的父类保存在一个table里面,然后用一个函数去搜索父类的方法。这时,只有将这个函数赋值个于元表的\\__index就好了。\n\n于是我们可以将class函数拓展成下面的样子\n\n```lua\nfunction class(className, ...)\n\tlocal cls = {__cname = className}\n\n    local supers = {...}\n\tfor i,super in ipairs(supers) do\n        cls.__supers = cls.__supers or {}\n        table.insert(cls.__supers, super)\n\n        if cls.super==nil then\n            cls.super=super\n        end\n\tend\n\n    if cls.__supers==nil or  #cls.__supers==1 then\n        setmetatable(cls, {__index=cls.super})\n\telse\n\t\tlocal index = function(t,k)\n\t\t\tfor i,v in ipairs(cls.__supers) do\n\t\t\t\tif v[k] then return v[k] end\n\t\t\tend\n\t\tend\n        setmetatable(cls, {__index=index})\n\tend\t\n\n\tcls.new = function(...)\n\t    local instance = {}\n\t\tsetmetatable(instance, {__index=cls})\n\t\tif cls.ctor then cls:ctor(...) end\n\t\treturn instance\n\tend\n\n\treturn cls\nend\n```\n\n之后我们就能这样去使用多继承机制了:\n\n```lua\n--ClassA.lua\n\nlocal ClassA = class(\"ClassA\")\n\nfunction ClassA:ctor()\nend\n\nfunction ClassA:methodA()\n\tprint(\"ClassA:methodA\")\nend\n\nreturn ClassA\n```\n\n```lua\n--ClassB.lua\n\nlocal ClassB = class(\"ClassB\")\n\nfunction ClassB:ctor()\nend\n\nfunction ClassB:methodB()\n\tprint(\"ClassB:methodB\")\nend\n\nreturn ClassB\n```\n\n```lua\n--ClassC.lua\n\nlocal ClassC = class(\"ClassC\", require(\"ClassA\"), require(\"ClassB\"))\n\nfunction ClassC:ctor()\nend\n\nreturn ClassC\n```\n\n```lua\n--main.lua\n\nrequire(\"function\")\n\nlocal c = require(\"ClassC\").new()\nc:methodA()\nc:methodB()\n```\n\n执行结果如下:\n\n>ClassA:methodA\n>ClassB:methodB\n","slug":"lua面向对象编程","published":1,"updated":"2017-06-02T22:47:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2unc0023w3fy9wdhiem0"},{"title":"lua泛型for的原理","date":"2016-10-23T15:10:47.000Z","_content":"学习lua的时候,一直觉得泛型for是个很有用的东西,也觉得它很神奇,但因为它是语法层面就支持的东西,所以就没有去深入思考其中的原理。直到最近看《Lua程序设计》才知道它底层的工作原理原来那么巧妙。\n\n## 泛型for原理\n\n泛型for的用法如下:\n```lua\nlocal person = {name=\"Jim\", age=18}\nfor k,v in pairs(person) do\n\tprint(k,v)\nend \n```\n\n输出结果如下:\n>name    Jim\n>age     18\n\n它究竟是怎么做到通过循环,把table中的key和value通通打印出来的呢？\n\n其实泛型for语句:\n\n```lua\nfor var_1, ..., var_n in <explist> do <block> end\n```\n\n等价以下的代码:\n\n```lua\ndo \n    local _f,_s,_var = <explist>\n    while true do\n        local var_1, ..., var_n = _f(_s, _var)\n        _var = var_1\n        if _var==nil then break end\n        <block>\n    end\nend\n```\n\n## pairs函数原理\n\n这里要先介绍一个基本函数next。如果k是table t的一个key,在调用next(t,k)的时候,会返回t的下一个key和对应的值,如果key为nil,则返回t的第一组key和value,如果没有下一组key和value则返回nil。\n\n其实pairs的定义很简单:\n\n```lua\nfunction pairs(t)\n    return next, t, nil\nend\n```\n\n它只是简单的返回了next函数和原来的table,所以泛型for又能这么写:\n\n```lua\nlocal person = {name=\"Jim\", age=18}\nfor k,v in next, person do\n    print(k,v)\nend \n```\n等价于:\n\n```lua\nlocal person = {name=\"Jim\", age=18}\ndo\n\tlocal _f,_s,_var = next, person\n\twhile true do\n\t\tk,v = _f(_s, _var)\n\t\t_var = k\n\t\tif _var==nil then break end\n\t\tprint(k,v)\n\tend\nend\n```\n\n## ipairs函数原理\n\nipairs函数比pairs函数要复杂一点。如果按照pair的做法,会出现以下情况:\n\n```lua\nlocal test1 = {\"one\", \"two\", three=3}\n\nfor k,v in next, test1 do\n\tprint(k,v)\nend\n\nprint(\"================\")\n\nfor i,v in ipairs(test1) do\n\tprint(i,v)\nend\n```\n\n输出如下:\n\n>1       one\n>2       two\n>three   3\n>\\================\n>1       one\n>2       two\n\n还会出现下面的这种情况:\n\n```lua\nlocal test1 = {\"one\", nil, \"three\"}\n\nfor k,v in next, test1 do\n\tprint(k,v)\nend\n\nprint(\"================\")\n\nfor i,v in ipairs(test1) do\n\tprint(i,v)\nend\n```\n\n输出:\n>1       one\n>3       three\n>\\================\n>1       one\n\n我们在使用ipairs的时候是想以数组的方式遍历table,但pairs会把table中的所有键值对都遍历一遍。使用ipairs的时候会从下标为1开始逐一遍历table,直到遇到value等于nil的时候停止,它的工作原理如下:\n\n```lua\nfunction iter(t, index)\n\tindex = index + 1\n\tlocal var = t[index]\n\tif var then\n\t\treturn index, var\n\tend\nend\n\nfunction ipairs(t)\n\treturn iter,t,0\nend\n```\n\n或者简化成下面的形式:\n\n```lua\nlocal test1 = {\"one\", \"two\", \"three\"}\n\nfunction iter(t, index)\n\tindex = index + 1\n\tlocal var = t[index]\n\tif var then\n\t\treturn index, var\n\tend\nend\n\nfor i,v in iter,test1,0 do\n\tprint(i,v)\nend\n```","source":"_posts/lua泛型for的原理.md","raw":"title: lua泛型for的原理\ndate: 2016-10-23 23:10:47\ntags:\n\t- 技术相关\n\t- lua\n---\n学习lua的时候,一直觉得泛型for是个很有用的东西,也觉得它很神奇,但因为它是语法层面就支持的东西,所以就没有去深入思考其中的原理。直到最近看《Lua程序设计》才知道它底层的工作原理原来那么巧妙。\n\n## 泛型for原理\n\n泛型for的用法如下:\n```lua\nlocal person = {name=\"Jim\", age=18}\nfor k,v in pairs(person) do\n\tprint(k,v)\nend \n```\n\n输出结果如下:\n>name    Jim\n>age     18\n\n它究竟是怎么做到通过循环,把table中的key和value通通打印出来的呢？\n\n其实泛型for语句:\n\n```lua\nfor var_1, ..., var_n in <explist> do <block> end\n```\n\n等价以下的代码:\n\n```lua\ndo \n    local _f,_s,_var = <explist>\n    while true do\n        local var_1, ..., var_n = _f(_s, _var)\n        _var = var_1\n        if _var==nil then break end\n        <block>\n    end\nend\n```\n\n## pairs函数原理\n\n这里要先介绍一个基本函数next。如果k是table t的一个key,在调用next(t,k)的时候,会返回t的下一个key和对应的值,如果key为nil,则返回t的第一组key和value,如果没有下一组key和value则返回nil。\n\n其实pairs的定义很简单:\n\n```lua\nfunction pairs(t)\n    return next, t, nil\nend\n```\n\n它只是简单的返回了next函数和原来的table,所以泛型for又能这么写:\n\n```lua\nlocal person = {name=\"Jim\", age=18}\nfor k,v in next, person do\n    print(k,v)\nend \n```\n等价于:\n\n```lua\nlocal person = {name=\"Jim\", age=18}\ndo\n\tlocal _f,_s,_var = next, person\n\twhile true do\n\t\tk,v = _f(_s, _var)\n\t\t_var = k\n\t\tif _var==nil then break end\n\t\tprint(k,v)\n\tend\nend\n```\n\n## ipairs函数原理\n\nipairs函数比pairs函数要复杂一点。如果按照pair的做法,会出现以下情况:\n\n```lua\nlocal test1 = {\"one\", \"two\", three=3}\n\nfor k,v in next, test1 do\n\tprint(k,v)\nend\n\nprint(\"================\")\n\nfor i,v in ipairs(test1) do\n\tprint(i,v)\nend\n```\n\n输出如下:\n\n>1       one\n>2       two\n>three   3\n>\\================\n>1       one\n>2       two\n\n还会出现下面的这种情况:\n\n```lua\nlocal test1 = {\"one\", nil, \"three\"}\n\nfor k,v in next, test1 do\n\tprint(k,v)\nend\n\nprint(\"================\")\n\nfor i,v in ipairs(test1) do\n\tprint(i,v)\nend\n```\n\n输出:\n>1       one\n>3       three\n>\\================\n>1       one\n\n我们在使用ipairs的时候是想以数组的方式遍历table,但pairs会把table中的所有键值对都遍历一遍。使用ipairs的时候会从下标为1开始逐一遍历table,直到遇到value等于nil的时候停止,它的工作原理如下:\n\n```lua\nfunction iter(t, index)\n\tindex = index + 1\n\tlocal var = t[index]\n\tif var then\n\t\treturn index, var\n\tend\nend\n\nfunction ipairs(t)\n\treturn iter,t,0\nend\n```\n\n或者简化成下面的形式:\n\n```lua\nlocal test1 = {\"one\", \"two\", \"three\"}\n\nfunction iter(t, index)\n\tindex = index + 1\n\tlocal var = t[index]\n\tif var then\n\t\treturn index, var\n\tend\nend\n\nfor i,v in iter,test1,0 do\n\tprint(i,v)\nend\n```","slug":"lua泛型for的原理","published":1,"updated":"2017-06-02T22:47:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2une0027w3fydib615dm"},{"title":"lua元表","date":"2016-10-28T14:45:37.000Z","_content":"\n## 元表是什么？\n\n在lua中,每个值都有一套预定义的操作集合。例如数字可以相加、比较、字符串可以连接,lua将这些操作的定义放在了元表中去描述。lua中的每个值都有一个元表。table和userdata可以有各自独立的元表,而其他类型则共享其类型所属的统一元表。(书上是这么说的，但是我用getmetatable方法只能获取到字符串的元表)lua在创建table的时候不会为它创建元表,所以,table没有加的操作,我们就可以通过给table设置我们自己写的元表,为table定义一套自定义的加的操作。\n\n\n## 如何获取元表?\n\nlua中通过getmetatable获取值得元表:\n\n```lua\nprint(\"str 1 : \"..tostring( getmetatable(\"str1\")) )\nprint(\"str 2 : \"..tostring( getmetatable(\"str1\")) )\nprint(\"nil : \"..tostring( getmetatable(nil)) )\nprint(\"number : \"..tostring( getmetatable(1)) )\nprint(\"function : \"..tostring( getmetatable(function()end)) )\nprint(\"table : \"..tostring( getmetatable({})) )\n```\n\n>str 1 : table: 009D9798\n>str 2 : table: 009D9798\n>nil : nilw\n>number : nil\n>function : nil\n>table : nil\n\n可以看到不同的字符串用的是同一个元表,而除了字符串之外其他的值的元表都是nil。这里就是我看到和书上不一样的地方，书上说每个值都有一个元表。不过这只是一个小疑点，并不影响我们对元表的理解。\n\n我们看看string的原表到底是个什么东西:\n\n```lua\nfunction dump(t)\n\tif t==nil then\n\t\tprint(t)\n\telse\n\t\tprint(\"{\")\n\t\tfor k,v in pairs(t) do\n\t\t\tprint(\"\\t\"..tostring(k)..\" = \"..tostring(v))\n\t\tend\n\t\tprint(\"}\")\n\tend\nend\ndump(getmetatable(\"str1\"))\n```\n\n输出如下:\n>{\n>        \\__index = table: 00AF9270\n>}\n\n字符串的元表里面只有一个元素:\\__index,它也是一个table,我们继续跟踪下看看它到底是什么:\n```lua\nfunction dump(t)\n\tif t==nil then\n\t\tprint(t)\n\telse\n\t\tprint(\"{\")\n\t\tfor k,v in pairs(t) do\n\t\t\tprint(\"\\t\"..tostring(k)..\" = \"..tostring(v))\n\t\tend\n\t\tprint(\"}\")\n\tend\nend\ndump(getmetatable(\"str1\").__index)\n```\n\n输出如下:\n>{\n>        sub = function: 00ABABF8\n>        upper = function: 00ABACB8\n>        len = function: 00AB9D00\n>        gfind = function: 00AB9CA0\n>        rep = function: 00ABAD58\n>        find = function: 00AB9E20\n>        match = function: 00ABA9F8\n>        char = function: 00AB9C40\n>        dump = function: 00AB9F20\n>        gmatch = function: 00AB9CA0\n>        reverse = function: 00ABAC38\n>        byte = function: 00AB9CC0\n>        format = function: 00AB9C80\n>        gsub = function: 00AB9CE0\n>        lower = function: 00AB9D40\n>}\n\n\\__index这个table定义了字符串的一些基本操作,如获取长度,查找子串等。它们的其实就定义在string这个table里,也就是说所有的字符串的元表的\\__index都是string:\n\n```lua\nfunction dump(t)\n\tif t==nil then\n\t\tprint(t)\n\telse\n\t\tprint(\"{\")\n\t\tfor k,v in pairs(t) do\n\t\t\tprint(\"\\t\"..tostring(k)..\" = \"..tostring(v))\n\t\tend\n\t\tprint(\"}\")\n\tend\nend\n\nprint(getmetatable(\"str\").__index)\nprint(string)\n```\n>table: 00C89270\n>table: 00C89270\n\n\n## 如何设置元表?\n\n在lua中,我们可以用setmetatable(table, metatable)这个方法去设置table的元表:\n\n```lua\nlocal t = {}\nprint(getmetatable(t))\nsetmetatable(t,{})\nprint(getmetatable(t))\n```\n\n输出如下:\n\n>nil\n>table: 0x7feaf1407190\n\n这样就成功为t设置了一个元表,这个元表是一个空的table。\n\n## 元表的作用\n\n那设置元表又有什么用呢？还记得元表的作用是什么吗？对定义对值得操作,例如下面的代码,我们为table设置了一个tostring的操作:\n```lua\nlocal t = {x=1,y=2}\nprint(tostring(t))\n\nlocal mt = {}\nmt.__tostring = function(t)return \"(\"..t.x..\",\"..t.y..\")\" end\nsetmetatable(t,mt)\nprint(tostring(t))\n```\n\n>table: 00B49678\n>(1,2)\n\n类似的在元表中我们可以定义下面的这些方法:\n\n|方法|作用|\n|--|--|\n|\\__add|加法|\n|\\__sub|减法|\n|\\__mul|乘法|\n|\\__div|除法|\n|\\__unm|相反数|\n|\\__mod|取模|\n|\\__pow|乘幂|\n|\\__concat|连接操作|\n|\\__eq|等于|\n|\\__lt|小于|\n|\\__le|小于等于|\n|\\__tostring|转化为字符串|\n|\\__index|读取不存在的字段|\n|\\__newindex|设置不存在的字段|\n\n注意lua会把a~=b转化为not(a==b),将a>b转化为b<a,将a>=b转化为b<=a,所以元表中并没有表示这几种操作的字段\n\n## 元表与类机制\n\n如果我们每创建一个table都要这样手动的为它创建一个元表,其实是很麻烦的一件事情,所以我们可以用下面的方法去简化操作:\n\n```lua\nlocal MyTable = {__tostring=function(t)return t.x..\",\"..t.y end}\n\nfunction MyTable.new(t)\n\tif t==nil then\n\t\tt = {}\n\tend\n\tsetmetatable(t, MyTable)\n\treturn t\nend\n\nprint(MyTable.new{x=1,y=2})\n```\n\n输出如下:\n\n>1,2\n\n\n看，这是不是有点像类？还记得\\__index吗？它用来定义访问table中没有的字段的时候的操作:\n\n```lua\nlocal mt = {}\nmt.__index = function(t,k)return \"no key [\"..k..\"] in table\" end\n\nlocal t = {x=1,y=2}\nsetmetatable(t,mt)\nprint(t.x)\nprint(t.y)\nprint(t.z)\n```\n\n输出如下:\n\n>1\n>2\n>no key [z] in table\n\n特殊的,如果\\__index是一个table的时候,在访问没有的字段的时候lua解释器就会到元表的\\__index中去找:\n\n```lua\nlocal t = {}\nprint(t.x)\n\nlocal index = {x=123}\nsetmetatable(t,{__index=index})\nprint(t.x)\n\nt.x = 321\nprint(t.x)\nprint(getmetatable(t).__index.x)\n```\n\n它的输出是这样的:\n>nil\n>123\n>321\n>123\n\n当在table中找不到字段时,解释器会去元表的\\__index字段中去找,如果\\__index中可以找到的话就用\\__index中的字段。如果table中有该字段的话,解释器就不会再去查询元表。嗯，听起来是不是有点像继承和重写?事实上lua的继承机制也是利用元表的这种特性实现的。\n","source":"_posts/lua元表.md","raw":"title: lua元表\ndate: 2016-10-28 22:45:37\ntags:\n\t- 技术相关\n\t- lua\n---\n\n## 元表是什么？\n\n在lua中,每个值都有一套预定义的操作集合。例如数字可以相加、比较、字符串可以连接,lua将这些操作的定义放在了元表中去描述。lua中的每个值都有一个元表。table和userdata可以有各自独立的元表,而其他类型则共享其类型所属的统一元表。(书上是这么说的，但是我用getmetatable方法只能获取到字符串的元表)lua在创建table的时候不会为它创建元表,所以,table没有加的操作,我们就可以通过给table设置我们自己写的元表,为table定义一套自定义的加的操作。\n\n\n## 如何获取元表?\n\nlua中通过getmetatable获取值得元表:\n\n```lua\nprint(\"str 1 : \"..tostring( getmetatable(\"str1\")) )\nprint(\"str 2 : \"..tostring( getmetatable(\"str1\")) )\nprint(\"nil : \"..tostring( getmetatable(nil)) )\nprint(\"number : \"..tostring( getmetatable(1)) )\nprint(\"function : \"..tostring( getmetatable(function()end)) )\nprint(\"table : \"..tostring( getmetatable({})) )\n```\n\n>str 1 : table: 009D9798\n>str 2 : table: 009D9798\n>nil : nilw\n>number : nil\n>function : nil\n>table : nil\n\n可以看到不同的字符串用的是同一个元表,而除了字符串之外其他的值的元表都是nil。这里就是我看到和书上不一样的地方，书上说每个值都有一个元表。不过这只是一个小疑点，并不影响我们对元表的理解。\n\n我们看看string的原表到底是个什么东西:\n\n```lua\nfunction dump(t)\n\tif t==nil then\n\t\tprint(t)\n\telse\n\t\tprint(\"{\")\n\t\tfor k,v in pairs(t) do\n\t\t\tprint(\"\\t\"..tostring(k)..\" = \"..tostring(v))\n\t\tend\n\t\tprint(\"}\")\n\tend\nend\ndump(getmetatable(\"str1\"))\n```\n\n输出如下:\n>{\n>        \\__index = table: 00AF9270\n>}\n\n字符串的元表里面只有一个元素:\\__index,它也是一个table,我们继续跟踪下看看它到底是什么:\n```lua\nfunction dump(t)\n\tif t==nil then\n\t\tprint(t)\n\telse\n\t\tprint(\"{\")\n\t\tfor k,v in pairs(t) do\n\t\t\tprint(\"\\t\"..tostring(k)..\" = \"..tostring(v))\n\t\tend\n\t\tprint(\"}\")\n\tend\nend\ndump(getmetatable(\"str1\").__index)\n```\n\n输出如下:\n>{\n>        sub = function: 00ABABF8\n>        upper = function: 00ABACB8\n>        len = function: 00AB9D00\n>        gfind = function: 00AB9CA0\n>        rep = function: 00ABAD58\n>        find = function: 00AB9E20\n>        match = function: 00ABA9F8\n>        char = function: 00AB9C40\n>        dump = function: 00AB9F20\n>        gmatch = function: 00AB9CA0\n>        reverse = function: 00ABAC38\n>        byte = function: 00AB9CC0\n>        format = function: 00AB9C80\n>        gsub = function: 00AB9CE0\n>        lower = function: 00AB9D40\n>}\n\n\\__index这个table定义了字符串的一些基本操作,如获取长度,查找子串等。它们的其实就定义在string这个table里,也就是说所有的字符串的元表的\\__index都是string:\n\n```lua\nfunction dump(t)\n\tif t==nil then\n\t\tprint(t)\n\telse\n\t\tprint(\"{\")\n\t\tfor k,v in pairs(t) do\n\t\t\tprint(\"\\t\"..tostring(k)..\" = \"..tostring(v))\n\t\tend\n\t\tprint(\"}\")\n\tend\nend\n\nprint(getmetatable(\"str\").__index)\nprint(string)\n```\n>table: 00C89270\n>table: 00C89270\n\n\n## 如何设置元表?\n\n在lua中,我们可以用setmetatable(table, metatable)这个方法去设置table的元表:\n\n```lua\nlocal t = {}\nprint(getmetatable(t))\nsetmetatable(t,{})\nprint(getmetatable(t))\n```\n\n输出如下:\n\n>nil\n>table: 0x7feaf1407190\n\n这样就成功为t设置了一个元表,这个元表是一个空的table。\n\n## 元表的作用\n\n那设置元表又有什么用呢？还记得元表的作用是什么吗？对定义对值得操作,例如下面的代码,我们为table设置了一个tostring的操作:\n```lua\nlocal t = {x=1,y=2}\nprint(tostring(t))\n\nlocal mt = {}\nmt.__tostring = function(t)return \"(\"..t.x..\",\"..t.y..\")\" end\nsetmetatable(t,mt)\nprint(tostring(t))\n```\n\n>table: 00B49678\n>(1,2)\n\n类似的在元表中我们可以定义下面的这些方法:\n\n|方法|作用|\n|--|--|\n|\\__add|加法|\n|\\__sub|减法|\n|\\__mul|乘法|\n|\\__div|除法|\n|\\__unm|相反数|\n|\\__mod|取模|\n|\\__pow|乘幂|\n|\\__concat|连接操作|\n|\\__eq|等于|\n|\\__lt|小于|\n|\\__le|小于等于|\n|\\__tostring|转化为字符串|\n|\\__index|读取不存在的字段|\n|\\__newindex|设置不存在的字段|\n\n注意lua会把a~=b转化为not(a==b),将a>b转化为b<a,将a>=b转化为b<=a,所以元表中并没有表示这几种操作的字段\n\n## 元表与类机制\n\n如果我们每创建一个table都要这样手动的为它创建一个元表,其实是很麻烦的一件事情,所以我们可以用下面的方法去简化操作:\n\n```lua\nlocal MyTable = {__tostring=function(t)return t.x..\",\"..t.y end}\n\nfunction MyTable.new(t)\n\tif t==nil then\n\t\tt = {}\n\tend\n\tsetmetatable(t, MyTable)\n\treturn t\nend\n\nprint(MyTable.new{x=1,y=2})\n```\n\n输出如下:\n\n>1,2\n\n\n看，这是不是有点像类？还记得\\__index吗？它用来定义访问table中没有的字段的时候的操作:\n\n```lua\nlocal mt = {}\nmt.__index = function(t,k)return \"no key [\"..k..\"] in table\" end\n\nlocal t = {x=1,y=2}\nsetmetatable(t,mt)\nprint(t.x)\nprint(t.y)\nprint(t.z)\n```\n\n输出如下:\n\n>1\n>2\n>no key [z] in table\n\n特殊的,如果\\__index是一个table的时候,在访问没有的字段的时候lua解释器就会到元表的\\__index中去找:\n\n```lua\nlocal t = {}\nprint(t.x)\n\nlocal index = {x=123}\nsetmetatable(t,{__index=index})\nprint(t.x)\n\nt.x = 321\nprint(t.x)\nprint(getmetatable(t).__index.x)\n```\n\n它的输出是这样的:\n>nil\n>123\n>321\n>123\n\n当在table中找不到字段时,解释器会去元表的\\__index字段中去找,如果\\__index中可以找到的话就用\\__index中的字段。如果table中有该字段的话,解释器就不会再去查询元表。嗯，听起来是不是有点像继承和重写?事实上lua的继承机制也是利用元表的这种特性实现的。\n","slug":"lua元表","published":1,"updated":"2017-06-02T22:47:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2unf002aw3fyhjxekgru"},{"title":"kotlin到底好在哪里","date":"2018-02-20T12:51:08.000Z","_content":"\n最近在学kotlin,虽然还没有像其他博主一样立马就爱上它.但是不得不说,kotlin对比起java还是有不少优势的.\n\n# 1、语法简洁\n\n首先是语法比较简洁,能不简单处理的就不啰嗦.\n\n## 1.1、变量与常量\n\n变量通过var关键字定义,常量通过val关键字定义.既支持类型推倒也支持显示声明类型.这样的话定义变量和常量写起来会比java简洁一些:\n\n```\nvar intVar = 1 // 通过取值可以自动推倒出变量的类型\nvar stringVar: String = \"abc\" // 也可以显式声明变量类型\nval INT_VALUE = 1 // 使用val关键字定义常量\n```\n\n## 1.2、类\n\n在kotlin中,类可以通过class关键字定义.支持在主构造方法中用var或者val关键字直接定义成员变量,例如下面的name和author,当然也支持在类结构体中定义成员变量,如price.\n\n```\n// 类,这个类有name,author和price三个成员变量\nclass Book(var name: String, val author: String, p: Int) {\n    var price = p\n        private set // 将price的set操作设置为私有,只能在类内部赋值,外部只能读取\n\n    fun isTheSameAuthor(other: Book): Boolean {\n        return author == other.author\n    }\n}\n```\n\n与java中不同的是,kotlin中所有的类成员变量都是通过类访问器get和set去访问成员变量的,例如下面的代码中对price的调用并不是直接操作price变量,而是通过get/set访问器去访问的.所以我们可以将price的set访问器设置为私有的,这样的话就不能在外部去设置price的值了:\n\n```\nvar book = Book(\"book\", \"author\", 100)\nprintln(book.price) // 调用price的get访问器获取price的值\nbook.price = 123 // error,通过price的set访问器设置price的值,但是我们已经将它声明为私有了所以外部不能调用\n```\n\n假设我们用java去实现上面的Book类,我们需要写成下面这个样子.是不是感觉java的语法会啰嗦很多?实际上下面的java代码我还去掉了空指针处理和final关键字修饰.所以实际上代码量会更大.kotlin中短短的七行代码,java中要实现完全一模一样的功能,起码需要数十行代码.\n\n```\npublic class Book {\n   private int price;\n   private String name;\n   private String author;\n\n   public Book(String name, String author, int p) {\n      this.name = name;\n      this.author = author;\n      this.price = p;\n   }\n\n   public boolean isTheSameAuthor(Book other) {\n      return Intrinsics.areEqual(this.author, other.author);\n   }\n\n   public int getPrice() {\n      return this.price;\n   }\n\n   private void setPrice(int var1) {\n      this.price = var1;\n   }\n\n   public String getName() {\n      return this.name;\n   }\n\n   public void setName(String var1) {\n      this.name = var1;\n   }\n\n   public String getAuthor() {\n      return this.author;\n   }\n}\n```\n\n## 1.3、数据类\n\n在kotlin中,我们还有可以用data class去定义单纯只是保存数据的数据类:\n\n```\n// 数据类,除了有name和age两个成员变量之外还自动生成了equals,hashCode,toString等方法\ndata class Person(var name: String, var age: Int)\n```\n\n有的同学可能会会,数据类和普通的类有什么区别呢?让我们看下下面的代码就一目了然了:\n\n```\ndata class PersonData(var name: String, var age: Int)\nclass PersonClass(var name: String, var age: Int)\n\nvar dataA = PersonData(\"jack\", 18)\nvar dataB = PersonData(\"jack\", 18)\nprintln(dataA) // PersonData(name=jack, age=18)\nprintln(dataB) // PersonData(name=jack, age=18)\nprintln(dataA == dataB) // true\n\nvar classA = PersonClass(\"peter\", 20)\nvar classB = PersonClass(\"peter\", 20)\nprintln(classA) // me.linjw.demo.TestKotlin.PersonClass@5fcfe4b2\nprintln(classB) // me.linjw.demo.TestKotlin.PersonClass@6bf2d08e\nprintln(classA == classB) // false\n```\n\n假设用java去实现的话就不知道这一行的kotlin代码需要多少行才能实现了.\n\n## 1.4、object 对象\n\n我们能使用object关键字直接实现单例模式:\n\n```\nobject DataBaseHelper {\n  ...\n}\n```\n\n它翻译成java是这样的:\n\n```\npublic class DataBaseHelper {\n  public static final DataBaseHelper INSTANCE;\n\n  private DataBaseHelper() {\n\n  }\n\n  static {\n    INSTANCE = new DataBaseHelper();\n  }\n}\n```\n\n\n# 2、命名参数\n\nkotlin支持命名参数。当一个方法的参数数目特别多的时候,命名参数就很有用了。例如String.regionMatches方法有五个参数:\n\n```\npublic boolean regionMatches(boolean ignoreCase, int toffset,\n            String other, int ooffset, int len) {\n\t...\n}\n```\n\n在调用的时候一眼很难看出哪个实参有什么作用:\n\n```\nString str = new String(\"hello world!\");\nString sub = new String(\"WORLD\");\nSystem.out.println(str.regionMatches(true, 6, sub, 0, 5));\n```\n\n而在kotlin中可以用命名参数将每个实参对应的形参注明出来,简直一目了然:\n\n```\nval str = \"hello world!\"\nval sub = \"WORLD\"\nprintln(str.regionMatches(thisOffset = 6, other = sub, otherOffset = 0, length = 5, ignoreCase = true))\n\n//命名参数可以用不同于函数声明的参数顺序传参\nprintln(str.regionMatches(ignoreCase = true, thisOffset = 6, other = sub, otherOffset = 0, length = 5))\n```\n\n而且使用命名参数的话可以不遵循方法声明的时候的参数顺序传参,因为我们已经将哪个实参传给哪个形参都标明了.\n\n\n# 3、空指针安全\n\n在kotlin中,每个类型都有其对应的可空类型,只有可空类型才能被赋值为null:\n\n```\nvar a: Int = 1 // 非空类型需要初始化为非null\nvar b: Int? // 可空类型可以不初始化,默认为null\nvar c: String = \"\" // 非空类型需要初始化为非null\nvar d: String? = null // 可空类型也可以显式赋值为null\nvar e: Float = 1.0f // 非空类型需要初始化为非null\nvar f: Float? = 2.0f // 可空类型也可以显式赋值为非null\n\na = null // error类型不能赋值为null,编译不通过\nb = null // ok\nc = null // error类型不能赋值为null,编译不通过\nd = null // ok\ne = null // error类型不能赋值为null,编译不通过\nf = null // ok\n```\n\n非空类型不可能为null,所以不用考虑空指针的问题.只有可空类型有可能为null,这个时候必须指定它为null的时候的行为.\n\n可以用\"?.\"做判空处理,或者使用\"!!.\"在空指针的情况下抛出空指针异常:\n\n```\nfun foo(str : String?){\n    println(str?.length) // str?.length表达式结果为null,可以正常运行\n    println(str!!.length) // 抛出空指针异常\n}\n```\n\nfoo方法翻译成java是这样的:\n\n```\npublic final void foo(@Nullable String str) {\n  Integer var2 = str != null?Integer.valueOf(str.length()):null;\n  System.out.println(var2);\n  if(str == null) {\n    Intrinsics.throwNpe(); // 抛出空指针异常\n  }\n\n  int var3 = str.length();\n  System.out.println(var3);\n}\n```\n\n很多文章在介绍kotlin的可空类型的时候都是以简化了判空处理的优点来介绍的.例如下面java方法中的判空处理,用kotlin只需要一行代码就可以了:\n\n```\n// java中需要自己判空\npublic Character front(String str) {\n    if (str != null){\n        return str.charAt(0);\n    }\n    return null;\n}\n\n// kotlin中用可空类型只需要一行代码\nfun front(str: String?): Char? {\n   return str?.get(0);\n}\n```\n\n但是在我看来,可空类型非空类型的意义并不在帮我们做简化了判空处理的代码.更重要的一点是明确指出了哪些变量是可能为空的,同时明确了为空的时候的调用应该怎么处理.\n\n对于非空类型,它永远不可能为空,我们不需要考虑它的空指针问题.而对于可空类型,我们需要明确指定在它为空的时候的调用抛出异常亦或进行执行.这样其实缩小了空指针异常的范围,同时也减小了空指针对程序稳定安全的破坏性.\n\n# 4、字符串模板\n\n在kotlin字符串中可以用\"$\"符号标识一个表达式,该表达式的值会被计算出来放到字符串中:\n\n```\nval str = \"abc\"\nprintln(\"$str.length is ${str.length}\") // 结果为 \"abc.length is 3\"\n```\n\n比起java用字符串拼接或者String.format的方式去处理都要优雅得多.\n\n# 5、高阶函数和Lambda表达式的支持\n\n\n在java中实现观察者模式,我们往往需要额外定义一个监听者的接口,这种监听者接口往往也只有一个方法,其实实际上属于比较冗余的代码,没有很大的实际价值:\n\n```\npublic class Button {\n    private OnClickListener mListener;\n\n    public void setOnClickListener(OnClickListener listener) {\n        mListener = listener;\n    }\n\n    public interface OnClickListener {\n        void onClick(Button button);\n    }\n}\n```\n\n而在kotlin中我们可以将函数直接作为一个对象保存起来,再也不用为监听者单独定义一个接口了:\n\n```\nclass Button {\n  var listener: ((Button) -> Unit)? = null\n\n  fun click() {\n    listener?.invoke(this)\n  }\n}\n\nvar btn = Button()\nbtn.listener = { print(\"on click\") }\nbtn.click()\n```\n\n# 6、泛型\n\n在java泛型中存在类型通配符,用\"? extends T\"指定类参数的上限,用\"? super T\"指定类型参数的下限.\n\n至于什么时候使用哪一种,在《Effect java》 中给出了PECS原则:\n\n> PECS: producer-extends,consumer-super\n\n在生产者中使用\"? extends T\",在消费者中使用\"? super T\".\n\njava中使用类型的关系去设计了通配符,这样做的确在实现上是比较清晰的.但是我个人其实更加喜欢kotlin中直接通过功能去规定类型安全的类型上下界.\n\n```\npublic <T> void copy(List<? super T> dest, List<? extends T> src) {\n  ...\n}\n```\n\nList<? super T> dest 是消费者,数据将会放到这里.而List<? extends T> src是生产者,数据从这里提供.\n\n实际上看copy这个java方法,在定义的时候需要稍微思考一下才能确定哪个用super哪个用extends.但是如果你用kotlin的话想都不用想,消费者用in,生产者用out:\n\n```\nfun <T> copy(dest: Array<in T>, src: Array<out T>) {\n  ...\n}\n```\n\n直接用in/out这种功能描述是不是比java用super/extends这种类型描述直接了很多?\n\n泛型这部分参考了《Kotlin极简教程》,这本书真的不错,强烈推荐.而大家如果对java泛型有兴趣的话可以去可空《Effect java》的相关章节或者也可以去看看我之前写的两篇文章 [《java泛型那些事》](http://blog.islinjw.cn/2018/01/06/java%E6%B3%9B%E5%9E%8B%E9%82%A3%E4%BA%9B%E4%BA%8B/)、[《再谈Java泛型》](http://blog.islinjw.cn/2018/02/04/%E5%86%8D%E8%B0%88Java%E6%B3%9B%E5%9E%8B/)\n\n# 7、无缝调用java\n\n当然,一个语言就算做的再好,但是没有一个健全的生态的话是很难被大众接受的.kotlin能够火起来,甚至被谷歌爸爸钦定为安卓的官方推荐语言.一个很重要的原因就是它可以无缝与java相互调用.以前写的java代码不用任何处理就能直接在kotlin中使用,而java也能无缝调用kotlin代码.\n\n实际上在安卓中,编译的时候kotlin代码就会被编译成java代码,所以它们其实是等价的.\n","source":"_posts/kotlin到底好在哪里.md","raw":"title: kotlin到底好在哪里\ndate: 2018-02-20 20:51:08\ntags:\n\t- 技术相关\n\t- kotlin\n---\n\n最近在学kotlin,虽然还没有像其他博主一样立马就爱上它.但是不得不说,kotlin对比起java还是有不少优势的.\n\n# 1、语法简洁\n\n首先是语法比较简洁,能不简单处理的就不啰嗦.\n\n## 1.1、变量与常量\n\n变量通过var关键字定义,常量通过val关键字定义.既支持类型推倒也支持显示声明类型.这样的话定义变量和常量写起来会比java简洁一些:\n\n```\nvar intVar = 1 // 通过取值可以自动推倒出变量的类型\nvar stringVar: String = \"abc\" // 也可以显式声明变量类型\nval INT_VALUE = 1 // 使用val关键字定义常量\n```\n\n## 1.2、类\n\n在kotlin中,类可以通过class关键字定义.支持在主构造方法中用var或者val关键字直接定义成员变量,例如下面的name和author,当然也支持在类结构体中定义成员变量,如price.\n\n```\n// 类,这个类有name,author和price三个成员变量\nclass Book(var name: String, val author: String, p: Int) {\n    var price = p\n        private set // 将price的set操作设置为私有,只能在类内部赋值,外部只能读取\n\n    fun isTheSameAuthor(other: Book): Boolean {\n        return author == other.author\n    }\n}\n```\n\n与java中不同的是,kotlin中所有的类成员变量都是通过类访问器get和set去访问成员变量的,例如下面的代码中对price的调用并不是直接操作price变量,而是通过get/set访问器去访问的.所以我们可以将price的set访问器设置为私有的,这样的话就不能在外部去设置price的值了:\n\n```\nvar book = Book(\"book\", \"author\", 100)\nprintln(book.price) // 调用price的get访问器获取price的值\nbook.price = 123 // error,通过price的set访问器设置price的值,但是我们已经将它声明为私有了所以外部不能调用\n```\n\n假设我们用java去实现上面的Book类,我们需要写成下面这个样子.是不是感觉java的语法会啰嗦很多?实际上下面的java代码我还去掉了空指针处理和final关键字修饰.所以实际上代码量会更大.kotlin中短短的七行代码,java中要实现完全一模一样的功能,起码需要数十行代码.\n\n```\npublic class Book {\n   private int price;\n   private String name;\n   private String author;\n\n   public Book(String name, String author, int p) {\n      this.name = name;\n      this.author = author;\n      this.price = p;\n   }\n\n   public boolean isTheSameAuthor(Book other) {\n      return Intrinsics.areEqual(this.author, other.author);\n   }\n\n   public int getPrice() {\n      return this.price;\n   }\n\n   private void setPrice(int var1) {\n      this.price = var1;\n   }\n\n   public String getName() {\n      return this.name;\n   }\n\n   public void setName(String var1) {\n      this.name = var1;\n   }\n\n   public String getAuthor() {\n      return this.author;\n   }\n}\n```\n\n## 1.3、数据类\n\n在kotlin中,我们还有可以用data class去定义单纯只是保存数据的数据类:\n\n```\n// 数据类,除了有name和age两个成员变量之外还自动生成了equals,hashCode,toString等方法\ndata class Person(var name: String, var age: Int)\n```\n\n有的同学可能会会,数据类和普通的类有什么区别呢?让我们看下下面的代码就一目了然了:\n\n```\ndata class PersonData(var name: String, var age: Int)\nclass PersonClass(var name: String, var age: Int)\n\nvar dataA = PersonData(\"jack\", 18)\nvar dataB = PersonData(\"jack\", 18)\nprintln(dataA) // PersonData(name=jack, age=18)\nprintln(dataB) // PersonData(name=jack, age=18)\nprintln(dataA == dataB) // true\n\nvar classA = PersonClass(\"peter\", 20)\nvar classB = PersonClass(\"peter\", 20)\nprintln(classA) // me.linjw.demo.TestKotlin.PersonClass@5fcfe4b2\nprintln(classB) // me.linjw.demo.TestKotlin.PersonClass@6bf2d08e\nprintln(classA == classB) // false\n```\n\n假设用java去实现的话就不知道这一行的kotlin代码需要多少行才能实现了.\n\n## 1.4、object 对象\n\n我们能使用object关键字直接实现单例模式:\n\n```\nobject DataBaseHelper {\n  ...\n}\n```\n\n它翻译成java是这样的:\n\n```\npublic class DataBaseHelper {\n  public static final DataBaseHelper INSTANCE;\n\n  private DataBaseHelper() {\n\n  }\n\n  static {\n    INSTANCE = new DataBaseHelper();\n  }\n}\n```\n\n\n# 2、命名参数\n\nkotlin支持命名参数。当一个方法的参数数目特别多的时候,命名参数就很有用了。例如String.regionMatches方法有五个参数:\n\n```\npublic boolean regionMatches(boolean ignoreCase, int toffset,\n            String other, int ooffset, int len) {\n\t...\n}\n```\n\n在调用的时候一眼很难看出哪个实参有什么作用:\n\n```\nString str = new String(\"hello world!\");\nString sub = new String(\"WORLD\");\nSystem.out.println(str.regionMatches(true, 6, sub, 0, 5));\n```\n\n而在kotlin中可以用命名参数将每个实参对应的形参注明出来,简直一目了然:\n\n```\nval str = \"hello world!\"\nval sub = \"WORLD\"\nprintln(str.regionMatches(thisOffset = 6, other = sub, otherOffset = 0, length = 5, ignoreCase = true))\n\n//命名参数可以用不同于函数声明的参数顺序传参\nprintln(str.regionMatches(ignoreCase = true, thisOffset = 6, other = sub, otherOffset = 0, length = 5))\n```\n\n而且使用命名参数的话可以不遵循方法声明的时候的参数顺序传参,因为我们已经将哪个实参传给哪个形参都标明了.\n\n\n# 3、空指针安全\n\n在kotlin中,每个类型都有其对应的可空类型,只有可空类型才能被赋值为null:\n\n```\nvar a: Int = 1 // 非空类型需要初始化为非null\nvar b: Int? // 可空类型可以不初始化,默认为null\nvar c: String = \"\" // 非空类型需要初始化为非null\nvar d: String? = null // 可空类型也可以显式赋值为null\nvar e: Float = 1.0f // 非空类型需要初始化为非null\nvar f: Float? = 2.0f // 可空类型也可以显式赋值为非null\n\na = null // error类型不能赋值为null,编译不通过\nb = null // ok\nc = null // error类型不能赋值为null,编译不通过\nd = null // ok\ne = null // error类型不能赋值为null,编译不通过\nf = null // ok\n```\n\n非空类型不可能为null,所以不用考虑空指针的问题.只有可空类型有可能为null,这个时候必须指定它为null的时候的行为.\n\n可以用\"?.\"做判空处理,或者使用\"!!.\"在空指针的情况下抛出空指针异常:\n\n```\nfun foo(str : String?){\n    println(str?.length) // str?.length表达式结果为null,可以正常运行\n    println(str!!.length) // 抛出空指针异常\n}\n```\n\nfoo方法翻译成java是这样的:\n\n```\npublic final void foo(@Nullable String str) {\n  Integer var2 = str != null?Integer.valueOf(str.length()):null;\n  System.out.println(var2);\n  if(str == null) {\n    Intrinsics.throwNpe(); // 抛出空指针异常\n  }\n\n  int var3 = str.length();\n  System.out.println(var3);\n}\n```\n\n很多文章在介绍kotlin的可空类型的时候都是以简化了判空处理的优点来介绍的.例如下面java方法中的判空处理,用kotlin只需要一行代码就可以了:\n\n```\n// java中需要自己判空\npublic Character front(String str) {\n    if (str != null){\n        return str.charAt(0);\n    }\n    return null;\n}\n\n// kotlin中用可空类型只需要一行代码\nfun front(str: String?): Char? {\n   return str?.get(0);\n}\n```\n\n但是在我看来,可空类型非空类型的意义并不在帮我们做简化了判空处理的代码.更重要的一点是明确指出了哪些变量是可能为空的,同时明确了为空的时候的调用应该怎么处理.\n\n对于非空类型,它永远不可能为空,我们不需要考虑它的空指针问题.而对于可空类型,我们需要明确指定在它为空的时候的调用抛出异常亦或进行执行.这样其实缩小了空指针异常的范围,同时也减小了空指针对程序稳定安全的破坏性.\n\n# 4、字符串模板\n\n在kotlin字符串中可以用\"$\"符号标识一个表达式,该表达式的值会被计算出来放到字符串中:\n\n```\nval str = \"abc\"\nprintln(\"$str.length is ${str.length}\") // 结果为 \"abc.length is 3\"\n```\n\n比起java用字符串拼接或者String.format的方式去处理都要优雅得多.\n\n# 5、高阶函数和Lambda表达式的支持\n\n\n在java中实现观察者模式,我们往往需要额外定义一个监听者的接口,这种监听者接口往往也只有一个方法,其实实际上属于比较冗余的代码,没有很大的实际价值:\n\n```\npublic class Button {\n    private OnClickListener mListener;\n\n    public void setOnClickListener(OnClickListener listener) {\n        mListener = listener;\n    }\n\n    public interface OnClickListener {\n        void onClick(Button button);\n    }\n}\n```\n\n而在kotlin中我们可以将函数直接作为一个对象保存起来,再也不用为监听者单独定义一个接口了:\n\n```\nclass Button {\n  var listener: ((Button) -> Unit)? = null\n\n  fun click() {\n    listener?.invoke(this)\n  }\n}\n\nvar btn = Button()\nbtn.listener = { print(\"on click\") }\nbtn.click()\n```\n\n# 6、泛型\n\n在java泛型中存在类型通配符,用\"? extends T\"指定类参数的上限,用\"? super T\"指定类型参数的下限.\n\n至于什么时候使用哪一种,在《Effect java》 中给出了PECS原则:\n\n> PECS: producer-extends,consumer-super\n\n在生产者中使用\"? extends T\",在消费者中使用\"? super T\".\n\njava中使用类型的关系去设计了通配符,这样做的确在实现上是比较清晰的.但是我个人其实更加喜欢kotlin中直接通过功能去规定类型安全的类型上下界.\n\n```\npublic <T> void copy(List<? super T> dest, List<? extends T> src) {\n  ...\n}\n```\n\nList<? super T> dest 是消费者,数据将会放到这里.而List<? extends T> src是生产者,数据从这里提供.\n\n实际上看copy这个java方法,在定义的时候需要稍微思考一下才能确定哪个用super哪个用extends.但是如果你用kotlin的话想都不用想,消费者用in,生产者用out:\n\n```\nfun <T> copy(dest: Array<in T>, src: Array<out T>) {\n  ...\n}\n```\n\n直接用in/out这种功能描述是不是比java用super/extends这种类型描述直接了很多?\n\n泛型这部分参考了《Kotlin极简教程》,这本书真的不错,强烈推荐.而大家如果对java泛型有兴趣的话可以去可空《Effect java》的相关章节或者也可以去看看我之前写的两篇文章 [《java泛型那些事》](http://blog.islinjw.cn/2018/01/06/java%E6%B3%9B%E5%9E%8B%E9%82%A3%E4%BA%9B%E4%BA%8B/)、[《再谈Java泛型》](http://blog.islinjw.cn/2018/02/04/%E5%86%8D%E8%B0%88Java%E6%B3%9B%E5%9E%8B/)\n\n# 7、无缝调用java\n\n当然,一个语言就算做的再好,但是没有一个健全的生态的话是很难被大众接受的.kotlin能够火起来,甚至被谷歌爸爸钦定为安卓的官方推荐语言.一个很重要的原因就是它可以无缝与java相互调用.以前写的java代码不用任何处理就能直接在kotlin中使用,而java也能无缝调用kotlin代码.\n\n实际上在安卓中,编译的时候kotlin代码就会被编译成java代码,所以它们其实是等价的.\n","slug":"kotlin到底好在哪里","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2unh002dw3fy743muq5g"},{"title":"java泛型那些事","date":"2018-01-05T17:11:02.000Z","_content":"\n# 泛型的类型安全性\n\n有许多原因促成了泛型的出现，而最引人注意的一个原因，就是为了创建容器类。\n\n如果没有泛型,如果我们需要实现一个通用的队列,那么只能使用Obejct数组去实现,并且add方法的参数和get方法的返回值都为Object:\n\n```\npublic class MyList {\n    private Object[] mData;\n\n    public void add(Object obj) {\n        ...\n    }\n\n    public Object get(int index) {\n        ...\n    }\n    ...\n}\n```\n\n但是这样的话其实是很不安全的,类型安全需要靠用户去自己维护。但用户往往都是愚蠢的:\n\n```\nMyList myList = new MyList();\nmyList.add(\"1\");\nmyList.add(\"2\");\nmyList.add(3);\n\nString val1 = (String) myList.get(0);\nString val2 = (String) myList.get(1);\nString val3 = (String) myList.get(2);\n```\n\n上面的代码在编译的时候没有问题,但是真正运行的时候程序跑着跑着就挂了,这就叫做类型不安全的设计。\n\n使用泛型的意义在于它是类型安全的,如果使用泛型规定了参数和返回值的类型的话,上面的代码在编译的时候就会失败:\n\n\n```\npublic class MyList<E> {\n  private Object[] mData;\n\n  ...\n\n  public void add(E obj) {\n    ...\n  }\n\n  public E get(int index) {\n    ...\n    return (E) mData[index];\n  }\n}\n\nMyList<String> myList = new MyList<>();\nmyList.add(\"1\");\nmyList.add(\"2\");\nmyList.add(3); //这里会编译失败\n\nString val1 = myList.get(0);\nString val2 = myList.get(1);\nString val3 = myList.get(0);\n```\n\n# 类型标识符\n\n在MyList&lt;E&gt;声明尖括号里面的就是类型标识符,它其实是一个占位符,代表了某个类型,我们在类里面就能用这个占位符代表某种类型。例如add方法的参数或者get的返回值,当然也能用来声明一个成员变量。\n\n可能有人会说经常看到都是用T泛型作为泛型标识符,为什么这里我们用E呢?\n\n其实用什么字母做标识符在java里面并没有硬性规定,甚至你也可以不用仅一个字符，用一个单词也是可以的。\n\n不过我们通常会按照习惯在不同场景下用不同的字母标识符:\n\n- E - Element (在集合中使用)\n- T - Type（Java 类）\n- K - Key（键）\n- V - Value（值）\n\n# 泛型通配符\n\n在泛型中有个很重要的知识点就是__泛型类型之间是不具有继承关系的__,也就是说List&lt;Object&gt;并不是List&lt;String&gt;的父类:\n\n```\npublic void printList(List<Object> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}\n\n\nList<String> strList = Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\");\nprintList(strList); //错误,List<Object>不是List<String>的父类\n```\n\n为了实现上面的printList方法,类型通配符就出现了:\n\n\n```\npublic void printList(List<?> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}\n\nList<String> strList = Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\");\nprintList(strList);\n```\n\nList&lt;?&gt;可以匹配List&lt;String&gt;、List&lt;Integer&gt;等等的各种类型。\n\n大家有可能会听过类型通配符上限和下限,这两个东西是怎样的概念呢？有时候我们会需要限定只能传入某些型的子类或者父类的容器:\n\n\n- 上限：<? extends T> 只能匹配T和T的子类\n\n- 下限：<? super T> 只能匹配T和T的父类\n\n```\n//只能传入ClassA的子类的容器\npublic void printList(List<? extends ClassA> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}\n\n//只能传入ClassA的父类的容器\npublic void printList(List<? super ClassA> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}\n```\n\n除了上面的通配符\"?\"，我们还可以直接用泛型方法去实现printListde,可以指定所有类型的列表或者ClassA的子类的列表:\n\n```\npublic <T> void printList(List<T> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}\n\npublic <T extends ClassA> void printList(List<T> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}\n```\n\n当然我们也能使用泛型的方式直接指定参数的上限,比如下面的foo方法就只能接收Number的子类:\n\n```\npublic <T extends Number> void foo(T arg){\n    ...\n}\n```\n\n但是如果直接使用泛型的方式的话我们不能指定指定它的下限,例如下面两种写法都是__不能通过编译__的:\n\n```\n//错误.不能直接指定泛型的下限\npublic <T super Number> void printList(List<T> list) {\n    ...\n}\n\n//错误.不能直接指定泛型的下限\npublic <T super Number> void foo(T arg){\n    ...\n}\n```\n\n# 类型擦除\n\n可能很多同学都会听说过泛型类型擦除的概念,这个类型擦除具体指的是怎样一回事？\n\n可以看看下面的foo方法,它本来想实现的功能是:如果传入的参数非空,就将它返回。否则,就创建一个同类型的实例返回。但是这段代码是不能通过编译的:\n\n```\n//错误,泛型的类型被擦除了,不能直接new出来\npublic <T> void foo(T arg) {\n    return arg != null ? arg : new T();\n}\n```\n\n原因在于java的泛型实现中有个叫做类型擦除的机制。简单来讲就是运行的时候是无法获取到泛型使用的实际类型的。\n\n例如上面的T类型,因为我们在运行时不能知道它到底是什么类型,所以也就无法将它new出来。\n\njava代码生成的Java字节代码中是不包含泛型中的类型信息的,所有泛型类的类型参数在编译时都会被擦除。虚拟机中没有泛型,只有普通类和普通方法。因此泛型的类型安全是在编译的时候去检测的。\n\n所以我们创建泛型对象时需要指明类型，让编译器尽早的做参数检查。\n\n像下面的代码可以顺利通过,甚至可以正常运行,直到将获取到的数值类型的数据强转成字符串的时候才报ClassCastException异常:\n\n```\nList list = new ArrayList<String>();\nlist.add(\"abc\");\nlist.add(123);\nString elemt1 = (String) list.get(0);\nString elemt2 = (String) list.get(1); // java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String\n```\n\n我们可以用反射的方法的验证一下类型擦除:\n\n```\nList<Integer> list = new ArrayList<Integer>();\nSystem.out.println(\"type : \" + Arrays.toString(list.getClass().getTypeParameters()));\n```\n\n它得到的类型仅仅是一个占位符而已:\n\n> type : [E]\n\n# 类型擦除机制的历史原因\n\n有人会问,为什么java会在编译的时候将类型擦除,而不像ｃ++一样通过在编译的时候将泛型类实例化为多个具体的类去实现泛型呢？\n\n其实“实例化为多个具体的类”这样的实现方式也是比较容易实现的,但是为了保持兼容性,所以java在泛型的实现上选取类型擦除的方式。实际上是做了一定的取舍的。\n\n为什么说选用类型擦除是为了保持兼容性呢?因为泛型并不是java与生俱来的。实际上到了java５的时候才引入了泛型。\n\n要让以前编译的程序在新版本的JRE还能正常运行，就意味着以前没有的限制不能突然冒出来。\n\n例如在泛型出来之前java就已经有了容器的存在,而且它具有可以存储不同类型的的特性:\n\n```\nArrayList things = new ArrayList();\nthings.add(Integer.valueOf(123));\nthings.add(\"abc\");\n```\n\n那么这段代码在Java 5引入泛型之后还必须要继续可以运行。\n\n这里有两种设计思路：\n\n1. 需要泛型化的类型（主要是容器（Collections）类型），以前有的就保持不变，然后平行地加一套泛型化版本的新类型；\n\n2. 直接把已有的类型泛型化，让所有需要泛型化的已有类型都原地泛型化，不添加任何平行于已有类型的泛型版。\n\n.NET在1.1 -> 2.0的时候选择了上面选项的1，而Java则选择了2。\n\n从Java设计者的角度看，这个取舍很明白：.NET在1.1 -> 2.0的时候，实际的应用代码量还很少（相对Java来说），而且整个体系都在微软的控制下，要做变更比较容易；\n\n而在Java 1.4.2 -> 5.0的时候，Java已经有大量程序部署在生产环境中，已经有很多应用和库程序的代码。如果这些代码在新版本的Java中，为了使用Java的新功能（例如泛型）而必须做大量源码层修改，那么新功能的普及速度就会大受影响，而且新功能会被吐槽。\n\n在原地泛型化后，java.util.ArrayList这个类型变成了java.util.ArrayList&lt;E&gt;。但是以前的代码直接用ArrayList，在新版本里必须还能继续用，所以就引出了“raw type”的概念——一个类型虽然被泛型化了，但还可以把它当作非泛型化的类型用。\n\n```\nArrayList         - raw type\nArrayList<E>      - open generic type (assuming E is type variable)\nArrayList<String> - closed generic type\nArrayList<?>      - unbounded wildcard type\n```\n\n下面这样的代码必须可以编译运行：\n\n```\nArrayList<Integer> ilist = new ArrayList<Integer>();\nArrayList<String> slist = new ArrayList<String>();\nArrayList list; // raw type\nlist = ilist;   // assigning closed generic type to raw type\nlist = slist;   // ditto\n```\n\n所以java的设计者在考虑了这一点之后选用类型擦除也就显而易见了。类型擦除实际上是将泛型类型转换了Obejct。由于所有的java类都是Object的子类,所以实现起来就很简单了。只需要在编译的时候将所有的泛型占位符都换成Object就可以了:\n\n```\n//源码的泛型代码\npublic <T> void foo(T arg){\n    ...\n}\n\n//编译时转换成的代码\npublic void foo(Object arg){\n    ...\n}\n```\n\n而在擦除类型的同时,java编译器会对该方法的调用进行类型检查,防止非法类型的调用。\n\n但如果在编写代码的时候就已经用raw type的话,编译器就不会做类型的安全性检查了。\n\n这样的实现导致了一个问题,List<E>泛型参数E被擦除后就变成了Object,那么就不能在泛型中使用int、long等原生数据类型了,因为它们并不是Object的子类。\n\n据说当时设计java语言的程序员和产品经理打了一架,并且在打赢之后成功劝服产品经理在提出兼容性这样奇葩的需求之后做出一点小小的让步。（虽然只是我胡说八道的脑补,但谁知道当时的实际情形是不是这样的呢?）\n\n于是乎我们现在在泛型中只能使用Integer、Long等封箱类型而不能用int、long等原生类型了。\n\n\nps: 上面这段类型擦除机制的历史原因参考了RednaxelaFX大神知乎上的一个回答,有兴趣的同学可以去知乎看看原来的[完整回答](https://www.zhihu.com/question/28665443/answer/118148143)\n","source":"_posts/java泛型那些事.md","raw":"title: java泛型那些事\ndate: 2018-01-06 01:11:02\ntags:\n\t- 技术相关\n\t- java\n---\n\n# 泛型的类型安全性\n\n有许多原因促成了泛型的出现，而最引人注意的一个原因，就是为了创建容器类。\n\n如果没有泛型,如果我们需要实现一个通用的队列,那么只能使用Obejct数组去实现,并且add方法的参数和get方法的返回值都为Object:\n\n```\npublic class MyList {\n    private Object[] mData;\n\n    public void add(Object obj) {\n        ...\n    }\n\n    public Object get(int index) {\n        ...\n    }\n    ...\n}\n```\n\n但是这样的话其实是很不安全的,类型安全需要靠用户去自己维护。但用户往往都是愚蠢的:\n\n```\nMyList myList = new MyList();\nmyList.add(\"1\");\nmyList.add(\"2\");\nmyList.add(3);\n\nString val1 = (String) myList.get(0);\nString val2 = (String) myList.get(1);\nString val3 = (String) myList.get(2);\n```\n\n上面的代码在编译的时候没有问题,但是真正运行的时候程序跑着跑着就挂了,这就叫做类型不安全的设计。\n\n使用泛型的意义在于它是类型安全的,如果使用泛型规定了参数和返回值的类型的话,上面的代码在编译的时候就会失败:\n\n\n```\npublic class MyList<E> {\n  private Object[] mData;\n\n  ...\n\n  public void add(E obj) {\n    ...\n  }\n\n  public E get(int index) {\n    ...\n    return (E) mData[index];\n  }\n}\n\nMyList<String> myList = new MyList<>();\nmyList.add(\"1\");\nmyList.add(\"2\");\nmyList.add(3); //这里会编译失败\n\nString val1 = myList.get(0);\nString val2 = myList.get(1);\nString val3 = myList.get(0);\n```\n\n# 类型标识符\n\n在MyList&lt;E&gt;声明尖括号里面的就是类型标识符,它其实是一个占位符,代表了某个类型,我们在类里面就能用这个占位符代表某种类型。例如add方法的参数或者get的返回值,当然也能用来声明一个成员变量。\n\n可能有人会说经常看到都是用T泛型作为泛型标识符,为什么这里我们用E呢?\n\n其实用什么字母做标识符在java里面并没有硬性规定,甚至你也可以不用仅一个字符，用一个单词也是可以的。\n\n不过我们通常会按照习惯在不同场景下用不同的字母标识符:\n\n- E - Element (在集合中使用)\n- T - Type（Java 类）\n- K - Key（键）\n- V - Value（值）\n\n# 泛型通配符\n\n在泛型中有个很重要的知识点就是__泛型类型之间是不具有继承关系的__,也就是说List&lt;Object&gt;并不是List&lt;String&gt;的父类:\n\n```\npublic void printList(List<Object> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}\n\n\nList<String> strList = Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\");\nprintList(strList); //错误,List<Object>不是List<String>的父类\n```\n\n为了实现上面的printList方法,类型通配符就出现了:\n\n\n```\npublic void printList(List<?> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}\n\nList<String> strList = Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\");\nprintList(strList);\n```\n\nList&lt;?&gt;可以匹配List&lt;String&gt;、List&lt;Integer&gt;等等的各种类型。\n\n大家有可能会听过类型通配符上限和下限,这两个东西是怎样的概念呢？有时候我们会需要限定只能传入某些型的子类或者父类的容器:\n\n\n- 上限：<? extends T> 只能匹配T和T的子类\n\n- 下限：<? super T> 只能匹配T和T的父类\n\n```\n//只能传入ClassA的子类的容器\npublic void printList(List<? extends ClassA> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}\n\n//只能传入ClassA的父类的容器\npublic void printList(List<? super ClassA> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}\n```\n\n除了上面的通配符\"?\"，我们还可以直接用泛型方法去实现printListde,可以指定所有类型的列表或者ClassA的子类的列表:\n\n```\npublic <T> void printList(List<T> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}\n\npublic <T extends ClassA> void printList(List<T> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}\n```\n\n当然我们也能使用泛型的方式直接指定参数的上限,比如下面的foo方法就只能接收Number的子类:\n\n```\npublic <T extends Number> void foo(T arg){\n    ...\n}\n```\n\n但是如果直接使用泛型的方式的话我们不能指定指定它的下限,例如下面两种写法都是__不能通过编译__的:\n\n```\n//错误.不能直接指定泛型的下限\npublic <T super Number> void printList(List<T> list) {\n    ...\n}\n\n//错误.不能直接指定泛型的下限\npublic <T super Number> void foo(T arg){\n    ...\n}\n```\n\n# 类型擦除\n\n可能很多同学都会听说过泛型类型擦除的概念,这个类型擦除具体指的是怎样一回事？\n\n可以看看下面的foo方法,它本来想实现的功能是:如果传入的参数非空,就将它返回。否则,就创建一个同类型的实例返回。但是这段代码是不能通过编译的:\n\n```\n//错误,泛型的类型被擦除了,不能直接new出来\npublic <T> void foo(T arg) {\n    return arg != null ? arg : new T();\n}\n```\n\n原因在于java的泛型实现中有个叫做类型擦除的机制。简单来讲就是运行的时候是无法获取到泛型使用的实际类型的。\n\n例如上面的T类型,因为我们在运行时不能知道它到底是什么类型,所以也就无法将它new出来。\n\njava代码生成的Java字节代码中是不包含泛型中的类型信息的,所有泛型类的类型参数在编译时都会被擦除。虚拟机中没有泛型,只有普通类和普通方法。因此泛型的类型安全是在编译的时候去检测的。\n\n所以我们创建泛型对象时需要指明类型，让编译器尽早的做参数检查。\n\n像下面的代码可以顺利通过,甚至可以正常运行,直到将获取到的数值类型的数据强转成字符串的时候才报ClassCastException异常:\n\n```\nList list = new ArrayList<String>();\nlist.add(\"abc\");\nlist.add(123);\nString elemt1 = (String) list.get(0);\nString elemt2 = (String) list.get(1); // java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String\n```\n\n我们可以用反射的方法的验证一下类型擦除:\n\n```\nList<Integer> list = new ArrayList<Integer>();\nSystem.out.println(\"type : \" + Arrays.toString(list.getClass().getTypeParameters()));\n```\n\n它得到的类型仅仅是一个占位符而已:\n\n> type : [E]\n\n# 类型擦除机制的历史原因\n\n有人会问,为什么java会在编译的时候将类型擦除,而不像ｃ++一样通过在编译的时候将泛型类实例化为多个具体的类去实现泛型呢？\n\n其实“实例化为多个具体的类”这样的实现方式也是比较容易实现的,但是为了保持兼容性,所以java在泛型的实现上选取类型擦除的方式。实际上是做了一定的取舍的。\n\n为什么说选用类型擦除是为了保持兼容性呢?因为泛型并不是java与生俱来的。实际上到了java５的时候才引入了泛型。\n\n要让以前编译的程序在新版本的JRE还能正常运行，就意味着以前没有的限制不能突然冒出来。\n\n例如在泛型出来之前java就已经有了容器的存在,而且它具有可以存储不同类型的的特性:\n\n```\nArrayList things = new ArrayList();\nthings.add(Integer.valueOf(123));\nthings.add(\"abc\");\n```\n\n那么这段代码在Java 5引入泛型之后还必须要继续可以运行。\n\n这里有两种设计思路：\n\n1. 需要泛型化的类型（主要是容器（Collections）类型），以前有的就保持不变，然后平行地加一套泛型化版本的新类型；\n\n2. 直接把已有的类型泛型化，让所有需要泛型化的已有类型都原地泛型化，不添加任何平行于已有类型的泛型版。\n\n.NET在1.1 -> 2.0的时候选择了上面选项的1，而Java则选择了2。\n\n从Java设计者的角度看，这个取舍很明白：.NET在1.1 -> 2.0的时候，实际的应用代码量还很少（相对Java来说），而且整个体系都在微软的控制下，要做变更比较容易；\n\n而在Java 1.4.2 -> 5.0的时候，Java已经有大量程序部署在生产环境中，已经有很多应用和库程序的代码。如果这些代码在新版本的Java中，为了使用Java的新功能（例如泛型）而必须做大量源码层修改，那么新功能的普及速度就会大受影响，而且新功能会被吐槽。\n\n在原地泛型化后，java.util.ArrayList这个类型变成了java.util.ArrayList&lt;E&gt;。但是以前的代码直接用ArrayList，在新版本里必须还能继续用，所以就引出了“raw type”的概念——一个类型虽然被泛型化了，但还可以把它当作非泛型化的类型用。\n\n```\nArrayList         - raw type\nArrayList<E>      - open generic type (assuming E is type variable)\nArrayList<String> - closed generic type\nArrayList<?>      - unbounded wildcard type\n```\n\n下面这样的代码必须可以编译运行：\n\n```\nArrayList<Integer> ilist = new ArrayList<Integer>();\nArrayList<String> slist = new ArrayList<String>();\nArrayList list; // raw type\nlist = ilist;   // assigning closed generic type to raw type\nlist = slist;   // ditto\n```\n\n所以java的设计者在考虑了这一点之后选用类型擦除也就显而易见了。类型擦除实际上是将泛型类型转换了Obejct。由于所有的java类都是Object的子类,所以实现起来就很简单了。只需要在编译的时候将所有的泛型占位符都换成Object就可以了:\n\n```\n//源码的泛型代码\npublic <T> void foo(T arg){\n    ...\n}\n\n//编译时转换成的代码\npublic void foo(Object arg){\n    ...\n}\n```\n\n而在擦除类型的同时,java编译器会对该方法的调用进行类型检查,防止非法类型的调用。\n\n但如果在编写代码的时候就已经用raw type的话,编译器就不会做类型的安全性检查了。\n\n这样的实现导致了一个问题,List<E>泛型参数E被擦除后就变成了Object,那么就不能在泛型中使用int、long等原生数据类型了,因为它们并不是Object的子类。\n\n据说当时设计java语言的程序员和产品经理打了一架,并且在打赢之后成功劝服产品经理在提出兼容性这样奇葩的需求之后做出一点小小的让步。（虽然只是我胡说八道的脑补,但谁知道当时的实际情形是不是这样的呢?）\n\n于是乎我们现在在泛型中只能使用Integer、Long等封箱类型而不能用int、long等原生类型了。\n\n\nps: 上面这段类型擦除机制的历史原因参考了RednaxelaFX大神知乎上的一个回答,有兴趣的同学可以去知乎看看原来的[完整回答](https://www.zhihu.com/question/28665443/answer/118148143)\n","slug":"java泛型那些事","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2unk002hw3fyqfnzmwph"},{"title":"c++模板中的class和typename","date":"2017-06-05T22:14:52.000Z","_content":"\n借来的《Effective STL》已经放在书架上很久了,想想这段时间不是在写lua做业务,就是在学安卓准备做业务,已经很久没有看过c++这个老伙计了。为了不把老本行丢了,也为了赶紧把书还回去给更多的人阅读。于是下定决心重头开始把它读完。\n\n# 模板中使用class和typename的区别\n\n还没翻几页,当看到这段代码的时候就楞了一下。印象中上次也是看到这里一下子没弄懂,还特地搜索过的。结果再来一遍的时候还是忘了。果然好记性不如烂笔头,赶紧写篇博客mark一下。\n\n这里讲的是作者在声明模板的时候使用typename而不是class。一般情况下,使用typename或者class只是编码风格的问题。但是在遇到从属类型(dependent type)的时候,为了避免潜在的预防解析二义性,必须用typename而不能用class。\n\n```\ntemplate<typename C>\nbool lastGreaterThanFirst(const C& container)\n{\n    if(container.empty()) return false;\n\n    typename C::const_iterator begin(container.begin());\n    typename C::const_iterator end(container.end());\n    return *--end > *begin;\n}\n```\n\n这里的重点是这两行:\n\n```\ntypename C::const_iterator begin(container.begin());\ntypename C::const_iterator end(container.end());\n```\n\n如果没有用typename关键字\n\n```\ntemplate<typename C>\nbool lastGreaterThanFirst(const C& container)\n{\n    if(container.empty()) return false;\n\n    C::const_iterator begin(container.begin());\n    C::const_iterator end(container.end());\n    return *--end > *begin;\n}\n```\n\n就会报错(《Effective STL》中指出有些编译器错误的接受了没有typename的代码,但这样的代码是不可移植的):\n\n```\ntest.cpp:6:2: error: missing 'typename' prior to dependent type name 'C::const_iterator'\n        C::const_iterator begin(container.begin());\n        ^~~~~~~~~~~~~~~~~\n        typename\ntest.cpp:7:2: error: missing 'typename' prior to dependent type name 'C::const_iterator'\n        C::const_iterator end(container.end());\n        ^~~~~~~~~~~~~~~~~\n        typename\n2 errors generated.\n```\n\n如果你在这里使用的是class而不是typename就会报错:\n\n```\ntest.cpp:8:11: error: elaborated type refers to a typedef\n        class C::const_iterator begin(container.begin());\n                 ^\ntest.cpp:15:2: note: in instantiation of function template specialization 'lastGreaterThanFirst<std::__1::vector<int, std::__1::allocator<int> > >' requested here\n        lastGreaterThanFirst(vec);\n        ^\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/vector:476:54: note: declared here\n    typedef __wrap_iter<const_pointer>               const_iterator;\n                                                     ^\n1 error generated.\n```\n\n\n# 为什么出现从属类型时需要用typename\n\n我们一步一步来解析。\n\n```\nClassA::foo\n```\n当你看到上面的代码的时候,你会觉得foo是什么？第一反应应该是ClassA的一个静态成员变量对吧？\n\n那当你继续往后看,看到下面的代码的时候,想想a是什么？\n\n```\nClassA::foo a;\n```\n\na是一个ClassA::foo类型的变量,ClassA::foo是一个内部类:\n\n```\nclass ClassA {\npublic:\n    class foo {\n    };\n};\n```\n\n或者ClassA内部的一个typedef:\n\n```\nclass ClassA {\npublic:\n    typedef int foo;\n};\n```\n\n当foo是ClassA的内部类或者是内部的一个typedef的时候,foo就是一个从属类型。\n\n而对于C::const_iterator,const_iterator可能是C的一个静态成员变量或者是C的一个从属类型,编译器默认是将它解析为一个变量的,所以需要用typename告诉编译器这是一个类型:\n\n```\ntypename C::const_iterator begin(container.begin());\n```\n\n# 出现从属类型时不需要用typename的特例\n\n在遇到从属类型出现在类模板定义中的基类列表的时候,是不需要用typename关键字指明这是一个类型的:\n\n```\nclass ClassA {\npublic:\n    class foo {\n    };\n};\n\ntemplate<typename C>\nclass ClassB : public C::foo {\n};\n```\n\n因为基类列表中的肯定是一个类型。\n","source":"_posts/c++模板中的class和typename.md","raw":"title: c++模板中的class和typename\ndate: 2017-06-06 06:14:52\ntags:\n  - 技术相关\n\t- C/C++\n---\n\n借来的《Effective STL》已经放在书架上很久了,想想这段时间不是在写lua做业务,就是在学安卓准备做业务,已经很久没有看过c++这个老伙计了。为了不把老本行丢了,也为了赶紧把书还回去给更多的人阅读。于是下定决心重头开始把它读完。\n\n# 模板中使用class和typename的区别\n\n还没翻几页,当看到这段代码的时候就楞了一下。印象中上次也是看到这里一下子没弄懂,还特地搜索过的。结果再来一遍的时候还是忘了。果然好记性不如烂笔头,赶紧写篇博客mark一下。\n\n这里讲的是作者在声明模板的时候使用typename而不是class。一般情况下,使用typename或者class只是编码风格的问题。但是在遇到从属类型(dependent type)的时候,为了避免潜在的预防解析二义性,必须用typename而不能用class。\n\n```\ntemplate<typename C>\nbool lastGreaterThanFirst(const C& container)\n{\n    if(container.empty()) return false;\n\n    typename C::const_iterator begin(container.begin());\n    typename C::const_iterator end(container.end());\n    return *--end > *begin;\n}\n```\n\n这里的重点是这两行:\n\n```\ntypename C::const_iterator begin(container.begin());\ntypename C::const_iterator end(container.end());\n```\n\n如果没有用typename关键字\n\n```\ntemplate<typename C>\nbool lastGreaterThanFirst(const C& container)\n{\n    if(container.empty()) return false;\n\n    C::const_iterator begin(container.begin());\n    C::const_iterator end(container.end());\n    return *--end > *begin;\n}\n```\n\n就会报错(《Effective STL》中指出有些编译器错误的接受了没有typename的代码,但这样的代码是不可移植的):\n\n```\ntest.cpp:6:2: error: missing 'typename' prior to dependent type name 'C::const_iterator'\n        C::const_iterator begin(container.begin());\n        ^~~~~~~~~~~~~~~~~\n        typename\ntest.cpp:7:2: error: missing 'typename' prior to dependent type name 'C::const_iterator'\n        C::const_iterator end(container.end());\n        ^~~~~~~~~~~~~~~~~\n        typename\n2 errors generated.\n```\n\n如果你在这里使用的是class而不是typename就会报错:\n\n```\ntest.cpp:8:11: error: elaborated type refers to a typedef\n        class C::const_iterator begin(container.begin());\n                 ^\ntest.cpp:15:2: note: in instantiation of function template specialization 'lastGreaterThanFirst<std::__1::vector<int, std::__1::allocator<int> > >' requested here\n        lastGreaterThanFirst(vec);\n        ^\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/vector:476:54: note: declared here\n    typedef __wrap_iter<const_pointer>               const_iterator;\n                                                     ^\n1 error generated.\n```\n\n\n# 为什么出现从属类型时需要用typename\n\n我们一步一步来解析。\n\n```\nClassA::foo\n```\n当你看到上面的代码的时候,你会觉得foo是什么？第一反应应该是ClassA的一个静态成员变量对吧？\n\n那当你继续往后看,看到下面的代码的时候,想想a是什么？\n\n```\nClassA::foo a;\n```\n\na是一个ClassA::foo类型的变量,ClassA::foo是一个内部类:\n\n```\nclass ClassA {\npublic:\n    class foo {\n    };\n};\n```\n\n或者ClassA内部的一个typedef:\n\n```\nclass ClassA {\npublic:\n    typedef int foo;\n};\n```\n\n当foo是ClassA的内部类或者是内部的一个typedef的时候,foo就是一个从属类型。\n\n而对于C::const_iterator,const_iterator可能是C的一个静态成员变量或者是C的一个从属类型,编译器默认是将它解析为一个变量的,所以需要用typename告诉编译器这是一个类型:\n\n```\ntypename C::const_iterator begin(container.begin());\n```\n\n# 出现从属类型时不需要用typename的特例\n\n在遇到从属类型出现在类模板定义中的基类列表的时候,是不需要用typename关键字指明这是一个类型的:\n\n```\nclass ClassA {\npublic:\n    class foo {\n    };\n};\n\ntemplate<typename C>\nclass ClassB : public C::foo {\n};\n```\n\n因为基类列表中的肯定是一个类型。\n","slug":"c++模板中的class和typename","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2unl002kw3fypydl5xex"},{"title":"automake学习笔记 - 模块化编译","date":"2017-03-21T05:36:36.000Z","_content":"\n一般来说一个工程会由许多不同的模块组成。源码放在一个地方，示例代码放到另一个地方，第三方库又放到其他地方。这种时候又应该怎么去使用automake呢？\n\n这篇文章就讨论了一下如何使用automake去进行模块化编译\n\n我们还是用easylog来做例子，下面是我们修改后的easylog工程的根目录下的文件:\n\n> configure.ac  examples  Makefile.am  src\n\n## src目录\n\nsrc目录放的就是库的源代码,我们使用src中的源代码编译出一个库来给其他的程序使用easylog的功能  \n\nsrc目录中有下面几个文件log\\_interface.h，easy\\_log.h，easy\\_log.cpp，cout\\_log\\_interface.h，cout\\_log\\_interface.cpp，Makefile.am。实际上就是除了main.cpp，其他文件都放到了这里来。因为我们提供给别的是一个库而不是一个可执行程序，所以main.cpp可以不需要编译到目标文件中\n\n.h和.cpp的内容和上一篇[文章](http://blog.islinjw.cn/2017/03/17/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-helloworld/)的内容是一样的。这里的重点其实是Makefile.am。让我们先来看看它的内容:\n\n```\nlib_LTLIBRARIES = libeasylog.la                                                             \nlibeasylog_la_SOURCES = cout_log_interface.cpp \\                                            \n                     easy_log.cpp\n```\n\n其实它的内容很简单，就是指定了要编译的库的名字和库的源码。但是有一个问题，我们这里需要编译的是但为什么这里的目标文件是libeasylog.la呢?\n\nLibtool是一种属于GNU构建系统的GNU程序设计工具,它将静态库和动态库抽象成了一种统一的叫做libtool库的概念。libtool库使用la作为后缀。它可以用来构建静态库也能用来构建动态库，而最终编译出来的到底是哪一种，在最后执行configure命令的时候才能确定。同时它编译的时候产生的文件就不再是.o文件而是.lo文件。  \n\n这里lib\\_LTLIBRARIES的lib前缀表示的就是目标文件是一个动态库而不是可执行文件(bin前缀表示目标文件是可执行文件,noinst\\_LTLIBRARIES表示目标文件是静态库)。而LTLIBRARIES的LT指的就是Libtool。还有一点是一般编译库文件的话我们会在文件名钱加上lib前缀，所以我们的目标文件是libeasylog.la。\n\n而下面的libeasylog\\_la\\_SOURCES就是指定编译libeasylog.la使用的源代码\n\n\n这里顺便说一点,如果这里需要链接其他的库的话需要用 \\_LIBADD 去指定。如需要链接libpthread这个库的话就需要这样写:\n\n```\nlibeasylog_la_LIBADD = -lpthread\n```\n\n\n\n## examples目录\n\nexamples目录里面放了这个库的example代码。因为我们的库是要提供给其他人使用的，所以一般除了文档之外，还会有一些例子去帮助使用者了解应该如何去使用我们的库。这个目录中的example.cpp其实就是上一篇[文章](http://blog.islinjw.cn/2017/03/17/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-helloworld/)中的main.cpp：\n\n```\n#include \"easy_log.h\"\n#include \"cout_log_interface.h\"\n\n\nint main()\n{\n    EasyLog log(std::make_shared<COutLogInterface>());\n    log.Debug(\"test\", \"testlog\");\n\n    return 0;\n}\n```\n\n这个目录下也有一个Makefile.am，它是用来配置example程序的编译选项的:\n\n```\nAM_CPPFLAGS = -I$(top_srcdir)/src\n\nbin_PROGRAMS = example\nexample_SOURCES = example.cpp\n\nexample_LDADD = -L$(top_builddir)/src \\\n\t\t\t\t-leasylog\n```\n\nAM\\_CPPFLAGS的值在c/c++预处理的时候会当做参数传给预处理器例如我们将源码目录传给预处理器，这样预处理器才能找到easy\\_log.h和cout\\_log\\_interface.h\n\n这里的top\\_srcdir变量会在configure是被定义，它的值是工程目录的位置(也就是configure所在目录的位置)，后面的top\\_builddir也是类似的，不过它的值是编译目录的位置(也就是执行make命令是所在的目录)\n\n这里编译出来的example就是我们的demo程序\n\n\n## 根目录\n\n根目录下也有个Makefile.am,这个文件的内容很简单:\n\n```\nSUBDIRS = src examples\n```\n\n就是将src和examples指定为子目录于是在make编译的时候,编译器就会进入到这两个目录中继续编译。它们在这里的先后顺序决定了编译的先后顺序。因为examples中的example程序是依赖于easylog库的,所以要然src先编译\n\n如果不在这里指定子目录的话,在编译目录执行make命令就不会自动编译子目录中为源码,需要自己进到子目录中手动执行make命令。如果工程中的某些部分是可选编译的时候可以这么做。\n\n最后就是configure.ac文件了:\n\n```\n#                                               -*- Autoconf -*-\n# Process this file with autoconf to produce a configure script.\n\nAC_PREREQ([2.69])\nAC_INIT([easylog], [0.0.2], [466474482@qq.com])\nAM_INIT_AUTOMAKE([-Wall -Werror foreign])\nAC_CONFIG_SRCDIR([src/log_interface.h])\nAC_CONFIG_HEADERS([config.h])\n\nAM_PROG_AR\nLT_INIT\n\n# Checks for programs.\nAC_PROG_CXX\nAC_PROG_CC\nAX_CXX_COMPILE_STDCXX_11\n\n# Checks for libraries.\n\n# Checks for header files.\n\n# Checks for typedefs, structures, and compiler characteristics.\n\n# Checks for library functions.\n\nAC_CONFIG_FILES([Makefile\n                 examples/Makefile\n                 src/Makefile])\n\nAC_OUTPUT\n```\n\n它和上一篇[文章](http://blog.islinjw.cn/2017/03/17/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-helloworld/)只有一点点小的不同:\n\n一是由于将log\\_interface.h放到src中了，所以AC\\_CONFIG\\_SRCDIR需要改一下\n\n```\nAC_CONFIG_SRCDIR([src/log_interface.h])\n```\n\n二是examples和src中的Makefile.am也需要在configure.ac中指定:\n```\nAC_CONFIG_FILES([Makefile\n                 examples/Makefile\n                 src/Makefile])\n```\n\nAC\\_CONFIG\\_FILES指定了一些需要从Makefile.in中生成的Makefile。这里如果不指定的话configure就不会为其生成Makefile\n\n\n三是多了AM\\_PROG\\_AR和LT\\_INIT。如果不定义这两个宏的话,执行autoreconf --install命令得到了下面的错误日志:\n\n```\nsrc/Makefile.am:1: error: Libtool library used but 'LIBTOOL' is undefined\nsrc/Makefile.am:1:   The usual way to define 'LIBTOOL' is to add 'LT_INIT'\nsrc/Makefile.am:1:   to 'configure.ac' and run 'aclocal' and 'autoconf' again.\nsrc/Makefile.am:1:   If 'LT_INIT' is in 'configure.ac', make sure\nsrc/Makefile.am:1:   its definition is in aclocal's search path.\nautomake: warnings are treated as errors\n/usr/share/automake-1.15/am/ltlibrary.am: warning: 'libeasylog.la': linking libtool libraries using a non-POSIX\n/usr/share/automake-1.15/am/ltlibrary.am: archiver requires 'AM_PROG_AR' in 'configure.ac'\nsrc/Makefile.am:1:   while processing Libtool library 'libeasylog.la'\nautoreconf: automake failed with exit status: 1\n```\n\n注意AM\\_PROG\\_AR 要放在 LT\\_INIT 之前,要不然 autoreconf --install 的时候会报warn\n\n如果已经加上了 LT\\_INIT 但还是会报错的话就是系统中没有安装libtool了,必须先安装一下:\n\n```\nsudo apt-get install libtool\n```\n\n## 编译工程\n\n1. 在工程根目录创建子build目录用于编译\n\n2. 进入build目录\n\n3. 执行../configure\n\n4. 执行make\n\n之后进入build/examples运行example就可以看到下面输出:\n\n> [test] testlog\n\n## 静态库和动态库的区别\n\n我们之前在src/Makefile.am中生成的是动态库lib\\_LTLIBRARIES,所以如果将build/src目录删掉,build/examples/example就会因为找不到库而报错:\n\n> /home/linjw/workspace/automake-demo/build/examples/.libs/lt-example: error while loading shared libraries: libeasylog.so.0: cannot open shared object file: No such file or directory\n\n但如果将Makefile.am改成生成静态库则不会报错，因为静态库将库的代码也编译到可执行程序之中了。\n\n```\nnoinst_LTLIBRARIES = libeasylog.la                                               \nlibeasylog_la_SOURCES = cout_log_interface.cpp \\                                    \n                     easy_log.cpp\n```\n\n这里的noinst代表的其实是no install的意思\n\n## Demo项目\n\n可以在[这里](https://github.com/bluesky466/automake-demo/tree/v0.0.2)查看完整的项目代码\n","source":"_posts/automake学习笔记-模块化编译.md","raw":"title: automake学习笔记 - 模块化编译\ndate: 2017-03-21 13:36:36\ntags:\n\t- 技术相关\n\t- 编译相关\n---\n\n一般来说一个工程会由许多不同的模块组成。源码放在一个地方，示例代码放到另一个地方，第三方库又放到其他地方。这种时候又应该怎么去使用automake呢？\n\n这篇文章就讨论了一下如何使用automake去进行模块化编译\n\n我们还是用easylog来做例子，下面是我们修改后的easylog工程的根目录下的文件:\n\n> configure.ac  examples  Makefile.am  src\n\n## src目录\n\nsrc目录放的就是库的源代码,我们使用src中的源代码编译出一个库来给其他的程序使用easylog的功能  \n\nsrc目录中有下面几个文件log\\_interface.h，easy\\_log.h，easy\\_log.cpp，cout\\_log\\_interface.h，cout\\_log\\_interface.cpp，Makefile.am。实际上就是除了main.cpp，其他文件都放到了这里来。因为我们提供给别的是一个库而不是一个可执行程序，所以main.cpp可以不需要编译到目标文件中\n\n.h和.cpp的内容和上一篇[文章](http://blog.islinjw.cn/2017/03/17/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-helloworld/)的内容是一样的。这里的重点其实是Makefile.am。让我们先来看看它的内容:\n\n```\nlib_LTLIBRARIES = libeasylog.la                                                             \nlibeasylog_la_SOURCES = cout_log_interface.cpp \\                                            \n                     easy_log.cpp\n```\n\n其实它的内容很简单，就是指定了要编译的库的名字和库的源码。但是有一个问题，我们这里需要编译的是但为什么这里的目标文件是libeasylog.la呢?\n\nLibtool是一种属于GNU构建系统的GNU程序设计工具,它将静态库和动态库抽象成了一种统一的叫做libtool库的概念。libtool库使用la作为后缀。它可以用来构建静态库也能用来构建动态库，而最终编译出来的到底是哪一种，在最后执行configure命令的时候才能确定。同时它编译的时候产生的文件就不再是.o文件而是.lo文件。  \n\n这里lib\\_LTLIBRARIES的lib前缀表示的就是目标文件是一个动态库而不是可执行文件(bin前缀表示目标文件是可执行文件,noinst\\_LTLIBRARIES表示目标文件是静态库)。而LTLIBRARIES的LT指的就是Libtool。还有一点是一般编译库文件的话我们会在文件名钱加上lib前缀，所以我们的目标文件是libeasylog.la。\n\n而下面的libeasylog\\_la\\_SOURCES就是指定编译libeasylog.la使用的源代码\n\n\n这里顺便说一点,如果这里需要链接其他的库的话需要用 \\_LIBADD 去指定。如需要链接libpthread这个库的话就需要这样写:\n\n```\nlibeasylog_la_LIBADD = -lpthread\n```\n\n\n\n## examples目录\n\nexamples目录里面放了这个库的example代码。因为我们的库是要提供给其他人使用的，所以一般除了文档之外，还会有一些例子去帮助使用者了解应该如何去使用我们的库。这个目录中的example.cpp其实就是上一篇[文章](http://blog.islinjw.cn/2017/03/17/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-helloworld/)中的main.cpp：\n\n```\n#include \"easy_log.h\"\n#include \"cout_log_interface.h\"\n\n\nint main()\n{\n    EasyLog log(std::make_shared<COutLogInterface>());\n    log.Debug(\"test\", \"testlog\");\n\n    return 0;\n}\n```\n\n这个目录下也有一个Makefile.am，它是用来配置example程序的编译选项的:\n\n```\nAM_CPPFLAGS = -I$(top_srcdir)/src\n\nbin_PROGRAMS = example\nexample_SOURCES = example.cpp\n\nexample_LDADD = -L$(top_builddir)/src \\\n\t\t\t\t-leasylog\n```\n\nAM\\_CPPFLAGS的值在c/c++预处理的时候会当做参数传给预处理器例如我们将源码目录传给预处理器，这样预处理器才能找到easy\\_log.h和cout\\_log\\_interface.h\n\n这里的top\\_srcdir变量会在configure是被定义，它的值是工程目录的位置(也就是configure所在目录的位置)，后面的top\\_builddir也是类似的，不过它的值是编译目录的位置(也就是执行make命令是所在的目录)\n\n这里编译出来的example就是我们的demo程序\n\n\n## 根目录\n\n根目录下也有个Makefile.am,这个文件的内容很简单:\n\n```\nSUBDIRS = src examples\n```\n\n就是将src和examples指定为子目录于是在make编译的时候,编译器就会进入到这两个目录中继续编译。它们在这里的先后顺序决定了编译的先后顺序。因为examples中的example程序是依赖于easylog库的,所以要然src先编译\n\n如果不在这里指定子目录的话,在编译目录执行make命令就不会自动编译子目录中为源码,需要自己进到子目录中手动执行make命令。如果工程中的某些部分是可选编译的时候可以这么做。\n\n最后就是configure.ac文件了:\n\n```\n#                                               -*- Autoconf -*-\n# Process this file with autoconf to produce a configure script.\n\nAC_PREREQ([2.69])\nAC_INIT([easylog], [0.0.2], [466474482@qq.com])\nAM_INIT_AUTOMAKE([-Wall -Werror foreign])\nAC_CONFIG_SRCDIR([src/log_interface.h])\nAC_CONFIG_HEADERS([config.h])\n\nAM_PROG_AR\nLT_INIT\n\n# Checks for programs.\nAC_PROG_CXX\nAC_PROG_CC\nAX_CXX_COMPILE_STDCXX_11\n\n# Checks for libraries.\n\n# Checks for header files.\n\n# Checks for typedefs, structures, and compiler characteristics.\n\n# Checks for library functions.\n\nAC_CONFIG_FILES([Makefile\n                 examples/Makefile\n                 src/Makefile])\n\nAC_OUTPUT\n```\n\n它和上一篇[文章](http://blog.islinjw.cn/2017/03/17/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-helloworld/)只有一点点小的不同:\n\n一是由于将log\\_interface.h放到src中了，所以AC\\_CONFIG\\_SRCDIR需要改一下\n\n```\nAC_CONFIG_SRCDIR([src/log_interface.h])\n```\n\n二是examples和src中的Makefile.am也需要在configure.ac中指定:\n```\nAC_CONFIG_FILES([Makefile\n                 examples/Makefile\n                 src/Makefile])\n```\n\nAC\\_CONFIG\\_FILES指定了一些需要从Makefile.in中生成的Makefile。这里如果不指定的话configure就不会为其生成Makefile\n\n\n三是多了AM\\_PROG\\_AR和LT\\_INIT。如果不定义这两个宏的话,执行autoreconf --install命令得到了下面的错误日志:\n\n```\nsrc/Makefile.am:1: error: Libtool library used but 'LIBTOOL' is undefined\nsrc/Makefile.am:1:   The usual way to define 'LIBTOOL' is to add 'LT_INIT'\nsrc/Makefile.am:1:   to 'configure.ac' and run 'aclocal' and 'autoconf' again.\nsrc/Makefile.am:1:   If 'LT_INIT' is in 'configure.ac', make sure\nsrc/Makefile.am:1:   its definition is in aclocal's search path.\nautomake: warnings are treated as errors\n/usr/share/automake-1.15/am/ltlibrary.am: warning: 'libeasylog.la': linking libtool libraries using a non-POSIX\n/usr/share/automake-1.15/am/ltlibrary.am: archiver requires 'AM_PROG_AR' in 'configure.ac'\nsrc/Makefile.am:1:   while processing Libtool library 'libeasylog.la'\nautoreconf: automake failed with exit status: 1\n```\n\n注意AM\\_PROG\\_AR 要放在 LT\\_INIT 之前,要不然 autoreconf --install 的时候会报warn\n\n如果已经加上了 LT\\_INIT 但还是会报错的话就是系统中没有安装libtool了,必须先安装一下:\n\n```\nsudo apt-get install libtool\n```\n\n## 编译工程\n\n1. 在工程根目录创建子build目录用于编译\n\n2. 进入build目录\n\n3. 执行../configure\n\n4. 执行make\n\n之后进入build/examples运行example就可以看到下面输出:\n\n> [test] testlog\n\n## 静态库和动态库的区别\n\n我们之前在src/Makefile.am中生成的是动态库lib\\_LTLIBRARIES,所以如果将build/src目录删掉,build/examples/example就会因为找不到库而报错:\n\n> /home/linjw/workspace/automake-demo/build/examples/.libs/lt-example: error while loading shared libraries: libeasylog.so.0: cannot open shared object file: No such file or directory\n\n但如果将Makefile.am改成生成静态库则不会报错，因为静态库将库的代码也编译到可执行程序之中了。\n\n```\nnoinst_LTLIBRARIES = libeasylog.la                                               \nlibeasylog_la_SOURCES = cout_log_interface.cpp \\                                    \n                     easy_log.cpp\n```\n\n这里的noinst代表的其实是no install的意思\n\n## Demo项目\n\n可以在[这里](https://github.com/bluesky466/automake-demo/tree/v0.0.2)查看完整的项目代码\n","slug":"automake学习笔记-模块化编译","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2unn002nw3fyc8sr2g16"},{"title":"automake学习笔记 - 安装与发布","date":"2017-03-26T07:06:56.000Z","_content":"\n辛辛苦苦写出来的代码当然是需要发布出来给自己或者别人去使用的。这篇文章就谈一谈发布相关的东西吧。\n\n## 安装\n\n软件在编译完后就需要进行安装。configure生成的Makefile支持install。使用make install 命令就可以将编译出来的软件安装到系统中。\n\n如果没有做配置，默认会安装到/usr/local中,当然如果需要的话也可以使用configure的--prefix参数指定安装的路径,如在build中执行下面的命令就可以将build目录指定为安装目录:\n\n> ../configure --prefix=\\`pwd\\`\n\n之后再执行下面的安装命令,工程在编译完后就会安装到build目录下。安装完毕之后可以看到build里面多了bin和lib两个目录\n\n> make install\n\nbin目录下是编译出来的可执行文件example,而lib目录下就是编译出来的依赖库:\n\n```\n-rw-r--r-- 1 linjw linjw 263K 3月  22 13:44 libeasylog.a\n-rwxr-xr-x 1 linjw linjw  985 3月  22 13:44 libeasylog.la\nlrwxrwxrwx 1 linjw linjw   19 3月  22 13:44 libeasylog.so -> libeasylog.so.0.0.0\nlrwxrwxrwx 1 linjw linjw   19 3月  22 13:44 libeasylog.so.0 -> libeasylog.so.0.0.0\n-rwxr-xr-x 1 linjw linjw 143K 3月  22 13:44 libeasylog.so.0.0.0\n```\n\n\n编译出来的libeasylog.so.0.0.0就可以直接拿出去给其他人使用了\n\n## 卸载\n\n卸载的话很简单，只需要执行下面的命令就行了\n\n> make uninstall\n\n当然你也可以选择手动去将安装的文件一个个删除,但是这样既麻烦又容易漏删或者错删\n\n## libtool 库版本号系统\n\n我们可以看到编译出来的so库是带版本号的，默认0.0.0,当然我们也能直接忽略版本号(某些可动态加载的的插件模块可能不需要版本号):\n\n```\nlib_LTLIBRARIES = libeasylog.la\n\nlibeasylog_la_SOURCES = cout_log_interface.cpp \\\n\t\t\t\t\t easy_log.cpp \n\nlibeasylog_la_LDFLAGS = -avoid-version\n```\n\n这样生成安装的so库就不会带版本号了:\n\n```\n-rw-r--r-- 1 linjw linjw 263K 3月  26 11:27 libeasylog.a\n-rwxr-xr-x 1 linjw linjw  975 3月  26 11:27 libeasylog.la\n-rwxr-xr-x 1 linjw linjw 143K 3月  26 11:27 libeasylog.so\n```\n\n当然，绝大部分的库都是需要带上版本号的。每个系统的库版本机制都不一样,libtool通过一种抽象的版本机制最终在创建库的时候才映射到具体的系统版本机制上。这是为了方便在交叉编译的时候可以用一种机制去管理不同平台上的各种版本机制。\n\nlibtool 库版本号系统有下面三个部分:\n\n- current\n\n接口的修改次数\n\n- revision\n\n上次修改后源码的修改次数(注意这里指的是只改动了实现,没有修改接口,如果改了接口的话应该要改current号，并且把revision置零)\n\n- age\n\n当前版本可以向前兼容的版本数\n\n[官方文档](http://www.gnu.org/software/libtool/manual/libtool.html#Updating-version-info)是这么描述这三个部分的更新规则的:\n\n> Here are a set of rules to help you update your library version information:\n1.    Start with version information of ‘0:0:0’ for each libtool library.\n2.    Update the version information only immediately before a public release of your software. More frequent updates are unnecessary, and only guarantee that the current interface number gets larger faster.\n3.    If the library source code has changed at all since the last update, then increment revision (‘c:r:a’ becomes ‘c:r+1:a’).\n4.    If any interfaces have been added, removed, or changed since the last update, increment current, and set revision to 0.\n5.    If any interfaces have been added since the last public release, then increment age.\n6.    If any interfaces have been removed or changed since the last public release, then set age to 0. \n\n翻译过来就是\n\n1. 库版本号应该开始于0.0.0\n2. 只有在正式发布库的时候才更新版本号以避免版本号增长过快\n3. 当实现代码改变的时候revision加1\n4. 当接口改变(无论是添加，删除还是修改接口声明)的时候current加1,同时revision重置为0\n5. 如果库只是增加了接口,则age加1\n6. 如果库删除或者修改了接口声明,则age重置为0\n\n这三个值可以用-version-info指定\n\n> -version-info current[:revision[:age]] \n\nrevision 和 age都可以省略,例如你这样设置:\n\n```\nlib_LTLIBRARIES = libeasylog.la\n\nlibeasylog_la_SOURCES = cout_log_interface.cpp \\\n\t\t\t\t\t easy_log.cpp \n\nlibeasylog_la_LDFLAGS = -version-info 3:12:1\n```\n\n表明接口被修改了三次,第三次修改接口之后又修改了12次源码,接口可以向前兼容1个版本\n\nmake install 后可以看到lib目录下生成的库长这样:\n\n```\n-rw-r--r-- 1 linjw linjw 263K 3月  26 12:11 libeasylog.a\n-rwxr-xr-x 1 linjw linjw  987 3月  26 12:11 libeasylog.la\nlrwxrwxrwx 1 linjw linjw   20 3月  26 12:11 libeasylog.so -> libeasylog.so.2.1.12\nlrwxrwxrwx 1 linjw linjw   20 3月  26 12:11 libeasylog.so.2 -> libeasylog.so.2.1.12\n-rwxr-xr-x 1 linjw linjw 143K 3月  26 12:11 libeasylog.so.2.1.12\n```\n\n为啥是libeasylog.so.2.1.12而不是libeasylog.so.3.12.1呢？\n\n原来这几个数字是这样计算的:\n\n库名.so.current-age.age.revision\n\n这样会引发一个问题:\n\n> 假设你的库有两个【3：0：1】【4：0：2】。 再假设在你编译程序的机器上安装了最新的【4：0：2】， 且你在程序中使用了该版本中新加的接口。当你程序编译好后， 你ldd发现你的程序依赖libraryname.so.2， 同时你将程序安装在了只安装了【3：0：1】的机器上， 你会发现你的程序能搜索到动态库， 却在运行的时候发现未定义的符号， 因为【3：0：1】中没有新添加的接口。 故你需要在运行机器上保证安装了同一主版本号最新的library， 以保证你的程序能正确运行。\n\n从 [libtool动态库版本系统之个人理解 ](http://blog.csdn.net/zlyong0018/article/details/16846325) 这篇博客引用\n\n## 手动指定版本号\n\n我之前了解到的so的命名规范其实和libtool的版本号系统的so库命名规范不一样:\n\n> 库名.so.主版本号.次版本号.发布版本号\n\n[官方文档](http://www.gnu.org/software/libtool/manual/libtool.html#Release-numbers)也有提到这一点:\n\n\n> Often, people want to encode the name of the package release into the shared library so that it is obvious to the user what package their programs are linked against. This convention is used especially on GNU/Linux:\n> \n> trick$ ls /usr/lib/libbfd*\n> /usr/lib/libbfd.a           /usr/lib/libbfd.so.2.7.0.2\n> /usr/lib/libbfd.so\n> trick$\n> \n> On ‘trick’, /usr/lib/libbfd.so is a symbolic link to libbfd.so.2.7.0.2, which was distributed as a part of ‘binutils-2.7.0.2’.\n> \n> Unfortunately, this convention conflicts directly with libtool’s idea of library interface versions, because the library interface rarely changes at the same time that the release number does, and the library suffix is never the same across all platforms.\n> \n> So, to accommodate both views, you can use the -release flag to set release information for libraries for which you do not want to use -version-info. For the libbfd example, the next release that uses libtool should be built with ‘-release 2.9.0’, which will produce the following files on GNU/Linux:\n> \n> trick$ ls /usr/lib/libbfd*\n> /usr/lib/libbfd-2.9.0.so     /usr/lib/libbfd.a\n> /usr/lib/libbfd.so\n> trick$\n> \n> In this case, /usr/lib/libbfd.so is a symbolic link to libbfd-2.9.0.so. This makes it obvious that the user is dealing with ‘binutils-2.9.0’, without compromising libtool’s idea of interface versions.\n> \n> Note that this option causes a modification of the library name, so do not use it unless you want to break binary compatibility with any past library releases. In general, you should only use -release for package-internal libraries or for ones whose interfaces change very frequently. \n\n可以使用-release去手动指定版本号,虽然官方不推荐用这种方式:\n\n```\nlib_LTLIBRARIES = libeasylog.la\n\nlibeasylog_la_SOURCES = cout_log_interface.cpp \\\n\t\t\t\t\t easy_log.cpp \n\nlibeasylog_la_LDFLAGS = -release 0.0.3\n```\n\n安装之后lib目录如下:\n\n```\n-rwxr-xr-x 1 linjw linjw 143K 3月  26 14:48 libeasylog-0.0.3.so\n-rw-r--r-- 1 linjw linjw 263K 3月  26 14:48 libeasylog.a\n-rwxr-xr-x 1 linjw linjw  993 3月  26 14:48 libeasylog.la\nlrwxrwxrwx 1 linjw linjw   19 3月  26 14:48 libeasylog.so -> libeasylog-0.0.3.so\n```\n\n可以在[这里](https://github.com/bluesky466/automake-demo/tree/v0.0.3)查看完整的项目代码\n","source":"_posts/automake学习笔记-安装与发布.md","raw":"title: automake学习笔记 - 安装与发布\ndate: 2017-03-26 15:06:56\ntags:\n\t- 技术相关\n\t- 编译相关\n---\n\n辛辛苦苦写出来的代码当然是需要发布出来给自己或者别人去使用的。这篇文章就谈一谈发布相关的东西吧。\n\n## 安装\n\n软件在编译完后就需要进行安装。configure生成的Makefile支持install。使用make install 命令就可以将编译出来的软件安装到系统中。\n\n如果没有做配置，默认会安装到/usr/local中,当然如果需要的话也可以使用configure的--prefix参数指定安装的路径,如在build中执行下面的命令就可以将build目录指定为安装目录:\n\n> ../configure --prefix=\\`pwd\\`\n\n之后再执行下面的安装命令,工程在编译完后就会安装到build目录下。安装完毕之后可以看到build里面多了bin和lib两个目录\n\n> make install\n\nbin目录下是编译出来的可执行文件example,而lib目录下就是编译出来的依赖库:\n\n```\n-rw-r--r-- 1 linjw linjw 263K 3月  22 13:44 libeasylog.a\n-rwxr-xr-x 1 linjw linjw  985 3月  22 13:44 libeasylog.la\nlrwxrwxrwx 1 linjw linjw   19 3月  22 13:44 libeasylog.so -> libeasylog.so.0.0.0\nlrwxrwxrwx 1 linjw linjw   19 3月  22 13:44 libeasylog.so.0 -> libeasylog.so.0.0.0\n-rwxr-xr-x 1 linjw linjw 143K 3月  22 13:44 libeasylog.so.0.0.0\n```\n\n\n编译出来的libeasylog.so.0.0.0就可以直接拿出去给其他人使用了\n\n## 卸载\n\n卸载的话很简单，只需要执行下面的命令就行了\n\n> make uninstall\n\n当然你也可以选择手动去将安装的文件一个个删除,但是这样既麻烦又容易漏删或者错删\n\n## libtool 库版本号系统\n\n我们可以看到编译出来的so库是带版本号的，默认0.0.0,当然我们也能直接忽略版本号(某些可动态加载的的插件模块可能不需要版本号):\n\n```\nlib_LTLIBRARIES = libeasylog.la\n\nlibeasylog_la_SOURCES = cout_log_interface.cpp \\\n\t\t\t\t\t easy_log.cpp \n\nlibeasylog_la_LDFLAGS = -avoid-version\n```\n\n这样生成安装的so库就不会带版本号了:\n\n```\n-rw-r--r-- 1 linjw linjw 263K 3月  26 11:27 libeasylog.a\n-rwxr-xr-x 1 linjw linjw  975 3月  26 11:27 libeasylog.la\n-rwxr-xr-x 1 linjw linjw 143K 3月  26 11:27 libeasylog.so\n```\n\n当然，绝大部分的库都是需要带上版本号的。每个系统的库版本机制都不一样,libtool通过一种抽象的版本机制最终在创建库的时候才映射到具体的系统版本机制上。这是为了方便在交叉编译的时候可以用一种机制去管理不同平台上的各种版本机制。\n\nlibtool 库版本号系统有下面三个部分:\n\n- current\n\n接口的修改次数\n\n- revision\n\n上次修改后源码的修改次数(注意这里指的是只改动了实现,没有修改接口,如果改了接口的话应该要改current号，并且把revision置零)\n\n- age\n\n当前版本可以向前兼容的版本数\n\n[官方文档](http://www.gnu.org/software/libtool/manual/libtool.html#Updating-version-info)是这么描述这三个部分的更新规则的:\n\n> Here are a set of rules to help you update your library version information:\n1.    Start with version information of ‘0:0:0’ for each libtool library.\n2.    Update the version information only immediately before a public release of your software. More frequent updates are unnecessary, and only guarantee that the current interface number gets larger faster.\n3.    If the library source code has changed at all since the last update, then increment revision (‘c:r:a’ becomes ‘c:r+1:a’).\n4.    If any interfaces have been added, removed, or changed since the last update, increment current, and set revision to 0.\n5.    If any interfaces have been added since the last public release, then increment age.\n6.    If any interfaces have been removed or changed since the last public release, then set age to 0. \n\n翻译过来就是\n\n1. 库版本号应该开始于0.0.0\n2. 只有在正式发布库的时候才更新版本号以避免版本号增长过快\n3. 当实现代码改变的时候revision加1\n4. 当接口改变(无论是添加，删除还是修改接口声明)的时候current加1,同时revision重置为0\n5. 如果库只是增加了接口,则age加1\n6. 如果库删除或者修改了接口声明,则age重置为0\n\n这三个值可以用-version-info指定\n\n> -version-info current[:revision[:age]] \n\nrevision 和 age都可以省略,例如你这样设置:\n\n```\nlib_LTLIBRARIES = libeasylog.la\n\nlibeasylog_la_SOURCES = cout_log_interface.cpp \\\n\t\t\t\t\t easy_log.cpp \n\nlibeasylog_la_LDFLAGS = -version-info 3:12:1\n```\n\n表明接口被修改了三次,第三次修改接口之后又修改了12次源码,接口可以向前兼容1个版本\n\nmake install 后可以看到lib目录下生成的库长这样:\n\n```\n-rw-r--r-- 1 linjw linjw 263K 3月  26 12:11 libeasylog.a\n-rwxr-xr-x 1 linjw linjw  987 3月  26 12:11 libeasylog.la\nlrwxrwxrwx 1 linjw linjw   20 3月  26 12:11 libeasylog.so -> libeasylog.so.2.1.12\nlrwxrwxrwx 1 linjw linjw   20 3月  26 12:11 libeasylog.so.2 -> libeasylog.so.2.1.12\n-rwxr-xr-x 1 linjw linjw 143K 3月  26 12:11 libeasylog.so.2.1.12\n```\n\n为啥是libeasylog.so.2.1.12而不是libeasylog.so.3.12.1呢？\n\n原来这几个数字是这样计算的:\n\n库名.so.current-age.age.revision\n\n这样会引发一个问题:\n\n> 假设你的库有两个【3：0：1】【4：0：2】。 再假设在你编译程序的机器上安装了最新的【4：0：2】， 且你在程序中使用了该版本中新加的接口。当你程序编译好后， 你ldd发现你的程序依赖libraryname.so.2， 同时你将程序安装在了只安装了【3：0：1】的机器上， 你会发现你的程序能搜索到动态库， 却在运行的时候发现未定义的符号， 因为【3：0：1】中没有新添加的接口。 故你需要在运行机器上保证安装了同一主版本号最新的library， 以保证你的程序能正确运行。\n\n从 [libtool动态库版本系统之个人理解 ](http://blog.csdn.net/zlyong0018/article/details/16846325) 这篇博客引用\n\n## 手动指定版本号\n\n我之前了解到的so的命名规范其实和libtool的版本号系统的so库命名规范不一样:\n\n> 库名.so.主版本号.次版本号.发布版本号\n\n[官方文档](http://www.gnu.org/software/libtool/manual/libtool.html#Release-numbers)也有提到这一点:\n\n\n> Often, people want to encode the name of the package release into the shared library so that it is obvious to the user what package their programs are linked against. This convention is used especially on GNU/Linux:\n> \n> trick$ ls /usr/lib/libbfd*\n> /usr/lib/libbfd.a           /usr/lib/libbfd.so.2.7.0.2\n> /usr/lib/libbfd.so\n> trick$\n> \n> On ‘trick’, /usr/lib/libbfd.so is a symbolic link to libbfd.so.2.7.0.2, which was distributed as a part of ‘binutils-2.7.0.2’.\n> \n> Unfortunately, this convention conflicts directly with libtool’s idea of library interface versions, because the library interface rarely changes at the same time that the release number does, and the library suffix is never the same across all platforms.\n> \n> So, to accommodate both views, you can use the -release flag to set release information for libraries for which you do not want to use -version-info. For the libbfd example, the next release that uses libtool should be built with ‘-release 2.9.0’, which will produce the following files on GNU/Linux:\n> \n> trick$ ls /usr/lib/libbfd*\n> /usr/lib/libbfd-2.9.0.so     /usr/lib/libbfd.a\n> /usr/lib/libbfd.so\n> trick$\n> \n> In this case, /usr/lib/libbfd.so is a symbolic link to libbfd-2.9.0.so. This makes it obvious that the user is dealing with ‘binutils-2.9.0’, without compromising libtool’s idea of interface versions.\n> \n> Note that this option causes a modification of the library name, so do not use it unless you want to break binary compatibility with any past library releases. In general, you should only use -release for package-internal libraries or for ones whose interfaces change very frequently. \n\n可以使用-release去手动指定版本号,虽然官方不推荐用这种方式:\n\n```\nlib_LTLIBRARIES = libeasylog.la\n\nlibeasylog_la_SOURCES = cout_log_interface.cpp \\\n\t\t\t\t\t easy_log.cpp \n\nlibeasylog_la_LDFLAGS = -release 0.0.3\n```\n\n安装之后lib目录如下:\n\n```\n-rwxr-xr-x 1 linjw linjw 143K 3月  26 14:48 libeasylog-0.0.3.so\n-rw-r--r-- 1 linjw linjw 263K 3月  26 14:48 libeasylog.a\n-rwxr-xr-x 1 linjw linjw  993 3月  26 14:48 libeasylog.la\nlrwxrwxrwx 1 linjw linjw   19 3月  26 14:48 libeasylog.so -> libeasylog-0.0.3.so\n```\n\n可以在[这里](https://github.com/bluesky466/automake-demo/tree/v0.0.3)查看完整的项目代码\n","slug":"automake学习笔记-安装与发布","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2unp002rw3fyg5scrcnp"},{"title":"automake学习笔记 - 交叉编译","date":"2017-04-02T03:05:27.000Z","_content":"\n## 什么是交叉编译\n\n很多时候我们因为各种原因需要在一个平台上编译其他平台的程序。如在linux或者windows上编译可以在安卓使用的so库、apk等。在linux上编译windows的dll或者exe等。\n\n这种在某个系统平台下可以产生另一个系统平台的可执行文件的技术就叫做交叉编译。\n\n## 使用automake进行交叉编译\n\nautomake就提供了交叉编译的功能，但是它的[官方文档](https://www.gnu.org/software/automake/manual/html_node/Cross_002dCompilation.html)十分的简单:\n\n> 2.2.8 Cross-Compilation\n>\n> To cross-compile is to build on one platform a binary that will run on another platform. When speaking of cross-compilation, it is important to distinguish between the build platform on which the compilation is performed, and the host platform on which the resulting executable is expected to run. The following configure options are used to specify each of them:\n>\n> --build=build\nThe system on which the package is built.\n>\n> --host=host\nThe system where built programs and libraries will run.\n>\n> When the --host is used, configure will search for the cross-compiling suite for this platform. Cross-compilation tools commonly have their target architecture as prefix of their name. For instance my cross-compiler for MinGW32 has its binaries called i586-mingw32msvc-gcc, i586-mingw32msvc-ld, i586-mingw32msvc-as, etc.\n>\n> Here is how we could build amhello-1.0 for i586-mingw32msvc on a GNU/Linux PC.\n>\n> ~/amhello-1.0 % ./configure --build i686-pc-linux-gnu --host i586-mingw32msvc\nchecking for a BSD-compatible install... /usr/bin/install -c\nchecking whether build environment is sane... yes\nchecking for gawk... gawk\nchecking whether make sets $(MAKE)... yes\nchecking for i586-mingw32msvc-strip... i586-mingw32msvc-strip\nchecking for i586-mingw32msvc-gcc... i586-mingw32msvc-gcc\nchecking for C compiler default output file name... a.exe\nchecking whether the C compiler works... yes\nchecking whether we are cross compiling... yes\nchecking for suffix of executables... .exe\nchecking for suffix of object files... o\nchecking whether we are using the GNU C compiler... yes\nchecking whether i586-mingw32msvc-gcc accepts -g... yes\nchecking for i586-mingw32msvc-gcc option to accept ANSI C...\n…\n~/amhello-1.0 % make\n…\n~/amhello-1.0 % cd src; file hello.exe\nhello.exe: MS Windows PE 32-bit Intel 80386 console executable not relocatable\nThe --host and --build options are usually all we need for cross-compiling. The only exception is if the package being built is itself a cross-compiler: we need a third option to specify its target architecture.\n>\n> --target=target\nWhen building compiler tools: the system for which the tools will create output.\n>\n> For instance when installing GCC, the GNU Compiler Collection, we can use --target=target to specify that we want to build GCC as a cross-compiler for target. Mixing --build and --target, we can actually cross-compile a cross-compiler; such a three-way cross-compilation is known as a Canadian cross.\n>\n> See Specifying the System Type in The Autoconf Manual, for more information about these configure options.\n\n简单的来说就是通过在执行configure的时候通过传入下面三个参数进行配置,然后和普通的编译一样使用make命令就能编译出指定平台的程序\n\n- --build\n\n编译工程的平台\n\n- --host\n\n编译出来的程序或者库需要运行的平台\n\n- --target\n\n当构建编译器时,指定该编译器编译的程序的运行平台\n\n但是看例子，我们指定平台却并不是简单的指定windows、android这么简单。\n\n> ~/amhello-1.0 % ./configure --build i686-pc-linux-gnu --host i586-mingw32msvc\n\n这里的 i686-pc-linux-gnu和 i586-mingw32msvc-gcc其实指的是一系列的编译工具。交叉编译工具的命名其实是有一定的格式的。 例如，用来编译windows程序的MinGW32的交叉编译器的二进制文件叫做i586-mingw32msvc-gcc，i586-mingw32msvc-ld，i586-mingw32msvc-as等。\n\n> MinGW是Minimalist GNU for Windows的意思，又称mingw32，是将GCC编译器和GNU Binutils移植到Win32平台下的产物，包括一系列头文件（Win32API）、库和可执行文件。-- [维基百科](https://zh.wikipedia.org/wiki/MinGW)\n\n其实就是我们指定了编译工具的前缀，然后automake就会更加这个前缀，找到对应的编译器去编译我们的程序。\n\n## 在linux上编译windows上的程序\n\n有人可能会问，为什么需要在linux上编译这么蛋疼而不直接在windows上编译呢？\n\n就按我遇到的情况来说吧。我们部门的自动构建服务器就是liunx的，我们的项目都需要通过它来编译、检查和发布，我们也习惯于在linux上编程，最重要的是我们的项目就是跨平台的，不管是windows、linux还是android上都需要可以运行，所以没有必要为每个平台搭建一套编译环境。直接在linux上编译所有平台的软件是最好的选择。\n\n为了在linux上交叉编译windows的程序，我们先要搭建一下交叉编译的环境:\n\n1. 安装交叉编译工具\n\n```\nsudo apt-get install mingw-w64\n```\n\n2. 更新配置，使用 posix thread\n\n```\nsudo update-alternatives --config i686-w64-mingw32-g++\nsudo update-alternatives --config i686-w64-mingw32-gcc\nsudo update-alternatives --config x86_64-w64-mingw32-g++\nsudo update-alternatives --config x86_64-w64-mingw32-gcc\n```\n\n上面的选项中，选择 posix 版本。\n\n> 可移植操作系统接口（英语：Portable Operating System Interface of UNIX，缩写为POSIX），是IEEE为要在各种UNIX操作系统上运行软件，而定义API的一系列互相关联的标准的总称，其正式称呼为IEEE Std 1003，而国际标准名称为ISO/IEC 9945。此标准源于一个大约开始于1985年的项目。POSIX这个名称是由理查德·斯托曼应IEEE的要求而提议的一个易于记忆的名称。它基本上是Portable Operating System Interface（可移植操作系统接口）的缩写，而X则表明其对Unix API的传承。\nLinux基本上逐步实现了POSIX兼容，但并没有参加正式的POSIX认证。[1]\n微软的Windows NT声称部分实现了POSIX标准。[2]\n当前的POSIX主要分为四个部分[3]：Base Definitions、System Interfaces、Shell and Utilities和Rationale。 -- [维基百科](https://zh.wikipedia.org/wiki/POSIX)\n\n按道理这个时候就可以在build目录执行下面的命令去编译了\n\n```\n../configure --prefix=`pwd` --host i686-w64-mingw32\n```\n\n但是执行了configure之后却会报下面的错误:\n\n> libtool: warning: undefined symbols not allowed in i686-w64-mingw32 shared libraries; building static only\n\n本来我们的工程是需要编译动态库的，但是如果报了这个错误，就会编出静态库来，最终install之后在bin目录下面只有一个 __example.exe__ ，而没有dll。解决方法是在src/Makefile.am中加上\n\n> libeasylog_la_LDFLAGS = -no-undefined\n\n这样编译安装之后就能在bin目录下看到 __example.exe__ 和 __libeasylog-0.dll__ 了\n\n这个时候将这两个东西拷贝到windows平台上去，记得它们需要在同级目录这样 __example.exe__ 才能找到 __libeasylog-0.dll__。然后在控制台中运行 __example.exe__ 就会报下面的错误,其实就是还有几个dll没有找到：\n\n> 无法启动此程序,因为计算机中丢失libstdc++-6.dll。尝试重新安装该程序以解决此问题。  \n>\n> 无法启动此程序,因为计算机中丢失libgcc_s_sjlj-1.dll。尝试重新安装该程序以解决此问题。\n\n我们到下面的目录把缺的dll也拷贝到example的同级目录\n\n> /usr/lib/gcc/i686-w64-mingw32/5.3-posix/\n\n再次运行发现有报了下面的错误:\n\n> 无法启动此程序,因为计算机中丢失libwinpthread-1.dll。尝试重新安装该程序以解决此问题。\n\n这个dll可以到下面的目录拷贝，同样放到example的同级目录，之后再运行example:\n\n> [test] testlog\n\n看已经成功运行了。\n\n## 在linux上编译安卓上的程序\n\n搭建安卓的交叉编译环境就是生成 standalone toochain\n\n首先下载NDK，解压，假设NDK的根目录为NDK_ROOT，然后执行\n\n```\nsudo $NDK_ROOT/build/tools/make-standalone-toolchain.sh \\\n     --platform=android-19 \\\n     --install-dir=$HOME/Android/standalone-toolchains/android-toolchain-arm \\\n     --toolchain=arm-linux-androideabi-4.9 \\\n     --stl=gnustl\n```\n\n最后配置环境变量\n\n```\nexport NDK_ROOT=$HOME/Android/android-ndk-r13b\nexport TOOLCHAIN_HOME=$HOME/Android/standalone-toolchains/android-toolchain-arm\nexport TOOLCHAIN_SYSROOT=$TOOLCHAIN_HOME/sysroot\nexport PATH=$PATH:$TOOLCHAIN_HOME/bin\n```\n\n环境搭建好之后在build目录中执行\n\n```\n../configure --prefix=`pwd` --host arm-linux-androideabi\n```\n\n之后就能使用make install命令编译并安装了。\n\n在某些机器上编译时会报找不到shared_ptr的错误,解决方法是在src/Makefile.am和examples/Makefile.am的CPPFLAGS宏加上-std=c++11:\n\n```\n#src/Makefile.am\nlib_LTLIBRARIES = libeasylog.la\n\nlibeasylog_la_SOURCES = cout_log_interface.cpp \\\n\t\t\t\t\t\teasy_log.cpp\n\nlibeasylog_la_CPPFLAGS = -std=c++11\n\nlibeasylog_la_LDFLAGS = -no-undefined\n```\n\n```\n#examples/Makefile.am\nAM_CPPFLAGS = -I$(top_srcdir)/src \\\n              -std=c++11\n\nbin_PROGRAMS = example\nexample_SOURCES = example.cpp\n\nexample_LDADD = -L$(top_builddir)/src \\\n\t\t\t\t-leasylog\n\n```\n\n编译安装完成后再bin目录可以见到 __example__ ,在lib目录可以看到 __libeasylog.so__。\n\n虽然看起来和linux程序一样，但是直接运行example的话会报错:\n\n> zsh: 可执行文件格式错误: ./example\n\n因为它的运行环境是安卓，在本机(Ubuntu)上不能运行\n\n如果你有一台root了的安卓机器的话，可以使用adb将example给push到/system/bin，将libeasylog.so给push到/system/lib。这样就能在adb shell中使用example命令得到下面的输出了:\n\n> [test] testlog\n\n当然，做应用的一般都不会直接编译出可执行程序来给安卓使用。更多的是编译出so来给apk通过jni调用c/c++的方法。但是编译的过程和这里是一样的，关于jni的使用我之后会另写一篇文章来讨论。\n\n## Demo项目\n\n可以在[这里](https://github.com/bluesky466/automake-demo/tree/v0.0.4)查看完整的项目代码\n","source":"_posts/automake学习笔记-交叉编译.md","raw":"title: automake学习笔记 - 交叉编译\ndate: 2017-04-02 11:05:27\ntags:\n\t- 技术相关\n\t- 编译相关\n---\n\n## 什么是交叉编译\n\n很多时候我们因为各种原因需要在一个平台上编译其他平台的程序。如在linux或者windows上编译可以在安卓使用的so库、apk等。在linux上编译windows的dll或者exe等。\n\n这种在某个系统平台下可以产生另一个系统平台的可执行文件的技术就叫做交叉编译。\n\n## 使用automake进行交叉编译\n\nautomake就提供了交叉编译的功能，但是它的[官方文档](https://www.gnu.org/software/automake/manual/html_node/Cross_002dCompilation.html)十分的简单:\n\n> 2.2.8 Cross-Compilation\n>\n> To cross-compile is to build on one platform a binary that will run on another platform. When speaking of cross-compilation, it is important to distinguish between the build platform on which the compilation is performed, and the host platform on which the resulting executable is expected to run. The following configure options are used to specify each of them:\n>\n> --build=build\nThe system on which the package is built.\n>\n> --host=host\nThe system where built programs and libraries will run.\n>\n> When the --host is used, configure will search for the cross-compiling suite for this platform. Cross-compilation tools commonly have their target architecture as prefix of their name. For instance my cross-compiler for MinGW32 has its binaries called i586-mingw32msvc-gcc, i586-mingw32msvc-ld, i586-mingw32msvc-as, etc.\n>\n> Here is how we could build amhello-1.0 for i586-mingw32msvc on a GNU/Linux PC.\n>\n> ~/amhello-1.0 % ./configure --build i686-pc-linux-gnu --host i586-mingw32msvc\nchecking for a BSD-compatible install... /usr/bin/install -c\nchecking whether build environment is sane... yes\nchecking for gawk... gawk\nchecking whether make sets $(MAKE)... yes\nchecking for i586-mingw32msvc-strip... i586-mingw32msvc-strip\nchecking for i586-mingw32msvc-gcc... i586-mingw32msvc-gcc\nchecking for C compiler default output file name... a.exe\nchecking whether the C compiler works... yes\nchecking whether we are cross compiling... yes\nchecking for suffix of executables... .exe\nchecking for suffix of object files... o\nchecking whether we are using the GNU C compiler... yes\nchecking whether i586-mingw32msvc-gcc accepts -g... yes\nchecking for i586-mingw32msvc-gcc option to accept ANSI C...\n…\n~/amhello-1.0 % make\n…\n~/amhello-1.0 % cd src; file hello.exe\nhello.exe: MS Windows PE 32-bit Intel 80386 console executable not relocatable\nThe --host and --build options are usually all we need for cross-compiling. The only exception is if the package being built is itself a cross-compiler: we need a third option to specify its target architecture.\n>\n> --target=target\nWhen building compiler tools: the system for which the tools will create output.\n>\n> For instance when installing GCC, the GNU Compiler Collection, we can use --target=target to specify that we want to build GCC as a cross-compiler for target. Mixing --build and --target, we can actually cross-compile a cross-compiler; such a three-way cross-compilation is known as a Canadian cross.\n>\n> See Specifying the System Type in The Autoconf Manual, for more information about these configure options.\n\n简单的来说就是通过在执行configure的时候通过传入下面三个参数进行配置,然后和普通的编译一样使用make命令就能编译出指定平台的程序\n\n- --build\n\n编译工程的平台\n\n- --host\n\n编译出来的程序或者库需要运行的平台\n\n- --target\n\n当构建编译器时,指定该编译器编译的程序的运行平台\n\n但是看例子，我们指定平台却并不是简单的指定windows、android这么简单。\n\n> ~/amhello-1.0 % ./configure --build i686-pc-linux-gnu --host i586-mingw32msvc\n\n这里的 i686-pc-linux-gnu和 i586-mingw32msvc-gcc其实指的是一系列的编译工具。交叉编译工具的命名其实是有一定的格式的。 例如，用来编译windows程序的MinGW32的交叉编译器的二进制文件叫做i586-mingw32msvc-gcc，i586-mingw32msvc-ld，i586-mingw32msvc-as等。\n\n> MinGW是Minimalist GNU for Windows的意思，又称mingw32，是将GCC编译器和GNU Binutils移植到Win32平台下的产物，包括一系列头文件（Win32API）、库和可执行文件。-- [维基百科](https://zh.wikipedia.org/wiki/MinGW)\n\n其实就是我们指定了编译工具的前缀，然后automake就会更加这个前缀，找到对应的编译器去编译我们的程序。\n\n## 在linux上编译windows上的程序\n\n有人可能会问，为什么需要在linux上编译这么蛋疼而不直接在windows上编译呢？\n\n就按我遇到的情况来说吧。我们部门的自动构建服务器就是liunx的，我们的项目都需要通过它来编译、检查和发布，我们也习惯于在linux上编程，最重要的是我们的项目就是跨平台的，不管是windows、linux还是android上都需要可以运行，所以没有必要为每个平台搭建一套编译环境。直接在linux上编译所有平台的软件是最好的选择。\n\n为了在linux上交叉编译windows的程序，我们先要搭建一下交叉编译的环境:\n\n1. 安装交叉编译工具\n\n```\nsudo apt-get install mingw-w64\n```\n\n2. 更新配置，使用 posix thread\n\n```\nsudo update-alternatives --config i686-w64-mingw32-g++\nsudo update-alternatives --config i686-w64-mingw32-gcc\nsudo update-alternatives --config x86_64-w64-mingw32-g++\nsudo update-alternatives --config x86_64-w64-mingw32-gcc\n```\n\n上面的选项中，选择 posix 版本。\n\n> 可移植操作系统接口（英语：Portable Operating System Interface of UNIX，缩写为POSIX），是IEEE为要在各种UNIX操作系统上运行软件，而定义API的一系列互相关联的标准的总称，其正式称呼为IEEE Std 1003，而国际标准名称为ISO/IEC 9945。此标准源于一个大约开始于1985年的项目。POSIX这个名称是由理查德·斯托曼应IEEE的要求而提议的一个易于记忆的名称。它基本上是Portable Operating System Interface（可移植操作系统接口）的缩写，而X则表明其对Unix API的传承。\nLinux基本上逐步实现了POSIX兼容，但并没有参加正式的POSIX认证。[1]\n微软的Windows NT声称部分实现了POSIX标准。[2]\n当前的POSIX主要分为四个部分[3]：Base Definitions、System Interfaces、Shell and Utilities和Rationale。 -- [维基百科](https://zh.wikipedia.org/wiki/POSIX)\n\n按道理这个时候就可以在build目录执行下面的命令去编译了\n\n```\n../configure --prefix=`pwd` --host i686-w64-mingw32\n```\n\n但是执行了configure之后却会报下面的错误:\n\n> libtool: warning: undefined symbols not allowed in i686-w64-mingw32 shared libraries; building static only\n\n本来我们的工程是需要编译动态库的，但是如果报了这个错误，就会编出静态库来，最终install之后在bin目录下面只有一个 __example.exe__ ，而没有dll。解决方法是在src/Makefile.am中加上\n\n> libeasylog_la_LDFLAGS = -no-undefined\n\n这样编译安装之后就能在bin目录下看到 __example.exe__ 和 __libeasylog-0.dll__ 了\n\n这个时候将这两个东西拷贝到windows平台上去，记得它们需要在同级目录这样 __example.exe__ 才能找到 __libeasylog-0.dll__。然后在控制台中运行 __example.exe__ 就会报下面的错误,其实就是还有几个dll没有找到：\n\n> 无法启动此程序,因为计算机中丢失libstdc++-6.dll。尝试重新安装该程序以解决此问题。  \n>\n> 无法启动此程序,因为计算机中丢失libgcc_s_sjlj-1.dll。尝试重新安装该程序以解决此问题。\n\n我们到下面的目录把缺的dll也拷贝到example的同级目录\n\n> /usr/lib/gcc/i686-w64-mingw32/5.3-posix/\n\n再次运行发现有报了下面的错误:\n\n> 无法启动此程序,因为计算机中丢失libwinpthread-1.dll。尝试重新安装该程序以解决此问题。\n\n这个dll可以到下面的目录拷贝，同样放到example的同级目录，之后再运行example:\n\n> [test] testlog\n\n看已经成功运行了。\n\n## 在linux上编译安卓上的程序\n\n搭建安卓的交叉编译环境就是生成 standalone toochain\n\n首先下载NDK，解压，假设NDK的根目录为NDK_ROOT，然后执行\n\n```\nsudo $NDK_ROOT/build/tools/make-standalone-toolchain.sh \\\n     --platform=android-19 \\\n     --install-dir=$HOME/Android/standalone-toolchains/android-toolchain-arm \\\n     --toolchain=arm-linux-androideabi-4.9 \\\n     --stl=gnustl\n```\n\n最后配置环境变量\n\n```\nexport NDK_ROOT=$HOME/Android/android-ndk-r13b\nexport TOOLCHAIN_HOME=$HOME/Android/standalone-toolchains/android-toolchain-arm\nexport TOOLCHAIN_SYSROOT=$TOOLCHAIN_HOME/sysroot\nexport PATH=$PATH:$TOOLCHAIN_HOME/bin\n```\n\n环境搭建好之后在build目录中执行\n\n```\n../configure --prefix=`pwd` --host arm-linux-androideabi\n```\n\n之后就能使用make install命令编译并安装了。\n\n在某些机器上编译时会报找不到shared_ptr的错误,解决方法是在src/Makefile.am和examples/Makefile.am的CPPFLAGS宏加上-std=c++11:\n\n```\n#src/Makefile.am\nlib_LTLIBRARIES = libeasylog.la\n\nlibeasylog_la_SOURCES = cout_log_interface.cpp \\\n\t\t\t\t\t\teasy_log.cpp\n\nlibeasylog_la_CPPFLAGS = -std=c++11\n\nlibeasylog_la_LDFLAGS = -no-undefined\n```\n\n```\n#examples/Makefile.am\nAM_CPPFLAGS = -I$(top_srcdir)/src \\\n              -std=c++11\n\nbin_PROGRAMS = example\nexample_SOURCES = example.cpp\n\nexample_LDADD = -L$(top_builddir)/src \\\n\t\t\t\t-leasylog\n\n```\n\n编译安装完成后再bin目录可以见到 __example__ ,在lib目录可以看到 __libeasylog.so__。\n\n虽然看起来和linux程序一样，但是直接运行example的话会报错:\n\n> zsh: 可执行文件格式错误: ./example\n\n因为它的运行环境是安卓，在本机(Ubuntu)上不能运行\n\n如果你有一台root了的安卓机器的话，可以使用adb将example给push到/system/bin，将libeasylog.so给push到/system/lib。这样就能在adb shell中使用example命令得到下面的输出了:\n\n> [test] testlog\n\n当然，做应用的一般都不会直接编译出可执行程序来给安卓使用。更多的是编译出so来给apk通过jni调用c/c++的方法。但是编译的过程和这里是一样的，关于jni的使用我之后会另写一篇文章来讨论。\n\n## Demo项目\n\n可以在[这里](https://github.com/bluesky466/automake-demo/tree/v0.0.4)查看完整的项目代码\n","slug":"automake学习笔记-交叉编译","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2unr002uw3fy13riwbn4"},{"title":"automake学习笔记 - helloworld","date":"2017-03-16T17:11:40.000Z","_content":"\n虽然之前已经用过一段时间的automake,但是总觉得对它的理解不过充分,只是知其然而不知其所以然。于是下定决心好好啃[文档](http://www.gnu.org/software/automake/manual/automake.html),并将学的的东西记录下来。\n\n这篇文章用一个简单的log工具的编译先对automake做一个hello world级别的介绍。\n\n## 代码\n我们的demo有6个文件cout\\_log\\_interface.h, cout\\_log\\_interface.cpp, log\\_interface.h, easy\\_log.h, easy\\_log.cpp, main.cpp\n\n简单介绍下代码吧,首先有个简单的Log类:\n\n```\nclass EasyLog {\npublic:\n    EasyLog(std::shared_ptr<LogInterface> interface);\n\n    void Info(const std::string& tag, const std::string& log);\n\n    void Debug(const std::string& tag, const std::string& log);\n\n    void Warn(const std::string& tag, const std::string& log);\n\n    void Error(const std::string& tag, const std::string& log);\n\nprivate:\n    std::string GetLog(const std::string& tag, const std::string& log) const;\n\n    std::shared_ptr<LogInterface> interface_;\n};\n```\n\n它的实现十分简单，就是将所有的操作代理给LogInterface:\n\n```\nEasyLog::EasyLog(shared_ptr<LogInterface> interface)\n    : interface_(interface)\n{\n}\n\nvoid EasyLog::Info(const string& tag, const string& log)\n{\n    interface_->DoLog(kInfo, tag, GetLog(tag, log));\n}\n\nvoid EasyLog::Debug(const string& tag, const string& log)\n{\n    interface_->DoLog(kDebug, tag, GetLog(tag, log));\n}\n\nvoid EasyLog::Warn(const string& tag, const string& log)\n{\n    interface_->DoLog(kWarn, tag, GetLog(tag, log));\n}\n\nvoid EasyLog::Error(const string& tag, const string& log)\n{\n    interface_->DoLog(kError, tag, GetLog(tag, log));\n}\n\nstd::string EasyLog::GetLog(const string& tag, const string& log) const\n{\n    return \"[\" + tag + \"]\" + \" \" + log;\n}\n```\n\nLogInterface是一个纯虚类，然后LogLevel是一个枚举体:\n\n```\nenum LogLevel {\n    kInfo,\n    kDebug,\n    kWarn,\n    kError\n};\n\nclass LogInterface {\npublic:\n    virtual void DoLog(LogLevel level, const std::string& tag, const std::string& log) = 0;\n};\n```\n\n我们再写一个使用标准输出打印log的LogInterface:\n\n```\nclass COutLogInterface : public LogInterface {\npublic:\n    virtual void DoLog(LogLevel level, const std::string& tag, const std::string& log);\n};\n```\n\n它的实现就是使用cout打印log:\n\n```\nvoid COutLogInterface::DoLog(LogLevel level, const string& tag, const string& log) {\n    cout<<log<<endl;\n}\n```\n\n当然需要有个main函数:\n\n```\nint main()\n{\n    EasyLog log(std::make_shared<COutLogInterface>());\n    log.Debug(\"test\", \"testlog\");\n    return 0;\n}\n```\n\n## Makefile.am\n\nautomake使用Makefile.am配置工程的源码,它的内容如下:\n\n```\nbin_PROGRAMS = easylog\neasylog_SOURCES = cout_log_interface.cpp \\\n                  easy_log.cpp \\\n                  main.cpp\n```\n\nbin\\_PROGRAMS 指定了要编译生成的目标程序的名字,在这里我们最终编译出来的目标程序的文件名是easylog\n\n之后的 easylog\\_SOURCES 指定了需要参与编译的源代码。\n\n如果需要同时编译多个目标程序的话可以用下面的方式分别指定各个目标程序的源代码\n\n```\nbin_PROGRAMS = program_a program_b\nprogram_a_SOURCES = code_a.cpp\nprogram_b_SOURCES = code_b.cpp \n```\n\n## configure.ac\n\n指定了源代码还不够，因为automake不仅仅可以用来生成编译c/c++的makefile，还可以用来编译生成其他许许多多语言的makefile，所以还需要指定编译器和依赖文件等。automake使用configure.ac配置这些东西,本例子的configure.ac是这么写的:\n\n```\nAC_INIT([easylog], [0.0.1], [466474482@qq.com])\nAM_INIT_AUTOMAKE([-Wall -Werror foreign])\nAC_CONFIG_HEADERS([config.h])\n\nAC_PROG_CXX\nAX_CXX_COMPILE_STDCXX_11\n\nAC_CONFIG_FILES([Makefile])\n\nAC_OUTPUT\n```\n\n简单分析一下configure.ac的内容:\n\n- AC\\_INIT \n\n指定了工程的名字、版本号、和bug的报告邮箱\n\n- AM\\_INIT\\_AUTOMAKE\n\n指定了一些选项,-Wall和-Werror指定编译的时候将所有的warning当做error来报错, foreign告诉automake这里不用遵循GNU标准。GNU软件包应该包括一些附加文件去描述如修改项，作者等信息。在这里我们不需要automake去检查这些附加文件的存在。\n\n- AC\\_CONFIG\\_HEADERS \n\n我们在AC\\_INIT中配置了版本号等信息,c/c++中一般需要用宏来定义它们,这里就指定了生成的配置宏的头文件名。配置了这里,automake就会自动帮我们生成config.h头文件,里面定义了一些VERSION之类的宏\n\n- AC\\_PROG\\_CXX\n\n该宏用于检查系统中是否有g++编译器\n\n- AX\\_CXX\\_COMPILE\\_STDCXX\\_11 \n\n检查系统的c++11编译支持\n\n- AC\\_CONFIG\\_FILES \n\n指定了需要configure生成的Makefile,autoreconf的时候会通过Makefile.am生成Makefile.in。而configure的时候会通过Makefile.in生成Makefile。因为Makefile.am和configure.ac在同级目录,所以直接写Makefile就好了。在后面我会介绍当Makefile.am和configure.ac不在同级目录的时候需要怎么配置\n\n- AC\\_OUTPUT\n\n这是一个结束标志,实际上它是一个脚本命令用来创建AC\\_CONFIG\\_HEADERS和AC\\_CONFIG\\_FILES所配置的文件\n\n## 生成Makefile\n\n首先要安装autoconf\n\n> sudo apt-get install autoconf\n\n然后使用下面的命令生成configure\n\n> autoreconf --install\n\n除了configure之外，它还会生成一些其他的文件，当然现在我们不需要去管这些文件\n\n之后就能使用configure脚本去生成Makefile和config.h等\n\n> ./configure\n\n\n## 编译工程\n\nMakefile都已经生成了，现在就可以使用make命令编译工程啦  \n\n编译成功之后就能在当前目录看到easylog程序。我们可以运行它:\n\n> ./easylog\n\n得到下面输出:\n\n> [test] testlog\n\n## 在build目录中编译项目\n\n现在我们编译生成的.o文件和目标程序都混在源代码中间,看起来很不舒服。我们可以创建一个build目录。然后进入build目录执行下面命令\n\n> ../configure\n\n这样就在build目录下生成Makefile了,于是现在我们在build中使用make命令编辑工程就会发现编译产生的.o文件和目标文件都在build中而不会污染源代码了。\n\n## 使用autoscan生成configure.ac                                                  \n                                                                                 \n如果直接手写configure.ac的话是比较困难的,很容易漏掉一些依赖项没有检查。所以就出现了autoscan这个工具,它可以帮我们检查工程中的依赖项生成configure.ac的模板,然后我们只需要在它生成的模板上略加改动就可以了。\n                                                                                 \n我们在工程目录下使用autoscan命令,会得到下面的两个文件:                           \n                                                                                 \n1. autoscan.log                                                                  \n                                                                                 \n2. configure.scan                                                                \n                                                                                 \nautoscan.log是一个日志文件,通过它我们可以知道一些配置为什么会被需要              \n                                                                                 \n而configure.scan就是生成出来的configure.ac的模板了,在easylog工程目录使用autoscan,生成的configure.scan内容如下\n                                                                                 \n```                                                                              \n#                                               -*- Autoconf -*-                 \n# Process this file with autoconf to produce a configure script.                 \n                                                                                 \nAC_PREREQ([2.69])                                                                \nAC_INIT([FULL-PACKAGE-NAME], [VERSION], [BUG-REPORT-ADDRESS])                    \nAC_CONFIG_SRCDIR([log_interface.h])                                              \nAC_CONFIG_HEADERS([config.h])                                                    \n                                                                                 \n# Checks for programs.                                                           \nAC_PROG_CXX                                                                      \nAC_PROG_CC                                                                       \n                                                                                 \n# Checks for libraries.                                                          \n                                                                                 \n# Checks for header files.                                                       \n                                                                                 \n# Checks for typedefs, structures, and compiler characteristics.                 \n                                                                                 \n# Checks for library functions.                                                  \n                                                                                 \nAC_CONFIG_FILES([Makefile])                                                      \nAC_OUTPUT                                                                        \n```                                                                              \n                                                                                 \n看是不是和我们之前手写的很像?我们只有在上面进行一些小的修改就能得到最终我们需要的configure.ac了\n\n这里有两个宏我们是没有见过的\n\n- AC\\_PREREQ\n\n用于检查autoconf的最低版本\n\n- AC\\_CONFIG\\_SRCDIR\n\n用一个项目中一定存在的文件去确定源码目录的有效性,这是一个安全检查宏。configure有一个--srcdir的参数可以指定源码目录,这个宏就可以检查出源码目录是否不小心配置错了\n\n## Demo项目\n\n可以在[这里](https://github.com/bluesky466/automake-demo/tree/v0.0.1)查看完整的项目代码\n","source":"_posts/automake学习笔记-helloworld.md","raw":"title: automake学习笔记 - helloworld\ndate: 2017-03-17 01:11:40\ntags:\n\t- 技术相关\n\t- 编译相关\n---\n\n虽然之前已经用过一段时间的automake,但是总觉得对它的理解不过充分,只是知其然而不知其所以然。于是下定决心好好啃[文档](http://www.gnu.org/software/automake/manual/automake.html),并将学的的东西记录下来。\n\n这篇文章用一个简单的log工具的编译先对automake做一个hello world级别的介绍。\n\n## 代码\n我们的demo有6个文件cout\\_log\\_interface.h, cout\\_log\\_interface.cpp, log\\_interface.h, easy\\_log.h, easy\\_log.cpp, main.cpp\n\n简单介绍下代码吧,首先有个简单的Log类:\n\n```\nclass EasyLog {\npublic:\n    EasyLog(std::shared_ptr<LogInterface> interface);\n\n    void Info(const std::string& tag, const std::string& log);\n\n    void Debug(const std::string& tag, const std::string& log);\n\n    void Warn(const std::string& tag, const std::string& log);\n\n    void Error(const std::string& tag, const std::string& log);\n\nprivate:\n    std::string GetLog(const std::string& tag, const std::string& log) const;\n\n    std::shared_ptr<LogInterface> interface_;\n};\n```\n\n它的实现十分简单，就是将所有的操作代理给LogInterface:\n\n```\nEasyLog::EasyLog(shared_ptr<LogInterface> interface)\n    : interface_(interface)\n{\n}\n\nvoid EasyLog::Info(const string& tag, const string& log)\n{\n    interface_->DoLog(kInfo, tag, GetLog(tag, log));\n}\n\nvoid EasyLog::Debug(const string& tag, const string& log)\n{\n    interface_->DoLog(kDebug, tag, GetLog(tag, log));\n}\n\nvoid EasyLog::Warn(const string& tag, const string& log)\n{\n    interface_->DoLog(kWarn, tag, GetLog(tag, log));\n}\n\nvoid EasyLog::Error(const string& tag, const string& log)\n{\n    interface_->DoLog(kError, tag, GetLog(tag, log));\n}\n\nstd::string EasyLog::GetLog(const string& tag, const string& log) const\n{\n    return \"[\" + tag + \"]\" + \" \" + log;\n}\n```\n\nLogInterface是一个纯虚类，然后LogLevel是一个枚举体:\n\n```\nenum LogLevel {\n    kInfo,\n    kDebug,\n    kWarn,\n    kError\n};\n\nclass LogInterface {\npublic:\n    virtual void DoLog(LogLevel level, const std::string& tag, const std::string& log) = 0;\n};\n```\n\n我们再写一个使用标准输出打印log的LogInterface:\n\n```\nclass COutLogInterface : public LogInterface {\npublic:\n    virtual void DoLog(LogLevel level, const std::string& tag, const std::string& log);\n};\n```\n\n它的实现就是使用cout打印log:\n\n```\nvoid COutLogInterface::DoLog(LogLevel level, const string& tag, const string& log) {\n    cout<<log<<endl;\n}\n```\n\n当然需要有个main函数:\n\n```\nint main()\n{\n    EasyLog log(std::make_shared<COutLogInterface>());\n    log.Debug(\"test\", \"testlog\");\n    return 0;\n}\n```\n\n## Makefile.am\n\nautomake使用Makefile.am配置工程的源码,它的内容如下:\n\n```\nbin_PROGRAMS = easylog\neasylog_SOURCES = cout_log_interface.cpp \\\n                  easy_log.cpp \\\n                  main.cpp\n```\n\nbin\\_PROGRAMS 指定了要编译生成的目标程序的名字,在这里我们最终编译出来的目标程序的文件名是easylog\n\n之后的 easylog\\_SOURCES 指定了需要参与编译的源代码。\n\n如果需要同时编译多个目标程序的话可以用下面的方式分别指定各个目标程序的源代码\n\n```\nbin_PROGRAMS = program_a program_b\nprogram_a_SOURCES = code_a.cpp\nprogram_b_SOURCES = code_b.cpp \n```\n\n## configure.ac\n\n指定了源代码还不够，因为automake不仅仅可以用来生成编译c/c++的makefile，还可以用来编译生成其他许许多多语言的makefile，所以还需要指定编译器和依赖文件等。automake使用configure.ac配置这些东西,本例子的configure.ac是这么写的:\n\n```\nAC_INIT([easylog], [0.0.1], [466474482@qq.com])\nAM_INIT_AUTOMAKE([-Wall -Werror foreign])\nAC_CONFIG_HEADERS([config.h])\n\nAC_PROG_CXX\nAX_CXX_COMPILE_STDCXX_11\n\nAC_CONFIG_FILES([Makefile])\n\nAC_OUTPUT\n```\n\n简单分析一下configure.ac的内容:\n\n- AC\\_INIT \n\n指定了工程的名字、版本号、和bug的报告邮箱\n\n- AM\\_INIT\\_AUTOMAKE\n\n指定了一些选项,-Wall和-Werror指定编译的时候将所有的warning当做error来报错, foreign告诉automake这里不用遵循GNU标准。GNU软件包应该包括一些附加文件去描述如修改项，作者等信息。在这里我们不需要automake去检查这些附加文件的存在。\n\n- AC\\_CONFIG\\_HEADERS \n\n我们在AC\\_INIT中配置了版本号等信息,c/c++中一般需要用宏来定义它们,这里就指定了生成的配置宏的头文件名。配置了这里,automake就会自动帮我们生成config.h头文件,里面定义了一些VERSION之类的宏\n\n- AC\\_PROG\\_CXX\n\n该宏用于检查系统中是否有g++编译器\n\n- AX\\_CXX\\_COMPILE\\_STDCXX\\_11 \n\n检查系统的c++11编译支持\n\n- AC\\_CONFIG\\_FILES \n\n指定了需要configure生成的Makefile,autoreconf的时候会通过Makefile.am生成Makefile.in。而configure的时候会通过Makefile.in生成Makefile。因为Makefile.am和configure.ac在同级目录,所以直接写Makefile就好了。在后面我会介绍当Makefile.am和configure.ac不在同级目录的时候需要怎么配置\n\n- AC\\_OUTPUT\n\n这是一个结束标志,实际上它是一个脚本命令用来创建AC\\_CONFIG\\_HEADERS和AC\\_CONFIG\\_FILES所配置的文件\n\n## 生成Makefile\n\n首先要安装autoconf\n\n> sudo apt-get install autoconf\n\n然后使用下面的命令生成configure\n\n> autoreconf --install\n\n除了configure之外，它还会生成一些其他的文件，当然现在我们不需要去管这些文件\n\n之后就能使用configure脚本去生成Makefile和config.h等\n\n> ./configure\n\n\n## 编译工程\n\nMakefile都已经生成了，现在就可以使用make命令编译工程啦  \n\n编译成功之后就能在当前目录看到easylog程序。我们可以运行它:\n\n> ./easylog\n\n得到下面输出:\n\n> [test] testlog\n\n## 在build目录中编译项目\n\n现在我们编译生成的.o文件和目标程序都混在源代码中间,看起来很不舒服。我们可以创建一个build目录。然后进入build目录执行下面命令\n\n> ../configure\n\n这样就在build目录下生成Makefile了,于是现在我们在build中使用make命令编辑工程就会发现编译产生的.o文件和目标文件都在build中而不会污染源代码了。\n\n## 使用autoscan生成configure.ac                                                  \n                                                                                 \n如果直接手写configure.ac的话是比较困难的,很容易漏掉一些依赖项没有检查。所以就出现了autoscan这个工具,它可以帮我们检查工程中的依赖项生成configure.ac的模板,然后我们只需要在它生成的模板上略加改动就可以了。\n                                                                                 \n我们在工程目录下使用autoscan命令,会得到下面的两个文件:                           \n                                                                                 \n1. autoscan.log                                                                  \n                                                                                 \n2. configure.scan                                                                \n                                                                                 \nautoscan.log是一个日志文件,通过它我们可以知道一些配置为什么会被需要              \n                                                                                 \n而configure.scan就是生成出来的configure.ac的模板了,在easylog工程目录使用autoscan,生成的configure.scan内容如下\n                                                                                 \n```                                                                              \n#                                               -*- Autoconf -*-                 \n# Process this file with autoconf to produce a configure script.                 \n                                                                                 \nAC_PREREQ([2.69])                                                                \nAC_INIT([FULL-PACKAGE-NAME], [VERSION], [BUG-REPORT-ADDRESS])                    \nAC_CONFIG_SRCDIR([log_interface.h])                                              \nAC_CONFIG_HEADERS([config.h])                                                    \n                                                                                 \n# Checks for programs.                                                           \nAC_PROG_CXX                                                                      \nAC_PROG_CC                                                                       \n                                                                                 \n# Checks for libraries.                                                          \n                                                                                 \n# Checks for header files.                                                       \n                                                                                 \n# Checks for typedefs, structures, and compiler characteristics.                 \n                                                                                 \n# Checks for library functions.                                                  \n                                                                                 \nAC_CONFIG_FILES([Makefile])                                                      \nAC_OUTPUT                                                                        \n```                                                                              \n                                                                                 \n看是不是和我们之前手写的很像?我们只有在上面进行一些小的修改就能得到最终我们需要的configure.ac了\n\n这里有两个宏我们是没有见过的\n\n- AC\\_PREREQ\n\n用于检查autoconf的最低版本\n\n- AC\\_CONFIG\\_SRCDIR\n\n用一个项目中一定存在的文件去确定源码目录的有效性,这是一个安全检查宏。configure有一个--srcdir的参数可以指定源码目录,这个宏就可以检查出源码目录是否不小心配置错了\n\n## Demo项目\n\n可以在[这里](https://github.com/bluesky466/automake-demo/tree/v0.0.1)查看完整的项目代码\n","slug":"automake学习笔记-helloworld","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2unt002xw3fyslozod29"},{"title":"ToolBar 学习笔记","date":"2016-01-25T06:56:42.000Z","_content":"\n虽然android studio在新建项目的时候就可以创建一个默认带有ToolBar的MainActivity，但是抱着学习学全套的精神，我们就从一个没有Activity的空项目入手，一步一步把ToolBar学透。\n\n## **一、创建基础ToolBar**\n\n创建完一个不带Activity的空项目之后的第一步就是创建自己的Activity了，注意这个Activity必须继承AppCompatActivity（ActionBarActivity已经被废弃了）。\n\n```java\n    public class MainActivity extends AppCompatActivity{\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.main_activity);\n        }\n    }\n```\n\n如果不能import android.support.v7.app.AppCompatActivity;的话就在build.gradle（Module：App）的dependencies里面添加\n\n    compile 'com.android.support:appcompat-v7:23.1.1'\n\n这个R.layout.main_activity也是要自己创建的，我这里创建了一个只有一个TextView的LinearLayout\n\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Hello World\"/>\n    </LinearLayout>\n```\n\n当然，不要忘了在manifests里面注册MainActivity\n```xml\n\t<activity android:name=\".MainActivity\"\n            android:label=\"@string/app_name\"\n            android:theme=\"@style/AppTheme\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\"/>\n                <category android:name=\"android.intent.category.LAUNCHER\"/>\n            </intent-filter>\n\t</activity>\n```\n然后运行程序就能就是下面这个样子：\n{% img /ToolBar-学习笔记/1.jpg %}\n\n## **二、自定义ToolBar样式**\n\n因为用上面的方法创建的ToolBar是Activity自带的，在需要自定义样式的时候不够灵活，所以我们把它去掉，换成我们自己创建的ToolBar。\n\n可以在@style/AppTheme添加如下item：\n\n```xml\n\t<!-- 去掉Activity自带的ToolBar -->\n\t<item name=\"windowNoTitle\">true</item>\n```\n\n这个时候再运行项目，就会发现ToolBar已经不见了。然后我们自己在R.layout.main_activity里面自己声明一个ToolBar:\n\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <android.support.v7.widget.Toolbar\n            android:id=\"@+id/toolbar\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"?attr/actionBarSize\"\n            android:theme=\"@style/ToolBarTheme\"/>\n\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Hello World\"/>\n\n    </LinearLayout>\n```\n\nToolBar的Theme分离出来放在@style/Theme,可以在这里自定义ToolBar的样式:\n```xml\n \t<style name=\"ToolBarTheme\" parent=\"Theme.AppCompat\">\n        <!-- 设置ToolBar底色 -->\n        <item name=\"android:background\">#3F51B5</item>\n        <!-- 设置字体颜色 -->\n        <item name=\"android:textColorPrimary\">#FFFFFF</item>\n    </style>\n```\n\n最后在MainActivity里调用setSupportActionBar，顺便设置调用ToolBar的方法设置一些属性。注意这里的ToolBar是导的android.support.v7.widget.Toolbar的包：\n\n```java\n    public class MainActivity extends AppCompatActivity{\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.main_activity);\n\n            Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n\n            toolbar.setTitle(\"title\"); //setTile方法必须在setSupportActionBar之前调用\n            toolbar.setSubtitle(\"subtitle\");\n            toolbar.setLogo(R.mipmap.ic_launcher);\n\n            setSupportActionBar(toolbar);\n\n            //给Navigate按钮加一个默认的返回箭头\n            //也可以用toolbar.setNavigationIcon()直接给Navigate设置icon\n        \tgetSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        }\n    }\n```\n\n运行起来之后长这个样子:\n{% img /ToolBar-学习笔记/2.jpg %}\n\n## **三、添加菜单按钮**\n\n首先创建一个menu/main.xml:\n\n```xml\n    <menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n        <item\n            android:id=\"@+id/btn_ico\"\n            android:title=\"btn_ico\"\n            android:icon=\"@mipmap/ic_launcher\"\n            app:showAsAction=\"ifRoom\" />\n        <item\n            android:id=\"@+id/btn_search\"\n            android:title=\"btn_search\"\n            app:actionViewClass=\"android.support.v7.widget.SearchView\"\n            app:showAsAction=\"ifRoom\" />\n        <item\n            android:id=\"@+id/btn_1\"\n            android:title=\"btn_1\"\n            app:showAsAction=\"never\" />\n        <item\n            android:id=\"@+id/btn_2\"\n            android:title=\"btn_2\"\n            app:showAsAction=\"never\"/>\n    </menu>\n```\n\n这里的app:showAsAction就是按钮出现的位置，它可以填入以下的值:\n1. always：这个值会使菜单项一直显示在ToolBar上。\n2. ifRoom：如果有足够的空间，这个值会使菜单项显示在ToolBar上。\n3. never：这个值使菜单项永远都不出现在ToolBar上。\n4. withText：这个值使菜单项和它的图标，菜单文本一起显示。 \n\n\n然后在MainActivity覆盖onCreateOptionsMenu方法：\n```java\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.main, menu);\n        return true;\n    }\n```\n\n运行程序之后长这个样子：\n{% img /ToolBar-学习笔记/3.jpg %}\n\n## **四、监听菜单按钮消息**\n\n监听这些菜单按钮的消息有两种方法\n1.覆盖Activity的onOptionsItemSelected方法\n\n```java\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Toast.makeText(this, item.getTitle(), Toast.LENGTH_SHORT).show();\n        return true;\n    }\n```\n\n2.调用ToolBar的setOnMenuItemClickListener方法\n\n```java\n    //setOnMenuItemClickListener方法必须在setSupportActionBar之后调用才有效\n    toolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() {\n        @Override\n        public boolean onMenuItemClick(MenuItem item) {\n            Toast.makeText(MainActivity.this, item.getTitle(), Toast.LENGTH_SHORT).show();\n            return false;\n        }\n    });\n```\n\n这个时候Navigation按钮的消息也是在上面两个回调方法中处理的，当然也能直接调用ToolBar的setNavigationOnClickListener方法设置，这样只有在该listener方法里面才会收到Navigation按钮的消息：\n```java\n    //setNavigationOnClickListener方法必须在setSupportActionBar之后调用才有效\n    toolbar.setNavigationOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            finish();\n        }\n    });\n```\n\n而ToolBar上的搜索按钮可以这样设置它的回调:\n```java\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.main, menu);\n        MenuItem item = menu.findItem(R.id.btn_search);\n        SearchView searcher = (SearchView) item.getActionView();\n        searcher.setOnQueryTextListener(new SearchView.OnQueryTextListener() {\n            @Override\n            public boolean onQueryTextSubmit(String query) {\n                Toast.makeText(MainActivity.this, query, Toast.LENGTH_SHORT).show();\n                return false;\n            }\n\n            @Override\n            public boolean onQueryTextChange(String newText) {\n                return false;\n            }\n        });\n        return true;\n    }\n```\n\n## **五、设置弹出菜单的样式**\n\n弹出菜单的样式默认是和ToolBar的样式一样的:\n{% img /ToolBar-学习笔记/4.jpg %}\n\n但也可以通过下面的方法自定义\n\n1.新建样式PopupTheme\n\n```xml\n\t<style name=\"PopupTheme\" parent=\"Theme.AppCompat\">\n        <item name=\"android:background\">#FFFFFF</item>\n        <item name=\"android:textColorPrimary\">#000000</item>\n    </style>\n```\n\n2.设置ToolBar的PopupTheme,注意这里的前缀是app:\n```xml\n\t<android.support.v7.widget.Toolbar\n        android:id=\"@+id/toolbar\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"?attr/actionBarSize\"\n        android:theme=\"@style/ToolBarTheme\"\n        app:popupTheme=\"@style/PopupTheme\"/>\n```\n\n效果如下：\n{% img /ToolBar-学习笔记/5.jpg %}\n","source":"_posts/ToolBar-学习笔记.md","raw":"title: ToolBar 学习笔记\ndate: 2016-01-25 14:56:42\ntags:\n    - 技术相关\n    - Android\n---\n\n虽然android studio在新建项目的时候就可以创建一个默认带有ToolBar的MainActivity，但是抱着学习学全套的精神，我们就从一个没有Activity的空项目入手，一步一步把ToolBar学透。\n\n## **一、创建基础ToolBar**\n\n创建完一个不带Activity的空项目之后的第一步就是创建自己的Activity了，注意这个Activity必须继承AppCompatActivity（ActionBarActivity已经被废弃了）。\n\n```java\n    public class MainActivity extends AppCompatActivity{\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.main_activity);\n        }\n    }\n```\n\n如果不能import android.support.v7.app.AppCompatActivity;的话就在build.gradle（Module：App）的dependencies里面添加\n\n    compile 'com.android.support:appcompat-v7:23.1.1'\n\n这个R.layout.main_activity也是要自己创建的，我这里创建了一个只有一个TextView的LinearLayout\n\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Hello World\"/>\n    </LinearLayout>\n```\n\n当然，不要忘了在manifests里面注册MainActivity\n```xml\n\t<activity android:name=\".MainActivity\"\n            android:label=\"@string/app_name\"\n            android:theme=\"@style/AppTheme\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\"/>\n                <category android:name=\"android.intent.category.LAUNCHER\"/>\n            </intent-filter>\n\t</activity>\n```\n然后运行程序就能就是下面这个样子：\n{% img /ToolBar-学习笔记/1.jpg %}\n\n## **二、自定义ToolBar样式**\n\n因为用上面的方法创建的ToolBar是Activity自带的，在需要自定义样式的时候不够灵活，所以我们把它去掉，换成我们自己创建的ToolBar。\n\n可以在@style/AppTheme添加如下item：\n\n```xml\n\t<!-- 去掉Activity自带的ToolBar -->\n\t<item name=\"windowNoTitle\">true</item>\n```\n\n这个时候再运行项目，就会发现ToolBar已经不见了。然后我们自己在R.layout.main_activity里面自己声明一个ToolBar:\n\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <android.support.v7.widget.Toolbar\n            android:id=\"@+id/toolbar\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"?attr/actionBarSize\"\n            android:theme=\"@style/ToolBarTheme\"/>\n\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Hello World\"/>\n\n    </LinearLayout>\n```\n\nToolBar的Theme分离出来放在@style/Theme,可以在这里自定义ToolBar的样式:\n```xml\n \t<style name=\"ToolBarTheme\" parent=\"Theme.AppCompat\">\n        <!-- 设置ToolBar底色 -->\n        <item name=\"android:background\">#3F51B5</item>\n        <!-- 设置字体颜色 -->\n        <item name=\"android:textColorPrimary\">#FFFFFF</item>\n    </style>\n```\n\n最后在MainActivity里调用setSupportActionBar，顺便设置调用ToolBar的方法设置一些属性。注意这里的ToolBar是导的android.support.v7.widget.Toolbar的包：\n\n```java\n    public class MainActivity extends AppCompatActivity{\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.main_activity);\n\n            Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n\n            toolbar.setTitle(\"title\"); //setTile方法必须在setSupportActionBar之前调用\n            toolbar.setSubtitle(\"subtitle\");\n            toolbar.setLogo(R.mipmap.ic_launcher);\n\n            setSupportActionBar(toolbar);\n\n            //给Navigate按钮加一个默认的返回箭头\n            //也可以用toolbar.setNavigationIcon()直接给Navigate设置icon\n        \tgetSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        }\n    }\n```\n\n运行起来之后长这个样子:\n{% img /ToolBar-学习笔记/2.jpg %}\n\n## **三、添加菜单按钮**\n\n首先创建一个menu/main.xml:\n\n```xml\n    <menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n        <item\n            android:id=\"@+id/btn_ico\"\n            android:title=\"btn_ico\"\n            android:icon=\"@mipmap/ic_launcher\"\n            app:showAsAction=\"ifRoom\" />\n        <item\n            android:id=\"@+id/btn_search\"\n            android:title=\"btn_search\"\n            app:actionViewClass=\"android.support.v7.widget.SearchView\"\n            app:showAsAction=\"ifRoom\" />\n        <item\n            android:id=\"@+id/btn_1\"\n            android:title=\"btn_1\"\n            app:showAsAction=\"never\" />\n        <item\n            android:id=\"@+id/btn_2\"\n            android:title=\"btn_2\"\n            app:showAsAction=\"never\"/>\n    </menu>\n```\n\n这里的app:showAsAction就是按钮出现的位置，它可以填入以下的值:\n1. always：这个值会使菜单项一直显示在ToolBar上。\n2. ifRoom：如果有足够的空间，这个值会使菜单项显示在ToolBar上。\n3. never：这个值使菜单项永远都不出现在ToolBar上。\n4. withText：这个值使菜单项和它的图标，菜单文本一起显示。 \n\n\n然后在MainActivity覆盖onCreateOptionsMenu方法：\n```java\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.main, menu);\n        return true;\n    }\n```\n\n运行程序之后长这个样子：\n{% img /ToolBar-学习笔记/3.jpg %}\n\n## **四、监听菜单按钮消息**\n\n监听这些菜单按钮的消息有两种方法\n1.覆盖Activity的onOptionsItemSelected方法\n\n```java\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Toast.makeText(this, item.getTitle(), Toast.LENGTH_SHORT).show();\n        return true;\n    }\n```\n\n2.调用ToolBar的setOnMenuItemClickListener方法\n\n```java\n    //setOnMenuItemClickListener方法必须在setSupportActionBar之后调用才有效\n    toolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() {\n        @Override\n        public boolean onMenuItemClick(MenuItem item) {\n            Toast.makeText(MainActivity.this, item.getTitle(), Toast.LENGTH_SHORT).show();\n            return false;\n        }\n    });\n```\n\n这个时候Navigation按钮的消息也是在上面两个回调方法中处理的，当然也能直接调用ToolBar的setNavigationOnClickListener方法设置，这样只有在该listener方法里面才会收到Navigation按钮的消息：\n```java\n    //setNavigationOnClickListener方法必须在setSupportActionBar之后调用才有效\n    toolbar.setNavigationOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            finish();\n        }\n    });\n```\n\n而ToolBar上的搜索按钮可以这样设置它的回调:\n```java\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.main, menu);\n        MenuItem item = menu.findItem(R.id.btn_search);\n        SearchView searcher = (SearchView) item.getActionView();\n        searcher.setOnQueryTextListener(new SearchView.OnQueryTextListener() {\n            @Override\n            public boolean onQueryTextSubmit(String query) {\n                Toast.makeText(MainActivity.this, query, Toast.LENGTH_SHORT).show();\n                return false;\n            }\n\n            @Override\n            public boolean onQueryTextChange(String newText) {\n                return false;\n            }\n        });\n        return true;\n    }\n```\n\n## **五、设置弹出菜单的样式**\n\n弹出菜单的样式默认是和ToolBar的样式一样的:\n{% img /ToolBar-学习笔记/4.jpg %}\n\n但也可以通过下面的方法自定义\n\n1.新建样式PopupTheme\n\n```xml\n\t<style name=\"PopupTheme\" parent=\"Theme.AppCompat\">\n        <item name=\"android:background\">#FFFFFF</item>\n        <item name=\"android:textColorPrimary\">#000000</item>\n    </style>\n```\n\n2.设置ToolBar的PopupTheme,注意这里的前缀是app:\n```xml\n\t<android.support.v7.widget.Toolbar\n        android:id=\"@+id/toolbar\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"?attr/actionBarSize\"\n        android:theme=\"@style/ToolBarTheme\"\n        app:popupTheme=\"@style/PopupTheme\"/>\n```\n\n效果如下：\n{% img /ToolBar-学习笔记/5.jpg %}\n","slug":"ToolBar-学习笔记","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2unw0030w3fytq2ahq7n"},{"title":"Retrofit 学习笔记","date":"2016-02-22T08:19:56.000Z","_content":"\n工欲善其事必先利其器，使用一些强大方便的器，可以大大的提高开发的效率，我认为 Retrofit 和 RxJava 就是这样的利器。\n\nRetrofit 是一个开源的 java http 请求库，目前已经更新到 2.0.0-beta4，官方的介绍是：\n\n> Type-safe HTTP client for Android and Java by Square, Inc.\n\n我在学习它的过程中遇到了不少问题，于是写了这篇东西把遇到的问题和解决方法都记录一下。\n\n## __android studio 导入 Retrofit__\n\n首先我使用的是 android studio，一开始搜索怎样使用第三方库的时候看到了不少的文章，有介绍导入 jar 包的，有介绍源码库的，但使用方法和我接下来介绍的都显得复杂很多。\n\n比如现在我们要使用 Retrofit ，先登录 [http://search.maven.org/](http://search.maven.org/)，搜索 Retrofit 我们可以看到搜出了不少东西，我们直接用最新的版本 2.0.0-beta4，可以看到它有两个版本，点进去看看：\n\n{% img /Retrofit-学习笔记/1.jpg %}\n\n原来一个是beta3，一个是beta4：\n\n{% img /Retrofit-学习笔记/2.jpg %}\n\n然后我们打开 android studio 项目的 build.gradle(Module: app)， 在它的 dependencies 里面加上  retrofit 的引用:\n\n```\n    dependencies {\n        compile fileTree(dir: 'libs', include: ['*.jar'])\n        testCompile 'junit:junit:4.12'\n        compile 'com.android.support:appcompat-v7:23.1.1'\n        compile 'com.squareup.retrofit2:retrofit:2.0.0-beta4'\n    }\n```\n\n要使用 [http://search.maven.org/](http://search.maven.org/)，搜索到的第三方库只需要在 dependencies 里面加上\n\n> compile 'GroupId:ArtifactId:Version'\n\n对应 retrofit 就是这句：\n\n> compile 'com.squareup.retrofit2:retrofit:2.0.0-beta4'\n\n再点击 android studio 弹出的 Sync Now，android studio 就会帮你自动下载和配置第三方库，而你就能直接使用了。\n\n{% img /Retrofit-学习笔记/3.jpg %}\n\n## __使用 Retrofit 的 Call 类获取 github 用户的信息__\n\n官方文档一开始就展示了一个简单的demo [http://square.github.io/retrofit/](http://square.github.io/retrofit/)\n\n可惜都是代码碎片，你按照它写好代码之后就会发现......报异常了。\n\n{% img /Retrofit-学习笔记/4.jpg %}\n\n{% img /Retrofit-学习笔记/5.jpg %}\n\n我先把讲讲我写的demo，最后再告诉你们官方文档到底哪里出问题了。\n\n首先定义一个 User 类用于保存获取到的用户信息：\n\n```java\n    public class User {\n        private String login;\n        private long id;\n        private String name;\n\n        @Override\n        public String toString() {\n            return \"login:\" + login + \", \"\n                    + \"id:\" + id + \", \"\n                    + \"name:\" + name;\n        }\n\n        public String getLogin() {\n            return login;\n        }\n\n        public void setLogin(String login) {\n            this.login = login;\n        }\n\n        public long getId() {\n            return id;\n        }\n\n        public void setId(long id) {\n            this.id = id;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n    }\n```\n\n接着定义一个接口用于告诉 Retrofit 怎样去获取数据，如下代码就表明使用 get 方法获取 users 路径下的 user 资源，使用的最终使用的时候，传入的 user 参数会替换 users/{user} 的 {user} 字段。\n\n不过我还真不知道它这里到底是怎么实现的，看来 java 基础还真要去补一补才行了。\n\n```java\n     public interface GitHubService {\n            @GET(\"users/{user}\")\n            Call<User> getUserInfoByCall(@Path(\"user\") String user);\n        }\n```\n\n之后就可以创建一个 GitHubService 实例了（我总觉得有点 java 黑魔法的感觉）：\n\n```java\n     GitHubService service = new Retrofit.Builder()\n                    .baseUrl(\"https://api.github.com\")\n                    .addConverterFactory(GsonConverterFactory.create())\n                    .build()\n                    .create(GitHubService.class);\n```\n\n然后调用 service 的 getUserInfoByCall 方法就能获取到一个 Call 对象了。像如下的代码，就能获取到一个用于访问 [https://api.github.com/users/bluesky466](https://api.github.com/users/bluesky466) 的 Call 对象：\n\n```java\n\tfinal Call<User> call = service.getUserInfoByCall(\"bluesky466\");\n```\n\n最后就能用 call 的 execute 方法访问服务器获取用户数据了。因为 execute 是同步的，而安卓不允许在 ui 线程访问网络，所以我们需要用一个子线程去访问。\n\n```java\n    new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        Response<User> response = call.execute();\n                        User user = response.body();\n                        Log.d(\"result\", user.toString());\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }).start();\n```\n\n结果如下：\n\n{% img /Retrofit-学习笔记/6.jpg %}\n\n当然，Retrofit 也提供了异步访问的方法：\n\n```java\n     call.enqueue(new Callback<User>() {\n                @Override\n                public void onResponse(Call<User> call, Response<User> response) {\n                    User user = response.body();\n                \tLog.d(\"result\", user.toString());\n                }\n\n                @Override\n                public void onFailure(Call<User> call, Throwable t) {\n\n                }\n            });\n```\n\nRetrofit 用获取到的数据生成了一个User对象。这是什么黑魔法？\n\n还记得我一开始说的按照官方文档的代码会报异常吗？\n\n官方文档的代码：\n\n```java\n    Retrofit retrofit = new Retrofit.Builder()\n        .baseUrl(\"https://api.github.com\")\n        .build();\n\n    GitHubService service = retrofit.create(GitHubService.class);\n```\n\n我的代码：\n\n```java\n    GitHubService service = new Retrofit.Builder()\n                        .baseUrl(\"https://api.github.com\")\n                        .addConverterFactory(GsonConverterFactory.create())\n                        .build()\n                        .create(GitHubService.class);\n```\n\n差别就在在这里：\n\n```\n\t.addConverterFactory(GsonConverterFactory.create())\n```\n\n我这里指定了一个 Gson 转换工厂，因为 [https://api.github.com](https://api.github.com) 使用josn 格式返回数据，所以我们可以使用 Gson 去解析它，然后生成一个 User 对象。\n\n不过就算你按我这样写代码又会发现找不到 GsonConverterFactory 的包......\n\n{% img /Retrofit-学习笔记/7.jpg %}\n\n原因在于 GsonConverterFactory 使用来转换json的，你也可以指定其他的 Factory 去转换 xml 之类的格式。而这些 Factory 并不包含在 Retrofit 库里面，需要用户自己去导入。\n\n{% img /Retrofit-学习笔记/8.jpg %}\n\n在 dependencies 中加入：\n\n```\n\tcompile 'com.squareup.retrofit2:converter-gson:2.0.0-beta4'\n```\n\n类似的库有下面这些：\n- __Gson__: com.squareup.retrofit2:converter-gson\n- __Jackson__: com.squareup.retrofit2:converter-jackson\n- __Moshi__: com.squareup.retrofit2:converter-moshi\n- __Protobuf__: com.squareup.retrofit2:converter-protobuf\n- __Wire__: com.squareup.retrofit2:converter-wire\n- __Simple__ XML: com.squareup.retrofit2:converter-simplexml\n- __Scalars__ (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars\n\n\n## __使用 Retrofit 配合 RxJava 获取 github 用户的信息__\n\nRxJava 在 GitHub 主页上的自我介绍是 \"a library for composing asynchronous and event-based programs using observable sequences for the Java VM\"（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。\n\n它可以用来替换 AsyncTask 之类的东西。\n\n关于 RxJava 有一篇很好的博客 -- [给 Android 开发者的 RxJava 详解](http://gank.io/post/560e15be2dca930e00da1083)。这里基本上把 RxJava 讲的很透彻了。我这里就不多说，只是讲一讲怎样在 Retrofit 中使用 RxJava。\n\n在 Retrofit 中使用 RxJava 首先需要导入 adapter-rxjava 库，而且因为是在安卓上使用，所以需要导入 RxJava 的 Android 平台的扩展 rxandroid 库：\n\n```\n\tcompile 'com.squareup.retrofit2:adapter-rxjava:2.0.0-beta4\n    compile 'io.reactivex:rxandroid:1.1.0'\n```\n\n添加 GitHubService 接口的 RxJava 获取方法：\n```java\n    public interface GitHubService {\n            @GET(\"users/{user}\")\n            Call<User> getUserInfoByCall(@Path(\"user\") String user);\n\n            @GET(\"users/{user}\")\n            Observable<User> getUserInfoByObservable(@Path(\"user\") String user);\n        }\n```\n\n然后创建 GitHubService 的时候需要指定 RxJava的适配工厂：\n\n```java\n     GitHubService service = new Retrofit.Builder()\n                    .baseUrl(\"https://api.github.com\")\n                    .addConverterFactory(GsonConverterFactory.create())//指定RxJava适配工厂\n                    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())\n                    .build()\n                    .create(GitHubService.class);\n```\n\n然后就是指定 subscribe 去输出结果了：\n\n```java\n    service.getUserInfoByObservable(\"bluesky466\")\n                    .subscribeOn(Schedulers.newThread())\n                    .observeOn(AndroidSchedulers.mainThread())\n                    .subscribe(new Subscriber<User>() {\n                        @Override\n                        public void onNext(User user) {\n                            if (user != null) {\n                                Log.d(\"result\", user.toString());\n                            }\n                        }\n\n                        @Override\n                        public void onCompleted() {\n                        }\n\n                        @Override\n                        public void onError(Throwable e) {\n                        }\n                    });\n```\n\n## __一个小 Demo__\n\n我写了一个 demo 用来展示 Retrofit 的用法，完整源码如下：\n\nMainActivity：\n\n```java\n    public class MainActivity extends AppCompatActivity {\n        private GitHubService mService;\n        private EditText mUserName;\n        private TextView mResult;\n\n        public interface GitHubService {\n            @GET(\"users/{user}\")\n            Call<User> getUserInfoByCall(@Path(\"user\") String user);\n\n            @GET(\"users/{user}\")\n            Observable<User> getUserInfoByObservable(@Path(\"user\") String user);\n        }\n\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.activity_main);\n\n            mUserName = (EditText) findViewById(R.id.username);\n            mResult = (TextView) findViewById(R.id.result);\n\n            Button btnCall = (Button) findViewById(R.id.btnCall);\n            btnCall.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    queryByCall(mUserName.getText().toString());\n                }\n            });\n\n            Button btnObservable = (Button) findViewById(R.id.btnObservable);\n            btnObservable.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    queryByObservable(mUserName.getText().toString());\n                }\n            });\n\n            mService = new Retrofit.Builder()\n                    .baseUrl(\"https://api.github.com\")\n                    .addConverterFactory(GsonConverterFactory.create())\n                    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())\n                    .build()\n                    .create(GitHubService.class);\n        }\n\n        private void queryByCall(final String username) {\n            mService.getUserInfoByCall(username).enqueue(new Callback<User>() {\n                @Override\n                public void onResponse(Call<User> call, Response<User> response) {\n                    if (response.body() != null) {\n                        mResult.setText(\"[ByCall] \" + response.body().toString());\n                    } else {\n                        mResult.setText(\"[ByCall] Not Found\");\n                    }\n                }\n\n                @Override\n                public void onFailure(Call<User> call, Throwable t) {\n                    mResult.setText(\"[ByCall] Not Found\");\n                }\n            });\n        }\n\n        private void queryByObservable(final String username) {\n            mService.getUserInfoByObservable(username)\n                    .subscribeOn(Schedulers.newThread())\n                    .observeOn(AndroidSchedulers.mainThread())\n                    .subscribe(new Subscriber<User>() {\n                        @Override\n                        public void onCompleted() {\n                        }\n\n                        @Override\n                        public void onError(Throwable e) {\n                            mResult.setText(\"[ByObservable] Not Found\");\n                        }\n\n                        @Override\n                        public void onNext(User user) {\n                            if (user != null) {\n                                mResult.setText(\"[ByObservable] \" + user.toString());\n                            }\n                        }\n                    });\n        }\n    }\n```\n\nactivity\\_main.xml:\n\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        xmlns:tools=\"http://schemas.android.com/tools\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <LinearLayout\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:orientation=\"horizontal\">\n\n            <EditText\n                android:id=\"@+id/username\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_weight=\"1\"\n                android:hint=\"user name\" />\n\n            <Button\n                android:id=\"@+id/btnCall\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"Call\" />\n\n            <Button\n                android:id=\"@+id/btnObservable\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"Observable\" />\n        </LinearLayout>\n\n        <TextView\n            android:id=\"@+id/result\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"\" />\n    </LinearLayout>\n```\n\nUser:\n\n```java\n    public class User {\n        private String login;\n        private long id;\n        private String name;\n\n        @Override\n        public String toString() {\n            return \"login:\" + login + \", \"\n                    + \"id:\" + id + \", \"\n                    + \"name:\" + name;\n        }\n\n        public String getLogin() {\n            return login;\n        }\n\n        public void setLogin(String login) {\n            this.login = login;\n        }\n\n        public long getId() {\n            return id;\n        }\n\n        public void setId(long id) {\n            this.id = id;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n    }\n\n```\n\ndependencies:\n\n```\n\tdependencies {\n        compile fileTree(dir: 'libs', include: ['*.jar'])\n        testCompile 'junit:junit:4.12'\n        compile 'com.android.support:appcompat-v7:23.1.1'\n        compile 'com.squareup.retrofit2:retrofit:2.0.0-beta4'\n        compile 'com.squareup.retrofit2:converter-gson:2.0.0-beta4'\n        compile 'com.squareup.retrofit2:adapter-rxjava:2.0.0-beta4'\n        compile 'io.reactivex:rxandroid:1.1.0'\n    }\n```\n","source":"_posts/Retrofit-学习笔记.md","raw":"title: Retrofit 学习笔记\ndate: 2016-02-22 16:19:56\ntags:\n\t- 技术相关\n\t- Android\n---\n\n工欲善其事必先利其器，使用一些强大方便的器，可以大大的提高开发的效率，我认为 Retrofit 和 RxJava 就是这样的利器。\n\nRetrofit 是一个开源的 java http 请求库，目前已经更新到 2.0.0-beta4，官方的介绍是：\n\n> Type-safe HTTP client for Android and Java by Square, Inc.\n\n我在学习它的过程中遇到了不少问题，于是写了这篇东西把遇到的问题和解决方法都记录一下。\n\n## __android studio 导入 Retrofit__\n\n首先我使用的是 android studio，一开始搜索怎样使用第三方库的时候看到了不少的文章，有介绍导入 jar 包的，有介绍源码库的，但使用方法和我接下来介绍的都显得复杂很多。\n\n比如现在我们要使用 Retrofit ，先登录 [http://search.maven.org/](http://search.maven.org/)，搜索 Retrofit 我们可以看到搜出了不少东西，我们直接用最新的版本 2.0.0-beta4，可以看到它有两个版本，点进去看看：\n\n{% img /Retrofit-学习笔记/1.jpg %}\n\n原来一个是beta3，一个是beta4：\n\n{% img /Retrofit-学习笔记/2.jpg %}\n\n然后我们打开 android studio 项目的 build.gradle(Module: app)， 在它的 dependencies 里面加上  retrofit 的引用:\n\n```\n    dependencies {\n        compile fileTree(dir: 'libs', include: ['*.jar'])\n        testCompile 'junit:junit:4.12'\n        compile 'com.android.support:appcompat-v7:23.1.1'\n        compile 'com.squareup.retrofit2:retrofit:2.0.0-beta4'\n    }\n```\n\n要使用 [http://search.maven.org/](http://search.maven.org/)，搜索到的第三方库只需要在 dependencies 里面加上\n\n> compile 'GroupId:ArtifactId:Version'\n\n对应 retrofit 就是这句：\n\n> compile 'com.squareup.retrofit2:retrofit:2.0.0-beta4'\n\n再点击 android studio 弹出的 Sync Now，android studio 就会帮你自动下载和配置第三方库，而你就能直接使用了。\n\n{% img /Retrofit-学习笔记/3.jpg %}\n\n## __使用 Retrofit 的 Call 类获取 github 用户的信息__\n\n官方文档一开始就展示了一个简单的demo [http://square.github.io/retrofit/](http://square.github.io/retrofit/)\n\n可惜都是代码碎片，你按照它写好代码之后就会发现......报异常了。\n\n{% img /Retrofit-学习笔记/4.jpg %}\n\n{% img /Retrofit-学习笔记/5.jpg %}\n\n我先把讲讲我写的demo，最后再告诉你们官方文档到底哪里出问题了。\n\n首先定义一个 User 类用于保存获取到的用户信息：\n\n```java\n    public class User {\n        private String login;\n        private long id;\n        private String name;\n\n        @Override\n        public String toString() {\n            return \"login:\" + login + \", \"\n                    + \"id:\" + id + \", \"\n                    + \"name:\" + name;\n        }\n\n        public String getLogin() {\n            return login;\n        }\n\n        public void setLogin(String login) {\n            this.login = login;\n        }\n\n        public long getId() {\n            return id;\n        }\n\n        public void setId(long id) {\n            this.id = id;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n    }\n```\n\n接着定义一个接口用于告诉 Retrofit 怎样去获取数据，如下代码就表明使用 get 方法获取 users 路径下的 user 资源，使用的最终使用的时候，传入的 user 参数会替换 users/{user} 的 {user} 字段。\n\n不过我还真不知道它这里到底是怎么实现的，看来 java 基础还真要去补一补才行了。\n\n```java\n     public interface GitHubService {\n            @GET(\"users/{user}\")\n            Call<User> getUserInfoByCall(@Path(\"user\") String user);\n        }\n```\n\n之后就可以创建一个 GitHubService 实例了（我总觉得有点 java 黑魔法的感觉）：\n\n```java\n     GitHubService service = new Retrofit.Builder()\n                    .baseUrl(\"https://api.github.com\")\n                    .addConverterFactory(GsonConverterFactory.create())\n                    .build()\n                    .create(GitHubService.class);\n```\n\n然后调用 service 的 getUserInfoByCall 方法就能获取到一个 Call 对象了。像如下的代码，就能获取到一个用于访问 [https://api.github.com/users/bluesky466](https://api.github.com/users/bluesky466) 的 Call 对象：\n\n```java\n\tfinal Call<User> call = service.getUserInfoByCall(\"bluesky466\");\n```\n\n最后就能用 call 的 execute 方法访问服务器获取用户数据了。因为 execute 是同步的，而安卓不允许在 ui 线程访问网络，所以我们需要用一个子线程去访问。\n\n```java\n    new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        Response<User> response = call.execute();\n                        User user = response.body();\n                        Log.d(\"result\", user.toString());\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }).start();\n```\n\n结果如下：\n\n{% img /Retrofit-学习笔记/6.jpg %}\n\n当然，Retrofit 也提供了异步访问的方法：\n\n```java\n     call.enqueue(new Callback<User>() {\n                @Override\n                public void onResponse(Call<User> call, Response<User> response) {\n                    User user = response.body();\n                \tLog.d(\"result\", user.toString());\n                }\n\n                @Override\n                public void onFailure(Call<User> call, Throwable t) {\n\n                }\n            });\n```\n\nRetrofit 用获取到的数据生成了一个User对象。这是什么黑魔法？\n\n还记得我一开始说的按照官方文档的代码会报异常吗？\n\n官方文档的代码：\n\n```java\n    Retrofit retrofit = new Retrofit.Builder()\n        .baseUrl(\"https://api.github.com\")\n        .build();\n\n    GitHubService service = retrofit.create(GitHubService.class);\n```\n\n我的代码：\n\n```java\n    GitHubService service = new Retrofit.Builder()\n                        .baseUrl(\"https://api.github.com\")\n                        .addConverterFactory(GsonConverterFactory.create())\n                        .build()\n                        .create(GitHubService.class);\n```\n\n差别就在在这里：\n\n```\n\t.addConverterFactory(GsonConverterFactory.create())\n```\n\n我这里指定了一个 Gson 转换工厂，因为 [https://api.github.com](https://api.github.com) 使用josn 格式返回数据，所以我们可以使用 Gson 去解析它，然后生成一个 User 对象。\n\n不过就算你按我这样写代码又会发现找不到 GsonConverterFactory 的包......\n\n{% img /Retrofit-学习笔记/7.jpg %}\n\n原因在于 GsonConverterFactory 使用来转换json的，你也可以指定其他的 Factory 去转换 xml 之类的格式。而这些 Factory 并不包含在 Retrofit 库里面，需要用户自己去导入。\n\n{% img /Retrofit-学习笔记/8.jpg %}\n\n在 dependencies 中加入：\n\n```\n\tcompile 'com.squareup.retrofit2:converter-gson:2.0.0-beta4'\n```\n\n类似的库有下面这些：\n- __Gson__: com.squareup.retrofit2:converter-gson\n- __Jackson__: com.squareup.retrofit2:converter-jackson\n- __Moshi__: com.squareup.retrofit2:converter-moshi\n- __Protobuf__: com.squareup.retrofit2:converter-protobuf\n- __Wire__: com.squareup.retrofit2:converter-wire\n- __Simple__ XML: com.squareup.retrofit2:converter-simplexml\n- __Scalars__ (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars\n\n\n## __使用 Retrofit 配合 RxJava 获取 github 用户的信息__\n\nRxJava 在 GitHub 主页上的自我介绍是 \"a library for composing asynchronous and event-based programs using observable sequences for the Java VM\"（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。\n\n它可以用来替换 AsyncTask 之类的东西。\n\n关于 RxJava 有一篇很好的博客 -- [给 Android 开发者的 RxJava 详解](http://gank.io/post/560e15be2dca930e00da1083)。这里基本上把 RxJava 讲的很透彻了。我这里就不多说，只是讲一讲怎样在 Retrofit 中使用 RxJava。\n\n在 Retrofit 中使用 RxJava 首先需要导入 adapter-rxjava 库，而且因为是在安卓上使用，所以需要导入 RxJava 的 Android 平台的扩展 rxandroid 库：\n\n```\n\tcompile 'com.squareup.retrofit2:adapter-rxjava:2.0.0-beta4\n    compile 'io.reactivex:rxandroid:1.1.0'\n```\n\n添加 GitHubService 接口的 RxJava 获取方法：\n```java\n    public interface GitHubService {\n            @GET(\"users/{user}\")\n            Call<User> getUserInfoByCall(@Path(\"user\") String user);\n\n            @GET(\"users/{user}\")\n            Observable<User> getUserInfoByObservable(@Path(\"user\") String user);\n        }\n```\n\n然后创建 GitHubService 的时候需要指定 RxJava的适配工厂：\n\n```java\n     GitHubService service = new Retrofit.Builder()\n                    .baseUrl(\"https://api.github.com\")\n                    .addConverterFactory(GsonConverterFactory.create())//指定RxJava适配工厂\n                    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())\n                    .build()\n                    .create(GitHubService.class);\n```\n\n然后就是指定 subscribe 去输出结果了：\n\n```java\n    service.getUserInfoByObservable(\"bluesky466\")\n                    .subscribeOn(Schedulers.newThread())\n                    .observeOn(AndroidSchedulers.mainThread())\n                    .subscribe(new Subscriber<User>() {\n                        @Override\n                        public void onNext(User user) {\n                            if (user != null) {\n                                Log.d(\"result\", user.toString());\n                            }\n                        }\n\n                        @Override\n                        public void onCompleted() {\n                        }\n\n                        @Override\n                        public void onError(Throwable e) {\n                        }\n                    });\n```\n\n## __一个小 Demo__\n\n我写了一个 demo 用来展示 Retrofit 的用法，完整源码如下：\n\nMainActivity：\n\n```java\n    public class MainActivity extends AppCompatActivity {\n        private GitHubService mService;\n        private EditText mUserName;\n        private TextView mResult;\n\n        public interface GitHubService {\n            @GET(\"users/{user}\")\n            Call<User> getUserInfoByCall(@Path(\"user\") String user);\n\n            @GET(\"users/{user}\")\n            Observable<User> getUserInfoByObservable(@Path(\"user\") String user);\n        }\n\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.activity_main);\n\n            mUserName = (EditText) findViewById(R.id.username);\n            mResult = (TextView) findViewById(R.id.result);\n\n            Button btnCall = (Button) findViewById(R.id.btnCall);\n            btnCall.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    queryByCall(mUserName.getText().toString());\n                }\n            });\n\n            Button btnObservable = (Button) findViewById(R.id.btnObservable);\n            btnObservable.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    queryByObservable(mUserName.getText().toString());\n                }\n            });\n\n            mService = new Retrofit.Builder()\n                    .baseUrl(\"https://api.github.com\")\n                    .addConverterFactory(GsonConverterFactory.create())\n                    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())\n                    .build()\n                    .create(GitHubService.class);\n        }\n\n        private void queryByCall(final String username) {\n            mService.getUserInfoByCall(username).enqueue(new Callback<User>() {\n                @Override\n                public void onResponse(Call<User> call, Response<User> response) {\n                    if (response.body() != null) {\n                        mResult.setText(\"[ByCall] \" + response.body().toString());\n                    } else {\n                        mResult.setText(\"[ByCall] Not Found\");\n                    }\n                }\n\n                @Override\n                public void onFailure(Call<User> call, Throwable t) {\n                    mResult.setText(\"[ByCall] Not Found\");\n                }\n            });\n        }\n\n        private void queryByObservable(final String username) {\n            mService.getUserInfoByObservable(username)\n                    .subscribeOn(Schedulers.newThread())\n                    .observeOn(AndroidSchedulers.mainThread())\n                    .subscribe(new Subscriber<User>() {\n                        @Override\n                        public void onCompleted() {\n                        }\n\n                        @Override\n                        public void onError(Throwable e) {\n                            mResult.setText(\"[ByObservable] Not Found\");\n                        }\n\n                        @Override\n                        public void onNext(User user) {\n                            if (user != null) {\n                                mResult.setText(\"[ByObservable] \" + user.toString());\n                            }\n                        }\n                    });\n        }\n    }\n```\n\nactivity\\_main.xml:\n\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        xmlns:tools=\"http://schemas.android.com/tools\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <LinearLayout\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:orientation=\"horizontal\">\n\n            <EditText\n                android:id=\"@+id/username\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_weight=\"1\"\n                android:hint=\"user name\" />\n\n            <Button\n                android:id=\"@+id/btnCall\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"Call\" />\n\n            <Button\n                android:id=\"@+id/btnObservable\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"Observable\" />\n        </LinearLayout>\n\n        <TextView\n            android:id=\"@+id/result\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"\" />\n    </LinearLayout>\n```\n\nUser:\n\n```java\n    public class User {\n        private String login;\n        private long id;\n        private String name;\n\n        @Override\n        public String toString() {\n            return \"login:\" + login + \", \"\n                    + \"id:\" + id + \", \"\n                    + \"name:\" + name;\n        }\n\n        public String getLogin() {\n            return login;\n        }\n\n        public void setLogin(String login) {\n            this.login = login;\n        }\n\n        public long getId() {\n            return id;\n        }\n\n        public void setId(long id) {\n            this.id = id;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n    }\n\n```\n\ndependencies:\n\n```\n\tdependencies {\n        compile fileTree(dir: 'libs', include: ['*.jar'])\n        testCompile 'junit:junit:4.12'\n        compile 'com.android.support:appcompat-v7:23.1.1'\n        compile 'com.squareup.retrofit2:retrofit:2.0.0-beta4'\n        compile 'com.squareup.retrofit2:converter-gson:2.0.0-beta4'\n        compile 'com.squareup.retrofit2:adapter-rxjava:2.0.0-beta4'\n        compile 'io.reactivex:rxandroid:1.1.0'\n    }\n```\n","slug":"Retrofit-学习笔记","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2unz0033w3fyvidxkwt1"},{"title":"OpenSL ES 学习笔记","date":"2018-09-01T12:24:42.000Z","_content":"\n一般来讲在安卓中常使用AudioRecord、MediaRecorder对音频进行采集,使用SoundPool、MediaPlayer、AudioTrack进行音频播放。\n\n但是这些接口都是java层的,而NDK其实也提供了一个叫做OpenSL的C语言引擎用于声音的处理。\n\nOpenSL入门难度比较大,而且网上也没有什么特别好的教程,我这里把自己了解到的一些知识记录下来,希望以后忘记的时候可以快速回忆起来,也希望对大家有用。\n\n这篇笔记的很多内容都参考了OpenSL的官方文档OpenSL\\_ES\\_Specification\\_1.0.1.pdf,它是全英文的,可以在NDK的安装目录下找到,大家可以大概浏览一下,具体路径为:\n\n> $NDK_ROOT/docs/Additional\\_library\\_docs/opensles\n\n为什么要学OpenSL呢?除了C/C++的性能优势(不过其实java的效率也不低)之外,最主要是因为最近入坑FFmpeg,如果使用java层的接口,还需要通过一层JNI,比较复杂,性能消耗也大。如果用OpenSL的话就能直接在C/C++里面把事情都处理了。\n\n# 基本概念\n\n## Object和Interface\n\n在OpenSL里面,Object和Interface是两个很重要的概念,基本上所有的操作都是通过它们两个去执行的。\n\nObject和Interface是包含关系,一个Object里面包含了多个Interface:\n\n{% img /OpenSLES学习笔记/1.png %}\n\n### Object\n\nObject是一个资源的抽象集合,可以通过它获取各种资源。\n\n例如我们可以通过Object的GetInterface方法获取Interface。\n\n所有的Object在OpenSL里面我们拿到的都是一个SLObjectItf:\n\n```\nstruct SLObjectItf_ {\n\tSLresult (*Realize) (SLObjectItf self,SLboolean async);\n\n\tSLresult (*Resume) (SLObjectItf self,SLboolean async);\n\n\tSLresult (*GetState) (SLObjectItf self,SLuint32 * pState);\n\n\tSLresult (*GetInterface) (SLObjectItf self, const SLInterfaceID iid, void * pInterface);\n\n\tSLresult (*RegisterCallback) (SLObjectItf self, slObjectCallback callback, void * pContext);\n\n\tvoid (*AbortAsyncOperation) (SLObjectItf self);\n\n\tvoid (*Destroy) (SLObjectItf self);\n\n\tSLresult (*SetPriority) (SLObjectItf self, SLint32 priority, SLboolean preemptable);\n\n\tSLresult (*GetPriority) (SLObjectItf self, SLint32 *pPriority, SLboolean *pPreemptable);\n\n\tSLresult (*SetLossOfControlInterfaces) (SLObjectItf self, SLint16 numInterfaces, SLInterfaceID * pInterfaceIDs, SLboolean enabled);\n};\n\ntypedef const struct SLObjectItf_ * const * SLObjectItf;\n```\n\n在创建出来之后必须先调用Realize方法做初始化。在不需要使用的时候调用Destroy方法释放资源。\n\n#### GetInterface\n\nGetInterface可以说是OpenSL里使用频率最高的方法,通过它我们可以获取Object里面的Interface。\n\n由于一个Object里面可能包含了多个Interface,所以GetInterface方法有个SLInterfaceID参数来指定到的需要获取Object里面的那个Interface。\n\n例如下面代码我们通过EngineObject去获取SL_IID_ENGINE这个id的Interface,而这个id对应的Interface就是SLEngineItf:\n\n```\n//create EngineObject\nSLObjectItf engineObject;\nslCreateEngine(&engineObject, 0, NULL, 0, NULL, NULL);\n(*engineObject)->Realize(engineObject, SL_BOOLEAN_FALSE);\n\n//get SLEngineItf\nSLEngineItf engineInterface;\n(*engineObject)->GetInterface(engineObject, SL_IID_ENGINE, &engineInterface);\n```\n\n\n## Interface\n\nInterface则是方法的集合,例如SLRecordItf里面包含了和录音相关的方法,SLPlayItf包含了和播放相关的方法。我们功能都是通过调用Interfaces的方法去实现的。\n\n#### SLEngineItf\n\nSLEngineItf是OpenSL里面最重要的一个Interface,我们可以通过它去创建各种Object,例如播放器、录音器、混音器的Object,然后在用这些Object去获取各种Interface去实现各种功能。\n\n\n```\nstruct SLEngineItf_ {\n\tSLresult (*CreateAudioPlayer) (SLEngineItf self, SLObjectItf * pPlayer, SLDataSource *pAudioSrc, SLDataSink *pAudioSnk, SLuint32 numInterfaces, const SLInterfaceID * pInterfaceIds, const SLboolean * pInterfaceRequired);\n\n\tSLresult (*CreateAudioRecorder) (SLEngineItf self, SLObjectItf * pRecorder, SLDataSource *pAudioSrc, SLDataSink *pAudioSnk, SLuint32 numInterfaces, const SLInterfaceID * pInterfaceIds, const SLboolean * pInterfaceRequired);\n\n\tSLresult (*CreateOutputMix) (SLEngineItf self, SLObjectItf * pMix, SLuint32 numInterfaces, const SLInterfaceID * pInterfaceIds, const SLboolean * pInterfaceRequired);\n\n\t...\n};\n```\n\n# 录音\n\nOpenSL的录音功能是通过AudioRecorder来实现的,而AudioRecorder是通过SLEngineItf.CreateAudioRecorder方法创建的:\n\n```\nSLresult (*CreateAudioRecorder) (\n        SLEngineItf self,\n        SLObjectItf * pRecorder,\n        SLDataSource * pAudioSrc,\n        SLDataSink * pAudioSnk,\n        SLuint32 numInterfaces,\n        const SLInterfaceID * pInterfaceIds,\n        const SLboolean * pInterfaceRequired\n    );\n```\n\n各个参数的意义如下:\n\n- SLEngineItf C语言不像c++,没有this指针,只能每次调用SLEngineItf的方法的时候手动传入\n- SLObjectItf 用于保存创建出来的AudioRecorderObject\n- SLDataSource 数据的来源\n- SLDataSink 数据的去处\n- numInterfaces 与下面的SLInterfaceID和SLboolean配合使用,用于标记SLInterfaceID数组和SLboolean的大小\n- SLInterfaceID 这里需要传入一个数组,指定创建的AudioRecorderObject会包含哪些Interface\n- SLboolean 这里也是一个数组,用来标记每个需要包含的Interface,如果AudioRecorderObject不支持,是不是需要直接创建AudioRecorderObject失败。\n\n最后的三个参数用于指定AudioRecorderObject需要包含哪些Interface,如果不包含,是不是要直接创建失败。如果成功的话我们就能使用AudioRecorderObject的GetInterface方法获取到这些Interface了。\n\nSLDataSource和SLDataSink可能比较难理解。我们可以看下OpenSL录音的原理:\n\n{% img /OpenSLES学习笔记/2.png %}\n\n简而言之, AudioRecorder会从SLDataSource指定的数据源获取数据,然后将数据保存到SLDataSink指定的接收器。\n\nSLDataSource很明显就是录音设备(SL\\_IODEVICE\\_AUDIOINPUT):\n\n```\nSLDataLocator_IODevice device;\ndevice.locatorType = SL_DATALOCATOR_IODEVICE;\ndevice.deviceType = SL_IODEVICE_AUDIOINPUT;\ndevice.deviceID = SL_DEFAULTDEVICEID_AUDIOINPUT;\ndevice.device = NULL; //Must be NULL if deviceID parameter is to be used.\n\nSLDataSource source;\nsource.pLocator = &device;\nsource.pFormat = NULL; //This parameter is ignored if pLocator is SLDataLocator_IODevice.\n```\n\n而SLDataSink就可以任由我们指定了,它官方支持下面的类型:\n\n```\nSLDataLocator_Address\nSLDataLocator_IODevice\nSLDataLocator_OutputMix\nSLDataLocator_URI\nSLDataLocator_BufferQueue\nSLDataLocator_MIDIBufferQueue\n```\n\nAndroid又拓展了下面几种类型:\n\n```\nSLDataLocator_AndroidFD\nSLDataLocator_AndroidBufferQueue\nSLDataLocator_AndroidSimpleBufferQueue\n```\n\n我这边把它设置成SLDataLocator_AndroidSimpleBufferQueue,它比较通用, AudioRecorder把数据放到这个队列中,我们再可以从这个队列中拿出来使用:\n\n```\nSLDataLocator_AndroidSimpleBufferQueue queue;\nqueue.locatorType = SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE;\nqueue.numBuffers = 2;\n\nSLDataFormat_PCM format;\nformat.formatType = SL_DATAFORMAT_PCM;\nformat.numChannels = numChannels;\nformat.samplesPerSec = samplingRate;\nformat.bitsPerSample = SL_PCMSAMPLEFORMAT_FIXED_16;\nformat.containerSize = SL_PCMSAMPLEFORMAT_FIXED_16;\nformat.channelMask = getChannelMask(numChannels);\nformat.endianness = SL_BYTEORDER_LITTLEENDIAN;\n\nSLDataSink sink;\nsink.pLocator = &queue;\nsink.pFormat = &format;\n```\n\n同时在创建的时候需要检测下SL\\_DATALOCATOR\\_ANDROIDSIMPLEBUFFERQUEUE是不是支持:\n\n```\nSLInterfaceID id[] = {SL_IID_ANDROIDSIMPLEBUFFERQUEUE};\nSLboolean required[] = {SL_BOOLEAN_TRUE};\n\nSLObjectItf recorderObject;\n(engineInterface)->CreateAudioRecorder(\n        engineInterface,\n        &(recorderObject),\n        &source,\n        &sink,\n        1,\n        id,\n        required\n);\n(*recorderObject)->Realize(recorderObject, SL_BOOLEAN_FALSE);\n```\n\n所以我们可以通过GetInterface获取SLAndroidSimpleBufferQueueItf,然后注册个队列满的监听回调:\n\n```\nSLAndroidSimpleBufferQueueItf queueInterface;\n(*recorderObject)->GetInterface(\n        recorderObject,\n        SL_IID_ANDROIDSIMPLEBUFFERQUEUE,\n        &(queueInterface)\n);\n\n(*queueInterface)->RegisterCallback(\n        queueInterface,\n        bufferQueueCallback,\n        NULL\n);\n```\n\n回调函数如下,我们可以在这个时候从队列里面读取下来的音频数据:\n\n```\nstatic void bufferQueueCallback(SLAndroidSimpleBufferQueueItf queue, void *pContext) {\n\t...\n}\n```\n\n最后需要打开录音设备开始录音:\n\n```\nSLRecordItf recorderInterface;\n(*recorderObject)->GetInterface(\n        recorderObject,\n        SL_IID_RECORD,\n        &(recorderInterface)\n);\n\n(*recorderInterface)->SetRecordState(\n        recorderInterface,\n        SL_RECORDSTATE_RECORDING\n);\n```\n\n这里需要注意的是我们必须在队列满的时候将数据取出来,如果不取,那队列里面就没有空间可以继续存储音频数据了:\n\n```\n(*queueInterface)->Enqueue(queueInterface, buffer, BUFFER_SIZE*sizeof(short));\n```\n\n# 播放\n\n播放的代码和录音很类似。我们需要先创建AudioPlayer:\n\n```\nSLresult (*CreateAudioPlayer) (\n    SLEngineItf self,\n    SLObjectItf * pPlayer,\n    SLDataSource *pAudioSrc,\n    SLDataSink *pAudioSnk,\n    SLuint32 numInterfaces,\n    const SLInterfaceID * pInterfaceIds,\n    const SLboolean * pInterfaceRequired\n);\n```\n\n它的参数和CreateAudioRecorder一样,我就不再一个个去解释了,可以看看播放的过程:\n\n{% img /OpenSLES学习笔记/3.png %}\n\nSLDataSource我也用SLDataLocator_AndroidSimpleBufferQueue,这样我们可以往队列中不断写入音频数据,AudioRecorder会从队列中不断获取数据传递到混音器中:\n\n```\nSLDataLocator_AndroidSimpleBufferQueue queue;\nqueue.locatorType = SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE;\nqueue.numBuffers = 2;\n\nSLDataFormat_PCM format;\nformat.formatType = SL_DATAFORMAT_PCM;\nformat.numChannels = numChannels;\nformat.samplesPerSec = samplingRate;\nformat.bitsPerSample = SL_PCMSAMPLEFORMAT_FIXED_16;\nformat.containerSize = SL_PCMSAMPLEFORMAT_FIXED_16;\nformat.channelMask = getChannelMask(numChannels);\nformat.endianness = SL_BYTEORDER_LITTLEENDIAN;\n\nSLDataSource source;\nsource.pLocator = &queue;\nsource.pFormat = &format;\n```\n\n而SLDataSink需要配置成混音器。混音器用于将多个音频混合并且输出到喇叭:\n\n```\nSLObjectItf outputMixObject;\n(*engineInterface)->CreateOutputMix(\n        engineInterface,\n        &(outputMixObject),\n        0,\n        NULL,\n        NULL\n);\n(*outputMixObject)->Realize(\n        outputMixObject,\n        SL_BOOLEAN_FALSE\n);\n\nSLDataLocator_OutputMix outputMix;\noutputMix.locatorType = SL_DATALOCATOR_OUTPUTMIX;\noutputMix.outputMix = outputMixObject;\n\nSLDataSink sink;\nsink.pLocator = &outputMix;\nsink.pFormat = NULL; //This parameter is ignored if pLocator is SLDataLocator_IODevice or SLDataLocator_OutputMix.\n```\n\n同样的我们在创建AudioPlayer的时候会检查是不是支持SL\\_IID_ANDROIDSIMPLEBUFFERQUEUE:\n\n```\nSLObjectItf playerObject;\nSLInterfaceID id[] = {SL_IID_ANDROIDSIMPLEBUFFERQUEUE};\nSLboolean required[] = {SL_BOOLEAN_TRUE};\n(*engineInterface)->CreateAudioPlayer(\n        engineInterface,\n        &(playerObject),\n        &source,\n        &sink,\n        1,\n        id,\n        required\n);\n(*playerObject)->Realize(playerObject, SL_BOOLEAN_FALSE);\n```\n\n最后我们需要注册队列空的监听和打开播放器开始播放:\n\n```\nSLAndroidSimpleBufferQueueItf queueInterface;\n(*playerObject)->GetInterface(\n        playerObject,\n        SL_IID_ANDROIDSIMPLEBUFFERQUEUE,\n        &(queueInterface)\n);\n(*queueInterface)->RegisterCallback(\n        queueInterface,\n        bufferQueueCallback,\n        NULL\n);\n\n//////Begin Playing//////\nSLPlayItf playInterface;\n(*playerObject)->GetInterface(\n        playerObject,\n        SL_IID_PLAY,\n        &(playInterface)\n);\n(*playInterface)->SetPlayState(\n        playInterface,\n        SL_PLAYSTATE_PLAYING\n);\n```\n\n# Demo\n\n这里有个简单的录音和播放的[demo](https://github.com/bluesky466/OpenSLDemo),按兴趣的同学可以参考一下。\n","source":"_posts/OpenSLES学习笔记.md","raw":"title: OpenSL ES 学习笔记\ndate: 2018-09-01 20:24:42\ntags:\n    - 技术相关\n    - Android\n    - C/C++\n---\n\n一般来讲在安卓中常使用AudioRecord、MediaRecorder对音频进行采集,使用SoundPool、MediaPlayer、AudioTrack进行音频播放。\n\n但是这些接口都是java层的,而NDK其实也提供了一个叫做OpenSL的C语言引擎用于声音的处理。\n\nOpenSL入门难度比较大,而且网上也没有什么特别好的教程,我这里把自己了解到的一些知识记录下来,希望以后忘记的时候可以快速回忆起来,也希望对大家有用。\n\n这篇笔记的很多内容都参考了OpenSL的官方文档OpenSL\\_ES\\_Specification\\_1.0.1.pdf,它是全英文的,可以在NDK的安装目录下找到,大家可以大概浏览一下,具体路径为:\n\n> $NDK_ROOT/docs/Additional\\_library\\_docs/opensles\n\n为什么要学OpenSL呢?除了C/C++的性能优势(不过其实java的效率也不低)之外,最主要是因为最近入坑FFmpeg,如果使用java层的接口,还需要通过一层JNI,比较复杂,性能消耗也大。如果用OpenSL的话就能直接在C/C++里面把事情都处理了。\n\n# 基本概念\n\n## Object和Interface\n\n在OpenSL里面,Object和Interface是两个很重要的概念,基本上所有的操作都是通过它们两个去执行的。\n\nObject和Interface是包含关系,一个Object里面包含了多个Interface:\n\n{% img /OpenSLES学习笔记/1.png %}\n\n### Object\n\nObject是一个资源的抽象集合,可以通过它获取各种资源。\n\n例如我们可以通过Object的GetInterface方法获取Interface。\n\n所有的Object在OpenSL里面我们拿到的都是一个SLObjectItf:\n\n```\nstruct SLObjectItf_ {\n\tSLresult (*Realize) (SLObjectItf self,SLboolean async);\n\n\tSLresult (*Resume) (SLObjectItf self,SLboolean async);\n\n\tSLresult (*GetState) (SLObjectItf self,SLuint32 * pState);\n\n\tSLresult (*GetInterface) (SLObjectItf self, const SLInterfaceID iid, void * pInterface);\n\n\tSLresult (*RegisterCallback) (SLObjectItf self, slObjectCallback callback, void * pContext);\n\n\tvoid (*AbortAsyncOperation) (SLObjectItf self);\n\n\tvoid (*Destroy) (SLObjectItf self);\n\n\tSLresult (*SetPriority) (SLObjectItf self, SLint32 priority, SLboolean preemptable);\n\n\tSLresult (*GetPriority) (SLObjectItf self, SLint32 *pPriority, SLboolean *pPreemptable);\n\n\tSLresult (*SetLossOfControlInterfaces) (SLObjectItf self, SLint16 numInterfaces, SLInterfaceID * pInterfaceIDs, SLboolean enabled);\n};\n\ntypedef const struct SLObjectItf_ * const * SLObjectItf;\n```\n\n在创建出来之后必须先调用Realize方法做初始化。在不需要使用的时候调用Destroy方法释放资源。\n\n#### GetInterface\n\nGetInterface可以说是OpenSL里使用频率最高的方法,通过它我们可以获取Object里面的Interface。\n\n由于一个Object里面可能包含了多个Interface,所以GetInterface方法有个SLInterfaceID参数来指定到的需要获取Object里面的那个Interface。\n\n例如下面代码我们通过EngineObject去获取SL_IID_ENGINE这个id的Interface,而这个id对应的Interface就是SLEngineItf:\n\n```\n//create EngineObject\nSLObjectItf engineObject;\nslCreateEngine(&engineObject, 0, NULL, 0, NULL, NULL);\n(*engineObject)->Realize(engineObject, SL_BOOLEAN_FALSE);\n\n//get SLEngineItf\nSLEngineItf engineInterface;\n(*engineObject)->GetInterface(engineObject, SL_IID_ENGINE, &engineInterface);\n```\n\n\n## Interface\n\nInterface则是方法的集合,例如SLRecordItf里面包含了和录音相关的方法,SLPlayItf包含了和播放相关的方法。我们功能都是通过调用Interfaces的方法去实现的。\n\n#### SLEngineItf\n\nSLEngineItf是OpenSL里面最重要的一个Interface,我们可以通过它去创建各种Object,例如播放器、录音器、混音器的Object,然后在用这些Object去获取各种Interface去实现各种功能。\n\n\n```\nstruct SLEngineItf_ {\n\tSLresult (*CreateAudioPlayer) (SLEngineItf self, SLObjectItf * pPlayer, SLDataSource *pAudioSrc, SLDataSink *pAudioSnk, SLuint32 numInterfaces, const SLInterfaceID * pInterfaceIds, const SLboolean * pInterfaceRequired);\n\n\tSLresult (*CreateAudioRecorder) (SLEngineItf self, SLObjectItf * pRecorder, SLDataSource *pAudioSrc, SLDataSink *pAudioSnk, SLuint32 numInterfaces, const SLInterfaceID * pInterfaceIds, const SLboolean * pInterfaceRequired);\n\n\tSLresult (*CreateOutputMix) (SLEngineItf self, SLObjectItf * pMix, SLuint32 numInterfaces, const SLInterfaceID * pInterfaceIds, const SLboolean * pInterfaceRequired);\n\n\t...\n};\n```\n\n# 录音\n\nOpenSL的录音功能是通过AudioRecorder来实现的,而AudioRecorder是通过SLEngineItf.CreateAudioRecorder方法创建的:\n\n```\nSLresult (*CreateAudioRecorder) (\n        SLEngineItf self,\n        SLObjectItf * pRecorder,\n        SLDataSource * pAudioSrc,\n        SLDataSink * pAudioSnk,\n        SLuint32 numInterfaces,\n        const SLInterfaceID * pInterfaceIds,\n        const SLboolean * pInterfaceRequired\n    );\n```\n\n各个参数的意义如下:\n\n- SLEngineItf C语言不像c++,没有this指针,只能每次调用SLEngineItf的方法的时候手动传入\n- SLObjectItf 用于保存创建出来的AudioRecorderObject\n- SLDataSource 数据的来源\n- SLDataSink 数据的去处\n- numInterfaces 与下面的SLInterfaceID和SLboolean配合使用,用于标记SLInterfaceID数组和SLboolean的大小\n- SLInterfaceID 这里需要传入一个数组,指定创建的AudioRecorderObject会包含哪些Interface\n- SLboolean 这里也是一个数组,用来标记每个需要包含的Interface,如果AudioRecorderObject不支持,是不是需要直接创建AudioRecorderObject失败。\n\n最后的三个参数用于指定AudioRecorderObject需要包含哪些Interface,如果不包含,是不是要直接创建失败。如果成功的话我们就能使用AudioRecorderObject的GetInterface方法获取到这些Interface了。\n\nSLDataSource和SLDataSink可能比较难理解。我们可以看下OpenSL录音的原理:\n\n{% img /OpenSLES学习笔记/2.png %}\n\n简而言之, AudioRecorder会从SLDataSource指定的数据源获取数据,然后将数据保存到SLDataSink指定的接收器。\n\nSLDataSource很明显就是录音设备(SL\\_IODEVICE\\_AUDIOINPUT):\n\n```\nSLDataLocator_IODevice device;\ndevice.locatorType = SL_DATALOCATOR_IODEVICE;\ndevice.deviceType = SL_IODEVICE_AUDIOINPUT;\ndevice.deviceID = SL_DEFAULTDEVICEID_AUDIOINPUT;\ndevice.device = NULL; //Must be NULL if deviceID parameter is to be used.\n\nSLDataSource source;\nsource.pLocator = &device;\nsource.pFormat = NULL; //This parameter is ignored if pLocator is SLDataLocator_IODevice.\n```\n\n而SLDataSink就可以任由我们指定了,它官方支持下面的类型:\n\n```\nSLDataLocator_Address\nSLDataLocator_IODevice\nSLDataLocator_OutputMix\nSLDataLocator_URI\nSLDataLocator_BufferQueue\nSLDataLocator_MIDIBufferQueue\n```\n\nAndroid又拓展了下面几种类型:\n\n```\nSLDataLocator_AndroidFD\nSLDataLocator_AndroidBufferQueue\nSLDataLocator_AndroidSimpleBufferQueue\n```\n\n我这边把它设置成SLDataLocator_AndroidSimpleBufferQueue,它比较通用, AudioRecorder把数据放到这个队列中,我们再可以从这个队列中拿出来使用:\n\n```\nSLDataLocator_AndroidSimpleBufferQueue queue;\nqueue.locatorType = SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE;\nqueue.numBuffers = 2;\n\nSLDataFormat_PCM format;\nformat.formatType = SL_DATAFORMAT_PCM;\nformat.numChannels = numChannels;\nformat.samplesPerSec = samplingRate;\nformat.bitsPerSample = SL_PCMSAMPLEFORMAT_FIXED_16;\nformat.containerSize = SL_PCMSAMPLEFORMAT_FIXED_16;\nformat.channelMask = getChannelMask(numChannels);\nformat.endianness = SL_BYTEORDER_LITTLEENDIAN;\n\nSLDataSink sink;\nsink.pLocator = &queue;\nsink.pFormat = &format;\n```\n\n同时在创建的时候需要检测下SL\\_DATALOCATOR\\_ANDROIDSIMPLEBUFFERQUEUE是不是支持:\n\n```\nSLInterfaceID id[] = {SL_IID_ANDROIDSIMPLEBUFFERQUEUE};\nSLboolean required[] = {SL_BOOLEAN_TRUE};\n\nSLObjectItf recorderObject;\n(engineInterface)->CreateAudioRecorder(\n        engineInterface,\n        &(recorderObject),\n        &source,\n        &sink,\n        1,\n        id,\n        required\n);\n(*recorderObject)->Realize(recorderObject, SL_BOOLEAN_FALSE);\n```\n\n所以我们可以通过GetInterface获取SLAndroidSimpleBufferQueueItf,然后注册个队列满的监听回调:\n\n```\nSLAndroidSimpleBufferQueueItf queueInterface;\n(*recorderObject)->GetInterface(\n        recorderObject,\n        SL_IID_ANDROIDSIMPLEBUFFERQUEUE,\n        &(queueInterface)\n);\n\n(*queueInterface)->RegisterCallback(\n        queueInterface,\n        bufferQueueCallback,\n        NULL\n);\n```\n\n回调函数如下,我们可以在这个时候从队列里面读取下来的音频数据:\n\n```\nstatic void bufferQueueCallback(SLAndroidSimpleBufferQueueItf queue, void *pContext) {\n\t...\n}\n```\n\n最后需要打开录音设备开始录音:\n\n```\nSLRecordItf recorderInterface;\n(*recorderObject)->GetInterface(\n        recorderObject,\n        SL_IID_RECORD,\n        &(recorderInterface)\n);\n\n(*recorderInterface)->SetRecordState(\n        recorderInterface,\n        SL_RECORDSTATE_RECORDING\n);\n```\n\n这里需要注意的是我们必须在队列满的时候将数据取出来,如果不取,那队列里面就没有空间可以继续存储音频数据了:\n\n```\n(*queueInterface)->Enqueue(queueInterface, buffer, BUFFER_SIZE*sizeof(short));\n```\n\n# 播放\n\n播放的代码和录音很类似。我们需要先创建AudioPlayer:\n\n```\nSLresult (*CreateAudioPlayer) (\n    SLEngineItf self,\n    SLObjectItf * pPlayer,\n    SLDataSource *pAudioSrc,\n    SLDataSink *pAudioSnk,\n    SLuint32 numInterfaces,\n    const SLInterfaceID * pInterfaceIds,\n    const SLboolean * pInterfaceRequired\n);\n```\n\n它的参数和CreateAudioRecorder一样,我就不再一个个去解释了,可以看看播放的过程:\n\n{% img /OpenSLES学习笔记/3.png %}\n\nSLDataSource我也用SLDataLocator_AndroidSimpleBufferQueue,这样我们可以往队列中不断写入音频数据,AudioRecorder会从队列中不断获取数据传递到混音器中:\n\n```\nSLDataLocator_AndroidSimpleBufferQueue queue;\nqueue.locatorType = SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE;\nqueue.numBuffers = 2;\n\nSLDataFormat_PCM format;\nformat.formatType = SL_DATAFORMAT_PCM;\nformat.numChannels = numChannels;\nformat.samplesPerSec = samplingRate;\nformat.bitsPerSample = SL_PCMSAMPLEFORMAT_FIXED_16;\nformat.containerSize = SL_PCMSAMPLEFORMAT_FIXED_16;\nformat.channelMask = getChannelMask(numChannels);\nformat.endianness = SL_BYTEORDER_LITTLEENDIAN;\n\nSLDataSource source;\nsource.pLocator = &queue;\nsource.pFormat = &format;\n```\n\n而SLDataSink需要配置成混音器。混音器用于将多个音频混合并且输出到喇叭:\n\n```\nSLObjectItf outputMixObject;\n(*engineInterface)->CreateOutputMix(\n        engineInterface,\n        &(outputMixObject),\n        0,\n        NULL,\n        NULL\n);\n(*outputMixObject)->Realize(\n        outputMixObject,\n        SL_BOOLEAN_FALSE\n);\n\nSLDataLocator_OutputMix outputMix;\noutputMix.locatorType = SL_DATALOCATOR_OUTPUTMIX;\noutputMix.outputMix = outputMixObject;\n\nSLDataSink sink;\nsink.pLocator = &outputMix;\nsink.pFormat = NULL; //This parameter is ignored if pLocator is SLDataLocator_IODevice or SLDataLocator_OutputMix.\n```\n\n同样的我们在创建AudioPlayer的时候会检查是不是支持SL\\_IID_ANDROIDSIMPLEBUFFERQUEUE:\n\n```\nSLObjectItf playerObject;\nSLInterfaceID id[] = {SL_IID_ANDROIDSIMPLEBUFFERQUEUE};\nSLboolean required[] = {SL_BOOLEAN_TRUE};\n(*engineInterface)->CreateAudioPlayer(\n        engineInterface,\n        &(playerObject),\n        &source,\n        &sink,\n        1,\n        id,\n        required\n);\n(*playerObject)->Realize(playerObject, SL_BOOLEAN_FALSE);\n```\n\n最后我们需要注册队列空的监听和打开播放器开始播放:\n\n```\nSLAndroidSimpleBufferQueueItf queueInterface;\n(*playerObject)->GetInterface(\n        playerObject,\n        SL_IID_ANDROIDSIMPLEBUFFERQUEUE,\n        &(queueInterface)\n);\n(*queueInterface)->RegisterCallback(\n        queueInterface,\n        bufferQueueCallback,\n        NULL\n);\n\n//////Begin Playing//////\nSLPlayItf playInterface;\n(*playerObject)->GetInterface(\n        playerObject,\n        SL_IID_PLAY,\n        &(playInterface)\n);\n(*playInterface)->SetPlayState(\n        playInterface,\n        SL_PLAYSTATE_PLAYING\n);\n```\n\n# Demo\n\n这里有个简单的录音和播放的[demo](https://github.com/bluesky466/OpenSLDemo),按兴趣的同学可以参考一下。\n","slug":"OpenSLES学习笔记","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2uo20036w3fyp3jldgq4"},{"title":"OkHttp源码解析","date":"2017-12-29T16:53:32.000Z","_content":"\n# 应用拦截器和网络拦截器\n\n以前其实就有一直在使用okhttp,也有听说过拦截器这东西,但是一直没有去深入了解。最近看《安卓进阶之光》刚好看到okhttp拦截器的内容,然后自己也去挖了下源码,才发现其巧妙之处。\n\n拦截器有两种,应用拦截器和网络拦截器。用法可以看下面的代码:\n\n```\nclass LogInterceptor implements Interceptor {\n    private String mName;\n\n    LogInterceptor(String name) {\n        mName = name;\n    }\n\n    @Override\n    public Response intercept(Chain chain) throws IOException {\n        Response response = chain.proceed(chain.request());\n        Log.d(\"LogInterceptor\", \"[\" + mName + \"] : request url = \" + response.request().url() + \", \" + response.headers().toString());\n        return response;\n    }\n}\n\nOkHttpClient client = new OkHttpClient.Builder()\n        .addInterceptor(new LogInterceptor(\"ApplicationInterceptor\"))\n        .addNetworkInterceptor(new LogInterceptor(\"NetworkInterceptor\"))\n        .build();\n\nRequest request = new Request.Builder()\n        .url(\"http://www.github.com\")\n        .build();\n\nclient.newCall(request).enqueue(null);\n```\n\n运行之后的打印如下:\n\n```\n12-29 00:07:02.378 12641-12859/com.example.okhttp D/LogInterceptor: [NetworkInterceptor] : request url = http://www.github.com/, Content-length: 0\n    Location: https://www.github.com/\n12-29 00:07:03.653 12641-12859/com.example.okhttp D/LogInterceptor: [NetworkInterceptor] : request url = https://www.github.com/, Content-length: 0\n    Location: https://github.com/\n12-29 00:07:04.889 12641-12859/com.example.okhttp D/LogInterceptor: [NetworkInterceptor] : request url = https://github.com/, Date: Thu, 28 Dec 2017 16:07:05 GMT\n    Content-Type: text/html; charset=utf-8\n    Transfer-Encoding: chunked\n    Server: GitHub.com\n    Status: 200 OK\n    ...(省略部分打印)\n12-29 00:07:04.896 12641-12859/com.example.okhttp D/LogInterceptor: [ApplicationInterceptor] : request url = https://github.com/, Date: Thu, 28 Dec 2017 16:07:05 GMT\n    Content-Type: text/html; charset=utf-8\n    Transfer-Encoding: chunked\n    Server: GitHub.com\n    Status: 200 OK\n    ...(省略部分打印)\n```\n\n拦截器是一种强大的机制,可以在拦截器中进行监视、重写和重试调用。像我们上面的代码就对请求进行了监视。\n\n从打印可以看到,网络拦截器拦截到了三个请求,同时拦截到了重定向的访问。而应用拦截器只拦截到了一个请求,同时我们可以看到它拦截到的请求的url是 __https://github.com/__ 和我们在代码中的请求 __http://www.github.com__ 并不一致。\n\n简单来讲,网络拦截器在每一次网络访问的时候都会拦截到请求,而应用拦截器只会在OkHttpClient.newCall返回的Call执行的时候被调用一次。\n\n# okhttp的运行流程\n\n在讲拦截器的实现之前我们先来简单介绍一下okhttp的运行流程。\n\n首先通过OkHttpClient.newCall我们可以获得一个RealCall:\n\n```\npublic class OkHttpClient implements Cloneable, Call.Factory {\n  ...\n  public Call newCall(Request request) {\n    return new RealCall(this, request);\n  }\n  ...\n}\n```\n\n## 异步访问\n\nRealCall实现了Call。接口,我们通过调用enqueue方法可以实现异步网络访问。让我们直接看看RealCall.enqueue吧:\n\n```\nfinal class RealCall implements Call {\n  ...\n  public void enqueue(Callback responseCallback) {\n    enqueue(responseCallback, false);\n  }\n\n  void enqueue(Callback responseCallback, boolean forWebSocket) {\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already Executed\");\n      executed = true;\n    }\n    client.dispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));\n  }\n  ...\n}\n```\n\nclient.dispatcher()可以获得一个Dispatcher,它用于网络访问任务的调度,我们的异步并发网络访问就是通过Dispatcher实现的。这里创建了一个AsyncCall,然后将它传入Dispatcher.enqueue。AsyncCall是RealCall的内部类,而且它实际上是一个Runnable：\n\n```\nfinal class RealCall implements Call {\n  ...\n  final class AsyncCall extends NamedRunnable {\n    ...\n  }\n  ...\n}\n```\n\n```\npublic abstract class NamedRunnable implements Runnable {\n  ...\n  @Override public final void run() {\n    String oldName = Thread.currentThread().getName();\n    Thread.currentThread().setName(name);\n    try {\n      execute();\n    } finally {\n      Thread.currentThread().setName(oldName);\n    }\n  }\n\n  protected abstract void execute();\n}\n```\n\nNamedRunnable在run方法里面会调用抽象的execute方法,在这个方法内部就会进行实际的网络访问。那Dispatcher.enqueue又做了写什么呢？其实Dispatcher.enqueue实际上将AsyncCall这个Runnable放到了一个线程池中：\n\n```\npublic final class Dispatcher {\n  ...\n  synchronized void enqueue(AsyncCall call) {\n    if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {\n      runningAsyncCalls.add(call);\n      executorService().execute(call);\n    } else {\n      readyAsyncCalls.add(call);\n    }\n  }\n  ...\n  public synchronized ExecutorService executorService() {\n    if (executorService == null) {\n      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,\n          new SynchronousQueue<Runnable>(), Util.threadFactory(\"OkHttp Dispatcher\", false));\n    }\n    return executorService;\n  }\n  ...\n}\n```\n\n一切明了,Call.enqueue实际上是将AsyncCall这个Runnable放到了线程池中执行去访问网络,而AsyncCall是RealCall的一个内部类,它持有RealCall的引用,所以在被线程池调用的时候可以获得Request的信息。\n\n所以将okhttp的异步流程简化之后实际上就是Dispatcher中的线程池对Runnable的执行:\n\n{% img /OkHttp源码解析/1.png %}\n\n然后我们看看AsyncCall.execute的具体实现:\n\n```\nfinal class AsyncCall extends NamedRunnable {\n  ...\n  @Override protected void execute() {\n   boolean signalledCallback = false;\n   try {\n     Response response = getResponseWithInterceptorChain(forWebSocket);\n     if (canceled) {\n       signalledCallback = true;\n       responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n     } else {\n       signalledCallback = true;\n       responseCallback.onResponse(RealCall.this, response);\n     }\n   } catch (IOException e) {\n     if (signalledCallback) {\n       // Do not signal the callback twice!\n       Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n     } else {\n       responseCallback.onFailure(RealCall.this, e);\n     }\n   } finally {\n     client.dispatcher().finished(this);\n   }\n  }\n  ...\n}\n```\n\n可以看到它是通过getResponseWithInterceptorChain来访问网络获取Response的。\n\n# 同步访问\n\n如果想用OkHttp去阻塞是的访问网络我们可以这样调用:\n\n```\nResponse response = client.newCall(request).execute();\n```\n\n这个execute是不是有点眼熟,但它是Call的一个方法,并不是我们上面异步访问中提到的NamedRunnable.execute:\n\n```\npublic interface Call {\n  ...\n  Response execute() throws IOException;\n  ..\n}\n```\n\n现在我们来看看具体实现:\n\n```\nfinal class RealCall implements Call {\n  ...\n  @Override public Response execute() throws IOException {\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already Executed\");\n      executed = true;\n    }\n    try {\n      client.dispatcher().executed(this);\n      Response result = getResponseWithInterceptorChain(false);\n      if (result == null) throw new IOException(\"Canceled\");\n      return result;\n    } finally {\n      client.dispatcher().finished(this);\n    }\n  }\n  ...\n}\n```\n\n它也是通过getResponseWithInterceptorChain来访问网络获取Response的。\n\n\n# 拦截器的实现\n\n我们在前面的小节中已经知道了,无论是同步还是异步,最终都是通过RealCall.getResponseWithInterceptorChain方法去访问网络的。但是在查看具体源代码的时候发现在okhttp3.4.0-RC1开始其具体的实现细节有了一些不一样的地方。所以我这边分开两部分来讲一讲okhttp3.4.0-RC1之前和之后拦截器的具体实现细节。\n\n## okhttp3.4.0-RC1之前的实现\n\nokhttp3.4.0-RC1之前的RealCall.getResponseWithInterceptorChain 中实际上是调用了ApplicationInterceptorChain.proceed方法去访问网络获取Response:\n\n```\nprivate Response getResponseWithInterceptorChain(boolean forWebSocket) throws IOException {\n  Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket);\n  return chain.proceed(originalRequest);\n}\n```\n\n然后继续看源码,可以发现proceed内部会从OkHttpClient获取序号为index的拦截器,并且创建新的序号加一的ApplicationInterceptorChain传递给拦截器去执行。于是有多少个拦截器就创建了多少个ApplicationInterceptorChain,他们会按照自己的序号调用对应的拦截器。这其实就是一种责任链模式的实现方式:\n\n```\n@Override public Response proceed(Request request) throws IOException {\n  // If there's another interceptor in the chain, call that.\n  if (index < client.interceptors().size()) {\n    Interceptor.Chain chain = new ApplicationInterceptorChain(index + 1, request, forWebSocket);\n    Interceptor interceptor = client.interceptors().get(index);\n    Response interceptedResponse = interceptor.intercept(chain);\n\n    if (interceptedResponse == null) {\n      throw new NullPointerException(\"application interceptor \" + interceptor\n          + \" returned null\");\n    }\n\n    return interceptedResponse;\n  }\n\n  // No more interceptors. Do HTTP.\n  return getResponse(request, forWebSocket);\n}\n```\n\n如果ApplicationInterceptorChain的序号大于OkHttpClient中注册的拦截器的数量,则调用getResponse方法。这里ApplicationInterceptorChain是RealCall的内部类,getResponse调用的是RealCall.getResponse方法。\n\n再看RealCall.getResponse方法,它内部有个while true的死循环,调用HttpEngine.sendRequest和HttpEngine.readResponse去发送请求和接收响应,如果出现了RouteException异常或者IOException异常则重新尝试访问:\n\n```\nResponse getResponse(Request request, boolean forWebSocket) throws IOException {\n    ...\n    while (true) {\n    ...\n    try {\n        engine.sendRequest();\n        engine.readResponse();\n        releaseConnection = false;\n    } catch (RouteException e) {\n        HttpEngine retryEngine = engine.recover(e.getLastConnectException(), true, null);\n        if (retryEngine != null) {\n            releaseConnection = false;\n            engine = retryEngine;\n            continue;\n        }\n        throw e.getLastConnectException();\n    }catch (IOException e) {\n        HttpEngine retryEngine = engine.recover(e, false, null);\n        if (retryEngine != null) {\n            releaseConnection = false;\n            engine = retryEngine;\n            continue;\n        }\n        throw e;\n    }\n    ...\n}\n```\n\n我们继续看engine.readResponse的实现,可以看到它调用了NetworkInterceptorChain.proceed方法去获取响应:\n\n```\npublic void readResponse() throws IOException {\n...\nResponse networkResponse;\n...\nnetworkResponse = new NetworkInterceptorChain(0, networkRequest,\n    \t\t\tstreamAllocation.connection()).proceed(networkRequest);\n...\n}\n```\n\nNetworkInterceptorChain.proceed和ApplicationInterceptorChain.proceed类似,也会不断的创建新的NetworkInterceptorChain并且调用网络拦截器,如果没有网络拦截器可以调用了,则会调用readNetworkResponse方法读取响应:\n\n```\n@Override public Response proceed(Request request) throws IOException {\n...\nif (index < client.networkInterceptors().size()) {\n    NetworkInterceptorChain chain = new NetworkInterceptorChain(index + 1, request, connection);\n    Interceptor interceptor = client.networkInterceptors().get(index);\n    Response interceptedResponse = interceptor.intercept(chain);\n    ...\n    return interceptedResponse;\n}\nResponse response = readNetworkResponse();\n...\nreturn response;\n}\n```\n\n这里还有一点需要说明的是NetworkInterceptorChain是HttpEngine的内部类,它调用的readNetworkResponse方法实际上是HttpEngine.readNetworkResponse。现在我们就对OkHttp拦截器的请求流程和拦截器的实现原理有了比较全面的了解,下面这张图对整个流程做一个总结:\n\n{% img /OkHttp源码解析/2.png %}\n\n\n## okhttp3.4.0-RC1之后的实现\n\n然后让我们再来看一下3.4.0-RC1之后的实现:\n\n```\nResponse getResponseWithInterceptorChain() throws IOException {\n  // Build a full stack of interceptors.\n  List<Interceptor> interceptors = new ArrayList<>();\n  interceptors.addAll(client.interceptors());\n  interceptors.add(retryAndFollowUpInterceptor);\n  interceptors.add(new BridgeInterceptor(client.cookieJar()));\n  interceptors.add(new CacheInterceptor(client.internalCache()));\n  interceptors.add(new ConnectInterceptor(client));\n  if (!forWebSocket) {\n    interceptors.addAll(client.networkInterceptors());\n  }\n  interceptors.add(new CallServerInterceptor(forWebSocket));\n\n  Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,\n      originalRequest, this, eventListener, client.connectTimeoutMillis(),\n      client.readTimeoutMillis(), client.writeTimeoutMillis());\n\n  return chain.proceed(originalRequest);\n}\n```\n\n这里已经不再区分ApplicationInterceptorChain和NetworkInterceptorChain了，统一用RealInterceptorChain去处理:\n\n```\npublic Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,\n    RealConnection connection) throws IOException {\n  ...\n\n  // Call the next interceptor in the chain.\n  RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,\n      connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,\n      writeTimeout);\n  Interceptor interceptor = interceptors.get(index);\n  Response response = interceptor.intercept(next);\n\n  ...\n\n  return response;\n}\n```\n\n这里将cookie处理、缓存处理、网络连接都作为责任链的一部分，比起3.4.0.RC-1之前更加完全的实现了责任链模式。这里有必要讲一下的就是retryAndFollowUpInterceptor, 它是一个RetryAndFollowUpInterceptor实例，它负责重连和重定向我们之前在3.4.0.RC-1之前看到的getResponse的while true就放到了这里来实现。\n\n让我们看看它的整个流程:\n\n\n{% img /OkHttp源码解析/3.png %}\n\n\n这样的实现是不是以前要清晰很多？所有的步骤一目了然，看过原来的版本再看看3.4.0.RC-1重构后的版本，的确有一种眼前一亮的惊艳之感。果然好代码都是需要一点点优化出来的。\n","source":"_posts/OkHttp源码解析.md","raw":"title: OkHttp源码解析\ndate: 2017-12-30 00:53:32\ntags:\n    - 技术相关\n    - Android\n---\n\n# 应用拦截器和网络拦截器\n\n以前其实就有一直在使用okhttp,也有听说过拦截器这东西,但是一直没有去深入了解。最近看《安卓进阶之光》刚好看到okhttp拦截器的内容,然后自己也去挖了下源码,才发现其巧妙之处。\n\n拦截器有两种,应用拦截器和网络拦截器。用法可以看下面的代码:\n\n```\nclass LogInterceptor implements Interceptor {\n    private String mName;\n\n    LogInterceptor(String name) {\n        mName = name;\n    }\n\n    @Override\n    public Response intercept(Chain chain) throws IOException {\n        Response response = chain.proceed(chain.request());\n        Log.d(\"LogInterceptor\", \"[\" + mName + \"] : request url = \" + response.request().url() + \", \" + response.headers().toString());\n        return response;\n    }\n}\n\nOkHttpClient client = new OkHttpClient.Builder()\n        .addInterceptor(new LogInterceptor(\"ApplicationInterceptor\"))\n        .addNetworkInterceptor(new LogInterceptor(\"NetworkInterceptor\"))\n        .build();\n\nRequest request = new Request.Builder()\n        .url(\"http://www.github.com\")\n        .build();\n\nclient.newCall(request).enqueue(null);\n```\n\n运行之后的打印如下:\n\n```\n12-29 00:07:02.378 12641-12859/com.example.okhttp D/LogInterceptor: [NetworkInterceptor] : request url = http://www.github.com/, Content-length: 0\n    Location: https://www.github.com/\n12-29 00:07:03.653 12641-12859/com.example.okhttp D/LogInterceptor: [NetworkInterceptor] : request url = https://www.github.com/, Content-length: 0\n    Location: https://github.com/\n12-29 00:07:04.889 12641-12859/com.example.okhttp D/LogInterceptor: [NetworkInterceptor] : request url = https://github.com/, Date: Thu, 28 Dec 2017 16:07:05 GMT\n    Content-Type: text/html; charset=utf-8\n    Transfer-Encoding: chunked\n    Server: GitHub.com\n    Status: 200 OK\n    ...(省略部分打印)\n12-29 00:07:04.896 12641-12859/com.example.okhttp D/LogInterceptor: [ApplicationInterceptor] : request url = https://github.com/, Date: Thu, 28 Dec 2017 16:07:05 GMT\n    Content-Type: text/html; charset=utf-8\n    Transfer-Encoding: chunked\n    Server: GitHub.com\n    Status: 200 OK\n    ...(省略部分打印)\n```\n\n拦截器是一种强大的机制,可以在拦截器中进行监视、重写和重试调用。像我们上面的代码就对请求进行了监视。\n\n从打印可以看到,网络拦截器拦截到了三个请求,同时拦截到了重定向的访问。而应用拦截器只拦截到了一个请求,同时我们可以看到它拦截到的请求的url是 __https://github.com/__ 和我们在代码中的请求 __http://www.github.com__ 并不一致。\n\n简单来讲,网络拦截器在每一次网络访问的时候都会拦截到请求,而应用拦截器只会在OkHttpClient.newCall返回的Call执行的时候被调用一次。\n\n# okhttp的运行流程\n\n在讲拦截器的实现之前我们先来简单介绍一下okhttp的运行流程。\n\n首先通过OkHttpClient.newCall我们可以获得一个RealCall:\n\n```\npublic class OkHttpClient implements Cloneable, Call.Factory {\n  ...\n  public Call newCall(Request request) {\n    return new RealCall(this, request);\n  }\n  ...\n}\n```\n\n## 异步访问\n\nRealCall实现了Call。接口,我们通过调用enqueue方法可以实现异步网络访问。让我们直接看看RealCall.enqueue吧:\n\n```\nfinal class RealCall implements Call {\n  ...\n  public void enqueue(Callback responseCallback) {\n    enqueue(responseCallback, false);\n  }\n\n  void enqueue(Callback responseCallback, boolean forWebSocket) {\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already Executed\");\n      executed = true;\n    }\n    client.dispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));\n  }\n  ...\n}\n```\n\nclient.dispatcher()可以获得一个Dispatcher,它用于网络访问任务的调度,我们的异步并发网络访问就是通过Dispatcher实现的。这里创建了一个AsyncCall,然后将它传入Dispatcher.enqueue。AsyncCall是RealCall的内部类,而且它实际上是一个Runnable：\n\n```\nfinal class RealCall implements Call {\n  ...\n  final class AsyncCall extends NamedRunnable {\n    ...\n  }\n  ...\n}\n```\n\n```\npublic abstract class NamedRunnable implements Runnable {\n  ...\n  @Override public final void run() {\n    String oldName = Thread.currentThread().getName();\n    Thread.currentThread().setName(name);\n    try {\n      execute();\n    } finally {\n      Thread.currentThread().setName(oldName);\n    }\n  }\n\n  protected abstract void execute();\n}\n```\n\nNamedRunnable在run方法里面会调用抽象的execute方法,在这个方法内部就会进行实际的网络访问。那Dispatcher.enqueue又做了写什么呢？其实Dispatcher.enqueue实际上将AsyncCall这个Runnable放到了一个线程池中：\n\n```\npublic final class Dispatcher {\n  ...\n  synchronized void enqueue(AsyncCall call) {\n    if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {\n      runningAsyncCalls.add(call);\n      executorService().execute(call);\n    } else {\n      readyAsyncCalls.add(call);\n    }\n  }\n  ...\n  public synchronized ExecutorService executorService() {\n    if (executorService == null) {\n      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,\n          new SynchronousQueue<Runnable>(), Util.threadFactory(\"OkHttp Dispatcher\", false));\n    }\n    return executorService;\n  }\n  ...\n}\n```\n\n一切明了,Call.enqueue实际上是将AsyncCall这个Runnable放到了线程池中执行去访问网络,而AsyncCall是RealCall的一个内部类,它持有RealCall的引用,所以在被线程池调用的时候可以获得Request的信息。\n\n所以将okhttp的异步流程简化之后实际上就是Dispatcher中的线程池对Runnable的执行:\n\n{% img /OkHttp源码解析/1.png %}\n\n然后我们看看AsyncCall.execute的具体实现:\n\n```\nfinal class AsyncCall extends NamedRunnable {\n  ...\n  @Override protected void execute() {\n   boolean signalledCallback = false;\n   try {\n     Response response = getResponseWithInterceptorChain(forWebSocket);\n     if (canceled) {\n       signalledCallback = true;\n       responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n     } else {\n       signalledCallback = true;\n       responseCallback.onResponse(RealCall.this, response);\n     }\n   } catch (IOException e) {\n     if (signalledCallback) {\n       // Do not signal the callback twice!\n       Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n     } else {\n       responseCallback.onFailure(RealCall.this, e);\n     }\n   } finally {\n     client.dispatcher().finished(this);\n   }\n  }\n  ...\n}\n```\n\n可以看到它是通过getResponseWithInterceptorChain来访问网络获取Response的。\n\n# 同步访问\n\n如果想用OkHttp去阻塞是的访问网络我们可以这样调用:\n\n```\nResponse response = client.newCall(request).execute();\n```\n\n这个execute是不是有点眼熟,但它是Call的一个方法,并不是我们上面异步访问中提到的NamedRunnable.execute:\n\n```\npublic interface Call {\n  ...\n  Response execute() throws IOException;\n  ..\n}\n```\n\n现在我们来看看具体实现:\n\n```\nfinal class RealCall implements Call {\n  ...\n  @Override public Response execute() throws IOException {\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already Executed\");\n      executed = true;\n    }\n    try {\n      client.dispatcher().executed(this);\n      Response result = getResponseWithInterceptorChain(false);\n      if (result == null) throw new IOException(\"Canceled\");\n      return result;\n    } finally {\n      client.dispatcher().finished(this);\n    }\n  }\n  ...\n}\n```\n\n它也是通过getResponseWithInterceptorChain来访问网络获取Response的。\n\n\n# 拦截器的实现\n\n我们在前面的小节中已经知道了,无论是同步还是异步,最终都是通过RealCall.getResponseWithInterceptorChain方法去访问网络的。但是在查看具体源代码的时候发现在okhttp3.4.0-RC1开始其具体的实现细节有了一些不一样的地方。所以我这边分开两部分来讲一讲okhttp3.4.0-RC1之前和之后拦截器的具体实现细节。\n\n## okhttp3.4.0-RC1之前的实现\n\nokhttp3.4.0-RC1之前的RealCall.getResponseWithInterceptorChain 中实际上是调用了ApplicationInterceptorChain.proceed方法去访问网络获取Response:\n\n```\nprivate Response getResponseWithInterceptorChain(boolean forWebSocket) throws IOException {\n  Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket);\n  return chain.proceed(originalRequest);\n}\n```\n\n然后继续看源码,可以发现proceed内部会从OkHttpClient获取序号为index的拦截器,并且创建新的序号加一的ApplicationInterceptorChain传递给拦截器去执行。于是有多少个拦截器就创建了多少个ApplicationInterceptorChain,他们会按照自己的序号调用对应的拦截器。这其实就是一种责任链模式的实现方式:\n\n```\n@Override public Response proceed(Request request) throws IOException {\n  // If there's another interceptor in the chain, call that.\n  if (index < client.interceptors().size()) {\n    Interceptor.Chain chain = new ApplicationInterceptorChain(index + 1, request, forWebSocket);\n    Interceptor interceptor = client.interceptors().get(index);\n    Response interceptedResponse = interceptor.intercept(chain);\n\n    if (interceptedResponse == null) {\n      throw new NullPointerException(\"application interceptor \" + interceptor\n          + \" returned null\");\n    }\n\n    return interceptedResponse;\n  }\n\n  // No more interceptors. Do HTTP.\n  return getResponse(request, forWebSocket);\n}\n```\n\n如果ApplicationInterceptorChain的序号大于OkHttpClient中注册的拦截器的数量,则调用getResponse方法。这里ApplicationInterceptorChain是RealCall的内部类,getResponse调用的是RealCall.getResponse方法。\n\n再看RealCall.getResponse方法,它内部有个while true的死循环,调用HttpEngine.sendRequest和HttpEngine.readResponse去发送请求和接收响应,如果出现了RouteException异常或者IOException异常则重新尝试访问:\n\n```\nResponse getResponse(Request request, boolean forWebSocket) throws IOException {\n    ...\n    while (true) {\n    ...\n    try {\n        engine.sendRequest();\n        engine.readResponse();\n        releaseConnection = false;\n    } catch (RouteException e) {\n        HttpEngine retryEngine = engine.recover(e.getLastConnectException(), true, null);\n        if (retryEngine != null) {\n            releaseConnection = false;\n            engine = retryEngine;\n            continue;\n        }\n        throw e.getLastConnectException();\n    }catch (IOException e) {\n        HttpEngine retryEngine = engine.recover(e, false, null);\n        if (retryEngine != null) {\n            releaseConnection = false;\n            engine = retryEngine;\n            continue;\n        }\n        throw e;\n    }\n    ...\n}\n```\n\n我们继续看engine.readResponse的实现,可以看到它调用了NetworkInterceptorChain.proceed方法去获取响应:\n\n```\npublic void readResponse() throws IOException {\n...\nResponse networkResponse;\n...\nnetworkResponse = new NetworkInterceptorChain(0, networkRequest,\n    \t\t\tstreamAllocation.connection()).proceed(networkRequest);\n...\n}\n```\n\nNetworkInterceptorChain.proceed和ApplicationInterceptorChain.proceed类似,也会不断的创建新的NetworkInterceptorChain并且调用网络拦截器,如果没有网络拦截器可以调用了,则会调用readNetworkResponse方法读取响应:\n\n```\n@Override public Response proceed(Request request) throws IOException {\n...\nif (index < client.networkInterceptors().size()) {\n    NetworkInterceptorChain chain = new NetworkInterceptorChain(index + 1, request, connection);\n    Interceptor interceptor = client.networkInterceptors().get(index);\n    Response interceptedResponse = interceptor.intercept(chain);\n    ...\n    return interceptedResponse;\n}\nResponse response = readNetworkResponse();\n...\nreturn response;\n}\n```\n\n这里还有一点需要说明的是NetworkInterceptorChain是HttpEngine的内部类,它调用的readNetworkResponse方法实际上是HttpEngine.readNetworkResponse。现在我们就对OkHttp拦截器的请求流程和拦截器的实现原理有了比较全面的了解,下面这张图对整个流程做一个总结:\n\n{% img /OkHttp源码解析/2.png %}\n\n\n## okhttp3.4.0-RC1之后的实现\n\n然后让我们再来看一下3.4.0-RC1之后的实现:\n\n```\nResponse getResponseWithInterceptorChain() throws IOException {\n  // Build a full stack of interceptors.\n  List<Interceptor> interceptors = new ArrayList<>();\n  interceptors.addAll(client.interceptors());\n  interceptors.add(retryAndFollowUpInterceptor);\n  interceptors.add(new BridgeInterceptor(client.cookieJar()));\n  interceptors.add(new CacheInterceptor(client.internalCache()));\n  interceptors.add(new ConnectInterceptor(client));\n  if (!forWebSocket) {\n    interceptors.addAll(client.networkInterceptors());\n  }\n  interceptors.add(new CallServerInterceptor(forWebSocket));\n\n  Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,\n      originalRequest, this, eventListener, client.connectTimeoutMillis(),\n      client.readTimeoutMillis(), client.writeTimeoutMillis());\n\n  return chain.proceed(originalRequest);\n}\n```\n\n这里已经不再区分ApplicationInterceptorChain和NetworkInterceptorChain了，统一用RealInterceptorChain去处理:\n\n```\npublic Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,\n    RealConnection connection) throws IOException {\n  ...\n\n  // Call the next interceptor in the chain.\n  RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,\n      connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,\n      writeTimeout);\n  Interceptor interceptor = interceptors.get(index);\n  Response response = interceptor.intercept(next);\n\n  ...\n\n  return response;\n}\n```\n\n这里将cookie处理、缓存处理、网络连接都作为责任链的一部分，比起3.4.0.RC-1之前更加完全的实现了责任链模式。这里有必要讲一下的就是retryAndFollowUpInterceptor, 它是一个RetryAndFollowUpInterceptor实例，它负责重连和重定向我们之前在3.4.0.RC-1之前看到的getResponse的while true就放到了这里来实现。\n\n让我们看看它的整个流程:\n\n\n{% img /OkHttp源码解析/3.png %}\n\n\n这样的实现是不是以前要清晰很多？所有的步骤一目了然，看过原来的版本再看看3.4.0.RC-1重构后的版本，的确有一种眼前一亮的惊艳之感。果然好代码都是需要一点点优化出来的。\n","slug":"OkHttp源码解析","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2uo5003aw3fysz9r6oki"},{"title":"Java自定义注解和动态代理","date":"2016-05-27T11:49:05.000Z","_content":"在学习Retrofit的时候就对它奇特的使用方式感到十分的好奇，为什么定义一个接口，使用\"@GET\",\"@Query\"这些奇怪的注解就能创建出能实际访问服务器的实例出来:\n\n```java\npublic interface GitHubService {\n    @GET(\"/users/{user}/repos\")\n    List<Repo> listRepos(@Path(\"user\") String user);\n}\n\nRestAdapter restAdapter = new RestAdapter.Builder()\n    .setEndpoint(\"https://api.github.com\")\n    .build();\nGitHubService service = restAdapter.create(GitHubService.class);\nList<Repo> repos = service.listRepos(\"octocat\");\n```\n\n尤其是对如何创建一个接口的实例感到万分的好奇，这几天回学校写毕设论文刚好有点空，于是就抽了点时间研究了一下。\n\n# 自定义Java注解\n\n说起Java的注解，大家都能很自然的想起\"@Override\",\"@Deprecated\",\"@Documented\"这些很常用的内置注解。但很多新手应该都不知道其实Java也是支持自定义注解的吧？(反正我以前是不知道的)\n\n## 元注解\n元注解的作用就是负责注解其他注解，Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解：\n\n- @Target\n- @Retention\n- @Documented\n- @Inherited\n\n### @Target\n\n@Target说明了自定义注解的修饰类型，也就是说可以用它来声明自定义注解可以用在什么地方，它的取值范围有：\n\n1. ElementType.CONSTRUCTOR : 用于描述构造器\n1. ElementType.FIELD : 用于描述域\n1. ElementType.LOCAL_VARIABLE : 用于描述局部变量\n1. ElementType.METHOD : 用于描述方法\n1. ElementType.PACKAGE : 用于描述包\n1. ElementType.PARAMETER : 用于描述参数\n1. ElementType.TYPE : 用于描述类、接口(包括注解类型) 或enum声明\n\n例如：\n\n```java\n@Target(ElementType.TYPE)\npublic @interface TypeAnnotation {\n}\n\n@Target(ElementType.METHOD)\npublic @interface MethodAnnotation {\n}\n\n@Target(ElementType.PARAMETER)\npublic @interface ParamAnnotation {\n}\n```\n\nTypeAnnotation可以用来修饰描述类、接口(包括注解类型) 或enum声明，MethodAnnotation可以用来修饰方法，ParamAnnotation可以用来修饰参数：\n\n```java\n@TypeAnnotation\npublic interface MyInterface {\n\t@MethodAnnotation\n\tpublic void func(@ParamAnnotation String param);\n}\n```\n\n## @Retention\n\n@Retention 定义了自定义注解的生命长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。\n\n它的取值有下面这些：\n\n1. RetentionPolicy.SOURCE : 在源文件中有效（即源文件保留）\n1. RetentionPolicy.CLASS : 在class文件中有效（即class保留）\n1. RetentionPolicy.RUNTIME : 时有效（即运行时保留）\n\n注解也是可以保存数据的，如value属性就是默认的数据保存属性:\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MethodAnnotation {\n\tString value() default \"default value\";\n}\n\npublic class ClassA{\n\t@MethodAnnotation()\n\tpublic void func1(){}\n    \n\t@MethodAnnotation(\"data\")\n\tpublic void func2(){}\n}\n\n```\n\n比如可以在程序运行的时候（因为声明了@Retention(RetentionPolicy.RUNTIME)）通过反射获取上面的ClassA.func1的注解MethodAnnotation保存的数据（默认值\"default value\"）和ClassA.func2的注解MethodAnnotation保存的数据（\"data\"）\n\n当然如果只能保持一个数据限制就太大了，你可以定义多个数据：\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MethodAnnotation {\n\tpublic enum EnumData{ DATA1, DATA2, DATA3};\n\t\n\tString data1();\n\tint data2() default 0xffff;\n\tEnumData data3() default EnumData.DATA1;\n}\n\npublic class ClassA{\n\t@MethodAnnotation(data1=\"data1\")\n\tpublic void func1(){}\n    \n\t@MethodAnnotation(data1=\"data1\", data2=0, data3=MethodAnnotation.EnumData.DATA1)\n\tpublic void func2(){}\n}\n```\n\n当属性没有用default指定默认值得时候在使用的时候必须由用户设置属性值（如这里的data1）\n\n注解参数的可支持数据类型：\n\n1.所有基本数据类型（int,float,boolean,byte,double,char,long,short)\n2.String类型\n3.Class类型\n4.enum类型\n5.Annotation类型\n6.以上所有类型的数组\n\n\n## @Inherited\n\n@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。\n\n# Java动态代理\n\n我知道可以用反射调用方法甚至创建对象，但我还真的没有想到怎样创建出一个接口的实例。用了各种形容方式之后终于找到了这种技术的专业名称:\"动态代理\"，下面是一个简单的例子：\n\n```java\npublic interface MyInterface{\n\tvoid func();\n}\n\npublic class MyHandler implements InvocationHandler{\n\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.print(\"call : \" + method.getName());\n\t\treturn null;\n\t}\n}\n\n\npublic static void main(String[] args){\n\t\tMyInterface myInterface = (MyInterface)Proxy.newProxyInstance(\n        \t\t MyInterface.class.getClassLoader(), \n\t\t\t     new Class[]{MyInterface.class}, \n\t\t\t     new MyHandler());\n\t\tmyInterface.func();\n}\n```\n\n这个例子的输出为：\n\n> call : func\n\n通过实现InvocationHandler接口，定义自己的handler类，再使用Proxy.newProxyInstance就可以实例化出一个接口的实例。当调用接口的方法的时候，InvocationHandler接口的invoke方法就会被调用，可以在这里编写实际的功能代码。\n\n当然也能将创建实例的代码抽象出来，实现复用：\n\n```java\nprivate static <T>T newProxyInstance(Class<T> c){\n\t\treturn (T)Proxy.newProxyInstance(\n\t\t\t\tc.getClassLoader(),\n\t\t\t\tnew Class<?>[]{c},\n\t\t\t\tnew DataBaseHalder(c));\n\t}\n    \npublic static void main(String[] args){\n    //使用方式\n    MyInterface myInterface = (MyInterface)newProxyInstance(MyInterface.class, new MyHandler());\n\tmyInterface.func();\n}\n```\n\n# 通过反射获取注解保存的数据\n- 通过Class.getAnnotation(XXXAnnotation.class)可以获取到方法的ElementType.METHOD或者类ElementType.TYPE类型的注解\n- 通过 Method.getParameterAnnotations()可以获取到方法各个参数的注解（ElementType.PARAMETER类型）\n\n这部分用代码来解释最直接了：\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface TypeAnnotation {\n\tString value();\n}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MethodAnnotation {\n\tString value();\n}\n\n@Target(ElementType.PARAMETER)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ParamAnnotation {\n\tString value();\n}\n\n@TypeAnnotation(\"interface MyInterface\")\npublic interface MyInterface{\n\t@MethodAnnotation(\"MyInterface.func\")\n\tvoid func(@ParamAnnotation(\"param1\") String a, @ParamAnnotation(\"param2\") int b);\n}\n\npublic class MyHandler implements InvocationHandler{\n\tprivate Class mClass;\n\t\n\tMyHandler(Class c){\n\t\tmClass = c;\n\t\tTypeAnnotation typeAnnotation = (TypeAnnotation) mClass.getAnnotation(TypeAnnotation.class);\n\t\tSystem.out.print(\"TypeAnnotation : \" + typeAnnotation.value() + \"\\n\");\n\t}\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\t\n\t\tMethodAnnotation methodAnnotation = (MethodAnnotation)method.getAnnotation(MethodAnnotation.class);\n\t\tSystem.out.print(\"MethodAnnotation : \" + methodAnnotation.value() + \"\\n\");\n\n\t\tClass[] parameterTypes = method.getParameterTypes();\n\t\tAnnotation[][] parameterAnnotations = method.getParameterAnnotations();\n\t\tfor(int i = 0; i< parameterAnnotations.length ; i++){\n\t\t\tClass type = parameterTypes[i];\n\t\t\tfor(Annotation annotation : parameterAnnotations[i]){\n\t\t\t\tif(annotation instanceof ParamAnnotation){\n\t\t\t\t\tParamAnnotation paramAnnotation = (ParamAnnotation) annotation;\n\t\t\t\t\tSystem.out.print(paramAnnotation.value() + \" - \" + args[i]  + \"[\" + type.getName() + \"]\"+ \"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n}\n\n//调用\npublic static void main(String[] args){\n\t\tMyInterface myInterface = (MyInterface)Proxy.newProxyInstance(\n\t\t\t\tMyInterface.class.getClassLoader(), \n\t\t\t\tnew Class<?>[]{MyInterface.class},\n\t\t\t\tnew MyHandler(MyInterface.class));\n\t\tmyInterface.func(\"data1\",123);\n}\n```\n\n输出如下：\n\n> TypeAnnotation : interface MyInterface\n> MethodAnnotation : MyInterface.func\n> param1 - data1[java.lang.String]\n> param2 - 123[int]\n\n这里最难理解的就是这两行代码：\n\n```java\nClass[] parameterTypes = method.getParameterTypes();\nAnnotation[][] parameterAnnotations = method.getParameterAnnotations();\n```\n\nmethod.getParameterTypes() 可以获取到参数的类型，而method.getParameterAnnotations()则获取到一个二维数组，它保存了所有变量的全部注解。\n\n# 一个简单的应用实例\n\n用过Retrofit的人都知道，这种动态代理技术在框架搭建完成之后，使用起来便十分的便利了，有兴趣的同学可以去看看Retrofit的相关资料。我这里再写一个模拟操作数据库的小例子，展示一下这种框架的便捷性。\n\n首先是接口的定义：\n\n```java\n@DataBase(database=\"SchoolSystem\", username=\"root\", password=\"123456\", ip=\"localhost\")\npublic interface IDataBaseOperation {\n\t@Table(\"Student\")\n\t@Column({\"name\",\"age\",\"sex\"})\n\tList<Map<String,String>> getStudentByName(@Condition(\"name\")String name);\n\t\n\t@Table(\"Student\")\n\t@Column({\"name\",\"age\",\"sex\"})\n\tList<Map<String,String>> getStudentOlder(@Condition(value=\"age\",compare=\">\")int age);\n\n\t@Table(\"Student\")\n\t@Column({\"name\",\"age\",\"sex\"})\n\tList<Map<String,String>> getStudentBySexAndAge(@Condition(\"sex\")String sex, @Condition(\"age\")int age);\n\t\n\t@Table(\"Teacher join Course on Teacher.id=Course.teacher\")\n\t@Column({\"Course.name\"})\n\tList<Map<String,String>> getCourseByTeacher(@Condition(\"Teacher.name\")String teacher);\n}\n```\n\n让我们先跳过实现细节，直接看它的用法：\n\n```java\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tIDataBaseOperation oprBaseOperation = newProxyInstance(IDataBaseOperation.class, new DataBaseHalder(IDataBaseOperation.class));\n\n\t\toprBaseOperation.getStudentByName(\"小红\");\n\t\toprBaseOperation.getStudentOlder(12);\n\t\toprBaseOperation.getStudentBySexAndAge(\"男\", 12);\n\t\toprBaseOperation.getCourseByTeacher(\"李老师\");\n\t}\n\t\n\tprivate static <T>T newProxyInstance(Class<T> c, InvocationHandler handler){\n\t\treturn (T)Proxy.newProxyInstance(\n\t\t\t\tc.getClassLoader(), \n\t\t\t\tnew Class<?>[]{c},\n\t\t\t\thandler);\n\t}\n}\n```\n\n这样我们就能看到这样的输出:\n\n> ===================================\n> \n> connect database : \n> ip : localhost\n> username : root\n> password : 123456\n> database : SchoolSystem\n>\n>===================================\n> select name,age,sex from Student where name = \"小红\";\n> select name,age,sex from Student where age > 12;\n> select name,age,sex from Student where sex = \"男\" and age = 12;\n> select Course.name from Teacher join Course on Teacher.id=Course.teacher where > > > Teacher.name = \"李老师\";\n\n这里没有真的去做数据库操作，只是用打印的方法模拟了一下，但如果真的要实现的话也是不难的。\n\n但从这几处使用代码来看，这个框架的是十分易用的，如果我们想要增加一个查询操作的话，只需要在IDataBaseOperation接口声明多一个方法，然后直接就能在得到实例后使用了。\n\n最后将一些细节代码也贴上来：\n\n```java\n//Column.java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Column {\n\tString[] value();\n}\n```\n\n```java\n//Condition.java\n@Target(ElementType.PARAMETER)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Condition {\n\tpublic String value();\n\tpublic String compare() default \"=\";\n}\n```\n\n```java\n//Table.java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Table {\n\tString value();\n}\n```\n\n```java\n//DataBase.java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface DataBase {\n\tString ip();\n\tString database();\n\tString username();\n\tString password();\n}\n```\n\n```java\n//DataBaseHalder.java\npublic class DataBaseHalder implements InvocationHandler{\n\tprivate Class mInterface;\n\t\n\tpublic DataBaseHalder(Class object){\n\t\tmInterface = object;\n\t\t\n\t\tDataBase db = (DataBase) mInterface.getAnnotation(DataBase.class);\n\n\t\tSystem.out.print(\"===================================\\n\");\n\t\tSystem.out.print(\"connect database : \\n\");\n\t\tSystem.out.print(\"ip : \" + db.ip() + \"\\n\");\n\t\tSystem.out.print(\"username : \" + db.username() + \"\\n\");\n\t\tSystem.out.print(\"password : \" + db.password() + \"\\n\");\n\t\tSystem.out.print(\"database : \" + db.database() + \"\\n\");\n\t\tSystem.out.print(\"===================================\\n\");\n\t\t\n\t}\n\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\t\n\t\tif(method.getName().matches(\"^get.*\")){\n\t\t\tString sql =  \"select \" + getColumns(method) + \" from \" + getTable(method) \n\t\t\t\t\t+ \" where \" + getCondition(method, args) + \";\";\n\t\t\tSystem.out.print(sql + \"\\n\");\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tprivate String getTable(Method method){\n\t\treturn method.getAnnotation(Table.class).value();\n\t}\n\t\n\tprivate String getColumns(Method method){\n\t\tString result = \"\";\n\t\tString conn = \"\";\n\t\tfor (String col : method.getAnnotation(Column.class).value()) {\n\t\t\tresult += conn + col;\n\t\t\tconn = \",\";\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate String getCondition(Method method, Object[] args) {\n\t\tString result = \"\";\n\t\tString andConnect = \"\";\n\t\tClass[] parameterTypes = method.getParameterTypes();\n\n\t\tAnnotation[][] parameterAnnotations = method.getParameterAnnotations();\n\t\tfor(int i = 0; i< parameterAnnotations.length ; i++){\n\t\t\tClass type = parameterTypes[i];\n\t\t\tfor(Annotation annotation : parameterAnnotations[i]){\n\t\t\t\tif(annotation instanceof Condition){\n\t\t\t\t\tresult += andConnect + parseCondition(type, args[i], (Condition) annotation);\n\t\t\t\t\tandConnect = \" and \";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate String parseCondition(Class argType, Object arg, Annotation annotation){\n\t\tCondition condition = (Condition) annotation;\n\t\tString result = condition.value() + \" \" + condition.compare() + \" \";\n\t\tif(argType == String.class){\n\t\t\tresult += \"\\\"\" + arg + \"\\\"\";\n\t\t}else{\n\t\t\tresult += arg;\n\t\t}\n\t\treturn result;\n\t}\n}\n```\n\n# 另外的一个实用的小例子\n\n相信做安卓的同学都遇到过在Activity.onCreate初始化的时候写一大堆的findViewById吧？这种重复性的无趣工作其实也可以用注解来简化：\n\n```java\npublic @interface ViewField {\n    int value();\n\n    public static class Processor{\n        public static void process(Activity activity) throws IllegalAccessException {\n            Field[] fields = activity.getClass().getDeclaredFields();\n            ViewField ann = null;\n            for (Field field : fields) {\n                ann = field.getAnnotation(ViewField.class);\n                if (ann!=null){\n                    field.setAccessible(true);\n                    field.set(activity, activity.findViewById(ann.value()));\n                }\n            }\n        }\n    }\n}\n```\n\n然后我们的Activity就可以这样写来让注解自动初始化View变量了：\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    @ViewField(R.id.text)\n    private TextView mTextView;\n\n    @ViewField(R.id.button)\n    private Button mButton;\n\n    @ViewField(R.id.image)\n    private ImageView mImageView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        try {\n            ViewField.Processor.process(this);\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n\n        mTextView.setText(\"text\");\n        mButton.setText(\"button\");\n        mImageView.setImageResource(R.mipmap.ic_launcher);\n    }\n}\n```\n\n当然有人说用注解，效率会很低。但我觉得这里的额外消耗其实根本不起眼，用这点小损耗换来编码的便利性是很值得的。但如果真的很在意，也能用下面的泛型方法简化findViewById操作：\n\n```java\nprotected <T extends View> T generateFindViewById(int id) {\n\t//return返回view时,加上泛型T\n\treturn (T) findViewById(id);\n}\nmButton = generateFindViewById(R.id.button);\n```\n\n这样能减少强制转换的操作，但编写效率还是不如用注解。\n","source":"_posts/Java自定义注解和动态代理.md","raw":"title: Java自定义注解和动态代理\ndate: 2016-05-27 19:49:05\ntags:\n\t- 技术相关\n\t- java\n---\n在学习Retrofit的时候就对它奇特的使用方式感到十分的好奇，为什么定义一个接口，使用\"@GET\",\"@Query\"这些奇怪的注解就能创建出能实际访问服务器的实例出来:\n\n```java\npublic interface GitHubService {\n    @GET(\"/users/{user}/repos\")\n    List<Repo> listRepos(@Path(\"user\") String user);\n}\n\nRestAdapter restAdapter = new RestAdapter.Builder()\n    .setEndpoint(\"https://api.github.com\")\n    .build();\nGitHubService service = restAdapter.create(GitHubService.class);\nList<Repo> repos = service.listRepos(\"octocat\");\n```\n\n尤其是对如何创建一个接口的实例感到万分的好奇，这几天回学校写毕设论文刚好有点空，于是就抽了点时间研究了一下。\n\n# 自定义Java注解\n\n说起Java的注解，大家都能很自然的想起\"@Override\",\"@Deprecated\",\"@Documented\"这些很常用的内置注解。但很多新手应该都不知道其实Java也是支持自定义注解的吧？(反正我以前是不知道的)\n\n## 元注解\n元注解的作用就是负责注解其他注解，Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解：\n\n- @Target\n- @Retention\n- @Documented\n- @Inherited\n\n### @Target\n\n@Target说明了自定义注解的修饰类型，也就是说可以用它来声明自定义注解可以用在什么地方，它的取值范围有：\n\n1. ElementType.CONSTRUCTOR : 用于描述构造器\n1. ElementType.FIELD : 用于描述域\n1. ElementType.LOCAL_VARIABLE : 用于描述局部变量\n1. ElementType.METHOD : 用于描述方法\n1. ElementType.PACKAGE : 用于描述包\n1. ElementType.PARAMETER : 用于描述参数\n1. ElementType.TYPE : 用于描述类、接口(包括注解类型) 或enum声明\n\n例如：\n\n```java\n@Target(ElementType.TYPE)\npublic @interface TypeAnnotation {\n}\n\n@Target(ElementType.METHOD)\npublic @interface MethodAnnotation {\n}\n\n@Target(ElementType.PARAMETER)\npublic @interface ParamAnnotation {\n}\n```\n\nTypeAnnotation可以用来修饰描述类、接口(包括注解类型) 或enum声明，MethodAnnotation可以用来修饰方法，ParamAnnotation可以用来修饰参数：\n\n```java\n@TypeAnnotation\npublic interface MyInterface {\n\t@MethodAnnotation\n\tpublic void func(@ParamAnnotation String param);\n}\n```\n\n## @Retention\n\n@Retention 定义了自定义注解的生命长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。\n\n它的取值有下面这些：\n\n1. RetentionPolicy.SOURCE : 在源文件中有效（即源文件保留）\n1. RetentionPolicy.CLASS : 在class文件中有效（即class保留）\n1. RetentionPolicy.RUNTIME : 时有效（即运行时保留）\n\n注解也是可以保存数据的，如value属性就是默认的数据保存属性:\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MethodAnnotation {\n\tString value() default \"default value\";\n}\n\npublic class ClassA{\n\t@MethodAnnotation()\n\tpublic void func1(){}\n    \n\t@MethodAnnotation(\"data\")\n\tpublic void func2(){}\n}\n\n```\n\n比如可以在程序运行的时候（因为声明了@Retention(RetentionPolicy.RUNTIME)）通过反射获取上面的ClassA.func1的注解MethodAnnotation保存的数据（默认值\"default value\"）和ClassA.func2的注解MethodAnnotation保存的数据（\"data\"）\n\n当然如果只能保持一个数据限制就太大了，你可以定义多个数据：\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MethodAnnotation {\n\tpublic enum EnumData{ DATA1, DATA2, DATA3};\n\t\n\tString data1();\n\tint data2() default 0xffff;\n\tEnumData data3() default EnumData.DATA1;\n}\n\npublic class ClassA{\n\t@MethodAnnotation(data1=\"data1\")\n\tpublic void func1(){}\n    \n\t@MethodAnnotation(data1=\"data1\", data2=0, data3=MethodAnnotation.EnumData.DATA1)\n\tpublic void func2(){}\n}\n```\n\n当属性没有用default指定默认值得时候在使用的时候必须由用户设置属性值（如这里的data1）\n\n注解参数的可支持数据类型：\n\n1.所有基本数据类型（int,float,boolean,byte,double,char,long,short)\n2.String类型\n3.Class类型\n4.enum类型\n5.Annotation类型\n6.以上所有类型的数组\n\n\n## @Inherited\n\n@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。\n\n# Java动态代理\n\n我知道可以用反射调用方法甚至创建对象，但我还真的没有想到怎样创建出一个接口的实例。用了各种形容方式之后终于找到了这种技术的专业名称:\"动态代理\"，下面是一个简单的例子：\n\n```java\npublic interface MyInterface{\n\tvoid func();\n}\n\npublic class MyHandler implements InvocationHandler{\n\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.print(\"call : \" + method.getName());\n\t\treturn null;\n\t}\n}\n\n\npublic static void main(String[] args){\n\t\tMyInterface myInterface = (MyInterface)Proxy.newProxyInstance(\n        \t\t MyInterface.class.getClassLoader(), \n\t\t\t     new Class[]{MyInterface.class}, \n\t\t\t     new MyHandler());\n\t\tmyInterface.func();\n}\n```\n\n这个例子的输出为：\n\n> call : func\n\n通过实现InvocationHandler接口，定义自己的handler类，再使用Proxy.newProxyInstance就可以实例化出一个接口的实例。当调用接口的方法的时候，InvocationHandler接口的invoke方法就会被调用，可以在这里编写实际的功能代码。\n\n当然也能将创建实例的代码抽象出来，实现复用：\n\n```java\nprivate static <T>T newProxyInstance(Class<T> c){\n\t\treturn (T)Proxy.newProxyInstance(\n\t\t\t\tc.getClassLoader(),\n\t\t\t\tnew Class<?>[]{c},\n\t\t\t\tnew DataBaseHalder(c));\n\t}\n    \npublic static void main(String[] args){\n    //使用方式\n    MyInterface myInterface = (MyInterface)newProxyInstance(MyInterface.class, new MyHandler());\n\tmyInterface.func();\n}\n```\n\n# 通过反射获取注解保存的数据\n- 通过Class.getAnnotation(XXXAnnotation.class)可以获取到方法的ElementType.METHOD或者类ElementType.TYPE类型的注解\n- 通过 Method.getParameterAnnotations()可以获取到方法各个参数的注解（ElementType.PARAMETER类型）\n\n这部分用代码来解释最直接了：\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface TypeAnnotation {\n\tString value();\n}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MethodAnnotation {\n\tString value();\n}\n\n@Target(ElementType.PARAMETER)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ParamAnnotation {\n\tString value();\n}\n\n@TypeAnnotation(\"interface MyInterface\")\npublic interface MyInterface{\n\t@MethodAnnotation(\"MyInterface.func\")\n\tvoid func(@ParamAnnotation(\"param1\") String a, @ParamAnnotation(\"param2\") int b);\n}\n\npublic class MyHandler implements InvocationHandler{\n\tprivate Class mClass;\n\t\n\tMyHandler(Class c){\n\t\tmClass = c;\n\t\tTypeAnnotation typeAnnotation = (TypeAnnotation) mClass.getAnnotation(TypeAnnotation.class);\n\t\tSystem.out.print(\"TypeAnnotation : \" + typeAnnotation.value() + \"\\n\");\n\t}\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\t\n\t\tMethodAnnotation methodAnnotation = (MethodAnnotation)method.getAnnotation(MethodAnnotation.class);\n\t\tSystem.out.print(\"MethodAnnotation : \" + methodAnnotation.value() + \"\\n\");\n\n\t\tClass[] parameterTypes = method.getParameterTypes();\n\t\tAnnotation[][] parameterAnnotations = method.getParameterAnnotations();\n\t\tfor(int i = 0; i< parameterAnnotations.length ; i++){\n\t\t\tClass type = parameterTypes[i];\n\t\t\tfor(Annotation annotation : parameterAnnotations[i]){\n\t\t\t\tif(annotation instanceof ParamAnnotation){\n\t\t\t\t\tParamAnnotation paramAnnotation = (ParamAnnotation) annotation;\n\t\t\t\t\tSystem.out.print(paramAnnotation.value() + \" - \" + args[i]  + \"[\" + type.getName() + \"]\"+ \"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n}\n\n//调用\npublic static void main(String[] args){\n\t\tMyInterface myInterface = (MyInterface)Proxy.newProxyInstance(\n\t\t\t\tMyInterface.class.getClassLoader(), \n\t\t\t\tnew Class<?>[]{MyInterface.class},\n\t\t\t\tnew MyHandler(MyInterface.class));\n\t\tmyInterface.func(\"data1\",123);\n}\n```\n\n输出如下：\n\n> TypeAnnotation : interface MyInterface\n> MethodAnnotation : MyInterface.func\n> param1 - data1[java.lang.String]\n> param2 - 123[int]\n\n这里最难理解的就是这两行代码：\n\n```java\nClass[] parameterTypes = method.getParameterTypes();\nAnnotation[][] parameterAnnotations = method.getParameterAnnotations();\n```\n\nmethod.getParameterTypes() 可以获取到参数的类型，而method.getParameterAnnotations()则获取到一个二维数组，它保存了所有变量的全部注解。\n\n# 一个简单的应用实例\n\n用过Retrofit的人都知道，这种动态代理技术在框架搭建完成之后，使用起来便十分的便利了，有兴趣的同学可以去看看Retrofit的相关资料。我这里再写一个模拟操作数据库的小例子，展示一下这种框架的便捷性。\n\n首先是接口的定义：\n\n```java\n@DataBase(database=\"SchoolSystem\", username=\"root\", password=\"123456\", ip=\"localhost\")\npublic interface IDataBaseOperation {\n\t@Table(\"Student\")\n\t@Column({\"name\",\"age\",\"sex\"})\n\tList<Map<String,String>> getStudentByName(@Condition(\"name\")String name);\n\t\n\t@Table(\"Student\")\n\t@Column({\"name\",\"age\",\"sex\"})\n\tList<Map<String,String>> getStudentOlder(@Condition(value=\"age\",compare=\">\")int age);\n\n\t@Table(\"Student\")\n\t@Column({\"name\",\"age\",\"sex\"})\n\tList<Map<String,String>> getStudentBySexAndAge(@Condition(\"sex\")String sex, @Condition(\"age\")int age);\n\t\n\t@Table(\"Teacher join Course on Teacher.id=Course.teacher\")\n\t@Column({\"Course.name\"})\n\tList<Map<String,String>> getCourseByTeacher(@Condition(\"Teacher.name\")String teacher);\n}\n```\n\n让我们先跳过实现细节，直接看它的用法：\n\n```java\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tIDataBaseOperation oprBaseOperation = newProxyInstance(IDataBaseOperation.class, new DataBaseHalder(IDataBaseOperation.class));\n\n\t\toprBaseOperation.getStudentByName(\"小红\");\n\t\toprBaseOperation.getStudentOlder(12);\n\t\toprBaseOperation.getStudentBySexAndAge(\"男\", 12);\n\t\toprBaseOperation.getCourseByTeacher(\"李老师\");\n\t}\n\t\n\tprivate static <T>T newProxyInstance(Class<T> c, InvocationHandler handler){\n\t\treturn (T)Proxy.newProxyInstance(\n\t\t\t\tc.getClassLoader(), \n\t\t\t\tnew Class<?>[]{c},\n\t\t\t\thandler);\n\t}\n}\n```\n\n这样我们就能看到这样的输出:\n\n> ===================================\n> \n> connect database : \n> ip : localhost\n> username : root\n> password : 123456\n> database : SchoolSystem\n>\n>===================================\n> select name,age,sex from Student where name = \"小红\";\n> select name,age,sex from Student where age > 12;\n> select name,age,sex from Student where sex = \"男\" and age = 12;\n> select Course.name from Teacher join Course on Teacher.id=Course.teacher where > > > Teacher.name = \"李老师\";\n\n这里没有真的去做数据库操作，只是用打印的方法模拟了一下，但如果真的要实现的话也是不难的。\n\n但从这几处使用代码来看，这个框架的是十分易用的，如果我们想要增加一个查询操作的话，只需要在IDataBaseOperation接口声明多一个方法，然后直接就能在得到实例后使用了。\n\n最后将一些细节代码也贴上来：\n\n```java\n//Column.java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Column {\n\tString[] value();\n}\n```\n\n```java\n//Condition.java\n@Target(ElementType.PARAMETER)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Condition {\n\tpublic String value();\n\tpublic String compare() default \"=\";\n}\n```\n\n```java\n//Table.java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Table {\n\tString value();\n}\n```\n\n```java\n//DataBase.java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface DataBase {\n\tString ip();\n\tString database();\n\tString username();\n\tString password();\n}\n```\n\n```java\n//DataBaseHalder.java\npublic class DataBaseHalder implements InvocationHandler{\n\tprivate Class mInterface;\n\t\n\tpublic DataBaseHalder(Class object){\n\t\tmInterface = object;\n\t\t\n\t\tDataBase db = (DataBase) mInterface.getAnnotation(DataBase.class);\n\n\t\tSystem.out.print(\"===================================\\n\");\n\t\tSystem.out.print(\"connect database : \\n\");\n\t\tSystem.out.print(\"ip : \" + db.ip() + \"\\n\");\n\t\tSystem.out.print(\"username : \" + db.username() + \"\\n\");\n\t\tSystem.out.print(\"password : \" + db.password() + \"\\n\");\n\t\tSystem.out.print(\"database : \" + db.database() + \"\\n\");\n\t\tSystem.out.print(\"===================================\\n\");\n\t\t\n\t}\n\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\t\n\t\tif(method.getName().matches(\"^get.*\")){\n\t\t\tString sql =  \"select \" + getColumns(method) + \" from \" + getTable(method) \n\t\t\t\t\t+ \" where \" + getCondition(method, args) + \";\";\n\t\t\tSystem.out.print(sql + \"\\n\");\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tprivate String getTable(Method method){\n\t\treturn method.getAnnotation(Table.class).value();\n\t}\n\t\n\tprivate String getColumns(Method method){\n\t\tString result = \"\";\n\t\tString conn = \"\";\n\t\tfor (String col : method.getAnnotation(Column.class).value()) {\n\t\t\tresult += conn + col;\n\t\t\tconn = \",\";\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate String getCondition(Method method, Object[] args) {\n\t\tString result = \"\";\n\t\tString andConnect = \"\";\n\t\tClass[] parameterTypes = method.getParameterTypes();\n\n\t\tAnnotation[][] parameterAnnotations = method.getParameterAnnotations();\n\t\tfor(int i = 0; i< parameterAnnotations.length ; i++){\n\t\t\tClass type = parameterTypes[i];\n\t\t\tfor(Annotation annotation : parameterAnnotations[i]){\n\t\t\t\tif(annotation instanceof Condition){\n\t\t\t\t\tresult += andConnect + parseCondition(type, args[i], (Condition) annotation);\n\t\t\t\t\tandConnect = \" and \";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate String parseCondition(Class argType, Object arg, Annotation annotation){\n\t\tCondition condition = (Condition) annotation;\n\t\tString result = condition.value() + \" \" + condition.compare() + \" \";\n\t\tif(argType == String.class){\n\t\t\tresult += \"\\\"\" + arg + \"\\\"\";\n\t\t}else{\n\t\t\tresult += arg;\n\t\t}\n\t\treturn result;\n\t}\n}\n```\n\n# 另外的一个实用的小例子\n\n相信做安卓的同学都遇到过在Activity.onCreate初始化的时候写一大堆的findViewById吧？这种重复性的无趣工作其实也可以用注解来简化：\n\n```java\npublic @interface ViewField {\n    int value();\n\n    public static class Processor{\n        public static void process(Activity activity) throws IllegalAccessException {\n            Field[] fields = activity.getClass().getDeclaredFields();\n            ViewField ann = null;\n            for (Field field : fields) {\n                ann = field.getAnnotation(ViewField.class);\n                if (ann!=null){\n                    field.setAccessible(true);\n                    field.set(activity, activity.findViewById(ann.value()));\n                }\n            }\n        }\n    }\n}\n```\n\n然后我们的Activity就可以这样写来让注解自动初始化View变量了：\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    @ViewField(R.id.text)\n    private TextView mTextView;\n\n    @ViewField(R.id.button)\n    private Button mButton;\n\n    @ViewField(R.id.image)\n    private ImageView mImageView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        try {\n            ViewField.Processor.process(this);\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n\n        mTextView.setText(\"text\");\n        mButton.setText(\"button\");\n        mImageView.setImageResource(R.mipmap.ic_launcher);\n    }\n}\n```\n\n当然有人说用注解，效率会很低。但我觉得这里的额外消耗其实根本不起眼，用这点小损耗换来编码的便利性是很值得的。但如果真的很在意，也能用下面的泛型方法简化findViewById操作：\n\n```java\nprotected <T extends View> T generateFindViewById(int id) {\n\t//return返回view时,加上泛型T\n\treturn (T) findViewById(id);\n}\nmButton = generateFindViewById(R.id.button);\n```\n\n这样能减少强制转换的操作，但编写效率还是不如用注解。\n","slug":"Java自定义注解和动态代理","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2uo7003dw3fyjum8ri7q"},{"title":"Java多线程 - 线程池","date":"2017-09-04T16:01:48.000Z","_content":"\n这篇文章大部分都是直接摘抄自《实战Java高并发程序设计》,基本上就是一篇笔记,用于以后忘了的时候可以回顾。\n\n# 框架提供的ExecutorService\n\nExecutors框架提供了各种类型的线程池,主要有以下工厂方法:\n\n```\npublic static ExecutorService newFixedThreadPool(int nThreads) \npublic static ExecutorService newSingleThreadExecutor()\npublic static ExecutorService newCachedThreadPool()\npublic static ScheduledExecutorService newSingleThreadScheduledExecutor()\npublic static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)\n```\n\n- newFixedThreadPool()方法. 该方法返回一个固定线程数量的线程池,该线程池中的线程数量始终不变,当有一个新任务时,线程池中若有空闲线程,则立即执行,若没有,则新任务会被暂时存在一个队列中,得有空闲线程时,便处理在任务队列中的任务\n\n- newSingleThreadExecutor()方法,改方法返回一个只有一个线程的线程池,若多余一个任务被提交到该线程池,任务会被保存在一个队伍队列,带线程空闲,按先入先出的顺序执行队列中的任务,\n\n- newCachedThreadPool()方法,该方法返回一个可根据实际情况调整线程数量的线程池.线程池数量是不确定的,但若有空闲线程可以复用,则会优先使用可以复用的线程,若所有线程均在工作,又有新的任务提交,则会创建新的线程处理任务,所有线程在当前任务执行完毕后,将返回线程池进行复用,\n\n- newSingleThreadScheduledExecutor()方法: 改方法返回一个ScheduledExecutorService对象,线程池大小为1 这个接口在ExecutorService接口之上拓展了在给定时间执行某任务的功能,如在某个固定的延时之后执行,或者周期性执行某个任务.\n\n- newScheduledThreadPool()方法:改方法也返回一个ScheduledExecutorService对象 但改线程池可以指定线程数量\n\n前面三个工厂方法创建的ExecutorService只需要使用ExecutorService.execute()方法或者submit()方法将需要执行的任务传入即可,这里就不细讲了。关于这两个方法的差异我会在后面细说,这里也不展开讨论了。\n\n后面两个工厂方法会创建ScheduledExecutorService。它有会多出下面三个schedule方法用于延迟执行任务:\n\n```\npublic ScheduledFuture<?> schedule(Runnable command,\n                                   long delay, TimeUnit unit);\npublic ScheduledFuture<?> scheduleAtFixedRate(Runnable command,\n                                              long initialDelay,\n                                              long period,\n                                              TimeUnit unit);\npublic ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,\n                                                 long initialDelay,\n                                                 long delay,\n                                                 TimeUnit unit);\n```\n\nschedule()方法会在给定时间,对方法进行一次调度。scheduleAtFixedRate()方法和scheduleWithFixedDelay()会对任务进行周期性调度。但两者有一点小小的差别:\n\n{% img /Java多线程-线程池/1.png %}\n\n对于FixedRate方式来说,任务调度的频率是一样的。它是以上一个任务开始执行时间为起点,之后的period时间,调度下一次任务。而FixDelay则是在上一个任务结束后,再经过delay时间进行任务调度。\n\n# ThreadPoolExecutor\n\n对于Executors.newFixedThreadPool()、Executors.newSingleThreadExecutor()、Executors.newCachedThreadPool()这几个方法虽然创建的线程池的功能特点完全不一样,但是他们其实都是使用了ThreadPoolExecutor实现:\n\n```\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\n    \npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue<Runnable>()));\n}\n\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue<Runnable>());\n}\n```\n\nThreadPoolExecutor的最重要的构造函数如下:\n\n```\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler)  \n```\n\n- corePoolSize: 指定了线程池中的线程数量\n- maximumPoolSize: 指定了线程池中的最大线程数量\n- keepAliveTime: 当线程池线程数量超过corePoolSize时,多余的空闲线程的存活时间。即,超过corePoolSize的空闲线程,在多长的时间内,会被销毁。\n- unit: keepAliveTime的时间单位\n- workQueue: 被提交但未被执行的任务\n- threadFactory: 线程工厂,用于创建线程,一般用默认即可\n- handler: 拒绝策略。但任务太多来不及处理,如何拒绝任务\n\n以上参数中,大部分都很简单,只有workQueue和handler需要说一下。\n\n内置的BlockingQueue有下面几种:\n\n- SynchronousQueue: 一个没有容量的队列。使用SynchronousQueue,提交的任务不会真正的被保存,而总是将新任务提交给线程执行。如果没有空闲线程,就创建新线程,如果线程数量已经到达最大值,则执行拒绝策略\n\n- ArrayBlockingQueue: 有界任务队列,若有新的任务需要执行,如果实际线程数少于corePoolSize则创建新的线程,如果大于corePoolSize,就会放入ArrayBlockingQueue中,如果ArrayBlockingQueue已满,在总线程数不大于maximumPoolSize的情况下会创建新线程,否则就执行拒绝策略\n\n- LinkedBlockingQueue: 无界任务队列,若有新的任务需要执行,如果实际线程数少于corePoolSize则创建新的线程,如果大于corePoolSize,就会放入LinkedBlockingQueue中等待\n\n- PriorityBlockingQueue: 它是一个特殊的无界队列,可以设定任务的优先级\n\n而内置的拒绝策略又有下面几种:\n\n- AbortPolicy策略: 该策略会直接抛出异常,阻止系统正常工作\n- CallerRunsPolicy策略: 只要线程池没有关闭,该策略直接在调用者线程中运行被拒绝的任务。(使用这个策略可能导致在主线程执行耗时操作)\n- DiscardOldestPolicy策略: 该策略丢弃一个最老的任务,并尝试重新提交任务\n- DiscardPolicy策略: 该策略默默丢弃拒绝的任务,不做任何处理。\n\n\n线程池任务调度的逻辑如下图所示:\n\n\n{% img /Java多线程-线程池/2.png %}\n\n# execute和submit的区别\n\nExecutorService.execute()和ExecutorService.submit()都可以提交任务去异步执行,但是它们之间有什么区别呢？\n\n```\nvoid execute(Runnable command);\nFuture<?> submit(Runnable task);\n<T> Future<T> submit(Callable<T> task);\n```\n\n- 返回值\n\nExecutorService.execute()没有返回值,只能简单的提交Runnable给线程池去运行\n\nExecutorService.submit(),有返回值,可以获得一个Future\n\n- 异常\n\nExecutorService.execute()的异常机制和普通线程的异常机制一样,必须用try、catch来捕获异常。如果没有捕获一些运行时异常,也会打印出堆栈信息:\n\n```\nExecutors.newCachedThreadPool().execute(\n        new Runnable() {\n            @Override\n            public void run() {\n                int i = 1 / 0;\n            }\n        }\n);\n```\n```\nException in thread \"pool-1-thread-1\" java.lang.ArithmeticException: / by zero\n```\n\nExecutorService.submit()的异常会被吃掉,下面的代码的异常会被默默吃掉,没有堆栈信息的打印:\n\n```\nExecutors.newCachedThreadPool().submit(\n        new Runnable() {\n            @Override\n            public void run() {\n                int i = 1 / 0;\n            }\n        }\n);\n```\n但是我们可以调用Future.get()方法,这样当抛出异常的时候系统也会打印堆栈:\n\n```\nFuture future = Executors.newCachedThreadPool().submit(\n        new Runnable() {\n            @Override\n            public void run() {\n                int i = 1 / 0;\n            }\n        }\n);\nfuture.get();\n```\n\n需要注意的是Future.get()是阻塞的,需要需要等待线程执行完毕才会返回,所以我们可以用这个方法获得Callable.call()的返回值:\n\n```\nFuture<Integer> future = Executors.newCachedThreadPool().submit(\n        new Callable<Integer>() {\n            @Override\n            public Integer call() throws Exception {\n                return 123;\n            }\n        }\n);\nSystem.out.println(future.get());\n```","source":"_posts/Java多线程-线程池.md","raw":"title: Java多线程 - 线程池\ndate: 2017-09-05 00:01:48\ntags:\n  - 技术相关\n  - java\n---\n\n这篇文章大部分都是直接摘抄自《实战Java高并发程序设计》,基本上就是一篇笔记,用于以后忘了的时候可以回顾。\n\n# 框架提供的ExecutorService\n\nExecutors框架提供了各种类型的线程池,主要有以下工厂方法:\n\n```\npublic static ExecutorService newFixedThreadPool(int nThreads) \npublic static ExecutorService newSingleThreadExecutor()\npublic static ExecutorService newCachedThreadPool()\npublic static ScheduledExecutorService newSingleThreadScheduledExecutor()\npublic static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)\n```\n\n- newFixedThreadPool()方法. 该方法返回一个固定线程数量的线程池,该线程池中的线程数量始终不变,当有一个新任务时,线程池中若有空闲线程,则立即执行,若没有,则新任务会被暂时存在一个队列中,得有空闲线程时,便处理在任务队列中的任务\n\n- newSingleThreadExecutor()方法,改方法返回一个只有一个线程的线程池,若多余一个任务被提交到该线程池,任务会被保存在一个队伍队列,带线程空闲,按先入先出的顺序执行队列中的任务,\n\n- newCachedThreadPool()方法,该方法返回一个可根据实际情况调整线程数量的线程池.线程池数量是不确定的,但若有空闲线程可以复用,则会优先使用可以复用的线程,若所有线程均在工作,又有新的任务提交,则会创建新的线程处理任务,所有线程在当前任务执行完毕后,将返回线程池进行复用,\n\n- newSingleThreadScheduledExecutor()方法: 改方法返回一个ScheduledExecutorService对象,线程池大小为1 这个接口在ExecutorService接口之上拓展了在给定时间执行某任务的功能,如在某个固定的延时之后执行,或者周期性执行某个任务.\n\n- newScheduledThreadPool()方法:改方法也返回一个ScheduledExecutorService对象 但改线程池可以指定线程数量\n\n前面三个工厂方法创建的ExecutorService只需要使用ExecutorService.execute()方法或者submit()方法将需要执行的任务传入即可,这里就不细讲了。关于这两个方法的差异我会在后面细说,这里也不展开讨论了。\n\n后面两个工厂方法会创建ScheduledExecutorService。它有会多出下面三个schedule方法用于延迟执行任务:\n\n```\npublic ScheduledFuture<?> schedule(Runnable command,\n                                   long delay, TimeUnit unit);\npublic ScheduledFuture<?> scheduleAtFixedRate(Runnable command,\n                                              long initialDelay,\n                                              long period,\n                                              TimeUnit unit);\npublic ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,\n                                                 long initialDelay,\n                                                 long delay,\n                                                 TimeUnit unit);\n```\n\nschedule()方法会在给定时间,对方法进行一次调度。scheduleAtFixedRate()方法和scheduleWithFixedDelay()会对任务进行周期性调度。但两者有一点小小的差别:\n\n{% img /Java多线程-线程池/1.png %}\n\n对于FixedRate方式来说,任务调度的频率是一样的。它是以上一个任务开始执行时间为起点,之后的period时间,调度下一次任务。而FixDelay则是在上一个任务结束后,再经过delay时间进行任务调度。\n\n# ThreadPoolExecutor\n\n对于Executors.newFixedThreadPool()、Executors.newSingleThreadExecutor()、Executors.newCachedThreadPool()这几个方法虽然创建的线程池的功能特点完全不一样,但是他们其实都是使用了ThreadPoolExecutor实现:\n\n```\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\n    \npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue<Runnable>()));\n}\n\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue<Runnable>());\n}\n```\n\nThreadPoolExecutor的最重要的构造函数如下:\n\n```\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler)  \n```\n\n- corePoolSize: 指定了线程池中的线程数量\n- maximumPoolSize: 指定了线程池中的最大线程数量\n- keepAliveTime: 当线程池线程数量超过corePoolSize时,多余的空闲线程的存活时间。即,超过corePoolSize的空闲线程,在多长的时间内,会被销毁。\n- unit: keepAliveTime的时间单位\n- workQueue: 被提交但未被执行的任务\n- threadFactory: 线程工厂,用于创建线程,一般用默认即可\n- handler: 拒绝策略。但任务太多来不及处理,如何拒绝任务\n\n以上参数中,大部分都很简单,只有workQueue和handler需要说一下。\n\n内置的BlockingQueue有下面几种:\n\n- SynchronousQueue: 一个没有容量的队列。使用SynchronousQueue,提交的任务不会真正的被保存,而总是将新任务提交给线程执行。如果没有空闲线程,就创建新线程,如果线程数量已经到达最大值,则执行拒绝策略\n\n- ArrayBlockingQueue: 有界任务队列,若有新的任务需要执行,如果实际线程数少于corePoolSize则创建新的线程,如果大于corePoolSize,就会放入ArrayBlockingQueue中,如果ArrayBlockingQueue已满,在总线程数不大于maximumPoolSize的情况下会创建新线程,否则就执行拒绝策略\n\n- LinkedBlockingQueue: 无界任务队列,若有新的任务需要执行,如果实际线程数少于corePoolSize则创建新的线程,如果大于corePoolSize,就会放入LinkedBlockingQueue中等待\n\n- PriorityBlockingQueue: 它是一个特殊的无界队列,可以设定任务的优先级\n\n而内置的拒绝策略又有下面几种:\n\n- AbortPolicy策略: 该策略会直接抛出异常,阻止系统正常工作\n- CallerRunsPolicy策略: 只要线程池没有关闭,该策略直接在调用者线程中运行被拒绝的任务。(使用这个策略可能导致在主线程执行耗时操作)\n- DiscardOldestPolicy策略: 该策略丢弃一个最老的任务,并尝试重新提交任务\n- DiscardPolicy策略: 该策略默默丢弃拒绝的任务,不做任何处理。\n\n\n线程池任务调度的逻辑如下图所示:\n\n\n{% img /Java多线程-线程池/2.png %}\n\n# execute和submit的区别\n\nExecutorService.execute()和ExecutorService.submit()都可以提交任务去异步执行,但是它们之间有什么区别呢？\n\n```\nvoid execute(Runnable command);\nFuture<?> submit(Runnable task);\n<T> Future<T> submit(Callable<T> task);\n```\n\n- 返回值\n\nExecutorService.execute()没有返回值,只能简单的提交Runnable给线程池去运行\n\nExecutorService.submit(),有返回值,可以获得一个Future\n\n- 异常\n\nExecutorService.execute()的异常机制和普通线程的异常机制一样,必须用try、catch来捕获异常。如果没有捕获一些运行时异常,也会打印出堆栈信息:\n\n```\nExecutors.newCachedThreadPool().execute(\n        new Runnable() {\n            @Override\n            public void run() {\n                int i = 1 / 0;\n            }\n        }\n);\n```\n```\nException in thread \"pool-1-thread-1\" java.lang.ArithmeticException: / by zero\n```\n\nExecutorService.submit()的异常会被吃掉,下面的代码的异常会被默默吃掉,没有堆栈信息的打印:\n\n```\nExecutors.newCachedThreadPool().submit(\n        new Runnable() {\n            @Override\n            public void run() {\n                int i = 1 / 0;\n            }\n        }\n);\n```\n但是我们可以调用Future.get()方法,这样当抛出异常的时候系统也会打印堆栈:\n\n```\nFuture future = Executors.newCachedThreadPool().submit(\n        new Runnable() {\n            @Override\n            public void run() {\n                int i = 1 / 0;\n            }\n        }\n);\nfuture.get();\n```\n\n需要注意的是Future.get()是阻塞的,需要需要等待线程执行完毕才会返回,所以我们可以用这个方法获得Callable.call()的返回值:\n\n```\nFuture<Integer> future = Executors.newCachedThreadPool().submit(\n        new Callable<Integer>() {\n            @Override\n            public Integer call() throws Exception {\n                return 123;\n            }\n        }\n);\nSystem.out.println(future.get());\n```","slug":"Java多线程-线程池","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2uo9003gw3fy2b5d2el8"},{"title":"Java多线程 - 如何正确的终止线程","date":"2017-08-23T16:50:09.000Z","_content":"\n最近打算读一下《实战java高并发程序设计》，夯实一下java多线程的知识。接下来应该会写一系列的读书笔记,里面会有多处引用到书中的代码或者文字。本文就是第一篇。\n\n\n# 不推荐使用的stop方法\n\nThread.stop()是一个被废弃的方法,不被推荐使用的原因是stop方法太过于暴力，强行把执行到一半的线程终止,并且会立即释放这个线程所有的锁。会破坏了线程中引用对象的一致性。\n\n例如在数据库中维护着一张用户表，记录了用户ID和用户名，使用Thread多线程写入两条记录:\n\n```\n记录1: ID=1,NAME=小明  \n记录2: ID=2,NAME=小王\n```\n\n如果在记录1写到一半的时候被stop结束了，就可能出现各种奇怪的现象：\n\n1. 记录1被记录2覆盖，没有任何数据留下。\n2. 记录1只有一半，即只有ID，而NAME为空。\n3. 记录1和记录2混在同一条记录中，最后写入了一条一半是记录1一半是记录2的脏数据\n\n所以,除非你很确定你在做什么,否则不要轻易使用stop方法\n\n# 使用判断标志位的方法中断线程\n\n那如果的确有中断线程的需求,我们需要怎么做呢？一般我们马上就会想到设置标志位的方法,即在线程中执行每一个步骤之前都判断一下是否需要退出线程:\n\n```\nclass WorkThread extends Thread {\n    private boolean mExitThread = false;\n\n    public void exitThread() {\n        mExitThread = true;\n    }\n\n    @Override\n    public void run() {\n        if (mExitThread) {\n            return;\n        }\n        //do something\n\n        if (mExitThread) {\n            return;\n        }\n        //do something\n\n        if (mExitThread) {\n            return;\n        }\n        //do something\n    }\n}\n```\n\n其实Thread类早就帮我们实现了这个中断标志了。与Thread中断相关的方法有下面三个:\n\n\n> public void Thread.interrupt() //线程中断  \n> public native boolean Thread.isInterrupted() //判断是否被中断  \n> public static native boolean Thread.interrupted() //判断是否中断,并清除当前中断状态\n\n\n所以上面的代码可以改写成这样:\n\n```\nclass WorkThread extends Thread {\n    @Override\n    public void run() {\n        if (isInterrupted()) {\n            return;\n        }\n        //do something\n\n        if (isInterrupted()) {\n            return;\n        }\n        //do something\n\n        if (isInterrupted()) {\n            return;\n        }\n        //do something\n    }\n}\n```\n\n这个时候我们只需要调用Thread.interrupt()方法就能安全的中断线程了。\n\n需要提醒一下的是Thread.interrupt()方法并不会像Thread.stop()方法一样立即结束线程,它只是设置了一个中断标志,需要在代码实现中去手动判断这个标志并且退出。\n\n像下面这个代码就算调了Thread.interrupt()方法也不会中断线程:\n\n```\nclass WorkThread extends Thread {\n    @Override\n    public void run() {\n        while(true){\n        \t//do something\n        }\n    }\n}\n```\n\n# Thread.interrupt的优点\n\n使用Thread.interrupt去中断线程除了可以免去自己实现标志位的烦恼之外,还可以中断sleep和wait中的线程。\n\n还记得我们在调用Thread.sleep()这个方法的时候都需要catch或者在方法签名中抛出InterruptedException这个异常吗:\n\n```\ntry {\n    Thread.sleep(1000);\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n```\n\n这个InterruptedException异常就是由于我们调用了Thread.interrupt方法抛出的。所以Thread.interrupt可以打断Thread.sleep。同样Thread.wait也是可以被Thread.interrupt打断的。\n\n需要注意的是如果sleep方法由于中断而抛出异常，此时，它会__清除中断标记__。所以在catch到这个异常的时候__需要再次设置中断标记__：\n\n```\nThread t1 = new Thread() {\n    @Override\n    public void run(){\n        while(true){\n            if(Thread.currentThread().isInterrupted()){\n                break;\n            }\n\n            System.out.println(\"hello world\");\n            try{\n                Thread.sleep(1000);\n            }catch(InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n};\n```\n","source":"_posts/Java多线程-如何正确的终止线程.md","raw":"title: Java多线程 - 如何正确的终止线程\ndate: 2017-08-24 00:50:09\ntags:\n\t- 技术相关\n\t- java\n---\n\n最近打算读一下《实战java高并发程序设计》，夯实一下java多线程的知识。接下来应该会写一系列的读书笔记,里面会有多处引用到书中的代码或者文字。本文就是第一篇。\n\n\n# 不推荐使用的stop方法\n\nThread.stop()是一个被废弃的方法,不被推荐使用的原因是stop方法太过于暴力，强行把执行到一半的线程终止,并且会立即释放这个线程所有的锁。会破坏了线程中引用对象的一致性。\n\n例如在数据库中维护着一张用户表，记录了用户ID和用户名，使用Thread多线程写入两条记录:\n\n```\n记录1: ID=1,NAME=小明  \n记录2: ID=2,NAME=小王\n```\n\n如果在记录1写到一半的时候被stop结束了，就可能出现各种奇怪的现象：\n\n1. 记录1被记录2覆盖，没有任何数据留下。\n2. 记录1只有一半，即只有ID，而NAME为空。\n3. 记录1和记录2混在同一条记录中，最后写入了一条一半是记录1一半是记录2的脏数据\n\n所以,除非你很确定你在做什么,否则不要轻易使用stop方法\n\n# 使用判断标志位的方法中断线程\n\n那如果的确有中断线程的需求,我们需要怎么做呢？一般我们马上就会想到设置标志位的方法,即在线程中执行每一个步骤之前都判断一下是否需要退出线程:\n\n```\nclass WorkThread extends Thread {\n    private boolean mExitThread = false;\n\n    public void exitThread() {\n        mExitThread = true;\n    }\n\n    @Override\n    public void run() {\n        if (mExitThread) {\n            return;\n        }\n        //do something\n\n        if (mExitThread) {\n            return;\n        }\n        //do something\n\n        if (mExitThread) {\n            return;\n        }\n        //do something\n    }\n}\n```\n\n其实Thread类早就帮我们实现了这个中断标志了。与Thread中断相关的方法有下面三个:\n\n\n> public void Thread.interrupt() //线程中断  \n> public native boolean Thread.isInterrupted() //判断是否被中断  \n> public static native boolean Thread.interrupted() //判断是否中断,并清除当前中断状态\n\n\n所以上面的代码可以改写成这样:\n\n```\nclass WorkThread extends Thread {\n    @Override\n    public void run() {\n        if (isInterrupted()) {\n            return;\n        }\n        //do something\n\n        if (isInterrupted()) {\n            return;\n        }\n        //do something\n\n        if (isInterrupted()) {\n            return;\n        }\n        //do something\n    }\n}\n```\n\n这个时候我们只需要调用Thread.interrupt()方法就能安全的中断线程了。\n\n需要提醒一下的是Thread.interrupt()方法并不会像Thread.stop()方法一样立即结束线程,它只是设置了一个中断标志,需要在代码实现中去手动判断这个标志并且退出。\n\n像下面这个代码就算调了Thread.interrupt()方法也不会中断线程:\n\n```\nclass WorkThread extends Thread {\n    @Override\n    public void run() {\n        while(true){\n        \t//do something\n        }\n    }\n}\n```\n\n# Thread.interrupt的优点\n\n使用Thread.interrupt去中断线程除了可以免去自己实现标志位的烦恼之外,还可以中断sleep和wait中的线程。\n\n还记得我们在调用Thread.sleep()这个方法的时候都需要catch或者在方法签名中抛出InterruptedException这个异常吗:\n\n```\ntry {\n    Thread.sleep(1000);\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n```\n\n这个InterruptedException异常就是由于我们调用了Thread.interrupt方法抛出的。所以Thread.interrupt可以打断Thread.sleep。同样Thread.wait也是可以被Thread.interrupt打断的。\n\n需要注意的是如果sleep方法由于中断而抛出异常，此时，它会__清除中断标记__。所以在catch到这个异常的时候__需要再次设置中断标记__：\n\n```\nThread t1 = new Thread() {\n    @Override\n    public void run(){\n        while(true){\n            if(Thread.currentThread().isInterrupted()){\n                break;\n            }\n\n            System.out.println(\"hello world\");\n            try{\n                Thread.sleep(1000);\n            }catch(InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n};\n```\n","slug":"Java多线程-如何正确的终止线程","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2uod003jw3fyzp0embo6"},{"title":"Java多线程 - 各种线程锁","date":"2017-08-30T16:07:53.000Z","_content":"\n多个线程同时对同一个对象进行读写操作,很容易会出现一些难以预料的问题。所以很多时候我们需要给代码块加锁,同一时刻只允许一个线程对某个对象进行操作。多线程之所以会容易引发一些难以发现的bug,很多时候是写代码的程序员对线程锁不熟悉或者干脆就没有在必要的地方给线程加锁导致的。这里我想总结一下java多线程中的各种锁的作用和用法,还有容易踩的坑。\n\n这篇文章里面有很多的文字和代码都来自于《实战Java高并发程序设计》。它真的是一本很不错的书,建议大家有空可以去看一下。\n\n# synchronized关键字\n\n## synchronized的作用\n\n关键字synchronized的作用是实现线程间的同步。它的工作是对同步的代码加锁,使得每一次,只能有一个线程进入同步块,从而保证线程间的安全性。\n\n关键字synchronized可以有多张用法,这里做一个简单的整理:\n\n> 指定加锁对象:对给定对象加锁,进入同步代码前要获取给定对象的锁。  \n> 直接作用于实例方法:相当于给当前实例加锁,进入同步代码块前要获得当前实例的锁。  \n> 直接作用于静态方法:相当于对当前类加锁,进入同步代码前要获取当前类的锁。\n\n下面来分别说一下上面的三点:\n\n假设我们有下面这样一个Runnable,在run方法里对__静态__成员变量sCount自增10000次:\n\n```\nclass Count implements Runnable {\n    private static int sCount = 0;\n\n    public static int getCount() {\n        return sCount;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10000; i++) {\n            sCount++;\n        }\n    }\n}\n```\n\n假设我们在两个Thread里面同时跑这个Runnable:\n\n```\nCount count = new Count();\nThread t1 = new Thread(count);\nThread t2 = new Thread(count);\nt1.start();\nt2.start();\ntry {\n    t1.join();\n    t2.join();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\nSystem.out.print(Count.getCount());\n```\n\n得到的结果并不是20000,而是一个比20000小的数,如14233。\n\n这是为什么呢？假设两个线程分别读取sCount为0,然后各自技术得到sCount为1,并先后写入这个结果,因此,虽然sCount++执行了2次,但是实际sCount的值只增加了1。\n\n我们可以用指定加锁对象的方法解决这个问题,这里因为两个Thread跑的是同一个Count实例,所以可以直接给this加锁:\n\n```\nclass Count implements Runnable {\n    private static int sCount = 0;\n\n    public static int getCount() {\n        return sCount;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10000; i++) {\n            synchronized (this) {\n                sCount++;\n            }\n        }\n    }\n}\n```\n\n我们也可以给实例方法加锁,这种方式和上面那一种的区别就是给this加锁,锁的区域比较小,两个线程交替执行sCount++操作,而给方法加锁的话,先拿到锁的线程会连续执行1000次sCount自增,然后再释放锁给另一个线程。\n\n```\nclass Count implements Runnable {\n    private static int sCount = 0;\n\n    public static int getCount() {\n        return sCount;\n    }\n\n    @Override\n    public synchronized void run() {\n        for (int i = 0; i < 10000; i++) {\n            sCount++;\n        }\n    }\n}\n```\n\nsynchronized直接作用于静态方法的用法和上面的给实例方法加锁类似,不过它是作用于静态方法:\n\n```\nclass Count implements Runnable {\n    private static int sCount = 0;\n\n    public static int getCount() {\n        return sCount;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10000; i++) {\n            increase();\n        }\n    }\n\n    private static synchronized void increase() {\n        sCount++;\n    }\n}\n```\n\n## 等待(wait)和通知(notify)\n\nObject有两个很重要的接口:Object.wait()和Object.notify()\n\n当在一个对象实例上调用了wait()方法后,当前线程就会在这个对象上等待。直到其他线程调用了这个对象的notify()方法或者notifyAll()方法。notifyAll()方法与notify()方法的区别是它会唤醒所有正在等待这个对象的线程,而notify()方法只会随机唤醒一个等待该对象的线程。\n\nwait()、notify()和notifyAll()都需要在synchronized语句中使用:\n\n```\nclass MyThread extends Thread {\n    private Object mLock;\n\n    public MyThread(Object lock) {\n        this.mLock = lock;\n    }\n\n    @Override\n    public void run() {\n        super.run();\n\n        synchronized (mLock) {\n            try {\n                mLock.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            System.out.println(\"in MyThread\");\n        }\n    }\n}\n```\n\n```\nObject lock = new Object();\nMyThread t = new MyThread(lock);\nt.start();\n\nSystem.out.println(\"before sleep\");\n\ntry {\n    Thread.sleep(2000);\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n\nSystem.out.println(\"after sleep\");\n\nsynchronized (lock) {\n    lock.notify();\n}\n\ntry {\n    t.join();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n```\n\n从上面的例子可以看出来,在调用wait()方法实际上已经释放了对象的锁,所以在其他线程中才能获取到这个对象的锁,从而进行notify操作。而等待的线程被唤醒后又需要重新获得对象的锁。\n\n## synchronized容易犯的隐蔽错误\n\n### 是否给同一个对象加锁\n\n在用synchronized给对象加锁的时候需要注意加锁是不是同一个,如将代码改成这样:\n\n```\nThread t1 = new Thread(new Count());\nThread t2 = new Thread(new Count());\nt1.start();\nt2.start();\ntry {\n    t1.join();\n    t2.join();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\nSystem.out.print(Count.getCount());\n```\n\n因为两个线程跑的是不同的Count实例,所以用给指定对象加锁和给实例方法加锁的方法都不能避免两个线程同时对__静态__成员变量sCount进行自增操作。\n\n但是如果用第三种作用于静态方法的写法,就能正确的加锁。\n\n### 是否给错误的对象加锁\n\n如我们将sCount的类型改成Integer,并且在sCount++的时候直接对sCount加锁会发生什么事情呢(毕竟我们会很自然的给要操作的对象加锁来实现线程同步)？\n\n```\nclass Count implements Runnable {\n    private static Integer sCount = 0;\n\n    public static int getCount() {\n        return sCount;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10000; i++) {\n            synchronized (sCount) {\n                sCount++;\n            }\n        }\n    }\n}\n```\n\n```\nCount count = new Count();\nThread t1 = new Thread(count);\nThread t2 = new Thread(count);\nt1.start();\nt2.start();\ntry {\n    t1.join();\n    t2.join();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\nSystem.out.print(Count.getCount());\n```\n\n最后的得到的结果仍然是比20000小的值。\n\n这是为什么呢？《实战Java高并发程序设计》中给出的解释是这样的:\n\n> 在Java中,Integer使用不变对象。也就是对象一旦被创建,就不可能被修改。也就是说,如果你有一个Integer代表1,那么它就永远是1,你不可能改变Integer的值,使它位。那如果你需要2怎么办呢？也很简单,新建一个Integer,并让它表示2即可。\n\n也就是说sCount在真实执行时变成了:\n\n> sCount = Integer.valueOf(sCount.intValue()+1);\n\n进一步看Integer.valueOf()，我们可以看到:\n\n```\npublic static Integer valueOf(int i) {\n    assert IntegerCache.high >= 127;\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n```\n\n所以在多个线程中,由于sCount一直在变,并不是同一个对象,所以两个线程的加锁可能加在了不同的Integer对象上,并没有真正的锁住代码块。\n\n我再举一个例子:\n\n```\npublic void increase(Integer integer){\n    integer++;\n}\n```\n\n在外面这样调用它,并不会使得传入的Integer增加:\n\n```\nInteger i = 0;\nincrease(i);\n```\n\n# 重入锁\n\nReentrantLock的意思是Re-Entrant-Lock也就是重入锁,它的特点就是在同一个线程中可以重复加锁,只需要解锁同样的次数就能真正解锁:\n\n```\nclass MyThread extends Thread {\n    private ReentrantLock mLock = new ReentrantLock();\n\n    @Override\n    public void run() {\n        super.run();\n\n        mLock.lock();\n        System.out.println(\"outside\");\n\n        mLock.lock();\n        System.out.println(\"inside\");\n        mLock.unlock();\n\n        mLock.unlock();\n    }\n}\n```\n\n事实上synchronized也是可重入的,比如下面的代码同样是可以正常退出的:\n\n```\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        super.run();\n        synchronized (this) {\n            System.out.println(\"outside\");\n            synchronized (this) {\n                System.out.println(\"inside\");\n            }\n        }\n    }\n}\n```\n\n与synchronized相比,重入锁需要程序员手动调用加锁和解锁,也因为如此,重入锁对逻辑控制的灵活性要远远好于synchronized。\n\n重入锁可以完全替代synchronized关键字。在JDK 5.0的早起版本中,重入锁的性能远远好于synchronized。但从JDK 6.0开始,JDK在synchronized做了大量优化,使得两者的性能差距并不大。\n\n## ReentrantLock是可中断的\n\n对于synchronized,如果它在等待锁,那么它就只有两个状态:获得锁继续执行或者保持等待。但是对于重入锁,就有了另外一种可能,那就是重入锁在等待的时候可以被中断:\n\n```\nclass MyThread extends Thread {\n    private ReentrantLock mLock = new ReentrantLock();\n\n    @Override\n    public void run() {\n        super.run();\n\n        try {\n            mLock.lockInterruptibly();\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }finally {\n            if(mLock.isHeldByCurrentThread()){\n                mLock.unlock();\n            }\n        }\n    }\n}\n```\n\n## ReentrantLock可以设置等待限时\n\nReentrantLock.tryLock()方法可以给等待锁设置最长等待时间,如果在设置的时间结束之前获取到锁就会返回true,否则返回false:\n\n```\nclass MyThread extends Thread {\n    private ReentrantLock mLock = new ReentrantLock();\n\n    @Override\n    public void run() {\n        super.run();\n\n        try {\n            if (mLock.tryLock(2, TimeUnit.SECONDS)) {\n                try {\n                    Thread.sleep(5000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            if (mLock.isHeldByCurrentThread()) {\n                mLock.unlock();\n            }\n        }\n    }\n}\n```\n\nReentrantLock.tryLock()也可以不带参数直接运行。在这种情况下,当前线程会尝试获得锁,如果锁并未被其他线程占用,则申请锁会成功,并立即返回true。如果锁被其他线程占用,则当前线程不会进行等待,而是立即返回false。\n\n## ReentrantLock可以设置公平锁\n\n大多数情况下,锁的申请是非公平的。也就是说,线程1首先请求了锁A，接着线程2也请求了锁A。那么当锁A可用时,是线程1可以获得锁还是线程2可以获得锁呢？这是不一定的。系统只是会从这个锁的等待队列里随机挑选一个:\n\n```\nclass MyThread extends Thread {\n    private ReentrantLock mLock;\n\n    public MyThread(String name, ReentrantLock lock) {\n        super(name);\n        this.mLock = lock;\n    }\n\n    @Override\n    public void run() {\n        super.run();\n\n        while (true) {\n            mLock.lock();\n            System.out.println(Thread.currentThread().getName() + \"获得锁\");\n            mLock.unlock();\n        }\n    }\n}\n```\n\n```\nReentrantLock lock = new ReentrantLock();\nMyThread t1 = new MyThread(\"t1\", lock);\nt1.start();\n\nMyThread t2 = new MyThread(\"t2\", lock);\nt2.start();\n\ntry {\n    t1.join();\n    t2.join();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n```\n\n打印如下:\n\n```\nt1获得锁\nt2获得锁\nt2获得锁\nt2获得锁\nt1获得锁\nt2获得锁\nt2获得锁\nt1获得锁\nt2获得锁\nt1获得锁\nt2获得锁\nt2获得锁\nt2获得锁\nt1获得锁\nt1获得锁\n```\n\nsynchronized产生的锁也是非公平的。但如果使用ReentrantLock(boolean fair)构造函数创建ReentrantLock,并且传入true。则该重入锁是公平的:\n\n```\nReentrantLock lock = new ReentrantLock(true);\nMyThread t1 = new MyThread(\"t1\", lock);\nt1.start();\n\nMyThread t2 = new MyThread(\"t2\", lock);\nt2.start();\n\ntry {\n    t1.join();\n    t2.join();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n```\n\n打印如下:\n\n```\nt1获得锁\nt2获得锁\nt1获得锁\nt2获得锁\nt1获得锁\nt2获得锁\nt1获得锁\nt2获得锁\nt1获得锁\nt2获得锁\nt1获得锁\n```\n\n需要注意的是实现公平锁必然要求系统维护一个有序队列,所以公平锁的实现成本较高,性能也相对低下,因此,默认情况下,锁是非公平的。\n\n## ReentrantLock可以与Condition配合使用\n\nCondition和之前讲过的Object.wait()还有Object.notify()的作用大致相同:\n\n```\nclass MyThread extends Thread {\n\tprivate ReentrantLock mLock;\n\tprivate Condition mCondition;\n\t\n\tpublic MyThread(ReentrantLock lock, Condition condition) {\n\t    this.mLock = lock;\n\t    this.mCondition = condition;\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t    super.run();\n\t\n\t    mLock.lock();\n\t    try {\n\t        mCondition.await();\n\t    } catch (InterruptedException e) {\n\t        e.printStackTrace();\n\t    }\n\t    mLock.unlock();\n\t\n\t    System.out.println(\"in MyThread\");\n\t}\n}\n```\n\n```\nReentrantLock lock = new ReentrantLock();\nCondition condition = lock.newCondition();\nMyThread t = new MyThread(lock, condition);\nt.start();\n\nSystem.out.println(\"before sleep\");\ntry {\n    Thread.sleep(2000);\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\nSystem.out.println(\"after sleep\");\n\nlock.lock();\ncondition.signal();\nlock.unlock();\n\ntry {\n    t.join();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n```\n\nCondition的操作需要在ReentrantLock.lock()和ReentrantLock.unlock()之间进行的。\n\nReentrantLock.newCondition()可以创建一个Condition。Condition.await()方法相当于Object.wait()方法,而Condition.signal()方法相当于Object.notify()方法。当然它也有对应的Condition.signalAll()方法。\n\n同样的在调用Condition.await()之后,线程占用的锁会被释放。这样在Condition.signal()方法调用的时候才获取到锁。\n\n需要注意的是Condition.signal()方法调用之后,被唤醒的线程因为需要重新获取锁。所以需要等到调用Condition.signal()的线程释放了锁(调用ReentrantLock.unlock())之后才能继续执行。\n\n\nCondition接口的基本方法如下,它提供了限时等待、不可中断的等待之类的操作:\n\n```\nvoid await() throws InterruptedException;\nvoid awaitUninterruptibly();\nlong awaitNanos(long nanosTimeout) throws InterruptedException;\nboolean await(long time, TimeUnit unit) throws InterruptedException;\nboolean awaitUntil(Date deadline) throws InterruptedException;\nvoid signal();\nvoid signalAll();\n```\n\n# 信号量\n\n信号量为多线程协作提供了更为强大的控制方法。广义上说,信号量是对锁的拓展。无论是synchronize还是重入锁,一次都只运行一个线程访问一个资源,而信号锁则可以指定多个线程,同时访问某一个资源。\n\n像下面的代码, MyRunnable被加锁的代码块一次会被5个线程执行:\n\n```\npublic class MyRunnable implements Runnable {\n    private Semaphore mSemaphore;\n\n    public MyRunnable(Semaphore semaphore) {\n        mSemaphore = semaphore;\n    }\n\n    @Override\n    public void run() {\n        try {\n            mSemaphore.acquire();\n            Thread.sleep(2000);\n            System.out.println(\"thread \" + Thread.currentThread().getId() + \" working\");\n            mSemaphore.release();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n```\n Semaphore semaphore = new Semaphore(5);\nfor (int i = 0; i < 19; i++) {\n    new Thread(new MyRunnable(semaphore)).start();\n}\n\nThread t = new Thread(new MyRunnable(semaphore));\nt.start();\nt.join();\n```\n\nSemaphore.acquire()方法尝试获得一个准入许可。如无法获得,线程就会等待。而Semaphore.release()则在线程访问资源结束后,释放一个许可。\n\nSemaphore有下面的一些常用方法:\n\n```\npublic Semaphore(int permits)\npublic Semaphore(int permits, boolean fair)\npublic void acquire() \npublic void acquireUninterruptibly()\npublic boolean tryAcquire()\npublic boolean tryAcquire(long timeout, TimeUnit unit)\npublic void release()\n```\n\n# 其他的一些锁\n\n## 读写锁\n\n读写锁(ReadWriteLock)是JDK5中提供的分离锁。读写分离锁可以有效的减少锁竞争。\n\n读写锁允许多个线程同时读,但是写写操作和读写操作就需要相互等待了。读写锁的访问约束如下:\n\n||读|写|\n|:-:|:-:|:-:|\n|读|非阻塞|阻塞|\n|写|阻塞|阻塞|\n\n读写操作在某些特定操作下可以提高程序的性能,如下面的代码。如果使用重入锁,需要十一秒左右才能运行完:\n\n```\npublic class Data {\n    private String mData = \"data\";\n    private ReentrantLock mLock = new ReentrantLock();\n\n    public String readData(){\n        mLock.lock();\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"read data : \" + mData);\n        String data = mData;\n        mLock.unlock();\n        return data;\n    }\n\n    public void writeData(String data){\n        mLock.lock();\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        mData = data;\n        System.out.println(\"write data : \" + mData);\n        mLock.unlock();\n    }\n}\n```\n\n```\nfinal Data data = new Data();\nfor (int i = 0; i < 10; i++) {\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            data.readData();\n        }\n    }).start();\n}\n\nThread write = new Thread(new Runnable() {\n    @Override\n    public void run() {\n       data.writeData(\"update data\");\n    }\n});\nwrite.start();\n```\n\n但是如果将重入锁改成读写锁的话只需要两秒左右就能完成:\n\n```\npublic class Data {\n    private String mData = \"data\";\n    private ReadWriteLock mLock = new ReentrantReadWriteLock();\n    private Lock mReadLock = mLock.readLock();\n    private Lock mWriteLock = mLock.writeLock();\n\n    public String readData(){\n        mReadLock.lock();\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        String data = mData;\n        System.out.println(\"read data : \" + mData);\n        mReadLock.unlock();\n        return data;\n    }\n\n    public void writeData(String data){\n        mWriteLock.lock();\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"write data : \" + mData);\n        mData = data;\n        mWriteLock.unlock();\n    }\n}\n```\n\n# 倒计时器、循环栅栏\n\n\n倒计时器(CountDownLatch)和循环栅栏(CyclicBarrier)因为比较不常用,所以这里就不讲了,有兴趣的同学可以自己去看一下《实战Java高并发程序设计》这本书。\n","source":"_posts/Java多线程-各种线程锁.md","raw":"title: Java多线程 - 各种线程锁\ndate: 2017-08-31 00:07:53\ntags:\n\t- 技术相关\n\t- java\n---\n\n多个线程同时对同一个对象进行读写操作,很容易会出现一些难以预料的问题。所以很多时候我们需要给代码块加锁,同一时刻只允许一个线程对某个对象进行操作。多线程之所以会容易引发一些难以发现的bug,很多时候是写代码的程序员对线程锁不熟悉或者干脆就没有在必要的地方给线程加锁导致的。这里我想总结一下java多线程中的各种锁的作用和用法,还有容易踩的坑。\n\n这篇文章里面有很多的文字和代码都来自于《实战Java高并发程序设计》。它真的是一本很不错的书,建议大家有空可以去看一下。\n\n# synchronized关键字\n\n## synchronized的作用\n\n关键字synchronized的作用是实现线程间的同步。它的工作是对同步的代码加锁,使得每一次,只能有一个线程进入同步块,从而保证线程间的安全性。\n\n关键字synchronized可以有多张用法,这里做一个简单的整理:\n\n> 指定加锁对象:对给定对象加锁,进入同步代码前要获取给定对象的锁。  \n> 直接作用于实例方法:相当于给当前实例加锁,进入同步代码块前要获得当前实例的锁。  \n> 直接作用于静态方法:相当于对当前类加锁,进入同步代码前要获取当前类的锁。\n\n下面来分别说一下上面的三点:\n\n假设我们有下面这样一个Runnable,在run方法里对__静态__成员变量sCount自增10000次:\n\n```\nclass Count implements Runnable {\n    private static int sCount = 0;\n\n    public static int getCount() {\n        return sCount;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10000; i++) {\n            sCount++;\n        }\n    }\n}\n```\n\n假设我们在两个Thread里面同时跑这个Runnable:\n\n```\nCount count = new Count();\nThread t1 = new Thread(count);\nThread t2 = new Thread(count);\nt1.start();\nt2.start();\ntry {\n    t1.join();\n    t2.join();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\nSystem.out.print(Count.getCount());\n```\n\n得到的结果并不是20000,而是一个比20000小的数,如14233。\n\n这是为什么呢？假设两个线程分别读取sCount为0,然后各自技术得到sCount为1,并先后写入这个结果,因此,虽然sCount++执行了2次,但是实际sCount的值只增加了1。\n\n我们可以用指定加锁对象的方法解决这个问题,这里因为两个Thread跑的是同一个Count实例,所以可以直接给this加锁:\n\n```\nclass Count implements Runnable {\n    private static int sCount = 0;\n\n    public static int getCount() {\n        return sCount;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10000; i++) {\n            synchronized (this) {\n                sCount++;\n            }\n        }\n    }\n}\n```\n\n我们也可以给实例方法加锁,这种方式和上面那一种的区别就是给this加锁,锁的区域比较小,两个线程交替执行sCount++操作,而给方法加锁的话,先拿到锁的线程会连续执行1000次sCount自增,然后再释放锁给另一个线程。\n\n```\nclass Count implements Runnable {\n    private static int sCount = 0;\n\n    public static int getCount() {\n        return sCount;\n    }\n\n    @Override\n    public synchronized void run() {\n        for (int i = 0; i < 10000; i++) {\n            sCount++;\n        }\n    }\n}\n```\n\nsynchronized直接作用于静态方法的用法和上面的给实例方法加锁类似,不过它是作用于静态方法:\n\n```\nclass Count implements Runnable {\n    private static int sCount = 0;\n\n    public static int getCount() {\n        return sCount;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10000; i++) {\n            increase();\n        }\n    }\n\n    private static synchronized void increase() {\n        sCount++;\n    }\n}\n```\n\n## 等待(wait)和通知(notify)\n\nObject有两个很重要的接口:Object.wait()和Object.notify()\n\n当在一个对象实例上调用了wait()方法后,当前线程就会在这个对象上等待。直到其他线程调用了这个对象的notify()方法或者notifyAll()方法。notifyAll()方法与notify()方法的区别是它会唤醒所有正在等待这个对象的线程,而notify()方法只会随机唤醒一个等待该对象的线程。\n\nwait()、notify()和notifyAll()都需要在synchronized语句中使用:\n\n```\nclass MyThread extends Thread {\n    private Object mLock;\n\n    public MyThread(Object lock) {\n        this.mLock = lock;\n    }\n\n    @Override\n    public void run() {\n        super.run();\n\n        synchronized (mLock) {\n            try {\n                mLock.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            System.out.println(\"in MyThread\");\n        }\n    }\n}\n```\n\n```\nObject lock = new Object();\nMyThread t = new MyThread(lock);\nt.start();\n\nSystem.out.println(\"before sleep\");\n\ntry {\n    Thread.sleep(2000);\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n\nSystem.out.println(\"after sleep\");\n\nsynchronized (lock) {\n    lock.notify();\n}\n\ntry {\n    t.join();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n```\n\n从上面的例子可以看出来,在调用wait()方法实际上已经释放了对象的锁,所以在其他线程中才能获取到这个对象的锁,从而进行notify操作。而等待的线程被唤醒后又需要重新获得对象的锁。\n\n## synchronized容易犯的隐蔽错误\n\n### 是否给同一个对象加锁\n\n在用synchronized给对象加锁的时候需要注意加锁是不是同一个,如将代码改成这样:\n\n```\nThread t1 = new Thread(new Count());\nThread t2 = new Thread(new Count());\nt1.start();\nt2.start();\ntry {\n    t1.join();\n    t2.join();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\nSystem.out.print(Count.getCount());\n```\n\n因为两个线程跑的是不同的Count实例,所以用给指定对象加锁和给实例方法加锁的方法都不能避免两个线程同时对__静态__成员变量sCount进行自增操作。\n\n但是如果用第三种作用于静态方法的写法,就能正确的加锁。\n\n### 是否给错误的对象加锁\n\n如我们将sCount的类型改成Integer,并且在sCount++的时候直接对sCount加锁会发生什么事情呢(毕竟我们会很自然的给要操作的对象加锁来实现线程同步)？\n\n```\nclass Count implements Runnable {\n    private static Integer sCount = 0;\n\n    public static int getCount() {\n        return sCount;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10000; i++) {\n            synchronized (sCount) {\n                sCount++;\n            }\n        }\n    }\n}\n```\n\n```\nCount count = new Count();\nThread t1 = new Thread(count);\nThread t2 = new Thread(count);\nt1.start();\nt2.start();\ntry {\n    t1.join();\n    t2.join();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\nSystem.out.print(Count.getCount());\n```\n\n最后的得到的结果仍然是比20000小的值。\n\n这是为什么呢？《实战Java高并发程序设计》中给出的解释是这样的:\n\n> 在Java中,Integer使用不变对象。也就是对象一旦被创建,就不可能被修改。也就是说,如果你有一个Integer代表1,那么它就永远是1,你不可能改变Integer的值,使它位。那如果你需要2怎么办呢？也很简单,新建一个Integer,并让它表示2即可。\n\n也就是说sCount在真实执行时变成了:\n\n> sCount = Integer.valueOf(sCount.intValue()+1);\n\n进一步看Integer.valueOf()，我们可以看到:\n\n```\npublic static Integer valueOf(int i) {\n    assert IntegerCache.high >= 127;\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n```\n\n所以在多个线程中,由于sCount一直在变,并不是同一个对象,所以两个线程的加锁可能加在了不同的Integer对象上,并没有真正的锁住代码块。\n\n我再举一个例子:\n\n```\npublic void increase(Integer integer){\n    integer++;\n}\n```\n\n在外面这样调用它,并不会使得传入的Integer增加:\n\n```\nInteger i = 0;\nincrease(i);\n```\n\n# 重入锁\n\nReentrantLock的意思是Re-Entrant-Lock也就是重入锁,它的特点就是在同一个线程中可以重复加锁,只需要解锁同样的次数就能真正解锁:\n\n```\nclass MyThread extends Thread {\n    private ReentrantLock mLock = new ReentrantLock();\n\n    @Override\n    public void run() {\n        super.run();\n\n        mLock.lock();\n        System.out.println(\"outside\");\n\n        mLock.lock();\n        System.out.println(\"inside\");\n        mLock.unlock();\n\n        mLock.unlock();\n    }\n}\n```\n\n事实上synchronized也是可重入的,比如下面的代码同样是可以正常退出的:\n\n```\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        super.run();\n        synchronized (this) {\n            System.out.println(\"outside\");\n            synchronized (this) {\n                System.out.println(\"inside\");\n            }\n        }\n    }\n}\n```\n\n与synchronized相比,重入锁需要程序员手动调用加锁和解锁,也因为如此,重入锁对逻辑控制的灵活性要远远好于synchronized。\n\n重入锁可以完全替代synchronized关键字。在JDK 5.0的早起版本中,重入锁的性能远远好于synchronized。但从JDK 6.0开始,JDK在synchronized做了大量优化,使得两者的性能差距并不大。\n\n## ReentrantLock是可中断的\n\n对于synchronized,如果它在等待锁,那么它就只有两个状态:获得锁继续执行或者保持等待。但是对于重入锁,就有了另外一种可能,那就是重入锁在等待的时候可以被中断:\n\n```\nclass MyThread extends Thread {\n    private ReentrantLock mLock = new ReentrantLock();\n\n    @Override\n    public void run() {\n        super.run();\n\n        try {\n            mLock.lockInterruptibly();\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }finally {\n            if(mLock.isHeldByCurrentThread()){\n                mLock.unlock();\n            }\n        }\n    }\n}\n```\n\n## ReentrantLock可以设置等待限时\n\nReentrantLock.tryLock()方法可以给等待锁设置最长等待时间,如果在设置的时间结束之前获取到锁就会返回true,否则返回false:\n\n```\nclass MyThread extends Thread {\n    private ReentrantLock mLock = new ReentrantLock();\n\n    @Override\n    public void run() {\n        super.run();\n\n        try {\n            if (mLock.tryLock(2, TimeUnit.SECONDS)) {\n                try {\n                    Thread.sleep(5000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            if (mLock.isHeldByCurrentThread()) {\n                mLock.unlock();\n            }\n        }\n    }\n}\n```\n\nReentrantLock.tryLock()也可以不带参数直接运行。在这种情况下,当前线程会尝试获得锁,如果锁并未被其他线程占用,则申请锁会成功,并立即返回true。如果锁被其他线程占用,则当前线程不会进行等待,而是立即返回false。\n\n## ReentrantLock可以设置公平锁\n\n大多数情况下,锁的申请是非公平的。也就是说,线程1首先请求了锁A，接着线程2也请求了锁A。那么当锁A可用时,是线程1可以获得锁还是线程2可以获得锁呢？这是不一定的。系统只是会从这个锁的等待队列里随机挑选一个:\n\n```\nclass MyThread extends Thread {\n    private ReentrantLock mLock;\n\n    public MyThread(String name, ReentrantLock lock) {\n        super(name);\n        this.mLock = lock;\n    }\n\n    @Override\n    public void run() {\n        super.run();\n\n        while (true) {\n            mLock.lock();\n            System.out.println(Thread.currentThread().getName() + \"获得锁\");\n            mLock.unlock();\n        }\n    }\n}\n```\n\n```\nReentrantLock lock = new ReentrantLock();\nMyThread t1 = new MyThread(\"t1\", lock);\nt1.start();\n\nMyThread t2 = new MyThread(\"t2\", lock);\nt2.start();\n\ntry {\n    t1.join();\n    t2.join();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n```\n\n打印如下:\n\n```\nt1获得锁\nt2获得锁\nt2获得锁\nt2获得锁\nt1获得锁\nt2获得锁\nt2获得锁\nt1获得锁\nt2获得锁\nt1获得锁\nt2获得锁\nt2获得锁\nt2获得锁\nt1获得锁\nt1获得锁\n```\n\nsynchronized产生的锁也是非公平的。但如果使用ReentrantLock(boolean fair)构造函数创建ReentrantLock,并且传入true。则该重入锁是公平的:\n\n```\nReentrantLock lock = new ReentrantLock(true);\nMyThread t1 = new MyThread(\"t1\", lock);\nt1.start();\n\nMyThread t2 = new MyThread(\"t2\", lock);\nt2.start();\n\ntry {\n    t1.join();\n    t2.join();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n```\n\n打印如下:\n\n```\nt1获得锁\nt2获得锁\nt1获得锁\nt2获得锁\nt1获得锁\nt2获得锁\nt1获得锁\nt2获得锁\nt1获得锁\nt2获得锁\nt1获得锁\n```\n\n需要注意的是实现公平锁必然要求系统维护一个有序队列,所以公平锁的实现成本较高,性能也相对低下,因此,默认情况下,锁是非公平的。\n\n## ReentrantLock可以与Condition配合使用\n\nCondition和之前讲过的Object.wait()还有Object.notify()的作用大致相同:\n\n```\nclass MyThread extends Thread {\n\tprivate ReentrantLock mLock;\n\tprivate Condition mCondition;\n\t\n\tpublic MyThread(ReentrantLock lock, Condition condition) {\n\t    this.mLock = lock;\n\t    this.mCondition = condition;\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t    super.run();\n\t\n\t    mLock.lock();\n\t    try {\n\t        mCondition.await();\n\t    } catch (InterruptedException e) {\n\t        e.printStackTrace();\n\t    }\n\t    mLock.unlock();\n\t\n\t    System.out.println(\"in MyThread\");\n\t}\n}\n```\n\n```\nReentrantLock lock = new ReentrantLock();\nCondition condition = lock.newCondition();\nMyThread t = new MyThread(lock, condition);\nt.start();\n\nSystem.out.println(\"before sleep\");\ntry {\n    Thread.sleep(2000);\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\nSystem.out.println(\"after sleep\");\n\nlock.lock();\ncondition.signal();\nlock.unlock();\n\ntry {\n    t.join();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n```\n\nCondition的操作需要在ReentrantLock.lock()和ReentrantLock.unlock()之间进行的。\n\nReentrantLock.newCondition()可以创建一个Condition。Condition.await()方法相当于Object.wait()方法,而Condition.signal()方法相当于Object.notify()方法。当然它也有对应的Condition.signalAll()方法。\n\n同样的在调用Condition.await()之后,线程占用的锁会被释放。这样在Condition.signal()方法调用的时候才获取到锁。\n\n需要注意的是Condition.signal()方法调用之后,被唤醒的线程因为需要重新获取锁。所以需要等到调用Condition.signal()的线程释放了锁(调用ReentrantLock.unlock())之后才能继续执行。\n\n\nCondition接口的基本方法如下,它提供了限时等待、不可中断的等待之类的操作:\n\n```\nvoid await() throws InterruptedException;\nvoid awaitUninterruptibly();\nlong awaitNanos(long nanosTimeout) throws InterruptedException;\nboolean await(long time, TimeUnit unit) throws InterruptedException;\nboolean awaitUntil(Date deadline) throws InterruptedException;\nvoid signal();\nvoid signalAll();\n```\n\n# 信号量\n\n信号量为多线程协作提供了更为强大的控制方法。广义上说,信号量是对锁的拓展。无论是synchronize还是重入锁,一次都只运行一个线程访问一个资源,而信号锁则可以指定多个线程,同时访问某一个资源。\n\n像下面的代码, MyRunnable被加锁的代码块一次会被5个线程执行:\n\n```\npublic class MyRunnable implements Runnable {\n    private Semaphore mSemaphore;\n\n    public MyRunnable(Semaphore semaphore) {\n        mSemaphore = semaphore;\n    }\n\n    @Override\n    public void run() {\n        try {\n            mSemaphore.acquire();\n            Thread.sleep(2000);\n            System.out.println(\"thread \" + Thread.currentThread().getId() + \" working\");\n            mSemaphore.release();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n```\n Semaphore semaphore = new Semaphore(5);\nfor (int i = 0; i < 19; i++) {\n    new Thread(new MyRunnable(semaphore)).start();\n}\n\nThread t = new Thread(new MyRunnable(semaphore));\nt.start();\nt.join();\n```\n\nSemaphore.acquire()方法尝试获得一个准入许可。如无法获得,线程就会等待。而Semaphore.release()则在线程访问资源结束后,释放一个许可。\n\nSemaphore有下面的一些常用方法:\n\n```\npublic Semaphore(int permits)\npublic Semaphore(int permits, boolean fair)\npublic void acquire() \npublic void acquireUninterruptibly()\npublic boolean tryAcquire()\npublic boolean tryAcquire(long timeout, TimeUnit unit)\npublic void release()\n```\n\n# 其他的一些锁\n\n## 读写锁\n\n读写锁(ReadWriteLock)是JDK5中提供的分离锁。读写分离锁可以有效的减少锁竞争。\n\n读写锁允许多个线程同时读,但是写写操作和读写操作就需要相互等待了。读写锁的访问约束如下:\n\n||读|写|\n|:-:|:-:|:-:|\n|读|非阻塞|阻塞|\n|写|阻塞|阻塞|\n\n读写操作在某些特定操作下可以提高程序的性能,如下面的代码。如果使用重入锁,需要十一秒左右才能运行完:\n\n```\npublic class Data {\n    private String mData = \"data\";\n    private ReentrantLock mLock = new ReentrantLock();\n\n    public String readData(){\n        mLock.lock();\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"read data : \" + mData);\n        String data = mData;\n        mLock.unlock();\n        return data;\n    }\n\n    public void writeData(String data){\n        mLock.lock();\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        mData = data;\n        System.out.println(\"write data : \" + mData);\n        mLock.unlock();\n    }\n}\n```\n\n```\nfinal Data data = new Data();\nfor (int i = 0; i < 10; i++) {\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            data.readData();\n        }\n    }).start();\n}\n\nThread write = new Thread(new Runnable() {\n    @Override\n    public void run() {\n       data.writeData(\"update data\");\n    }\n});\nwrite.start();\n```\n\n但是如果将重入锁改成读写锁的话只需要两秒左右就能完成:\n\n```\npublic class Data {\n    private String mData = \"data\";\n    private ReadWriteLock mLock = new ReentrantReadWriteLock();\n    private Lock mReadLock = mLock.readLock();\n    private Lock mWriteLock = mLock.writeLock();\n\n    public String readData(){\n        mReadLock.lock();\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        String data = mData;\n        System.out.println(\"read data : \" + mData);\n        mReadLock.unlock();\n        return data;\n    }\n\n    public void writeData(String data){\n        mWriteLock.lock();\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"write data : \" + mData);\n        mData = data;\n        mWriteLock.unlock();\n    }\n}\n```\n\n# 倒计时器、循环栅栏\n\n\n倒计时器(CountDownLatch)和循环栅栏(CyclicBarrier)因为比较不常用,所以这里就不讲了,有兴趣的同学可以自己去看一下《实战Java高并发程序设计》这本书。\n","slug":"Java多线程-各种线程锁","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2uof003mw3fy149zgs2g"},{"title":"Java多线程 - Future模式","date":"2017-09-09T07:51:43.000Z","_content":"\n# 什么是Future模式\n\nFuture模式是多线程开发中非常常见的一种设计模式。它的核心思想是异步调用。当我们需要调用一个函数方法时。如果这个函数执行很慢,那么我们就要进行等待。但有时候,我们可能并不急着要结果。因此,我们可以让被调用者立即返回,让他在后台慢慢处理这个请求。对于调用者来说,则可以先处理一些其他任务,在真正需要数据的场合再去尝试获取需要的数据。\n\n用生活中的例子来打个比喻,就像叫外卖。比如在午休之前我们可以提前叫外卖,只需要点好食物,下个单。然后我们可以继续工作。到了中午下班的时候外卖也就到了,然后就可以吃个午餐,再美滋滋的睡个午觉。而如果你在下班的时候才叫外卖,那就只能坐在那里干等着外卖小哥,最后拿到外卖吃完午饭,午休时间也差不多结束了。\n\n使用Future模式,获取数据的时候无法立即得到需要的数据。而是先拿到一个契约,你可以再将来需要的时候再用这个契约去获取需要的数据,这个契约就好比叫外卖的例子里的外卖订单。\n\n# 用普通方式和Future模式的差别\n\n我们可以看一下使用普通模式和用Future模式的时序图。可以看出来普通模式是串行的,在遇到耗时操作的时候只能等待。而Future模式,只是发起了耗时操作,函数立马就返回了,并不会阻塞客户端线程。所以在工作线程执行耗时操作的时候客户端无需等待,可以继续做其他事情,等到需要的时候再向工作线程获取结果:\n\n{% img /Java多线程-Future模式/1.png %}\n\n# Future模式的简单实现\n\n首先是FutureData,它是只是一个包装类,创建它不需要耗时。在工作线程准备好数据之后可以使用setData方法将数据传入。而客户端线程只需要在需要的时候调用getData方法即可,如果这个时候数据还没有准备好,那么getData方法就会等待,如果已经准备好了就好直接返回。\n\n```\npublic class FutureData<T> {\n    private boolean mIsReady = false;\n    private T mData;\n\n    public synchronized void setData(T data) {\n        mIsReady = true;\n        mData = data;\n\n        notifyAll();\n    }\n\n    public synchronized T getData() {\n        while (!mIsReady) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        return mData;\n    }\n}\n```\n\n接着是服务端,客户端在向服务端请求数据的时候服务端不会实际去加载数据,它只是创建一个FutureData,然后创建子线程去加载,而它只需要直接返回FutureData就可以了。\n\n```\npublic class Server {\n    public FutureData<String> getString() {\n        final FutureData<String> data = new FutureData<>();\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                data.setData(\"world\");\n            }\n        }).start();\n\n        return data;\n    }\n}\n```\n\n客户端代码如下,整个程序只需要运行2秒多,但如果不使用Future模式的话就需要三秒了。\n\n```\nServer server = new Server();\nFutureData<String> futureData = server.getString();\n\n//先执行其他操作\nString hello = \"hello\";\ntry {\n    Thread.sleep(1000);\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n\nSystem.out.print(hello + \" \" + futureData.getData());\n```\n\n# JDK中的Future模式\n\n还记得我之前的一篇文章《Java多线程 - 线程池》中写的ExecutorService.execute()和ExecutorService.submit()的区别吗(如果没有看过的读者可以去看一下)？\n\nexecute方法其实是在Executor中定义的,而ExecutorService继承了Executor。它只是简单的提交了一个Runnable给线程池中的线程去调用:\n\n```\npublic interface Executor {\n    void execute(Runnable command);\n}\n\npublic interface ExecutorService extends Executor {\n\t...\n}\n```\n\n而submit方法是ExecutorService中定义的,它们都会返回一个Future对象。实际上submit方法就是使用的Future模式:\n\n```\npublic interface ExecutorService extends Executor {\n\t...\n\t<T> Future<T> submit(Callable<T> task);\n\t\t\n\t<T> Future<T> submit(Runnable task, T result);\n\t\t\n\tFuture<?> submit(Runnable task);\n\t...\n}\n```\n\n__Future<?> submit(Runnable task) :__\n\n它的返回值实际上是Future<Void>,子线程是不会返回数据的。\n\n__<T> Future<T> submit(Runnable task, T result) :__\n\n这个方法是不是很蛋疼,返回的结果在调用的时候已经给出了。如果我一开始就知道结果那我为什么又要发起子线程呢？\n\n其实不然,这个result可以是一个代理,它不是实际的结果,它只是存储了结果。我这里给出一个例子大家体会一下吧:\n\n```\nfinal String[] result = new String[1];\n\nRunnable r = new Runnable() {\n    public void run() {\n        result[0] = \"hello world\";\n    }\n};\n\nFuture<String[]> future = Executors.newSingleThreadExecutor().submit(r, result);\n    \ntry {\n    System.out.println(\"result[0]: \" + future.get()[0]);\n} catch (InterruptedException e) {\n    e.printStackTrace();\n} catch (ExecutionException e) {\n    e.printStackTrace();\n}\n```\n\n__<T> Future<T> submit(Callable<T> task) :__\n\n这个方法就比较好理解了, Callable.call()方法在子线程中被调用,同时它有返回值,只有将加载的数据直接return出来就好:\n\n```\nFuture<String> future = Executors.newSingleThreadExecutor()\n        .submit(new Callable<String>() {\n            @Override\n            public String call() throws Exception {\n                return \"Hello World\";\n            }\n        });\n\ntry {\n    System.out.print(future.get());\n} catch (InterruptedException e) {\n    e.printStackTrace();\n} catch (ExecutionException e) {\n    e.printStackTrace();\n}\n```\n\n# 一个实际的例子\n\n比如我们在计算两个List<Integer>中的数的总和的时候就可以用Future模式提高效率:\n\n```\npublic int getTotal(final List<Integer> a, final List<Integer> b) throws ExecutionException, InterruptedException {\n    Future<Integer> future = Executors.newCachedThreadPool().submit(new Callable<Integer>() {\n        @Override\n        public Integer call() throws Exception {\n            int r = 0;\n            for (int num : a) {\n                r += num;\n            }\n            return r;\n        }\n    });\n\n    int r = 0;\n    for (int num : b) {\n        r += num;\n    }\n    return r + future.get();\n}\n```\n","source":"_posts/Java多线程-Future模式.md","raw":"title: Java多线程 - Future模式\ndate: 2017-09-09 15:51:43\ntags:\n\t- 技术相关\n\t- java\n---\n\n# 什么是Future模式\n\nFuture模式是多线程开发中非常常见的一种设计模式。它的核心思想是异步调用。当我们需要调用一个函数方法时。如果这个函数执行很慢,那么我们就要进行等待。但有时候,我们可能并不急着要结果。因此,我们可以让被调用者立即返回,让他在后台慢慢处理这个请求。对于调用者来说,则可以先处理一些其他任务,在真正需要数据的场合再去尝试获取需要的数据。\n\n用生活中的例子来打个比喻,就像叫外卖。比如在午休之前我们可以提前叫外卖,只需要点好食物,下个单。然后我们可以继续工作。到了中午下班的时候外卖也就到了,然后就可以吃个午餐,再美滋滋的睡个午觉。而如果你在下班的时候才叫外卖,那就只能坐在那里干等着外卖小哥,最后拿到外卖吃完午饭,午休时间也差不多结束了。\n\n使用Future模式,获取数据的时候无法立即得到需要的数据。而是先拿到一个契约,你可以再将来需要的时候再用这个契约去获取需要的数据,这个契约就好比叫外卖的例子里的外卖订单。\n\n# 用普通方式和Future模式的差别\n\n我们可以看一下使用普通模式和用Future模式的时序图。可以看出来普通模式是串行的,在遇到耗时操作的时候只能等待。而Future模式,只是发起了耗时操作,函数立马就返回了,并不会阻塞客户端线程。所以在工作线程执行耗时操作的时候客户端无需等待,可以继续做其他事情,等到需要的时候再向工作线程获取结果:\n\n{% img /Java多线程-Future模式/1.png %}\n\n# Future模式的简单实现\n\n首先是FutureData,它是只是一个包装类,创建它不需要耗时。在工作线程准备好数据之后可以使用setData方法将数据传入。而客户端线程只需要在需要的时候调用getData方法即可,如果这个时候数据还没有准备好,那么getData方法就会等待,如果已经准备好了就好直接返回。\n\n```\npublic class FutureData<T> {\n    private boolean mIsReady = false;\n    private T mData;\n\n    public synchronized void setData(T data) {\n        mIsReady = true;\n        mData = data;\n\n        notifyAll();\n    }\n\n    public synchronized T getData() {\n        while (!mIsReady) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        return mData;\n    }\n}\n```\n\n接着是服务端,客户端在向服务端请求数据的时候服务端不会实际去加载数据,它只是创建一个FutureData,然后创建子线程去加载,而它只需要直接返回FutureData就可以了。\n\n```\npublic class Server {\n    public FutureData<String> getString() {\n        final FutureData<String> data = new FutureData<>();\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                data.setData(\"world\");\n            }\n        }).start();\n\n        return data;\n    }\n}\n```\n\n客户端代码如下,整个程序只需要运行2秒多,但如果不使用Future模式的话就需要三秒了。\n\n```\nServer server = new Server();\nFutureData<String> futureData = server.getString();\n\n//先执行其他操作\nString hello = \"hello\";\ntry {\n    Thread.sleep(1000);\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n\nSystem.out.print(hello + \" \" + futureData.getData());\n```\n\n# JDK中的Future模式\n\n还记得我之前的一篇文章《Java多线程 - 线程池》中写的ExecutorService.execute()和ExecutorService.submit()的区别吗(如果没有看过的读者可以去看一下)？\n\nexecute方法其实是在Executor中定义的,而ExecutorService继承了Executor。它只是简单的提交了一个Runnable给线程池中的线程去调用:\n\n```\npublic interface Executor {\n    void execute(Runnable command);\n}\n\npublic interface ExecutorService extends Executor {\n\t...\n}\n```\n\n而submit方法是ExecutorService中定义的,它们都会返回一个Future对象。实际上submit方法就是使用的Future模式:\n\n```\npublic interface ExecutorService extends Executor {\n\t...\n\t<T> Future<T> submit(Callable<T> task);\n\t\t\n\t<T> Future<T> submit(Runnable task, T result);\n\t\t\n\tFuture<?> submit(Runnable task);\n\t...\n}\n```\n\n__Future<?> submit(Runnable task) :__\n\n它的返回值实际上是Future<Void>,子线程是不会返回数据的。\n\n__<T> Future<T> submit(Runnable task, T result) :__\n\n这个方法是不是很蛋疼,返回的结果在调用的时候已经给出了。如果我一开始就知道结果那我为什么又要发起子线程呢？\n\n其实不然,这个result可以是一个代理,它不是实际的结果,它只是存储了结果。我这里给出一个例子大家体会一下吧:\n\n```\nfinal String[] result = new String[1];\n\nRunnable r = new Runnable() {\n    public void run() {\n        result[0] = \"hello world\";\n    }\n};\n\nFuture<String[]> future = Executors.newSingleThreadExecutor().submit(r, result);\n    \ntry {\n    System.out.println(\"result[0]: \" + future.get()[0]);\n} catch (InterruptedException e) {\n    e.printStackTrace();\n} catch (ExecutionException e) {\n    e.printStackTrace();\n}\n```\n\n__<T> Future<T> submit(Callable<T> task) :__\n\n这个方法就比较好理解了, Callable.call()方法在子线程中被调用,同时它有返回值,只有将加载的数据直接return出来就好:\n\n```\nFuture<String> future = Executors.newSingleThreadExecutor()\n        .submit(new Callable<String>() {\n            @Override\n            public String call() throws Exception {\n                return \"Hello World\";\n            }\n        });\n\ntry {\n    System.out.print(future.get());\n} catch (InterruptedException e) {\n    e.printStackTrace();\n} catch (ExecutionException e) {\n    e.printStackTrace();\n}\n```\n\n# 一个实际的例子\n\n比如我们在计算两个List<Integer>中的数的总和的时候就可以用Future模式提高效率:\n\n```\npublic int getTotal(final List<Integer> a, final List<Integer> b) throws ExecutionException, InterruptedException {\n    Future<Integer> future = Executors.newCachedThreadPool().submit(new Callable<Integer>() {\n        @Override\n        public Integer call() throws Exception {\n            int r = 0;\n            for (int num : a) {\n                r += num;\n            }\n            return r;\n        }\n    });\n\n    int r = 0;\n    for (int num : b) {\n        r += num;\n    }\n    return r + future.get();\n}\n```\n","slug":"Java多线程-Future模式","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2uog003pw3fypssoih65"},{"title":"GTest源码剖析 - 测试代码的注册","date":"2016-02-15T14:07:08.000Z","_content":"单元测试框架，最基本的功能当然就是运行用户所编写的测试用例了。\n\n## __毫无技巧的方法__\n\n一种毫无技巧的方法就是用户手动在 main 函数里面将自己编写的测试代码注册到框架中，就像下面的代码：\n```cpp\n    void test1() {...}\n    void test2() {...}\n    void test3() {...}\n    ...\n\n    int main(){\n        RegisterTestFunc(test1);\n        RegisterTestFunc(test2);\n        RegisterTestFunc(test3);\n        ...\n        return 0;\n    }\n```\n\n这样的代码虽然可以运行，但是将初始化的责任放到的用户那里，这样的代码是不够优秀的。有两种容易出现的情况：一是项目中可能拥有大量的测试代码，用户很有可能会漏掉其中的部分测试代码，忘记把它们注册到测试框架中。二是可能用户去掉了一些测试代码，却又忘了去掉注册的代码。\n\n后者编译器会报错，但前者却没有办法检测（除非对着测试结果一条条的检测，看是否所有测试代码都运行了）。\n\n## __一种有问题的方法__\n\n最好在编写测试代码的时候就能通过一种机制帮用户注册，而不用用户手动去注册。面对这个需求，我脑海里面想到的第一个方法就是利用全局变量和宏定义。\n\n首先定义一个用来管理注册的测试方法的类：\n```cpp\n\ttypedef list<function<void()>> FuncList;\n    class Test{\n    public:\n        Test(const function<void()>& test_func){\n            test_funcs_.push_back(test_func);\n        }\n\n        static void runAllTest(){\n            for (auto func : test_funcs_){\n                func();\n            }\n        }\n\n    private:\n        static FuncList test_funcs_;\n    };\n```\n\n它有一个静态的成员变量 test\\_funcs\\_ ，用来保存测试方法，同时它有一个构造函数用来将传入的测试方法插入 test\\_funcs\\_ 中\n\n接着定义一个宏：\n```cpp\n    #define TEST_FUNC(NAME) \\\n        void NAME(); \\\n        static Test register_##NAME(NAME); \\\n        void NAME()\n```\n它在帮助我们在定义一个测试方法的时候自动注册到 test\\_funcs\\_ 中。原理其实很简单，就是在声明一个函数的同时声明一个 Test 全局变量，将定义的测试方法传入，这个测试函数就会在 Test 的构造函数中被插入 test\\_funcs\\_ 。\n\n所以我们只要这样编写测试代码，就能实现自动注册了：\n```cpp\n\tTEST_FUNC(testSomething){\n        ...\n    }\n```\n\n看起来这个方法不错是吧？可惜这种方法是有问题的！至少在我的 vs2013 上会崩溃！\n\n问题就出在 Test 全局变量和 Test::test\\_funcs\\_ 的初始化顺序上。你无法保证 Test::test\\_funcs\\_ 比全局变量 Test 先初始化。很奇怪是吧？ Test 的静态成员变量居然比 Test 全局变量的初始化时间晚，也就是说在 Test 这个类还没有完全准备好的时候，就已经拿来创建一个全局变量了。书上一直强调的全局变量的初始化顺序不能确定难道也有这种含义？\n\n## __一种可能可行的方法__\n\n既然是因为初始化顺序导致了内存错误，那我们只要使用某种机制让保存测试函数的容器首先初始化就行了。\n\n让我们将 Test 类的定义修改成下面的样子：\n\n```cpp\n    class Test{\n    public:\n        virtual void run() = 0;\n\n        static void runAllTest(){\n            for (auto i : test_list){\n                i->run();\n            }\n        }\n\n    protected:\n        static void addTest(Test* test){\n            test_list.push_back(test);\n        }\n\n    private:\n        static list<Test*> test_list;\n    };\n```\n\n容器里面不再直接放测试函数，改为放 Test 的指针。而 Test 又是一个抽象类，所以事实上放的是 Test 的子类。\n\n再把 TEST_FUNC 宏的定义改成下面的样子：\n\n```cpp\n    #define TEST_FUNC(NAME) \\\n        class NAME : public Test{ \\\n        public: \\\n            virtual void run(); \\\n        private: \\\n            NAME(){ \\\n                addTest(this); \\\n            } \\\n            static NAME* instance_; \\\n        }; \\\n        NAME* NAME::instance_ = new NAME(); \\\n        void NAME::run()\n\n```\n\n现在实际上用户写的测试方法实现的是 Test 的子类的 run 方法。\n\n依然是需要在定义测试方法的时候顺便定义一个全局变量，但我们换了一种方式，定义了一个类静态变量。子类在构造函数中把自己注册到 Test 的测试容器中，而且子类还包含了一个本类指针静态成员变量（有点拗口，但看代码很容易看出来）。在子类的静态成员变量初始化的之前，父类的静态成员变量应该就已经初始化了。就是根据这种机制，达到了我们的目的。\n\n使用方法还是一样：\n\n```cpp\n    TEST_FUNC(testSomething){\n        ...\n    }\n```\n\n为什么说这是“一种可能可行的方法”呢？因为父类的静态成员变量初始化先于子类的静态成员变量初始化这个前提是我自己推论的。可能是我读的书少或者读书不仔细，至今没有在哪里见到有提及父类和子类的静态成员变量的初始化顺序的。所以虽然在我的编译器上它的确能正常的工作，但为了严谨起见，姑且称为“可能”的吧。如果有人有在哪里看到这方面的描述，请务必私信我，让我把“可能”二字去掉或者将标题改成“另一种有问题的方法”\n\n## __GTest 的做法__\n\n讲了这么久我的想法，现状让我们来看看谷歌的大神们是怎么做的吧。\n\n我们从 TEST 宏看起：\n\n```cpp\n    #if !GTEST_DONT_DEFINE_TEST\n    # define TEST(test_case_name, test_name) GTEST_TEST(test_case_name, test_name)\n    #endif\n```\n\n这里这么搞，主要是为了防止 TEST 被系统或者其他框架定义了。如果出现这种情况，只要把GTEST\\_DONT\\_DEFINE\\_TEST 定义为 1，之后编写测试用例的时候直接使用 GTEST\\_TEST 就好了。不得不说，他们考虑的真仔细。让我们继续跟踪，看 GTEST\\_TEST：\n\n```cpp\n    #define GTEST_TEST(test_case_name, test_name)\\\n      GTEST_TEST_(test_case_name, test_name, \\\n                  ::testing::Test, ::testing::internal::GetTestTypeId())\n```\n\nGTEST\\_TEST 宏又用到了另一个宏 GTEST\\_TEST\\_，但我想先说一下 GetTestTypeId，这个东西的用法真的令我眼前一亮，不得不佩服：\n\n```cpp\n    TypeId GetTestTypeId() {\n      return GetTypeId<Test>();\n    }\n\n\t...\n\n\ttemplate <typename T>\n    TypeId GetTypeId() {\n      // The compiler is required to allocate a different\n      // TypeIdHelper<T>::dummy_ variable for each T used to instantiate\n      // the template.  Therefore, the address of dummy_ is guaranteed to\n      // be unique.\n      return &(TypeIdHelper<T>::dummy_);\n    }\n\n\t...\n\n    template <typename T>\n    class TypeIdHelper {\n     public:\n      // dummy_ must not have a const type.  Otherwise an overly eager\n      // compiler (e.g. MSVC 7.1 & 8.0) may try to merge\n      // TypeIdHelper<T>::dummy_ for different Ts as an \"optimization\".\n      static bool dummy_;\n    };\n```\n\n这里直接用一个类的静态成员变量的地址当作 id 号。当时我就懵逼了，明明很简单，怎么就感觉那么玄幻呢？\n\n膜拜完我们再继续看 GTEST\\_TEST\\_：\n```cpp\n    #define GTEST_TEST_(test_case_name, test_name, parent_class, parent_id)\\\n    class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class {\\\n     public:\\\n      GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}\\\n     private:\\\n      virtual void TestBody();\\\n      static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;\\\n      GTEST_DISALLOW_COPY_AND_ASSIGN_(\\\n          GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\\\n    };\\\n    \\\n    ::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)\\\n      ::test_info_ =\\\n        ::testing::internal::MakeAndRegisterTestInfo(\\\n            #test_case_name, #test_name, NULL, NULL, \\\n            (parent_id), \\\n            parent_class::SetUpTestCase, \\\n            parent_class::TearDownTestCase, \\\n            new ::testing::internal::TestFactoryImpl<\\\n                GTEST_TEST_CLASS_NAME_(test_case_name, test_name)>);\\\n    void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()\n```\n\n这个宏的做法和我的最后一个方法的 TEST\\_FUNC 宏差不多，用户写的测试函数实际上是实现了 ::testing::Test 的子类的 TestBody 方法。也是初始化了子类的一个静态成员变量，但GTest这里没有我那么暴力，它初始化的是一个 TestInfo 类型的的静态成员变量，这里面包含了测试的很多信息。其中最重要的是 ::testing::internal::TestFactoryImpl 这个东西：\n\n```cpp\n    template <class TestClass>\n    class TestFactoryImpl : public TestFactoryBase {\n     public:\n      virtual Test* CreateTest() { return new TestClass; }\n    };\n\n    ...\n\n\tclass TestFactoryBase {\n     public:\n      virtual ~TestFactoryBase() {}\n\n      // Creates a test instance to run. The instance is both created and destroyed\n      // within TestInfoImpl::Run()\n      virtual Test* CreateTest() = 0;\n\n     protected:\n      TestFactoryBase() {}\n\n     private:\n      GTEST_DISALLOW_COPY_AND_ASSIGN_(TestFactoryBase);\n    };\n```\n\n它是一个工厂类，用来创建传入的测试类的实例，也就是 GTEST\\_TEST\\_CLASS\\_NAME\\_(test\\_case\\_name, test\\_name)> 这个类，它的 TestBody 就是用户所写的测试代码。可以看看 GTEST\\_TEST\\_CLASS\\_NAME\\_ 的定义：\n\n```cpp\n    #define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n      test_case_name##_##test_name##_Test\n```\n\nok,很简单是吧？就是字符串拼接而已。\n\n好了，让我们继续深入，看看 MakeAndRegisterTestInfo ：\n```cpp\n\t//gtest.cc\n    TestInfo* MakeAndRegisterTestInfo(\n        const char* test_case_name,\n        const char* name,\n        const char* type_param,\n        const char* value_param,\n        TypeId fixture_class_id,\n        SetUpTestCaseFunc set_up_tc,\n        TearDownTestCaseFunc tear_down_tc,\n        TestFactoryBase* factory) {\n      TestInfo* const test_info =\n          new TestInfo(test_case_name, name, type_param, value_param,\n                       fixture_class_id, factory);\n      GetUnitTestImpl()->AddTestInfo(set_up_tc, tear_down_tc, test_info);\n      return test_info;\n    }\n\n\t//gtest-internal-inl.h\n\tinline UnitTestImpl* GetUnitTestImpl() {\n      return UnitTest::GetInstance()->impl();\n    }\n\n    //gtest.h\n    class GTEST_API_ UnitTest {\n     public:\n      static UnitTest* GetInstance();\n      ...\n      internal::UnitTestImpl* impl() { return impl_; }\n      ...\n      internal::UnitTestImpl* impl_;\n      ...\n    };\n\n    //gtest.cc\n    UnitTest* UnitTest::GetInstance() {\n      // When compiled with MSVC 7.1 in optimized mode, destroying the\n      // UnitTest object upon exiting the program messes up the exit code,\n      // causing successful tests to appear failed.  We have to use a\n      // different implementation in this case to bypass the compiler bug.\n      // This implementation makes the compiler happy, at the cost of\n      // leaking the UnitTest object.\n\n      // CodeGear C++Builder insists on a public destructor for the\n      // default implementation.  Use this implementation to keep good OO\n      // design with private destructor.\n\n    #if (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)\n      static UnitTest* const instance = new UnitTest;\n      return instance;\n    #else\n      static UnitTest instance;\n      return &instance;\n    #endif  // (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)\n    }\n\n    //gtest-internal-inl.h\n    class GTEST_API_ UnitTestImpl {\n    \t...\n        void AddTestInfo(Test::SetUpTestCaseFunc set_up_tc,\n                   Test::TearDownTestCaseFunc tear_down_tc,\n                   TestInfo* test_info) {\n        // In order to support thread-safe death tests, we need to\n        // remember the original working directory when the test program\n        // was first invoked.  We cannot do this in RUN_ALL_TESTS(), as\n        // the user may have changed the current directory before calling\n        // RUN_ALL_TESTS().  Therefore we capture the current directory in\n        // AddTestInfo(), which is called to register a TEST or TEST_F\n        // before main() is reached.\n        if (original_working_dir_.IsEmpty()) {\n          original_working_dir_.Set(FilePath::GetCurrentDir());\n          GTEST_CHECK_(!original_working_dir_.IsEmpty())\n              << \"Failed to get the current working directory.\";\n        }\n\n        GetTestCase(test_info->test_case_name(),\n                    test_info->type_param(),\n                    set_up_tc,\n                    tear_down_tc)->AddTestInfo(test_info);\n      }\n      ...\n      //这个方法从test_cases_里面获取TestCase\n      TestCase* GetTestCase(const char* test_case_name,\n                        const char* type_param,\n                        Test::SetUpTestCaseFunc set_up_tc,\n                        Test::TearDownTestCaseFunc tear_down_tc);\n      ...\n      std::vector<TestCase*> test_cases_;\n      ...\n    };\n\n    //gtest.cc\n    void TestCase::AddTestInfo(TestInfo * test_info) {\n      test_info_list_.push_back(test_info);\n      test_indices_.push_back(static_cast<int>(test_indices_.size()));\n    }\n\n    //gtest.h\n    class GTEST_API_ TestCase {\n    \t...\n    \tstd::vector<TestInfo*> test_info_list_;\n        std::vector<int> test_indices_;\n        ...\n    };\n```\n\n代码很多，我简单的描述一下。UnitTest 是一个单例类，它有一个成员变量 internal::UnitTestImpl* impl\\_， impl\\_ 里面又有成员变量 test\\_info\\_list\\_。最终我们写的测试类就放在 test\\_info\\_list\\_ 里。\n\n九曲十八弯，实际 GTest 用一个单例类 UnitTest 保存了注册的测试代码（放在 ::testing::Test 子类的 TestBody 方法里面）。\n\n那他是怎么解决初始化顺序的问题的？注意看 UnitTest::GetInstance() 方法：\n\n```cpp\n\t//gtest.cc\n    UnitTest* UnitTest::GetInstance() {\n      // When compiled with MSVC 7.1 in optimized mode, destroying the\n      // UnitTest object upon exiting the program messes up the exit code,\n      // causing successful tests to appear failed.  We have to use a\n      // different implementation in this case to bypass the compiler bug.\n      // This implementation makes the compiler happy, at the cost of\n      // leaking the UnitTest object.\n\n      // CodeGear C++Builder insists on a public destructor for the\n      // default implementation.  Use this implementation to keep good OO\n      // design with private destructor.\n\n    #if (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)\n      static UnitTest* const instance = new UnitTest;\n      return instance;\n    #else\n      static UnitTest instance;\n      return &instance;\n    #endif  // (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)\n    }\n```\n\n这里使用了局部静态变量，在第一次进入这个方法的时候就会生成一个 UnitTest 实例！不需要靠人品祈祷编译器按照我们设想的顺序创建全局变量！\n\n谷歌大神们不愧是大神，在看 GTest 源码的时候我都不知道被惊艳了多少次，真心学到了不少东西。怪不得别人都说看源码才是最好的提升方式。\n","source":"_posts/GTest源码剖析-测试代码的注册.md","raw":"title: GTest源码剖析 - 测试代码的注册\ndate: 2016-02-15 22:07:08\ntags:\n\t- 技术相关\n\t- 单元测试\n---\n单元测试框架，最基本的功能当然就是运行用户所编写的测试用例了。\n\n## __毫无技巧的方法__\n\n一种毫无技巧的方法就是用户手动在 main 函数里面将自己编写的测试代码注册到框架中，就像下面的代码：\n```cpp\n    void test1() {...}\n    void test2() {...}\n    void test3() {...}\n    ...\n\n    int main(){\n        RegisterTestFunc(test1);\n        RegisterTestFunc(test2);\n        RegisterTestFunc(test3);\n        ...\n        return 0;\n    }\n```\n\n这样的代码虽然可以运行，但是将初始化的责任放到的用户那里，这样的代码是不够优秀的。有两种容易出现的情况：一是项目中可能拥有大量的测试代码，用户很有可能会漏掉其中的部分测试代码，忘记把它们注册到测试框架中。二是可能用户去掉了一些测试代码，却又忘了去掉注册的代码。\n\n后者编译器会报错，但前者却没有办法检测（除非对着测试结果一条条的检测，看是否所有测试代码都运行了）。\n\n## __一种有问题的方法__\n\n最好在编写测试代码的时候就能通过一种机制帮用户注册，而不用用户手动去注册。面对这个需求，我脑海里面想到的第一个方法就是利用全局变量和宏定义。\n\n首先定义一个用来管理注册的测试方法的类：\n```cpp\n\ttypedef list<function<void()>> FuncList;\n    class Test{\n    public:\n        Test(const function<void()>& test_func){\n            test_funcs_.push_back(test_func);\n        }\n\n        static void runAllTest(){\n            for (auto func : test_funcs_){\n                func();\n            }\n        }\n\n    private:\n        static FuncList test_funcs_;\n    };\n```\n\n它有一个静态的成员变量 test\\_funcs\\_ ，用来保存测试方法，同时它有一个构造函数用来将传入的测试方法插入 test\\_funcs\\_ 中\n\n接着定义一个宏：\n```cpp\n    #define TEST_FUNC(NAME) \\\n        void NAME(); \\\n        static Test register_##NAME(NAME); \\\n        void NAME()\n```\n它在帮助我们在定义一个测试方法的时候自动注册到 test\\_funcs\\_ 中。原理其实很简单，就是在声明一个函数的同时声明一个 Test 全局变量，将定义的测试方法传入，这个测试函数就会在 Test 的构造函数中被插入 test\\_funcs\\_ 。\n\n所以我们只要这样编写测试代码，就能实现自动注册了：\n```cpp\n\tTEST_FUNC(testSomething){\n        ...\n    }\n```\n\n看起来这个方法不错是吧？可惜这种方法是有问题的！至少在我的 vs2013 上会崩溃！\n\n问题就出在 Test 全局变量和 Test::test\\_funcs\\_ 的初始化顺序上。你无法保证 Test::test\\_funcs\\_ 比全局变量 Test 先初始化。很奇怪是吧？ Test 的静态成员变量居然比 Test 全局变量的初始化时间晚，也就是说在 Test 这个类还没有完全准备好的时候，就已经拿来创建一个全局变量了。书上一直强调的全局变量的初始化顺序不能确定难道也有这种含义？\n\n## __一种可能可行的方法__\n\n既然是因为初始化顺序导致了内存错误，那我们只要使用某种机制让保存测试函数的容器首先初始化就行了。\n\n让我们将 Test 类的定义修改成下面的样子：\n\n```cpp\n    class Test{\n    public:\n        virtual void run() = 0;\n\n        static void runAllTest(){\n            for (auto i : test_list){\n                i->run();\n            }\n        }\n\n    protected:\n        static void addTest(Test* test){\n            test_list.push_back(test);\n        }\n\n    private:\n        static list<Test*> test_list;\n    };\n```\n\n容器里面不再直接放测试函数，改为放 Test 的指针。而 Test 又是一个抽象类，所以事实上放的是 Test 的子类。\n\n再把 TEST_FUNC 宏的定义改成下面的样子：\n\n```cpp\n    #define TEST_FUNC(NAME) \\\n        class NAME : public Test{ \\\n        public: \\\n            virtual void run(); \\\n        private: \\\n            NAME(){ \\\n                addTest(this); \\\n            } \\\n            static NAME* instance_; \\\n        }; \\\n        NAME* NAME::instance_ = new NAME(); \\\n        void NAME::run()\n\n```\n\n现在实际上用户写的测试方法实现的是 Test 的子类的 run 方法。\n\n依然是需要在定义测试方法的时候顺便定义一个全局变量，但我们换了一种方式，定义了一个类静态变量。子类在构造函数中把自己注册到 Test 的测试容器中，而且子类还包含了一个本类指针静态成员变量（有点拗口，但看代码很容易看出来）。在子类的静态成员变量初始化的之前，父类的静态成员变量应该就已经初始化了。就是根据这种机制，达到了我们的目的。\n\n使用方法还是一样：\n\n```cpp\n    TEST_FUNC(testSomething){\n        ...\n    }\n```\n\n为什么说这是“一种可能可行的方法”呢？因为父类的静态成员变量初始化先于子类的静态成员变量初始化这个前提是我自己推论的。可能是我读的书少或者读书不仔细，至今没有在哪里见到有提及父类和子类的静态成员变量的初始化顺序的。所以虽然在我的编译器上它的确能正常的工作，但为了严谨起见，姑且称为“可能”的吧。如果有人有在哪里看到这方面的描述，请务必私信我，让我把“可能”二字去掉或者将标题改成“另一种有问题的方法”\n\n## __GTest 的做法__\n\n讲了这么久我的想法，现状让我们来看看谷歌的大神们是怎么做的吧。\n\n我们从 TEST 宏看起：\n\n```cpp\n    #if !GTEST_DONT_DEFINE_TEST\n    # define TEST(test_case_name, test_name) GTEST_TEST(test_case_name, test_name)\n    #endif\n```\n\n这里这么搞，主要是为了防止 TEST 被系统或者其他框架定义了。如果出现这种情况，只要把GTEST\\_DONT\\_DEFINE\\_TEST 定义为 1，之后编写测试用例的时候直接使用 GTEST\\_TEST 就好了。不得不说，他们考虑的真仔细。让我们继续跟踪，看 GTEST\\_TEST：\n\n```cpp\n    #define GTEST_TEST(test_case_name, test_name)\\\n      GTEST_TEST_(test_case_name, test_name, \\\n                  ::testing::Test, ::testing::internal::GetTestTypeId())\n```\n\nGTEST\\_TEST 宏又用到了另一个宏 GTEST\\_TEST\\_，但我想先说一下 GetTestTypeId，这个东西的用法真的令我眼前一亮，不得不佩服：\n\n```cpp\n    TypeId GetTestTypeId() {\n      return GetTypeId<Test>();\n    }\n\n\t...\n\n\ttemplate <typename T>\n    TypeId GetTypeId() {\n      // The compiler is required to allocate a different\n      // TypeIdHelper<T>::dummy_ variable for each T used to instantiate\n      // the template.  Therefore, the address of dummy_ is guaranteed to\n      // be unique.\n      return &(TypeIdHelper<T>::dummy_);\n    }\n\n\t...\n\n    template <typename T>\n    class TypeIdHelper {\n     public:\n      // dummy_ must not have a const type.  Otherwise an overly eager\n      // compiler (e.g. MSVC 7.1 & 8.0) may try to merge\n      // TypeIdHelper<T>::dummy_ for different Ts as an \"optimization\".\n      static bool dummy_;\n    };\n```\n\n这里直接用一个类的静态成员变量的地址当作 id 号。当时我就懵逼了，明明很简单，怎么就感觉那么玄幻呢？\n\n膜拜完我们再继续看 GTEST\\_TEST\\_：\n```cpp\n    #define GTEST_TEST_(test_case_name, test_name, parent_class, parent_id)\\\n    class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class {\\\n     public:\\\n      GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}\\\n     private:\\\n      virtual void TestBody();\\\n      static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;\\\n      GTEST_DISALLOW_COPY_AND_ASSIGN_(\\\n          GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\\\n    };\\\n    \\\n    ::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)\\\n      ::test_info_ =\\\n        ::testing::internal::MakeAndRegisterTestInfo(\\\n            #test_case_name, #test_name, NULL, NULL, \\\n            (parent_id), \\\n            parent_class::SetUpTestCase, \\\n            parent_class::TearDownTestCase, \\\n            new ::testing::internal::TestFactoryImpl<\\\n                GTEST_TEST_CLASS_NAME_(test_case_name, test_name)>);\\\n    void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()\n```\n\n这个宏的做法和我的最后一个方法的 TEST\\_FUNC 宏差不多，用户写的测试函数实际上是实现了 ::testing::Test 的子类的 TestBody 方法。也是初始化了子类的一个静态成员变量，但GTest这里没有我那么暴力，它初始化的是一个 TestInfo 类型的的静态成员变量，这里面包含了测试的很多信息。其中最重要的是 ::testing::internal::TestFactoryImpl 这个东西：\n\n```cpp\n    template <class TestClass>\n    class TestFactoryImpl : public TestFactoryBase {\n     public:\n      virtual Test* CreateTest() { return new TestClass; }\n    };\n\n    ...\n\n\tclass TestFactoryBase {\n     public:\n      virtual ~TestFactoryBase() {}\n\n      // Creates a test instance to run. The instance is both created and destroyed\n      // within TestInfoImpl::Run()\n      virtual Test* CreateTest() = 0;\n\n     protected:\n      TestFactoryBase() {}\n\n     private:\n      GTEST_DISALLOW_COPY_AND_ASSIGN_(TestFactoryBase);\n    };\n```\n\n它是一个工厂类，用来创建传入的测试类的实例，也就是 GTEST\\_TEST\\_CLASS\\_NAME\\_(test\\_case\\_name, test\\_name)> 这个类，它的 TestBody 就是用户所写的测试代码。可以看看 GTEST\\_TEST\\_CLASS\\_NAME\\_ 的定义：\n\n```cpp\n    #define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n      test_case_name##_##test_name##_Test\n```\n\nok,很简单是吧？就是字符串拼接而已。\n\n好了，让我们继续深入，看看 MakeAndRegisterTestInfo ：\n```cpp\n\t//gtest.cc\n    TestInfo* MakeAndRegisterTestInfo(\n        const char* test_case_name,\n        const char* name,\n        const char* type_param,\n        const char* value_param,\n        TypeId fixture_class_id,\n        SetUpTestCaseFunc set_up_tc,\n        TearDownTestCaseFunc tear_down_tc,\n        TestFactoryBase* factory) {\n      TestInfo* const test_info =\n          new TestInfo(test_case_name, name, type_param, value_param,\n                       fixture_class_id, factory);\n      GetUnitTestImpl()->AddTestInfo(set_up_tc, tear_down_tc, test_info);\n      return test_info;\n    }\n\n\t//gtest-internal-inl.h\n\tinline UnitTestImpl* GetUnitTestImpl() {\n      return UnitTest::GetInstance()->impl();\n    }\n\n    //gtest.h\n    class GTEST_API_ UnitTest {\n     public:\n      static UnitTest* GetInstance();\n      ...\n      internal::UnitTestImpl* impl() { return impl_; }\n      ...\n      internal::UnitTestImpl* impl_;\n      ...\n    };\n\n    //gtest.cc\n    UnitTest* UnitTest::GetInstance() {\n      // When compiled with MSVC 7.1 in optimized mode, destroying the\n      // UnitTest object upon exiting the program messes up the exit code,\n      // causing successful tests to appear failed.  We have to use a\n      // different implementation in this case to bypass the compiler bug.\n      // This implementation makes the compiler happy, at the cost of\n      // leaking the UnitTest object.\n\n      // CodeGear C++Builder insists on a public destructor for the\n      // default implementation.  Use this implementation to keep good OO\n      // design with private destructor.\n\n    #if (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)\n      static UnitTest* const instance = new UnitTest;\n      return instance;\n    #else\n      static UnitTest instance;\n      return &instance;\n    #endif  // (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)\n    }\n\n    //gtest-internal-inl.h\n    class GTEST_API_ UnitTestImpl {\n    \t...\n        void AddTestInfo(Test::SetUpTestCaseFunc set_up_tc,\n                   Test::TearDownTestCaseFunc tear_down_tc,\n                   TestInfo* test_info) {\n        // In order to support thread-safe death tests, we need to\n        // remember the original working directory when the test program\n        // was first invoked.  We cannot do this in RUN_ALL_TESTS(), as\n        // the user may have changed the current directory before calling\n        // RUN_ALL_TESTS().  Therefore we capture the current directory in\n        // AddTestInfo(), which is called to register a TEST or TEST_F\n        // before main() is reached.\n        if (original_working_dir_.IsEmpty()) {\n          original_working_dir_.Set(FilePath::GetCurrentDir());\n          GTEST_CHECK_(!original_working_dir_.IsEmpty())\n              << \"Failed to get the current working directory.\";\n        }\n\n        GetTestCase(test_info->test_case_name(),\n                    test_info->type_param(),\n                    set_up_tc,\n                    tear_down_tc)->AddTestInfo(test_info);\n      }\n      ...\n      //这个方法从test_cases_里面获取TestCase\n      TestCase* GetTestCase(const char* test_case_name,\n                        const char* type_param,\n                        Test::SetUpTestCaseFunc set_up_tc,\n                        Test::TearDownTestCaseFunc tear_down_tc);\n      ...\n      std::vector<TestCase*> test_cases_;\n      ...\n    };\n\n    //gtest.cc\n    void TestCase::AddTestInfo(TestInfo * test_info) {\n      test_info_list_.push_back(test_info);\n      test_indices_.push_back(static_cast<int>(test_indices_.size()));\n    }\n\n    //gtest.h\n    class GTEST_API_ TestCase {\n    \t...\n    \tstd::vector<TestInfo*> test_info_list_;\n        std::vector<int> test_indices_;\n        ...\n    };\n```\n\n代码很多，我简单的描述一下。UnitTest 是一个单例类，它有一个成员变量 internal::UnitTestImpl* impl\\_， impl\\_ 里面又有成员变量 test\\_info\\_list\\_。最终我们写的测试类就放在 test\\_info\\_list\\_ 里。\n\n九曲十八弯，实际 GTest 用一个单例类 UnitTest 保存了注册的测试代码（放在 ::testing::Test 子类的 TestBody 方法里面）。\n\n那他是怎么解决初始化顺序的问题的？注意看 UnitTest::GetInstance() 方法：\n\n```cpp\n\t//gtest.cc\n    UnitTest* UnitTest::GetInstance() {\n      // When compiled with MSVC 7.1 in optimized mode, destroying the\n      // UnitTest object upon exiting the program messes up the exit code,\n      // causing successful tests to appear failed.  We have to use a\n      // different implementation in this case to bypass the compiler bug.\n      // This implementation makes the compiler happy, at the cost of\n      // leaking the UnitTest object.\n\n      // CodeGear C++Builder insists on a public destructor for the\n      // default implementation.  Use this implementation to keep good OO\n      // design with private destructor.\n\n    #if (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)\n      static UnitTest* const instance = new UnitTest;\n      return instance;\n    #else\n      static UnitTest instance;\n      return &instance;\n    #endif  // (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)\n    }\n```\n\n这里使用了局部静态变量，在第一次进入这个方法的时候就会生成一个 UnitTest 实例！不需要靠人品祈祷编译器按照我们设想的顺序创建全局变量！\n\n谷歌大神们不愧是大神，在看 GTest 源码的时候我都不知道被惊艳了多少次，真心学到了不少东西。怪不得别人都说看源码才是最好的提升方式。\n","slug":"GTest源码剖析-测试代码的注册","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2uoj003sw3fy38pti8g8"},{"title":"GTest实例解析","date":"2016-02-08T09:01:49.000Z","_content":"gtest是google的一套开源的c++单元测试框架，可以方便程序员对自己的代码进行单元测试。学习这套框架，除了墙外的官方文档之外，我强力推荐[玩转Google开源C\\+\\+单元测试框架Google Test系列](http://www.cnblogs.com/coderzh/archive/2009/04/06/1426755.html)。\n\n这系列的博客已经将gtest讲的十分详细了，所以我这篇博客就不再详细介绍gtest的基本使用方法了，而是通过一个简单的例子，介绍一下如何在实际的项目中使用它。同时也会通过分析gtest的源代码，使得大家能够更好的理解gtest的工作原理\n\n## __需要测试的类__\n\n首先我实现了一个简单的类TwoDimensionalMark，它的功能相当于bool二维数组，可以将二维下标标记为true或者false。只不过它内部使用位运算，一个字节可以记录八个标记数据，可以大量节省内存。它的声明如下：\n\n```cpp\n    class TwoDimensionalMark{\n        public:\n            TwoDimensionalMark(int row, int col, bool flag = false);\n            TwoDimensionalMark(const TwoDimensionalMark& cpy)；\n            ~TwoDimensionalMark();\n            const TwoDimensionalMark& operator =(const TwoDimensionalMark& cpy)；\n\n            //将所有的位置标记为true或者false\n            void clean(bool mark);\n\n            //设置(x,y)下标为true或者false\n            void set(int x, int y, bool mark);\n\n            //获取(x,y)下标的数据\n            bool check(int x, int y)const;\n\n            int getRow();\n            int getCol();\n\n            ...\n    };\n```\n\n## __完整的测试代码__\n我先把完整的测试代码放在这里，可以先简单浏览一遍。\n```cpp\n    #include \"TwoDimensionalMark.h\"\n    #include \"gtest/gtest.h\"\n    #include <cstdlib>\n    #include <vector>\n\n    using namespace std;\n\n    struct MarkSize{\n        MarkSize(int r, int c): row(r),col(c){}\n        int row, col;\n    };\n    class TestWithMarkSize : public testing::TestWithParam<MarkSize>{\n    public:\n        struct Coord{\n            int x, y;\n        };\n\n        vector<vector<bool> > CreateContrast(int row, int col, bool flag){\n            vector<vector<bool> > contrast(row);\n            for (int i = 0; i < row; i++){\n                contrast[i] = vector<bool>(col, flag);\n            }\n            return contrast;\n        }\n\n        vector<Coord> CreateRandCoords(int row, int col){\n            int yRange = row * 3;\n            int xRange = col * 3;\n            int numRandCoord = row * col / 2;\n\n            vector<Coord> coords;\n            for (int i = 0; i < numRandCoord; i++){\n                int x = (rand() % xRange) - col;\n                int y = (rand() % yRange) - row;\n                coords.push_back({ x, y });\n            }\n\n            return coords;\n        }\n\n        void SetFlag(TwoDimensionalMark* mark,  vector<vector<bool> >* contrast,  \n                    const MarkSize& size, const vector<Coord>& coords, bool flag){\n            for (auto c : coords){\n                mark->set(c.x, c.y, flag);\n                //随机位置有可能在row，col之外，要防止溢出\n                if (c.x >= 0 && c.x < size.col && c.y >= 0 && c.y < size.row){\n                    (*contrast)[c.y][c.x] = flag;\n                }\n            }\n        }\n    };\n\n    //行数多于列数的情况\n    INSTANTIATE_TEST_CASE_P(RowLTCol, TestWithMarkSize,\ttesting::Values(MarkSize(200, 100), MarkSize(50, 30)));\n    //行数少于列数的情况\n    INSTANTIATE_TEST_CASE_P(ColLTRow, TestWithMarkSize,\ttesting::Values(MarkSize(10, 100), MarkSize(3, 10)));\n    //行数等于列数的情况\n    INSTANTIATE_TEST_CASE_P(RowEQCol, TestWithMarkSize,\ttesting::Values(MarkSize(100, 100), MarkSize(3, 3)));\n\n\n    TEST_P(TestWithMarkSize,testWithTrueClean){\n        MarkSize size = GetParam();\n\n        //初始化TwoDimensionalMark和用来做对比的contrast,将他们全部用true填充\n        TwoDimensionalMark mark(size.row, size.col);\n        mark.clean(true);\n        vector<vector<bool> > contrast = CreateContrast(size.row, size.col, true);\n\n        //验证mark和contrast里面都是true\n        for (int i = 0; i < size.row; i++){\n            for (int j = 0; j < size.col; j++){\n                ASSERT_TRUE(mark.check(j, i));\n                ASSERT_TRUE(contrast[i][j]);\n            }\n        }\n\n        //随机将一些坐标位置,这个函数生成的随机位置有可能在row，col之外\n        vector<Coord> coords = CreateRandCoords(size.row, size.col);\n\n        //将mark和contrast的之前随机生成的位置设为false\n        SetFlag(&mark, &contrast, size, coords, false);\n\n        //检测随机生成的位置上的值有没有设置正确\n        //mark若位置超出范围则返回false,而contrast则需要防止溢出\n        for (auto c : coords){\n            ASSERT_FALSE(mark.check(c.x,c.y));\n            if (c.x >= 0 && c.x < size.col && c.y >= 0 && c.y < size.row){\n                ASSERT_FALSE(contrast[c.y][c.x]);\n            }\n        }\n\n        //对比contrast和mark，两者应该相等\n        for (int y = 0; y < size.row; y++)\n            for (int x = 0; x < size.col; x++){\n                ASSERT_EQ(contrast[y][x], mark.check(x, y));\n            }\n    }\n\n    TEST_P(TestWithMarkSize, testWithFalseClean){\n        MarkSize size = GetParam();\n\n        //初始化TwoDimensionalMark和用来做对比的contrast,将他们全部用false填充\n        TwoDimensionalMark mark(size.row, size.col);\n        mark.clean(false);\n        vector<vector<bool> > contrast = CreateContrast(size.row, size.col, false);\n\n        //验证mark和contrast里面都是false\n        for (int i = 0; i < size.row; i++){\n            for (int j = 0; j < size.col; j++){\n                ASSERT_FALSE(mark.check(j, i));\n                ASSERT_FALSE(contrast[i][j]);\n            }\n        }\n\n        //随机将一些坐标位置,这个函数生成的随机位置有可能在row，col之外\n        vector<Coord> coords = CreateRandCoords(size.row, size.col);\n\n        //将mark和contrast的之前随机生成的位置设为true\n        SetFlag(&mark, &contrast, size, coords, true);\n\n        //检测随机生成的位置上的值有没有设置正确\n        //mark若位置超出范围则返回false,而contrast则需要防止溢出\n        for (auto c : coords){\n            if (c.x >= 0 && c.x < size.col && c.y >= 0 && c.y < size.row){\n                ASSERT_TRUE(contrast[c.y][c.x]);\n                ASSERT_TRUE(mark.check(c.x, c.y));\n            }\n            else{\n                ASSERT_FALSE(mark.check(c.x, c.y));\n            }\n        }\n    }\n\n    int main(int argc, char* argv[])\n    {\n        testing::InitGoogleTest(&argc, argv);\n        int result =  RUN_ALL_TESTS();\n        getchar();\n        return result;\n    }\n```\n\n## __传入多个参数__\n\n为了覆盖各种大小的情况（行和列数量相等，行多于列，行少于列），需要定义多个不同行列数的TwoDimensionalMark。但如果每个测试用例都手动硬编码的话将会有许多的重复代码，这个时候就可以使用参数化的方法去将行列数作为参数传入各个测试用例中，详细的介绍看[这里](http://www.cnblogs.com/coderzh/archive/2009/04/08/1431297.html)。\n\n这篇博客只写到了一个参数的处理。但我们这里需要传入行数和列数两个参数应该怎么办？\n其实很方法也很简单，首先定义一个结构体MarkSize用于保存行数和列数\n\n```cpp\n    struct MarkSize{\n        MarkSize(int r, int c): row(r),col(c){}\n        int row, col;\n    }\n```\n\n用它作为TestWithParam的模板参数，再声明一个类继承于它。\n\n```cpp\n    class TestWithMarkSize : public testing::TestWithParam<MarkSize>{\n    }\n```\n\n然后传入参数，这里我定义了三组参数，每组两个。分别对应行数比较多，列数比较多，行数列数一样多三种情况：\n\n```cpp\n    //行数多于列数的情况\n    INSTANTIATE_TEST_CASE_P(RowLTCol, TestWithMarkSize,\ttesting::Values(MarkSize(200, 100), MarkSize(50, 30)));\n    //行数少于列数的情况\n    INSTANTIATE_TEST_CASE_P(ColLTRow, TestWithMarkSize,\ttesting::Values(MarkSize(10, 100), MarkSize(3, 10)));\n    //行数等于列数的情况\n    INSTANTIATE_TEST_CASE_P(RowEQCol, TestWithMarkSize,\ttesting::Values(MarkSize(100, 100), MarkSize(3, 3)));\n```\n\n这样一来，只要是 test_case_name 为 TestWithMarkSize 的测试用例都可以使用GetParam方法获取传入的参数了：\n\n```cpp\n    TEST_P(TestWithMarkSize,testWithTrueClean){\n        MarkSize size = GetParam();\n        ...\n    }\n\n    TEST_P(TestWithMarkSize, testWithFalseClean){\n\t\tMarkSize size = GetParam();\n\t\t...\n\t}\n```\n\n\n## __TEST\\_P源码解析__\n\nTEST\\_P 宏的定义如下\n\n```cpp\n    # define TEST_P(test_case_name, test_name) \\\n      class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n          : public test_case_name { \\\n      ...\n      }; \\\n      ...\n      void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()\n```\n\nGTEST_TEST_CLASS_NAME_又是个什么东西？其实它的功能十分简单，就是将类名拼接出来而已，它的定义如下：\n\n```cpp\n    #define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n      test_case_name##_##test_name##_Test\n```\n\n\n所以我们使用 TEST_P(TestWithMarkSize,testWithTrueClean){...} 实际上就是定义了一个 TestWithMarkSize 的子类 TestWithMarkSize_testWithTrueClean_Test。\n\n而花括号里面实际上就是void TestWithMarkSize_testWithTrueClean_Test::TestBody()的实现。\n\n也就是说，实际上我们的测试用例都是TestWithMarkSize的子类。所以我们可以将一些公共的方法和数据结构定义在TestWithMarkSize内，只要将他们声明为protected或者public，就能在TEST_P(TestWithMarkSize,testWithTrueClean){...} 和 TEST_P(TestWithMarkSize,testWithFalseClean){...} 内使用。\n\n这样既可以提炼重复代码，又能将它们的作用范围限定在测试用例中，防止提炼出来的函数或者定义的数据结构放在全局影响实际的功能代码。\n\n如我这里定义的 Coord 结构体和CreateContrast、CreateRandCoords 和 SetFlag 方法。\n\n而GetParam()的定义如下：\n\n```cpp\n    static const ParamType* parameter_;\n\n    const ParamType& GetParam() const {\n        GTEST_CHECK_(parameter_ != NULL)\n            << \"GetParam() can only be called inside a value-parameterized test \"\n            << \"-- did you intend to write TEST_P instead of TEST_F?\";\n        return *parameter_;\n    }\n```\n\n既然 const T* WithParamInterface<T>::parameter_ 是有一个类静态成员变量，那就不难理解为什么所有继承于 TestWithMarkSize 的测试用例都能拿到同样的参数了。\n\n## __测试用例分析__\n\n要知道 TwoDimensionalMark 实际上的功能是和bool二维数组基本一样的，所以我们就很自然的想到使用一个对比用的bool二维数组作为参照，去测试 TwoDimensionalMark 的功能究竟有没有bug。\n\nTEST_P(TestWithMarkSize,testWithTrueClean) 的测试分下面三个步骤：\n\n1.根据传入的数组大小，创建了一个 TwoDimensionalMark 和用两重 vector 实现的 bool 二维数组。\n\n2.将它们全部用true填充，然后验证每一个下标的数据是否均为 true，如此去测试TwoDimensionalMark::clean(true) 的功能\n\n3.随机生成一些坐标，将 TwoDimensionalMark 和 bool 二维数组对应这些坐标的数据都设为 false 。然后检测设置的位置的数据是否都为false，还有对比两者每个下标的数据是否相等。以测试 set 和 check 方法是否正确。同时因为这些下标有些是超出范围之外的，也能测试 TwoDimensionalMark 对超出范围的操作是否正确\n\n代码如下：\n\n```cpp\n    TEST_P(TestWithMarkSize,testWithTrueClean){\n        MarkSize size = GetParam();\n\n        //初始化TwoDimensionalMark和用来做对比的contrast,将他们全部用true填充\n        TwoDimensionalMark mark(size.row, size.col);\n        mark.clean(true);\n        vector<vector<bool> > contrast = CreateContrast(size.row, size.col, true);\n\n        //验证mark和contrast里面都是true\n        for (int i = 0; i < size.row; i++){\n            for (int j = 0; j < size.col; j++){\n                ASSERT_TRUE(mark.check(j, i));\n                ASSERT_TRUE(contrast[i][j]);\n            }\n        }\n\n        //随机将一些坐标位置,这个函数生成的随机位置有可能在row，col之外\n        vector<Coord> coords = CreateRandCoords(size.row, size.col);\n\n        //将mark和contrast的之前随机生成的位置设为false\n        SetFlag(&mark, &contrast, size, coords, false);\n\n        //检测随机生成的位置上的值有没有设置正确\n        //mark若位置超出范围则返回false,而contrast则需要防止溢出\n        for (auto c : coords){\n            ASSERT_FALSE(mark.check(c.x,c.y));\n            if (c.x >= 0 && c.x < size.col && c.y >= 0 && c.y < size.row){\n                ASSERT_FALSE(contrast[c.y][c.x]);\n            }\n        }\n\n        //对比contrast和mark，两者应该相等\n        for (int y = 0; y < size.row; y++)\n            for (int x = 0; x < size.col; x++){\n                ASSERT_EQ(contrast[y][x], mark.check(x, y));\n            }\n    }\n```\n\nTEST_P(TestWithMarkSize, testWithFalseClean) 和上面的差不多，只不过换成一开始用 false 填充，之后设置随机下标的数据为 true，读者可以自己查看代码，这里就不详细分析了。\n\n## __测试结果__\n\n运行测试代码得到下面的结果：\n{% img /GTest实例解析/1.jpg %}\n\n全部测试均通过！\n\n完整代码:[https://github.com/bluesky466/GTestDemo](https://github.com/bluesky466/GTestDemo)\n（为了方便，我直接将实现写在了头文件里，好孩子不要学~）\n","source":"_posts/GTest实例解析.md","raw":"title: GTest实例解析\ndate: 2016-02-08 17:01:49\ntags:\n\t- 技术相关\n\t- 单元测试\n---\ngtest是google的一套开源的c++单元测试框架，可以方便程序员对自己的代码进行单元测试。学习这套框架，除了墙外的官方文档之外，我强力推荐[玩转Google开源C\\+\\+单元测试框架Google Test系列](http://www.cnblogs.com/coderzh/archive/2009/04/06/1426755.html)。\n\n这系列的博客已经将gtest讲的十分详细了，所以我这篇博客就不再详细介绍gtest的基本使用方法了，而是通过一个简单的例子，介绍一下如何在实际的项目中使用它。同时也会通过分析gtest的源代码，使得大家能够更好的理解gtest的工作原理\n\n## __需要测试的类__\n\n首先我实现了一个简单的类TwoDimensionalMark，它的功能相当于bool二维数组，可以将二维下标标记为true或者false。只不过它内部使用位运算，一个字节可以记录八个标记数据，可以大量节省内存。它的声明如下：\n\n```cpp\n    class TwoDimensionalMark{\n        public:\n            TwoDimensionalMark(int row, int col, bool flag = false);\n            TwoDimensionalMark(const TwoDimensionalMark& cpy)；\n            ~TwoDimensionalMark();\n            const TwoDimensionalMark& operator =(const TwoDimensionalMark& cpy)；\n\n            //将所有的位置标记为true或者false\n            void clean(bool mark);\n\n            //设置(x,y)下标为true或者false\n            void set(int x, int y, bool mark);\n\n            //获取(x,y)下标的数据\n            bool check(int x, int y)const;\n\n            int getRow();\n            int getCol();\n\n            ...\n    };\n```\n\n## __完整的测试代码__\n我先把完整的测试代码放在这里，可以先简单浏览一遍。\n```cpp\n    #include \"TwoDimensionalMark.h\"\n    #include \"gtest/gtest.h\"\n    #include <cstdlib>\n    #include <vector>\n\n    using namespace std;\n\n    struct MarkSize{\n        MarkSize(int r, int c): row(r),col(c){}\n        int row, col;\n    };\n    class TestWithMarkSize : public testing::TestWithParam<MarkSize>{\n    public:\n        struct Coord{\n            int x, y;\n        };\n\n        vector<vector<bool> > CreateContrast(int row, int col, bool flag){\n            vector<vector<bool> > contrast(row);\n            for (int i = 0; i < row; i++){\n                contrast[i] = vector<bool>(col, flag);\n            }\n            return contrast;\n        }\n\n        vector<Coord> CreateRandCoords(int row, int col){\n            int yRange = row * 3;\n            int xRange = col * 3;\n            int numRandCoord = row * col / 2;\n\n            vector<Coord> coords;\n            for (int i = 0; i < numRandCoord; i++){\n                int x = (rand() % xRange) - col;\n                int y = (rand() % yRange) - row;\n                coords.push_back({ x, y });\n            }\n\n            return coords;\n        }\n\n        void SetFlag(TwoDimensionalMark* mark,  vector<vector<bool> >* contrast,  \n                    const MarkSize& size, const vector<Coord>& coords, bool flag){\n            for (auto c : coords){\n                mark->set(c.x, c.y, flag);\n                //随机位置有可能在row，col之外，要防止溢出\n                if (c.x >= 0 && c.x < size.col && c.y >= 0 && c.y < size.row){\n                    (*contrast)[c.y][c.x] = flag;\n                }\n            }\n        }\n    };\n\n    //行数多于列数的情况\n    INSTANTIATE_TEST_CASE_P(RowLTCol, TestWithMarkSize,\ttesting::Values(MarkSize(200, 100), MarkSize(50, 30)));\n    //行数少于列数的情况\n    INSTANTIATE_TEST_CASE_P(ColLTRow, TestWithMarkSize,\ttesting::Values(MarkSize(10, 100), MarkSize(3, 10)));\n    //行数等于列数的情况\n    INSTANTIATE_TEST_CASE_P(RowEQCol, TestWithMarkSize,\ttesting::Values(MarkSize(100, 100), MarkSize(3, 3)));\n\n\n    TEST_P(TestWithMarkSize,testWithTrueClean){\n        MarkSize size = GetParam();\n\n        //初始化TwoDimensionalMark和用来做对比的contrast,将他们全部用true填充\n        TwoDimensionalMark mark(size.row, size.col);\n        mark.clean(true);\n        vector<vector<bool> > contrast = CreateContrast(size.row, size.col, true);\n\n        //验证mark和contrast里面都是true\n        for (int i = 0; i < size.row; i++){\n            for (int j = 0; j < size.col; j++){\n                ASSERT_TRUE(mark.check(j, i));\n                ASSERT_TRUE(contrast[i][j]);\n            }\n        }\n\n        //随机将一些坐标位置,这个函数生成的随机位置有可能在row，col之外\n        vector<Coord> coords = CreateRandCoords(size.row, size.col);\n\n        //将mark和contrast的之前随机生成的位置设为false\n        SetFlag(&mark, &contrast, size, coords, false);\n\n        //检测随机生成的位置上的值有没有设置正确\n        //mark若位置超出范围则返回false,而contrast则需要防止溢出\n        for (auto c : coords){\n            ASSERT_FALSE(mark.check(c.x,c.y));\n            if (c.x >= 0 && c.x < size.col && c.y >= 0 && c.y < size.row){\n                ASSERT_FALSE(contrast[c.y][c.x]);\n            }\n        }\n\n        //对比contrast和mark，两者应该相等\n        for (int y = 0; y < size.row; y++)\n            for (int x = 0; x < size.col; x++){\n                ASSERT_EQ(contrast[y][x], mark.check(x, y));\n            }\n    }\n\n    TEST_P(TestWithMarkSize, testWithFalseClean){\n        MarkSize size = GetParam();\n\n        //初始化TwoDimensionalMark和用来做对比的contrast,将他们全部用false填充\n        TwoDimensionalMark mark(size.row, size.col);\n        mark.clean(false);\n        vector<vector<bool> > contrast = CreateContrast(size.row, size.col, false);\n\n        //验证mark和contrast里面都是false\n        for (int i = 0; i < size.row; i++){\n            for (int j = 0; j < size.col; j++){\n                ASSERT_FALSE(mark.check(j, i));\n                ASSERT_FALSE(contrast[i][j]);\n            }\n        }\n\n        //随机将一些坐标位置,这个函数生成的随机位置有可能在row，col之外\n        vector<Coord> coords = CreateRandCoords(size.row, size.col);\n\n        //将mark和contrast的之前随机生成的位置设为true\n        SetFlag(&mark, &contrast, size, coords, true);\n\n        //检测随机生成的位置上的值有没有设置正确\n        //mark若位置超出范围则返回false,而contrast则需要防止溢出\n        for (auto c : coords){\n            if (c.x >= 0 && c.x < size.col && c.y >= 0 && c.y < size.row){\n                ASSERT_TRUE(contrast[c.y][c.x]);\n                ASSERT_TRUE(mark.check(c.x, c.y));\n            }\n            else{\n                ASSERT_FALSE(mark.check(c.x, c.y));\n            }\n        }\n    }\n\n    int main(int argc, char* argv[])\n    {\n        testing::InitGoogleTest(&argc, argv);\n        int result =  RUN_ALL_TESTS();\n        getchar();\n        return result;\n    }\n```\n\n## __传入多个参数__\n\n为了覆盖各种大小的情况（行和列数量相等，行多于列，行少于列），需要定义多个不同行列数的TwoDimensionalMark。但如果每个测试用例都手动硬编码的话将会有许多的重复代码，这个时候就可以使用参数化的方法去将行列数作为参数传入各个测试用例中，详细的介绍看[这里](http://www.cnblogs.com/coderzh/archive/2009/04/08/1431297.html)。\n\n这篇博客只写到了一个参数的处理。但我们这里需要传入行数和列数两个参数应该怎么办？\n其实很方法也很简单，首先定义一个结构体MarkSize用于保存行数和列数\n\n```cpp\n    struct MarkSize{\n        MarkSize(int r, int c): row(r),col(c){}\n        int row, col;\n    }\n```\n\n用它作为TestWithParam的模板参数，再声明一个类继承于它。\n\n```cpp\n    class TestWithMarkSize : public testing::TestWithParam<MarkSize>{\n    }\n```\n\n然后传入参数，这里我定义了三组参数，每组两个。分别对应行数比较多，列数比较多，行数列数一样多三种情况：\n\n```cpp\n    //行数多于列数的情况\n    INSTANTIATE_TEST_CASE_P(RowLTCol, TestWithMarkSize,\ttesting::Values(MarkSize(200, 100), MarkSize(50, 30)));\n    //行数少于列数的情况\n    INSTANTIATE_TEST_CASE_P(ColLTRow, TestWithMarkSize,\ttesting::Values(MarkSize(10, 100), MarkSize(3, 10)));\n    //行数等于列数的情况\n    INSTANTIATE_TEST_CASE_P(RowEQCol, TestWithMarkSize,\ttesting::Values(MarkSize(100, 100), MarkSize(3, 3)));\n```\n\n这样一来，只要是 test_case_name 为 TestWithMarkSize 的测试用例都可以使用GetParam方法获取传入的参数了：\n\n```cpp\n    TEST_P(TestWithMarkSize,testWithTrueClean){\n        MarkSize size = GetParam();\n        ...\n    }\n\n    TEST_P(TestWithMarkSize, testWithFalseClean){\n\t\tMarkSize size = GetParam();\n\t\t...\n\t}\n```\n\n\n## __TEST\\_P源码解析__\n\nTEST\\_P 宏的定义如下\n\n```cpp\n    # define TEST_P(test_case_name, test_name) \\\n      class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n          : public test_case_name { \\\n      ...\n      }; \\\n      ...\n      void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()\n```\n\nGTEST_TEST_CLASS_NAME_又是个什么东西？其实它的功能十分简单，就是将类名拼接出来而已，它的定义如下：\n\n```cpp\n    #define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n      test_case_name##_##test_name##_Test\n```\n\n\n所以我们使用 TEST_P(TestWithMarkSize,testWithTrueClean){...} 实际上就是定义了一个 TestWithMarkSize 的子类 TestWithMarkSize_testWithTrueClean_Test。\n\n而花括号里面实际上就是void TestWithMarkSize_testWithTrueClean_Test::TestBody()的实现。\n\n也就是说，实际上我们的测试用例都是TestWithMarkSize的子类。所以我们可以将一些公共的方法和数据结构定义在TestWithMarkSize内，只要将他们声明为protected或者public，就能在TEST_P(TestWithMarkSize,testWithTrueClean){...} 和 TEST_P(TestWithMarkSize,testWithFalseClean){...} 内使用。\n\n这样既可以提炼重复代码，又能将它们的作用范围限定在测试用例中，防止提炼出来的函数或者定义的数据结构放在全局影响实际的功能代码。\n\n如我这里定义的 Coord 结构体和CreateContrast、CreateRandCoords 和 SetFlag 方法。\n\n而GetParam()的定义如下：\n\n```cpp\n    static const ParamType* parameter_;\n\n    const ParamType& GetParam() const {\n        GTEST_CHECK_(parameter_ != NULL)\n            << \"GetParam() can only be called inside a value-parameterized test \"\n            << \"-- did you intend to write TEST_P instead of TEST_F?\";\n        return *parameter_;\n    }\n```\n\n既然 const T* WithParamInterface<T>::parameter_ 是有一个类静态成员变量，那就不难理解为什么所有继承于 TestWithMarkSize 的测试用例都能拿到同样的参数了。\n\n## __测试用例分析__\n\n要知道 TwoDimensionalMark 实际上的功能是和bool二维数组基本一样的，所以我们就很自然的想到使用一个对比用的bool二维数组作为参照，去测试 TwoDimensionalMark 的功能究竟有没有bug。\n\nTEST_P(TestWithMarkSize,testWithTrueClean) 的测试分下面三个步骤：\n\n1.根据传入的数组大小，创建了一个 TwoDimensionalMark 和用两重 vector 实现的 bool 二维数组。\n\n2.将它们全部用true填充，然后验证每一个下标的数据是否均为 true，如此去测试TwoDimensionalMark::clean(true) 的功能\n\n3.随机生成一些坐标，将 TwoDimensionalMark 和 bool 二维数组对应这些坐标的数据都设为 false 。然后检测设置的位置的数据是否都为false，还有对比两者每个下标的数据是否相等。以测试 set 和 check 方法是否正确。同时因为这些下标有些是超出范围之外的，也能测试 TwoDimensionalMark 对超出范围的操作是否正确\n\n代码如下：\n\n```cpp\n    TEST_P(TestWithMarkSize,testWithTrueClean){\n        MarkSize size = GetParam();\n\n        //初始化TwoDimensionalMark和用来做对比的contrast,将他们全部用true填充\n        TwoDimensionalMark mark(size.row, size.col);\n        mark.clean(true);\n        vector<vector<bool> > contrast = CreateContrast(size.row, size.col, true);\n\n        //验证mark和contrast里面都是true\n        for (int i = 0; i < size.row; i++){\n            for (int j = 0; j < size.col; j++){\n                ASSERT_TRUE(mark.check(j, i));\n                ASSERT_TRUE(contrast[i][j]);\n            }\n        }\n\n        //随机将一些坐标位置,这个函数生成的随机位置有可能在row，col之外\n        vector<Coord> coords = CreateRandCoords(size.row, size.col);\n\n        //将mark和contrast的之前随机生成的位置设为false\n        SetFlag(&mark, &contrast, size, coords, false);\n\n        //检测随机生成的位置上的值有没有设置正确\n        //mark若位置超出范围则返回false,而contrast则需要防止溢出\n        for (auto c : coords){\n            ASSERT_FALSE(mark.check(c.x,c.y));\n            if (c.x >= 0 && c.x < size.col && c.y >= 0 && c.y < size.row){\n                ASSERT_FALSE(contrast[c.y][c.x]);\n            }\n        }\n\n        //对比contrast和mark，两者应该相等\n        for (int y = 0; y < size.row; y++)\n            for (int x = 0; x < size.col; x++){\n                ASSERT_EQ(contrast[y][x], mark.check(x, y));\n            }\n    }\n```\n\nTEST_P(TestWithMarkSize, testWithFalseClean) 和上面的差不多，只不过换成一开始用 false 填充，之后设置随机下标的数据为 true，读者可以自己查看代码，这里就不详细分析了。\n\n## __测试结果__\n\n运行测试代码得到下面的结果：\n{% img /GTest实例解析/1.jpg %}\n\n全部测试均通过！\n\n完整代码:[https://github.com/bluesky466/GTestDemo](https://github.com/bluesky466/GTestDemo)\n（为了方便，我直接将实现写在了头文件里，好孩子不要学~）\n","slug":"GTest实例解析","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2uok003vw3fy99o472lm"},{"title":"DrawerLayout 学习笔记","date":"2016-01-27T09:44:24.000Z","_content":"\nDrawerLayout的使用十分简单，使用android.support.v4.widget.DrawerLayout标签即可，DrawerLayout的第一个子标签就是正文，其他布局都是抽屉布局（默认隐藏在屏幕外）。可以使用android:layout_gravity属性指定是隐藏在屏幕的左边或者右边。\n\n## **一、使用DrawerLayout布局**\n\n把activity_main.xml修改成下面的样子，这里声明了一个LinearLayout作为正文布局（DrawerLayout的第一个子标签），和其他两个LinearLayout布局作为抽屉布局（将android:layout_gravity设置为left或者right）：\n\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <android.support.v4.widget.DrawerLayout\n            android:id=\"@+id/drawer_layout\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\">\n\n            <!-- 正文布局 -->\n            <LinearLayout\n                android:id=\"@+id/content\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:gravity=\"center_horizontal\"\n                android:orientation=\"horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"content\" />\n\n            </LinearLayout>\n\n            <!-- 从左边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_left\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"left\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"left\" />\n            </LinearLayout>\n\n            <!-- 从右边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_right\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"right\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"right\" />\n            </LinearLayout>\n        </android.support.v4.widget.DrawerLayout>\n    </LinearLayout>\n```\n\n运行之后就长这个样子，可以用手指从左边或者右边把抽屉布局拖出来：\n{% img /DrawerLayout-学习笔记/1.jpg %}\n\n{% img /DrawerLayout-学习笔记/3.jpg %}\n\n{% img /DrawerLayout-学习笔记/2.jpg %}\n\n当然也能在代码里面调用openDrawer来显示：\n```java \n    //打开左边的抽屉布局\n    drawerLayout.openDrawer(Gravity.LEFT);\n    //打开右边的抽屉布局\n    drawerLayout.openDrawer(Gravity.RIGHT);\n```\n  \n  \n## **二、使用ActionBarDrawerToggle**\nandroid提供了一个ActionBarDrawerToggle来简化DrawerLayout的操作，用法十分简单。\n1.自定义一个ToolBar（可以查看我之前的一篇博文）\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <android.support.v7.widget.Toolbar\n            android:id=\"@+id/toolbar\"\n            android:background=\"#3F51B5\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"?attr/actionBarSize\" />\n\n        <android.support.v4.widget.DrawerLayout\n            android:id=\"@+id/drawer_layout\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\">\n\n            <!-- 正文布局 -->\n            <LinearLayout\n                android:id=\"@+id/content\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:gravity=\"center_horizontal\"\n                android:orientation=\"horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"content\" />\n\n            </LinearLayout>\n\n            <!-- 从左边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_left\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"left\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"left\" />\n            </LinearLayout>\n\n            <!-- 从右边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_right\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"right\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"right\" />\n            </LinearLayout>\n        </android.support.v4.widget.DrawerLayout>\n    </LinearLayout>\n```\n\n2.在acvitity代码中创建ActionBarDrawerToggle并重写下面的方法就可以了\n- 在onPostCreate方法中调用ActionBarDrawerToggle.syncState()，如果不调用该方法，则ActionBarDrawerToggle不会显示 （onPostCreate在Activity完全加载成功之后调用，这个时候所有界面资源都已经创建和初始化完成）\n- 在onOptionsItemSelected方法中调用ActionBarDrawerToggle.onOptionsItemSelected()。（原本我以为这里是用来实现按下按钮打开和关闭抽屉布局的，但经测试，就算不调用也能正常运行。）\n```java\n    public class MainActivity extends AppCompatActivity {\n        ActionBarDrawerToggle mToggle;\n\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n\n            setContentView(R.layout.activity_main);\n\n            Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n            setSupportActionBar(toolbar);\n\n            DrawerLayout drawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);\n            mToggle = new ActionBarDrawerToggle(this, drawerLayout,toolbar,R.string.drawer_open, R.string.drawer_close);\n\n            drawerLayout.setDrawerListener(mToggle);\n        }\n\n        @Override\n        protected void onPostCreate(Bundle savedInstanceState) {\n        \t//onPostCreate在Activity完全加载成功之后调用\n            //这个时候所有界面资源都已经创建和初始化完成\n            super.onPostCreate(savedInstanceState);\n\n            //如果不调用该方法，则ActionBarDrawerToggle不会显示\n            mToggle.syncState();\n        }\n\n        @Override\n        public boolean onOptionsItemSelected(MenuItem item) {\n        \t//原本我以为这里是用来实现按下按钮打开和关闭抽屉布局的\n            //但经测试，就算不调用也能正常运行。\n            return mToggle.onOptionsItemSelected(item) || super.onOptionsItemSelected(item);\n        }\n    }\n```\n\n运行可以得到下面这效果，可以使用控制按钮来打开和关闭左边的抽屉布局，那个控制按钮还实现了一种特别酷炫的动画：\n{% img /DrawerLayout-学习笔记/4.jpg %}\n\n{% img /DrawerLayout-学习笔记/5.jpg %}\n\n{% img /DrawerLayout-学习笔记/6.jpg %}\n  \n  \n## **三、将抽屉布局的层级填到toolbar之上**\n知乎的安卓app也使用了DrawerLayout，但它的抽屉布局显示的时候是位于toolbar之上的。我们只要把toolbar标签放到内容布局（DrawerLayout的第一个子标签）里面就能实现这样的效果了。\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <android.support.v4.widget.DrawerLayout\n            android:id=\"@+id/drawer_layout\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\">\n\n            <!-- 正文布局 -->\n            <LinearLayout\n                android:id=\"@+id/content\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:gravity=\"center_horizontal\"\n                android:orientation=\"horizontal\">\n\n                <!-- 把toolbar放到这里，使抽屉布局层级比toolbar高 -->\n                <android.support.v7.widget.Toolbar\n                    android:id=\"@+id/toolbar\"\n                    android:background=\"#3F51B5\"\n                    android:layout_width=\"match_parent\"\n                    android:layout_height=\"?attr/actionBarSize\" />\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"content\" />\n\n            </LinearLayout>\n\n            <!-- 从左边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_left\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"left\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"left\" />\n            </LinearLayout>\n\n            <!-- 从右边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_right\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"right\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"right\" />\n            </LinearLayout>\n        </android.support.v4.widget.DrawerLayout>\n    </LinearLayout>\n```\n\n运行效果如下：\n\n{% img /DrawerLayout-学习笔记/7.jpg %}\n","source":"_posts/DrawerLayout-学习笔记.md","raw":"title: DrawerLayout 学习笔记\ndate: 2016-01-27 17:44:24\ntags:\n\t- 技术相关\n\t- Android\n---\n\nDrawerLayout的使用十分简单，使用android.support.v4.widget.DrawerLayout标签即可，DrawerLayout的第一个子标签就是正文，其他布局都是抽屉布局（默认隐藏在屏幕外）。可以使用android:layout_gravity属性指定是隐藏在屏幕的左边或者右边。\n\n## **一、使用DrawerLayout布局**\n\n把activity_main.xml修改成下面的样子，这里声明了一个LinearLayout作为正文布局（DrawerLayout的第一个子标签），和其他两个LinearLayout布局作为抽屉布局（将android:layout_gravity设置为left或者right）：\n\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <android.support.v4.widget.DrawerLayout\n            android:id=\"@+id/drawer_layout\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\">\n\n            <!-- 正文布局 -->\n            <LinearLayout\n                android:id=\"@+id/content\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:gravity=\"center_horizontal\"\n                android:orientation=\"horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"content\" />\n\n            </LinearLayout>\n\n            <!-- 从左边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_left\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"left\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"left\" />\n            </LinearLayout>\n\n            <!-- 从右边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_right\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"right\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"right\" />\n            </LinearLayout>\n        </android.support.v4.widget.DrawerLayout>\n    </LinearLayout>\n```\n\n运行之后就长这个样子，可以用手指从左边或者右边把抽屉布局拖出来：\n{% img /DrawerLayout-学习笔记/1.jpg %}\n\n{% img /DrawerLayout-学习笔记/3.jpg %}\n\n{% img /DrawerLayout-学习笔记/2.jpg %}\n\n当然也能在代码里面调用openDrawer来显示：\n```java \n    //打开左边的抽屉布局\n    drawerLayout.openDrawer(Gravity.LEFT);\n    //打开右边的抽屉布局\n    drawerLayout.openDrawer(Gravity.RIGHT);\n```\n  \n  \n## **二、使用ActionBarDrawerToggle**\nandroid提供了一个ActionBarDrawerToggle来简化DrawerLayout的操作，用法十分简单。\n1.自定义一个ToolBar（可以查看我之前的一篇博文）\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <android.support.v7.widget.Toolbar\n            android:id=\"@+id/toolbar\"\n            android:background=\"#3F51B5\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"?attr/actionBarSize\" />\n\n        <android.support.v4.widget.DrawerLayout\n            android:id=\"@+id/drawer_layout\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\">\n\n            <!-- 正文布局 -->\n            <LinearLayout\n                android:id=\"@+id/content\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:gravity=\"center_horizontal\"\n                android:orientation=\"horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"content\" />\n\n            </LinearLayout>\n\n            <!-- 从左边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_left\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"left\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"left\" />\n            </LinearLayout>\n\n            <!-- 从右边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_right\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"right\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"right\" />\n            </LinearLayout>\n        </android.support.v4.widget.DrawerLayout>\n    </LinearLayout>\n```\n\n2.在acvitity代码中创建ActionBarDrawerToggle并重写下面的方法就可以了\n- 在onPostCreate方法中调用ActionBarDrawerToggle.syncState()，如果不调用该方法，则ActionBarDrawerToggle不会显示 （onPostCreate在Activity完全加载成功之后调用，这个时候所有界面资源都已经创建和初始化完成）\n- 在onOptionsItemSelected方法中调用ActionBarDrawerToggle.onOptionsItemSelected()。（原本我以为这里是用来实现按下按钮打开和关闭抽屉布局的，但经测试，就算不调用也能正常运行。）\n```java\n    public class MainActivity extends AppCompatActivity {\n        ActionBarDrawerToggle mToggle;\n\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n\n            setContentView(R.layout.activity_main);\n\n            Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n            setSupportActionBar(toolbar);\n\n            DrawerLayout drawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);\n            mToggle = new ActionBarDrawerToggle(this, drawerLayout,toolbar,R.string.drawer_open, R.string.drawer_close);\n\n            drawerLayout.setDrawerListener(mToggle);\n        }\n\n        @Override\n        protected void onPostCreate(Bundle savedInstanceState) {\n        \t//onPostCreate在Activity完全加载成功之后调用\n            //这个时候所有界面资源都已经创建和初始化完成\n            super.onPostCreate(savedInstanceState);\n\n            //如果不调用该方法，则ActionBarDrawerToggle不会显示\n            mToggle.syncState();\n        }\n\n        @Override\n        public boolean onOptionsItemSelected(MenuItem item) {\n        \t//原本我以为这里是用来实现按下按钮打开和关闭抽屉布局的\n            //但经测试，就算不调用也能正常运行。\n            return mToggle.onOptionsItemSelected(item) || super.onOptionsItemSelected(item);\n        }\n    }\n```\n\n运行可以得到下面这效果，可以使用控制按钮来打开和关闭左边的抽屉布局，那个控制按钮还实现了一种特别酷炫的动画：\n{% img /DrawerLayout-学习笔记/4.jpg %}\n\n{% img /DrawerLayout-学习笔记/5.jpg %}\n\n{% img /DrawerLayout-学习笔记/6.jpg %}\n  \n  \n## **三、将抽屉布局的层级填到toolbar之上**\n知乎的安卓app也使用了DrawerLayout，但它的抽屉布局显示的时候是位于toolbar之上的。我们只要把toolbar标签放到内容布局（DrawerLayout的第一个子标签）里面就能实现这样的效果了。\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <android.support.v4.widget.DrawerLayout\n            android:id=\"@+id/drawer_layout\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\">\n\n            <!-- 正文布局 -->\n            <LinearLayout\n                android:id=\"@+id/content\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:gravity=\"center_horizontal\"\n                android:orientation=\"horizontal\">\n\n                <!-- 把toolbar放到这里，使抽屉布局层级比toolbar高 -->\n                <android.support.v7.widget.Toolbar\n                    android:id=\"@+id/toolbar\"\n                    android:background=\"#3F51B5\"\n                    android:layout_width=\"match_parent\"\n                    android:layout_height=\"?attr/actionBarSize\" />\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"content\" />\n\n            </LinearLayout>\n\n            <!-- 从左边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_left\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"left\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"left\" />\n            </LinearLayout>\n\n            <!-- 从右边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_right\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"right\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"right\" />\n            </LinearLayout>\n        </android.support.v4.widget.DrawerLayout>\n    </LinearLayout>\n```\n\n运行效果如下：\n\n{% img /DrawerLayout-学习笔记/7.jpg %}\n","slug":"DrawerLayout-学习笔记","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2uol003yw3fyrchf16qo"},{"title":"Dagger2学习笔记(二)","date":"2017-05-16T16:27:30.000Z","_content":"\n在上一篇[文章](http://blog.islinjw.cn/2017/05/13/Dagger2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/)我们讲了用于搜索的SearchActivity的实现，这一篇文章我们继续以剩下的两个Activity的实现为例，讲一下Dagger2的其他特性。这两个Activity分别是用了展示SearchActivity搜索的用户的头像和用户名的UserInfoActivity和点击用户头像跳转到的展示用户followers的FollowerActivity。\n\n\n在我们的Demo中有个叫做UserInfoLoader的类，它是用来向github服务器请求用户信息和follower信息的，会在多个actiity中被使用，例如在FollowerPresenter和UserInfoPresenter中都需要注入UserInfoLoader。最简单的方式是我们可以直接使用@Inject注解标注它的构造方法，使得Dagger2可以直接创建它的实例去注入FollowerPresenter和UserInfoPresenter中。\n\n```\nclass UserInfoLoader {\n\t...\n\t@Inject\n\tUserInfoLoader() {\n\t}\n\t...\n}\n\n```\n\n# Module复用\n\n当然我们也能用复用Module的方式，这种方式虽然比直接用@Inject注解构造方法复杂，但是它还有其他十分有用的功能，接下来我会慢慢分析。\n\n首先我们把它的Module单独抽出来，放到AppModule中：\n\n```\n@Module\npublic class AppModule {\n    @Provides\n\tUserInfoLoader provideUserInfoLoader() {\n        return new UserInfoLoader();\n\t}\n}\n```\n\n## 共用Module\n\n我们复用这个Module的方式有几种，一是同时放在FollowerComponent和UserInfoComponent的modules中:\n\n```\n@Component(modules = {AppModule.class, FollowerPresenterModule.class})\npublic interface FollowerComponent {\n    void inject(FollowerPresenter presenter);\n    void inject(FollowerActivity activity);\n}\n\n```\n\n```\n@Component(modules = {AppModule.class, UserInfoPresenterModule.class})\npublic interface UserInfoComponent {\n    void inject(UserInfoPresenter presenter);\n    void inject(UserInfoActivity activity);\n}\n```\n\n## 使用dependencies\n\n第二种方式是使用dependencies，首先我们需要声明多一个AppComponent接口\n\n```\n@Component(modules = {AppModule.class})\npublic interface AppComponent {\n    UserInfoLoader provideUserInfoLoader();\n}\n\n```\n\n这个接口的provideUserInfoLoader()方法就是提供出来给子依赖获取UserInfoLoader的，因为dependencies子依赖是获取不了父依赖的modules里面的Provides的。\n\n之后声明FollowerComponent和UserInfoComponent:\n\n```\n@Component(dependencies = AppComponent.class, modules = {UserInfoPresenterModule.class})\npublic interface UserInfoComponent {\n    void inject(UserInfoPresenter presenter);\n    void inject(UserInfoActivity activity);\n}\n```\n\n```\n@Component(dependencies = AppComponent.class, modules = {FollowerPresenterModule.class})\npublic interface FollowerComponent {\n    void inject(FollowerPresenter presenter);\n    void inject(FollowerActivity activity);\n}\n\n```\n\n最后就再去实现注入:\n```\nFollowerComponent component = DaggerFollowerComponent.builder()\n\t.appComponent(getAppComponent())\n    .followerPresenterModule(new FollowerPresenterModule(this))\n    .build();\ncomponent.inject(this);\ncomponent.inject(mPresenter);\n```\n\n```\nUserInfoComponent component = DaggerUserInfoComponent.builder()\n    .appComponent(getAppComponent())\n    .userInfoPresenterModule(new UserInfoPresenterModule(this))\n    .build();\ncomponent.inject(this);\ncomponent.inject(mPresenter);\n```\n\n这里的AppComponent是公用的，所以我们放到Application中:\n\n```\npublic class AppApplication extends Application {\n    private AppComponent mAppComponent;\n\n\tpublic AppApplication() {\n        super();\n\n        mAppComponent = DaggerAppComponent.create();\n\t}\n\n\tpublic AppComponent getAppComponent() {\n        return mAppComponent;\n\t}\n}\n```\n\n然后在Activity中这样获取AppComponent:\n\n```\nAppComponent getAppComponent() {\n    return ((AppApplication)getApplication()).getAppComponent();\n}\n```\n\n我们尝试注释掉AppComponent.provideUserInfoLoader，rebuild一下，发现居然没有报错，这是怎么回事？其实是因为UserInfoLoader的构造方法使用@Inject注解标注了，所以可以直接通过构造方法创建UserInfoLoader来注入FollowerPresenter和FollowerActivity。\n\n我们再把UserInfoLoader的构造方法的@Inject注解注释掉，这时候再rebuild就可以发现报错了。\n\n然后再取消掉AppComponent.provideUserInfoLoader的注释，就能顺利编过了。因为我们的AppModule.provideUserInfoLoader是通过new 一个UserInfoLoader出来的，所以可以不依赖构造方法的@Inject注解。\n\n## 使用Subcomponent\n\n最后一种方法就是使用@Subcomponent注解，这中方法和使用dependencies有点像，他们的区别在于使用@Subcomponent方法AppComponent不需要提供一个provideUserInfoLoader方法，子依赖可以直接使用AppComponent中的modules。首先我们要这样声明AppComponent:\n\n```\n@Component(modules = {AppModule.class})\npublic interface AppComponent {\n    FollowerComponent plus(FollowerPresenterModule module);\n    UserInfoComponent plus(UserInfoPresenterModule module);\n}\n```\n\n然后FollowerComponent和UserInfoComponent的定义如下:\n\n```\n@Subcomponent(modules = {FollowerPresenterModule.class})\npublic interface FollowerComponent {\n    void inject(FollowerPresenter presenter);\n    void inject(FollowerActivity activity);\n}\n```\n\n```\n@Subcomponent(modules = {UserInfoPresenterModule.class})\npublic interface UserInfoComponent {\n    void inject(UserInfoPresenter presenter);\n    void inject(UserInfoActivity activity);\n}\n```\n\n注入的实现代码如下:\n\n```\nFollowerComponent component = getAppComponent().plus(new FollowerPresenterModule(this));\n\ncomponent.inject(this);\ncomponent.inject(mPresenter);\n```\n\n# Scope\n\n现在还有一个问题，现在FollowerComponent和UserInfoComponent虽然都往Presenter注入了UserInfoLoader，但他们是不同的实例:\n\n> D/UserInfoPresenter: mUserInfoLoader : com.example.linjw.dagger2demo.model.UserInfoLoader@31e117c\n> D/FollowerPresenter: mUserInfoLoader : com.example.linjw.dagger2demo.model.UserInfoLoader@c9ad63b\n\n如果我想他们使用的就是同一个UserInfoLoader实例呢？需要怎么做？\n\nDagger2中有作用域的概念，可以规定几个Component在同一个作用域，在同一个作用域注入的依赖就是同一个实例。\n\n首先需要声明我们的Scope:\n\n```\n@Scope\n@Retention(RUNTIME)\npublic @interface AppScope {\n}\n```\n\n然后就只需要将Module的Provides方法和Component用同一个Scope注解标注一下，就能让他们处于同一个作用域了。\n\n比如我们需要在AppModule.provideUserInfoLoader标注:\n```\n@Module\npublic class AppModule {\n    @AppScope\n    @Provides\n\tUserInfoLoader provideUserInfoLoader() {\n        return new UserInfoLoader();\n\t}\n}\n```\n\n像我们使用Subcomponent去实现依赖继承，我们就只需要在AppComponent中标注就好了，这样他们的子依赖也会处于AppScope中:\n\n```\n@AppScope\n@Component(modules = {AppModule.class})\npublic interface AppComponent {\n    FollowerComponent plus(FollowerPresenterModule module);\n    UserInfoComponent plus(UserInfoPresenterModule module);\n}\n```\n\n> D/UserInfoPresenter: mUserInfoLoader : com.example.linjw.dagger2demo.model.UserInfoLoader@31e117c\n> D/FollowerPresenter: mUserInfoLoader : com.example.linjw.dagger2demo.model.UserInfoLoader@31e117c\n\n# Demo地址\n\n可以在[这里](https://github.com/bluesky466/Dagger2Demo)查看完整代码\n","source":"_posts/Dagger2学习笔记-二.md","raw":"title: Dagger2学习笔记(二)\ndate: 2017-05-17 00:27:30\ntags:\n\t- 技术相关\n\t- Android\n---\n\n在上一篇[文章](http://blog.islinjw.cn/2017/05/13/Dagger2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/)我们讲了用于搜索的SearchActivity的实现，这一篇文章我们继续以剩下的两个Activity的实现为例，讲一下Dagger2的其他特性。这两个Activity分别是用了展示SearchActivity搜索的用户的头像和用户名的UserInfoActivity和点击用户头像跳转到的展示用户followers的FollowerActivity。\n\n\n在我们的Demo中有个叫做UserInfoLoader的类，它是用来向github服务器请求用户信息和follower信息的，会在多个actiity中被使用，例如在FollowerPresenter和UserInfoPresenter中都需要注入UserInfoLoader。最简单的方式是我们可以直接使用@Inject注解标注它的构造方法，使得Dagger2可以直接创建它的实例去注入FollowerPresenter和UserInfoPresenter中。\n\n```\nclass UserInfoLoader {\n\t...\n\t@Inject\n\tUserInfoLoader() {\n\t}\n\t...\n}\n\n```\n\n# Module复用\n\n当然我们也能用复用Module的方式，这种方式虽然比直接用@Inject注解构造方法复杂，但是它还有其他十分有用的功能，接下来我会慢慢分析。\n\n首先我们把它的Module单独抽出来，放到AppModule中：\n\n```\n@Module\npublic class AppModule {\n    @Provides\n\tUserInfoLoader provideUserInfoLoader() {\n        return new UserInfoLoader();\n\t}\n}\n```\n\n## 共用Module\n\n我们复用这个Module的方式有几种，一是同时放在FollowerComponent和UserInfoComponent的modules中:\n\n```\n@Component(modules = {AppModule.class, FollowerPresenterModule.class})\npublic interface FollowerComponent {\n    void inject(FollowerPresenter presenter);\n    void inject(FollowerActivity activity);\n}\n\n```\n\n```\n@Component(modules = {AppModule.class, UserInfoPresenterModule.class})\npublic interface UserInfoComponent {\n    void inject(UserInfoPresenter presenter);\n    void inject(UserInfoActivity activity);\n}\n```\n\n## 使用dependencies\n\n第二种方式是使用dependencies，首先我们需要声明多一个AppComponent接口\n\n```\n@Component(modules = {AppModule.class})\npublic interface AppComponent {\n    UserInfoLoader provideUserInfoLoader();\n}\n\n```\n\n这个接口的provideUserInfoLoader()方法就是提供出来给子依赖获取UserInfoLoader的，因为dependencies子依赖是获取不了父依赖的modules里面的Provides的。\n\n之后声明FollowerComponent和UserInfoComponent:\n\n```\n@Component(dependencies = AppComponent.class, modules = {UserInfoPresenterModule.class})\npublic interface UserInfoComponent {\n    void inject(UserInfoPresenter presenter);\n    void inject(UserInfoActivity activity);\n}\n```\n\n```\n@Component(dependencies = AppComponent.class, modules = {FollowerPresenterModule.class})\npublic interface FollowerComponent {\n    void inject(FollowerPresenter presenter);\n    void inject(FollowerActivity activity);\n}\n\n```\n\n最后就再去实现注入:\n```\nFollowerComponent component = DaggerFollowerComponent.builder()\n\t.appComponent(getAppComponent())\n    .followerPresenterModule(new FollowerPresenterModule(this))\n    .build();\ncomponent.inject(this);\ncomponent.inject(mPresenter);\n```\n\n```\nUserInfoComponent component = DaggerUserInfoComponent.builder()\n    .appComponent(getAppComponent())\n    .userInfoPresenterModule(new UserInfoPresenterModule(this))\n    .build();\ncomponent.inject(this);\ncomponent.inject(mPresenter);\n```\n\n这里的AppComponent是公用的，所以我们放到Application中:\n\n```\npublic class AppApplication extends Application {\n    private AppComponent mAppComponent;\n\n\tpublic AppApplication() {\n        super();\n\n        mAppComponent = DaggerAppComponent.create();\n\t}\n\n\tpublic AppComponent getAppComponent() {\n        return mAppComponent;\n\t}\n}\n```\n\n然后在Activity中这样获取AppComponent:\n\n```\nAppComponent getAppComponent() {\n    return ((AppApplication)getApplication()).getAppComponent();\n}\n```\n\n我们尝试注释掉AppComponent.provideUserInfoLoader，rebuild一下，发现居然没有报错，这是怎么回事？其实是因为UserInfoLoader的构造方法使用@Inject注解标注了，所以可以直接通过构造方法创建UserInfoLoader来注入FollowerPresenter和FollowerActivity。\n\n我们再把UserInfoLoader的构造方法的@Inject注解注释掉，这时候再rebuild就可以发现报错了。\n\n然后再取消掉AppComponent.provideUserInfoLoader的注释，就能顺利编过了。因为我们的AppModule.provideUserInfoLoader是通过new 一个UserInfoLoader出来的，所以可以不依赖构造方法的@Inject注解。\n\n## 使用Subcomponent\n\n最后一种方法就是使用@Subcomponent注解，这中方法和使用dependencies有点像，他们的区别在于使用@Subcomponent方法AppComponent不需要提供一个provideUserInfoLoader方法，子依赖可以直接使用AppComponent中的modules。首先我们要这样声明AppComponent:\n\n```\n@Component(modules = {AppModule.class})\npublic interface AppComponent {\n    FollowerComponent plus(FollowerPresenterModule module);\n    UserInfoComponent plus(UserInfoPresenterModule module);\n}\n```\n\n然后FollowerComponent和UserInfoComponent的定义如下:\n\n```\n@Subcomponent(modules = {FollowerPresenterModule.class})\npublic interface FollowerComponent {\n    void inject(FollowerPresenter presenter);\n    void inject(FollowerActivity activity);\n}\n```\n\n```\n@Subcomponent(modules = {UserInfoPresenterModule.class})\npublic interface UserInfoComponent {\n    void inject(UserInfoPresenter presenter);\n    void inject(UserInfoActivity activity);\n}\n```\n\n注入的实现代码如下:\n\n```\nFollowerComponent component = getAppComponent().plus(new FollowerPresenterModule(this));\n\ncomponent.inject(this);\ncomponent.inject(mPresenter);\n```\n\n# Scope\n\n现在还有一个问题，现在FollowerComponent和UserInfoComponent虽然都往Presenter注入了UserInfoLoader，但他们是不同的实例:\n\n> D/UserInfoPresenter: mUserInfoLoader : com.example.linjw.dagger2demo.model.UserInfoLoader@31e117c\n> D/FollowerPresenter: mUserInfoLoader : com.example.linjw.dagger2demo.model.UserInfoLoader@c9ad63b\n\n如果我想他们使用的就是同一个UserInfoLoader实例呢？需要怎么做？\n\nDagger2中有作用域的概念，可以规定几个Component在同一个作用域，在同一个作用域注入的依赖就是同一个实例。\n\n首先需要声明我们的Scope:\n\n```\n@Scope\n@Retention(RUNTIME)\npublic @interface AppScope {\n}\n```\n\n然后就只需要将Module的Provides方法和Component用同一个Scope注解标注一下，就能让他们处于同一个作用域了。\n\n比如我们需要在AppModule.provideUserInfoLoader标注:\n```\n@Module\npublic class AppModule {\n    @AppScope\n    @Provides\n\tUserInfoLoader provideUserInfoLoader() {\n        return new UserInfoLoader();\n\t}\n}\n```\n\n像我们使用Subcomponent去实现依赖继承，我们就只需要在AppComponent中标注就好了，这样他们的子依赖也会处于AppScope中:\n\n```\n@AppScope\n@Component(modules = {AppModule.class})\npublic interface AppComponent {\n    FollowerComponent plus(FollowerPresenterModule module);\n    UserInfoComponent plus(UserInfoPresenterModule module);\n}\n```\n\n> D/UserInfoPresenter: mUserInfoLoader : com.example.linjw.dagger2demo.model.UserInfoLoader@31e117c\n> D/FollowerPresenter: mUserInfoLoader : com.example.linjw.dagger2demo.model.UserInfoLoader@31e117c\n\n# Demo地址\n\n可以在[这里](https://github.com/bluesky466/Dagger2Demo)查看完整代码\n","slug":"Dagger2学习笔记-二","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2uoo0041w3fyigrtzpmm"},{"title":"Dagger2学习笔记(一)","date":"2017-05-12T22:53:27.000Z","_content":"\n依赖注入是一种十分好的技巧，它能解偶高层次模块和低层次模块，使得高层模块不用将底层模块硬编码到内部。\n所有依赖的底层模块都由外部注入，实际是一种面向接口编程。高层模块不依赖底层模块的实现细节，可以方便的做到替换底层模块。\n这种技术在编写跨平台程序的时候可以很容易的替换调依赖系统的底层模块，并且在做单元测试的时候也可以很容易的使用stub对象注入宿主类中从而方便宿主类的测试代码的编写。\n\n# 使用Dagger2实现依赖注入\n\n如果不使用DI框架，我们也可以在构造方法里传入依赖类或着用setter方法来将依赖类注入宿主类。但是这样的话就会需要我们在业务逻辑中处理依赖类的生成和注入，其实这些依赖的注入代码和业务都没有什么关系，仅仅是一些初始化的操作而已，如果可以将这些与业务逻辑无关的代码都独立出去，这样的话我们的代码逻辑就会更加的简洁和清晰。Dagger2就是一个十分强大的DI框架，它可以帮助我们轻松的在业务逻辑之外实现依赖注入。\n\n下面我将用一个小Demo来介绍一下Dagger2的用法。这个小Demo的功能是通过github帐号搜索用户头像和用户名，同时列出该用户的follower\n\n## Dagger2的引入\n\nDagger2没有使用反射，它是通过编译时生成代码来实现依赖注入的。所以需要引入apt:\n\n```\n//build.gradle(project)\n...\nbuildscript {\n\trepositories {\n\t\tjcenter()\n\t}\n\n\tdependencies {\n\t\tclasspath 'com.android.tools.build:gradle:2.3.0'\n\t\tclasspath 'com.neenbedankt.gradle.plugins:android-apt:1.8'\n\t}\n}\n...\n```\n\n```\n//build.gradle(app)\napply plugin: 'com.android.application'\napply plugin: 'com.neenbedankt.android-apt'\n...\n```\n\n之后再引入javax.annotation和dagger2:\n```\n//build.gradle(app)\n...\ndependencies {\n\t...\n\tcompile 'com.google.dagger:dagger:2.4'\n\tapt 'com.google.dagger:dagger-compiler:2.4'\n\tcompile 'org.glassfish:javax.annotation:10.0-b28'\n\t...\n}\n```\n\n## Dagger2的两个重要组件\n\nDagger2有两个十分重要的组件：Module和Component。\n\n- Module\n\n\tModule是依赖的提供者，Dagger2框架通过Module的Provides方法获取被依赖类的实例。\n\n- Component\n\n\tComponent是一个注入接口，Dagger2框架通过Component将依赖注入到高层类中。\n\n\t用一个形象的比喻来说明就是Module是装有被依赖类的针筒，Component是针头。Dagger2通过选择针筒和针头的不同组合可以将不同的被依赖实例注入到高层模块中。\n\n## 实现搜索页面\n\n### @Inject注解\n\n我们的搜索页面很简单，只有一个输入框和一个搜索安按钮，它的作用是输入要搜索的用户的账号。我们使用MVP模式去实现它,因为它不需要model层，所以只有View和Presenter:\n\n```\npublic interface SearchView {\n\t...\n}\n```\n\n```\npublic class SearchPresenter{\n\t...\n\t@Inject\n\tSearchView mSearchView;\n\n    @Inject\n    Context mContext;\n\n\t@Inject\n    public SearchPresenter() {\n        Log.d(TAG, \"SearchPresenter()\");\n    }\n\t...\n}\n```\n\n```\npublic class SearchActivity extends Activity implements SearchView {\n\t...\n\t@Inject\n\tSearchPresenter mSearchPresenter;\n\t...\n}\n```\n\n我们通过@Inject注解告诉Dagger2哪些成员变量是需要被注入的，这里需要注意的是被@Inject标注的成员变量不可以是private的，因为Dagger2没有用到反射，而是通过生成代码去完成注入的，所以一旦你将成员变量声明成private的，那Dagger2就不能访问到它，从而无法无法完成注入了。@Inject还有另外一个作用就是告诉Dagger2用哪个构造函数去创建实例，如这里Dagger2就会用SearchPresenter()去创建SearchPresenter的实例，这个构造函数的作用在接下来就会被讲到。\n\n### Module\n\n然后再让我们来看看SearchPresenterModule:\n\n```\n@Module\npublic class SearchPresenterModule {\n    private SearchActivity mSearchActivity;\n\n    public SearchPresenterModule(SearchActivity view) {\n        mSearchActivity = view;\n    }\n\n    @Provides\n    SearchView provideSearchView() {\n        return mSearchActivity;\n    }\n\n    @Provides\n    Context provideContext() {\n        return mSearchActivity;\n    }\n}\n```\n\n注入SearchPresenter所需要的SearchView和Context就是从这里提供的\n\nModule类首先需要使用@Module注解标注，让Dagger2知道这是一个Module，然后内部的使用@Provides注解标注的方法就是用来获取被依赖类的实例的方法,例如provideSearchView就可以用来提供SearchView\n\n一般我习惯@Provide方法加上provide前缀，但是这个也不是必须，可以没有这个前缀。\n\n### Component\n\n接着看看Component:\n\n```\n@Component(modules = {SearchPresenterModule.class})\npublic interface SearchComponent {\n    void inject(SearchActivity activity);\n\n    void inject(SearchPresenter presenter);\n}\n```\n\nComponent是一个被@Component注解标注的接口，Dagger2会自动生成实现这个接口的类，去完成注入的功能。我们需要用modules去告诉Component从哪个Module中获取被依赖类的实例。这里Dagger2就会自动生成实现了SearchComponent接口的DaggerSearchComponent类，它有两个方法，分别用来向SearchActivity和SearchPresenter注入依赖。\n\n向SearchPresenter注入的SearchView和Context都是SearchPresenterModule提供的这个很容易理解，但是向SearchActivity注入的SearchPresenter又是从哪里来的呢?还记得我们用@Inject标注了SearchPresenter的一个构造函数了吗？Dagger2会使用我们标注的构造函数创建出一个SearchPresenter来给SearchActivity注入使用。\n\n### 调用注入方法实现注入\n\n在SearchActivity的onCreate方法中将依赖注入到SearchActivity和SearchPresenter中:\n\n\n```\nSearchComponent component = DaggerSearchComponent.builder()\n                .searchPresenterModule(new SearchPresenterModule(this))\n                .build();\n\ncomponent.inject(this);\ncomponent.inject(mSearchPresenter);\n```\n\n它实际是通过查找SearchActivity和SearchPresenter中带有@Inject注解的成员变量知道哪个变量需要被注入，然后通过SearchPresenterModule的provide方法和SearchPresenter被标注的构造方法获取到被依赖类的实例去实现注入的。\n\n这里有一点需要注意的是调用顺序，inject(SearchActivity activity)要在inject(SearchPresenter presenter)前面调用，因为需要先将SearchActivity.this的mSearchPresenter注入，才能向mSearchPresenter中再注入SearchActivity\n\n### 指定构造函数\n\n我们在前面讲到过@Inject可以指定构造函数，其实它还有另一重意义，就是存在多个构造函数的时候选择其中一种。\n\n我们现在添加另外一种SearchPresenter构造函数,然后中添加打印:\n\n```\npublic class SearchPresenter{\n\t...\n\t@Inject\n\tSearchView mSearchView;\n\n    @Inject\n    Context mContext;\n\n\t@Inject\n    public SearchPresenter() {\n        Log.d(TAG, \"SearchPresenter()\");\n    }\n\n\tpublic SearchPresenter(Context context) {\n\t    Log.d(TAG, \"SearchPresenter(Context context)\");\n\t\tmContext = context;\n\t}\n\t...\n}\n```\n\n让我们看看运行的时候到底调的是哪个构造函数吧:\n\n> D/SearchPresenter(27333): SearchPresenter()\n\n如果我们把SearchPresenter类修改一下呢?\n\n```\npublic class SearchPresenter{\n\t...\n\t@Inject\n\tSearchView mSearchView;\n\n    // @Inject 注释掉\n    Context mContext;\n\n\t// @Inject 注释掉\n    public SearchPresenter() {\n        Log.d(TAG, \"SearchPresenter()\");\n    }\n\n\t@Inject // 添加@Inject\n\tpublic SearchPresenter(Context context) {\n\t    Log.d(TAG, \"SearchPresenter(Context context)\");\n\t\tmContext = context;\n\t}\n\t...\n}\n```\n\n现在可以看到打印:\n\n> D/SearchPresenter(27693): SearchPresenter(Context context)\n\n从打印来看，@Inject的确是可以选择构造函数的。但还有个细节不知道大家有没有注意到,我们去掉了mContext的@Inject,改由构造函数传入。这个传入构造函数的Context又是怎么来的呢？\n\n答案在SearchPresenterModule里:\n\n```\n@Module\npublic class SearchPresenterModule {\n    private SearchActivity mSearchActivity;\n\n    public SearchPresenterModule(SearchActivity view) {\n        mSearchActivity = view;\n    }\n\n    @Provides\n    SearchView provideSearchView() {\n        return mSearchActivity;\n    }\n\n\t// 是它,是它,就是它\n    @Provides\n    Context provideContext() {\n        return mSearchActivity;\n    }\n}\n```\n\n没错SearchPresenterModule.provideContext()这个方法还能创建Context出来给SearchPresenter的构造函数使用！\n\n# Demo地址\n\n可以在[这里](https://github.com/bluesky466/Dagger2Demo)查看完整代码，剩余部分的代码会在下一篇文章里介绍。\n","source":"_posts/Dagger2学习笔记-一.md","raw":"title: Dagger2学习笔记(一)\ndate: 2017-05-13 06:53:27\ntags:\n\t- 技术相关\n\t- Android\n---\n\n依赖注入是一种十分好的技巧，它能解偶高层次模块和低层次模块，使得高层模块不用将底层模块硬编码到内部。\n所有依赖的底层模块都由外部注入，实际是一种面向接口编程。高层模块不依赖底层模块的实现细节，可以方便的做到替换底层模块。\n这种技术在编写跨平台程序的时候可以很容易的替换调依赖系统的底层模块，并且在做单元测试的时候也可以很容易的使用stub对象注入宿主类中从而方便宿主类的测试代码的编写。\n\n# 使用Dagger2实现依赖注入\n\n如果不使用DI框架，我们也可以在构造方法里传入依赖类或着用setter方法来将依赖类注入宿主类。但是这样的话就会需要我们在业务逻辑中处理依赖类的生成和注入，其实这些依赖的注入代码和业务都没有什么关系，仅仅是一些初始化的操作而已，如果可以将这些与业务逻辑无关的代码都独立出去，这样的话我们的代码逻辑就会更加的简洁和清晰。Dagger2就是一个十分强大的DI框架，它可以帮助我们轻松的在业务逻辑之外实现依赖注入。\n\n下面我将用一个小Demo来介绍一下Dagger2的用法。这个小Demo的功能是通过github帐号搜索用户头像和用户名，同时列出该用户的follower\n\n## Dagger2的引入\n\nDagger2没有使用反射，它是通过编译时生成代码来实现依赖注入的。所以需要引入apt:\n\n```\n//build.gradle(project)\n...\nbuildscript {\n\trepositories {\n\t\tjcenter()\n\t}\n\n\tdependencies {\n\t\tclasspath 'com.android.tools.build:gradle:2.3.0'\n\t\tclasspath 'com.neenbedankt.gradle.plugins:android-apt:1.8'\n\t}\n}\n...\n```\n\n```\n//build.gradle(app)\napply plugin: 'com.android.application'\napply plugin: 'com.neenbedankt.android-apt'\n...\n```\n\n之后再引入javax.annotation和dagger2:\n```\n//build.gradle(app)\n...\ndependencies {\n\t...\n\tcompile 'com.google.dagger:dagger:2.4'\n\tapt 'com.google.dagger:dagger-compiler:2.4'\n\tcompile 'org.glassfish:javax.annotation:10.0-b28'\n\t...\n}\n```\n\n## Dagger2的两个重要组件\n\nDagger2有两个十分重要的组件：Module和Component。\n\n- Module\n\n\tModule是依赖的提供者，Dagger2框架通过Module的Provides方法获取被依赖类的实例。\n\n- Component\n\n\tComponent是一个注入接口，Dagger2框架通过Component将依赖注入到高层类中。\n\n\t用一个形象的比喻来说明就是Module是装有被依赖类的针筒，Component是针头。Dagger2通过选择针筒和针头的不同组合可以将不同的被依赖实例注入到高层模块中。\n\n## 实现搜索页面\n\n### @Inject注解\n\n我们的搜索页面很简单，只有一个输入框和一个搜索安按钮，它的作用是输入要搜索的用户的账号。我们使用MVP模式去实现它,因为它不需要model层，所以只有View和Presenter:\n\n```\npublic interface SearchView {\n\t...\n}\n```\n\n```\npublic class SearchPresenter{\n\t...\n\t@Inject\n\tSearchView mSearchView;\n\n    @Inject\n    Context mContext;\n\n\t@Inject\n    public SearchPresenter() {\n        Log.d(TAG, \"SearchPresenter()\");\n    }\n\t...\n}\n```\n\n```\npublic class SearchActivity extends Activity implements SearchView {\n\t...\n\t@Inject\n\tSearchPresenter mSearchPresenter;\n\t...\n}\n```\n\n我们通过@Inject注解告诉Dagger2哪些成员变量是需要被注入的，这里需要注意的是被@Inject标注的成员变量不可以是private的，因为Dagger2没有用到反射，而是通过生成代码去完成注入的，所以一旦你将成员变量声明成private的，那Dagger2就不能访问到它，从而无法无法完成注入了。@Inject还有另外一个作用就是告诉Dagger2用哪个构造函数去创建实例，如这里Dagger2就会用SearchPresenter()去创建SearchPresenter的实例，这个构造函数的作用在接下来就会被讲到。\n\n### Module\n\n然后再让我们来看看SearchPresenterModule:\n\n```\n@Module\npublic class SearchPresenterModule {\n    private SearchActivity mSearchActivity;\n\n    public SearchPresenterModule(SearchActivity view) {\n        mSearchActivity = view;\n    }\n\n    @Provides\n    SearchView provideSearchView() {\n        return mSearchActivity;\n    }\n\n    @Provides\n    Context provideContext() {\n        return mSearchActivity;\n    }\n}\n```\n\n注入SearchPresenter所需要的SearchView和Context就是从这里提供的\n\nModule类首先需要使用@Module注解标注，让Dagger2知道这是一个Module，然后内部的使用@Provides注解标注的方法就是用来获取被依赖类的实例的方法,例如provideSearchView就可以用来提供SearchView\n\n一般我习惯@Provide方法加上provide前缀，但是这个也不是必须，可以没有这个前缀。\n\n### Component\n\n接着看看Component:\n\n```\n@Component(modules = {SearchPresenterModule.class})\npublic interface SearchComponent {\n    void inject(SearchActivity activity);\n\n    void inject(SearchPresenter presenter);\n}\n```\n\nComponent是一个被@Component注解标注的接口，Dagger2会自动生成实现这个接口的类，去完成注入的功能。我们需要用modules去告诉Component从哪个Module中获取被依赖类的实例。这里Dagger2就会自动生成实现了SearchComponent接口的DaggerSearchComponent类，它有两个方法，分别用来向SearchActivity和SearchPresenter注入依赖。\n\n向SearchPresenter注入的SearchView和Context都是SearchPresenterModule提供的这个很容易理解，但是向SearchActivity注入的SearchPresenter又是从哪里来的呢?还记得我们用@Inject标注了SearchPresenter的一个构造函数了吗？Dagger2会使用我们标注的构造函数创建出一个SearchPresenter来给SearchActivity注入使用。\n\n### 调用注入方法实现注入\n\n在SearchActivity的onCreate方法中将依赖注入到SearchActivity和SearchPresenter中:\n\n\n```\nSearchComponent component = DaggerSearchComponent.builder()\n                .searchPresenterModule(new SearchPresenterModule(this))\n                .build();\n\ncomponent.inject(this);\ncomponent.inject(mSearchPresenter);\n```\n\n它实际是通过查找SearchActivity和SearchPresenter中带有@Inject注解的成员变量知道哪个变量需要被注入，然后通过SearchPresenterModule的provide方法和SearchPresenter被标注的构造方法获取到被依赖类的实例去实现注入的。\n\n这里有一点需要注意的是调用顺序，inject(SearchActivity activity)要在inject(SearchPresenter presenter)前面调用，因为需要先将SearchActivity.this的mSearchPresenter注入，才能向mSearchPresenter中再注入SearchActivity\n\n### 指定构造函数\n\n我们在前面讲到过@Inject可以指定构造函数，其实它还有另一重意义，就是存在多个构造函数的时候选择其中一种。\n\n我们现在添加另外一种SearchPresenter构造函数,然后中添加打印:\n\n```\npublic class SearchPresenter{\n\t...\n\t@Inject\n\tSearchView mSearchView;\n\n    @Inject\n    Context mContext;\n\n\t@Inject\n    public SearchPresenter() {\n        Log.d(TAG, \"SearchPresenter()\");\n    }\n\n\tpublic SearchPresenter(Context context) {\n\t    Log.d(TAG, \"SearchPresenter(Context context)\");\n\t\tmContext = context;\n\t}\n\t...\n}\n```\n\n让我们看看运行的时候到底调的是哪个构造函数吧:\n\n> D/SearchPresenter(27333): SearchPresenter()\n\n如果我们把SearchPresenter类修改一下呢?\n\n```\npublic class SearchPresenter{\n\t...\n\t@Inject\n\tSearchView mSearchView;\n\n    // @Inject 注释掉\n    Context mContext;\n\n\t// @Inject 注释掉\n    public SearchPresenter() {\n        Log.d(TAG, \"SearchPresenter()\");\n    }\n\n\t@Inject // 添加@Inject\n\tpublic SearchPresenter(Context context) {\n\t    Log.d(TAG, \"SearchPresenter(Context context)\");\n\t\tmContext = context;\n\t}\n\t...\n}\n```\n\n现在可以看到打印:\n\n> D/SearchPresenter(27693): SearchPresenter(Context context)\n\n从打印来看，@Inject的确是可以选择构造函数的。但还有个细节不知道大家有没有注意到,我们去掉了mContext的@Inject,改由构造函数传入。这个传入构造函数的Context又是怎么来的呢？\n\n答案在SearchPresenterModule里:\n\n```\n@Module\npublic class SearchPresenterModule {\n    private SearchActivity mSearchActivity;\n\n    public SearchPresenterModule(SearchActivity view) {\n        mSearchActivity = view;\n    }\n\n    @Provides\n    SearchView provideSearchView() {\n        return mSearchActivity;\n    }\n\n\t// 是它,是它,就是它\n    @Provides\n    Context provideContext() {\n        return mSearchActivity;\n    }\n}\n```\n\n没错SearchPresenterModule.provideContext()这个方法还能创建Context出来给SearchPresenter的构造函数使用！\n\n# Demo地址\n\n可以在[这里](https://github.com/bluesky466/Dagger2Demo)查看完整代码，剩余部分的代码会在下一篇文章里介绍。\n","slug":"Dagger2学习笔记-一","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2uop0044w3fywgr1cnpd"},{"title":"Android温故而知新 - launchMode","date":"2017-06-29T17:07:02.000Z","_content":"\nActivity有四种launchMode,[android官方文档](https://developer.android.com/guide/topics/manifest/activity-element.html?hl=zh-cn)的介绍如下:\n\n|启动模式|多个实例?|注释|\n|:-----:|:-----:|:--:|\n| “standard”|是|默认值。系统始终会在目标任务中创建新的 Activity 实例并向其传送 Intent。|\n|“singleTop”|有条件|如果目标任务的顶部已存在一个 Activity 实例，则系统会通过调用该实例的 onNewIntent() 方法向其传送 Intent，而不是创建新的 Activity 实例。|\n|“singleTask”| 否|系统在新任务的根位置创建 Activity 并向其传送 Intent。 不过，如果已存在一个 Activity 实例，则系统会通过调用该实例的 onNewIntent() 方法向其传送 Intent，而不是创建新的 Activity 实例。|\n|“singleInstance”|否|与“singleTask\"”相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。 该 Activity 始终是其任务唯一仅有的成员。|\n\n# 测试demo\n\n我们通过两个Activity之间的跳转和任务栈打印来理解launchMode的作用。\n\n这两个Activity使用同一个布局, TextView用来打印任务栈的id和activity实例，然后是两个按钮，分别用来启动两个activity:\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\">\n\n    <TextView\n        android:id=\"@+id/label\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\" />\n\n    <Button\n        android:id=\"@+id/gotoFirstActivity\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:onClick=\"onClick\"\n        android:text=\"goto first activity\" />\n\n    <Button\n        android:id=\"@+id/gotoSecondActivity\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:onClick=\"onClick\"\n        android:text=\"goto second activity\" />\n\n</LinearLayout>\n```\n\nActivty代码如下:\n\n```\npublic class FirstActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_layout);\n\n        Utils.initActivity(this);\n    }\n\n    public void onClick(View view) {\n        Utils.onClick(this, view.getId());\n    }\n}\n```\n\n```\npublic class SecondActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_layout);\n\n        Utils.initActivity(this);\n    }\n\n    public void onClick(View view) {\n        Utils.onClick(this, view.getId());\n    }\n}\n```\n\n因为两个activity的代码很相似，所以我把它们放到了静态类Utils中:\n\n```\npublic class Utils {\n    public static void initActivity(Activity activity) {\n        TextView label = (TextView) activity.findViewById(R.id.label);\n        label.setText(\"task : \" + activity.getTaskId() + \" activity : \" + activity);\n    }\n\n\n    public static void onClick(Context context, int id) {\n        Intent intent;\n        if (id == R.id.gotoFirstActivity) {\n            intent = new Intent(context, FirstActivity.class);\n        } else {\n            intent = new Intent(context, SecondActivity.class);\n        }\n        context.startActivity(intent);\n    }\n}\n```\n\n# 查看任务栈\n\n我们可以在adb shell中使用dumpsys activity可以看到任务栈。这个命令的打印会比较多,但是有两个部分是比较重要的。\n\n一个是Recent tasks,这里可以看到各个任务栈的总体信息,如我们的demo在第0个任务栈,它的Task id 是483,包名是linjw.demo.launchmodedemo,栈里面有6个Activity\n\n```\nACTIVITY MANAGER RECENT TASKS (dumpsys activity recents)\n  Recent tasks:\n  * Recent #0: TaskRecord{f69123d #483 A=linjw.demo.launchmodedemo U=0 sz=6}\n  * Recent #1: TaskRecord{b798a32 #487 A=com.android.systemui U=0 sz=0}\n  * Recent #2: TaskRecord{f874383 #486 A=com.tencent.mm U=0 sz=1}\n  * Recent #3: TaskRecord{d7bd900 #479 A=com.meizu.flyme.launcher U=0 sz=1}\n  * Recent #4: TaskRecord{8f5d797 #482 A=com.tencent.mobileqq U=0 sz=0}\n  * Recent #5: TaskRecord{fd99539 #481 A=android.task.stk.task U=0 sz=0}\n  * Recent #6: TaskRecord{7c9951e #480 A=com.android.incallui U=0 sz=1}\n  * Recent #7: TaskRecord{e32177e #478 A=com.zhihu.android U=0 sz=0}\n  * Recent #8: TaskRecord{7f094df #472 A=com.meizu.media.reader U=0 sz=0}\n```\n\n在它的下面可以看到里面的具体的activity,并且可以看到叫起它的Intent:\n\n```\nACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)\nDisplay #0 (activities from top to bottom):\n  Stack #1:\n    Task id #483\n      TaskRecord{f69123d #483 A=linjw.demo.launchmodedemo U=0 sz=6}\n      Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10100000 cmp=linjw.demo.launchmodedemo/.FirstActivity }\n        Hist #5: ActivityRecord{786c71e u0 linjw.demo.launchmodedemo/.FirstActivity t483}\n          Intent { cmp=linjw.demo.launchmodedemo/.FirstActivity }\n          ProcessRecord{245852c 7994:linjw.demo.launchmodedemo/u0a61}\n        Hist #4: ActivityRecord{6d5da5d u0 linjw.demo.launchmodedemo/.SecondActivity t483}\n          Intent { cmp=linjw.demo.launchmodedemo/.SecondActivity }\n          ProcessRecord{245852c 7994:linjw.demo.launchmodedemo/u0a61}\n        Hist #3: ActivityRecord{90b9f88 u0 linjw.demo.launchmodedemo/.FirstActivity t483}\n          Intent { cmp=linjw.demo.launchmodedemo/.FirstActivity }\n          ProcessRecord{245852c 7994:linjw.demo.launchmodedemo/u0a61}\n        Hist #2: ActivityRecord{1de66e u0 linjw.demo.launchmodedemo/.SecondActivity t483}\n          Intent { cmp=linjw.demo.launchmodedemo/.SecondActivity }\n          ProcessRecord{245852c 7994:linjw.demo.launchmodedemo/u0a61}\n        Hist #1: ActivityRecord{17dd5b1 u0 linjw.demo.launchmodedemo/.FirstActivity t483}\n          Intent { cmp=linjw.demo.launchmodedemo/.FirstActivity }\n          ProcessRecord{245852c 7994:linjw.demo.launchmodedemo/u0a61}\n        Hist #0: ActivityRecord{9f195f8 u0 linjw.demo.launchmodedemo/.FirstActivity t483}\n          Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10100000 cmp=linjw.demo.launchmodedemo/.FirstActivity }\n          ProcessRecord{245852c 7994:linjw.demo.launchmodedemo/u0a61}\n    ...\n```\n\n例如Hist #0这个Activity是从桌面点击应用图标进入的,所以它的Intent带android.intent.category.LAUNCHER这个category和FLAG_ACTIVITY\\_LAUNCHED\\_FROM\\_HISTORY(0x00100000)、 FLAG\\_RECEIVER\\_FOREGROUND(0x10000000)这两个Flag,而其他的Activity都是我们通过点击按钮叫起的,我们的Intent里面没有带任何的category和Flag,所以只有cmp标识是哪个Activity。\n\n我们可以通过Intent#setFlags(int) 设置Flag、Intent#addCategory(String) 添加category\n\n有时候可以通过这个命令查看Activity的启动模式结合各种launchMode的作用来定位一些bug\n\n# standard\n\nstandard是默认的启动模式,在没有配置android:launchMode的时候就会默认用这种启动模式,当然也可以显示指定为standard。\n\n它的特点是每次都会启动一个新的Activity实例,我们连续点击第一个按钮两次然后再连续点击两次返回键,截图如下:\n\n{% img /Android温故而知新-launchMode/standard1.png %}\n\n{% img /Android温故而知新-launchMode/standard2.png %}\n\n任务栈状态图如下:\n\n{% img /Android温故而知新-launchMode/standard3.png %}\n\n\n\n# singleTop\n\n当launchMode是singleTop的时候，如果task栈的栈顶Activity和将要启动的Activity是同一个Activity的话,就不会再启动第二个Activity。我们将FirstActivity设为singleTop,在启动demo之后无论按第一个按钮多少次,任务栈里面都只会有一个FirstActivity。\n\n{% img /Android温故而知新-launchMode/singleTop1.png %}\n\n任务栈状态图如下:\n\n{% img /Android温故而知新-launchMode/singleTop2.png %}\n\n\n但是当任务栈的栈顶Activity和将要启动的Activity不是同一个Activity的时候,就会启动新的Activity,并将它压入栈顶而不管栈里面还有没有这个Activity:\n\n{% img /Android温故而知新-launchMode/singleTop3.png %}\n\n{% img /Android温故而知新-launchMode/singleTop4.png %}\n\n任务栈状态图如下:\n\n{% img /Android温故而知新-launchMode/singleTop5.png %}\n\n# singleTask\n\n我们将FirstActivity和SecondActivity的launchMode都设置为singleTask,启动demo之后先按“GOTO SECOND ACTIVITY”再按“GOTO FIRST ACTIVITY”,截图如下:\n\n{% img /Android温故而知新-launchMode/singleTask1.png %}\n\n我们可以看到在SecondActivity中启动FirstActivity,结果就返回了第一个Activity。如果这个时候再按返回键就会推出应用。\n\nsingleTask的作用就是在任务栈中寻找将要启动的Activity,如果找到的话就将它上面的Activity都弹出栈,直到它成为栈顶。\n\n任务栈状态图如下:\n\n{% img /Android温故而知新-launchMode/singleTask2.png %}\n\n# singleInstance\n\n官方文档的介绍是:\n\n> 与“singleTask\"”相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。 该 Activity 始终是其任务唯一仅有的成员。\n\n就是说系统会为singleInstance Activity单独创建一个任务栈,这个任务栈里是这个Activity独占的,不会再压入其他的Activity。而且它是系统唯一的,当singleInstance Activity已经存在于系统的某一任务栈中,就会直接跳到那个任务栈的Activity中,而不会新启动一个Activity。\n\n我们将FirstActivity设为standard, SecondActivity设为singleInstance。启动demo之后先按“GOTO SECOND ACTIVITY”再按“GOTO FIRST ACTIVITY”。然后再一直按返回键到退出应用。截图如下:\n\n{% img /Android温故而知新-launchMode/singleInstance1.png %}\n\n{% img /Android温故而知新-launchMode/singleInstance2.png %}\n\n任务栈状态图如下:\n\n{% img /Android温故而知新-launchMode/singleInstance3.png %}\n\n\n启动应用之后先点击“GOTO SECOND ACTIVITY”,这个时候系统会新建一个任务栈(Task 20)来放SecondActivity\n\n在SecondActivity中再启动FirstActivity,因为Task 20这个任务栈是SecondActivity独占的。所以不会在这个任务栈压入其他Activity,而会回到原来的任务栈上(Task 19)。又因为FirstActivity的launchMode是standard,所以不管原来的栈里面有没有FirstActivity,都会压入一个新的FirstActivity。\n\n这个时候再按返回键就不是回到SecondActivity了,因为它在其他的任务栈里面,要先将当前任务栈清空。\n\n这个时候按返回键会将当前的Activity弹出栈,于是就跳到了一开始的FirstActivity。之后再按返回键,因为Task 19这个任务栈空了,就会去到SecondActivity的栈,于是就去到了SecondActivity。最后再按返回键就会退出应用了。\n\n要再次提醒需注意的是singleInstance的Activity是系统唯一的,也就是说你在demo这里启动了这个SecondActivity的SecondActivity,然后按home键回到桌面去启动其他应用,从其他应用再启动一个SecondActivity也是去到原来的那个SecondActivity","source":"_posts/Android温故而知新-launchMode.md","raw":"title: Android温故而知新 - launchMode\ndate: 2017-06-30 01:07:02\ntags:\n    - 技术相关\n    - Android\n---\n\nActivity有四种launchMode,[android官方文档](https://developer.android.com/guide/topics/manifest/activity-element.html?hl=zh-cn)的介绍如下:\n\n|启动模式|多个实例?|注释|\n|:-----:|:-----:|:--:|\n| “standard”|是|默认值。系统始终会在目标任务中创建新的 Activity 实例并向其传送 Intent。|\n|“singleTop”|有条件|如果目标任务的顶部已存在一个 Activity 实例，则系统会通过调用该实例的 onNewIntent() 方法向其传送 Intent，而不是创建新的 Activity 实例。|\n|“singleTask”| 否|系统在新任务的根位置创建 Activity 并向其传送 Intent。 不过，如果已存在一个 Activity 实例，则系统会通过调用该实例的 onNewIntent() 方法向其传送 Intent，而不是创建新的 Activity 实例。|\n|“singleInstance”|否|与“singleTask\"”相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。 该 Activity 始终是其任务唯一仅有的成员。|\n\n# 测试demo\n\n我们通过两个Activity之间的跳转和任务栈打印来理解launchMode的作用。\n\n这两个Activity使用同一个布局, TextView用来打印任务栈的id和activity实例，然后是两个按钮，分别用来启动两个activity:\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\">\n\n    <TextView\n        android:id=\"@+id/label\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\" />\n\n    <Button\n        android:id=\"@+id/gotoFirstActivity\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:onClick=\"onClick\"\n        android:text=\"goto first activity\" />\n\n    <Button\n        android:id=\"@+id/gotoSecondActivity\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:onClick=\"onClick\"\n        android:text=\"goto second activity\" />\n\n</LinearLayout>\n```\n\nActivty代码如下:\n\n```\npublic class FirstActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_layout);\n\n        Utils.initActivity(this);\n    }\n\n    public void onClick(View view) {\n        Utils.onClick(this, view.getId());\n    }\n}\n```\n\n```\npublic class SecondActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_layout);\n\n        Utils.initActivity(this);\n    }\n\n    public void onClick(View view) {\n        Utils.onClick(this, view.getId());\n    }\n}\n```\n\n因为两个activity的代码很相似，所以我把它们放到了静态类Utils中:\n\n```\npublic class Utils {\n    public static void initActivity(Activity activity) {\n        TextView label = (TextView) activity.findViewById(R.id.label);\n        label.setText(\"task : \" + activity.getTaskId() + \" activity : \" + activity);\n    }\n\n\n    public static void onClick(Context context, int id) {\n        Intent intent;\n        if (id == R.id.gotoFirstActivity) {\n            intent = new Intent(context, FirstActivity.class);\n        } else {\n            intent = new Intent(context, SecondActivity.class);\n        }\n        context.startActivity(intent);\n    }\n}\n```\n\n# 查看任务栈\n\n我们可以在adb shell中使用dumpsys activity可以看到任务栈。这个命令的打印会比较多,但是有两个部分是比较重要的。\n\n一个是Recent tasks,这里可以看到各个任务栈的总体信息,如我们的demo在第0个任务栈,它的Task id 是483,包名是linjw.demo.launchmodedemo,栈里面有6个Activity\n\n```\nACTIVITY MANAGER RECENT TASKS (dumpsys activity recents)\n  Recent tasks:\n  * Recent #0: TaskRecord{f69123d #483 A=linjw.demo.launchmodedemo U=0 sz=6}\n  * Recent #1: TaskRecord{b798a32 #487 A=com.android.systemui U=0 sz=0}\n  * Recent #2: TaskRecord{f874383 #486 A=com.tencent.mm U=0 sz=1}\n  * Recent #3: TaskRecord{d7bd900 #479 A=com.meizu.flyme.launcher U=0 sz=1}\n  * Recent #4: TaskRecord{8f5d797 #482 A=com.tencent.mobileqq U=0 sz=0}\n  * Recent #5: TaskRecord{fd99539 #481 A=android.task.stk.task U=0 sz=0}\n  * Recent #6: TaskRecord{7c9951e #480 A=com.android.incallui U=0 sz=1}\n  * Recent #7: TaskRecord{e32177e #478 A=com.zhihu.android U=0 sz=0}\n  * Recent #8: TaskRecord{7f094df #472 A=com.meizu.media.reader U=0 sz=0}\n```\n\n在它的下面可以看到里面的具体的activity,并且可以看到叫起它的Intent:\n\n```\nACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)\nDisplay #0 (activities from top to bottom):\n  Stack #1:\n    Task id #483\n      TaskRecord{f69123d #483 A=linjw.demo.launchmodedemo U=0 sz=6}\n      Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10100000 cmp=linjw.demo.launchmodedemo/.FirstActivity }\n        Hist #5: ActivityRecord{786c71e u0 linjw.demo.launchmodedemo/.FirstActivity t483}\n          Intent { cmp=linjw.demo.launchmodedemo/.FirstActivity }\n          ProcessRecord{245852c 7994:linjw.demo.launchmodedemo/u0a61}\n        Hist #4: ActivityRecord{6d5da5d u0 linjw.demo.launchmodedemo/.SecondActivity t483}\n          Intent { cmp=linjw.demo.launchmodedemo/.SecondActivity }\n          ProcessRecord{245852c 7994:linjw.demo.launchmodedemo/u0a61}\n        Hist #3: ActivityRecord{90b9f88 u0 linjw.demo.launchmodedemo/.FirstActivity t483}\n          Intent { cmp=linjw.demo.launchmodedemo/.FirstActivity }\n          ProcessRecord{245852c 7994:linjw.demo.launchmodedemo/u0a61}\n        Hist #2: ActivityRecord{1de66e u0 linjw.demo.launchmodedemo/.SecondActivity t483}\n          Intent { cmp=linjw.demo.launchmodedemo/.SecondActivity }\n          ProcessRecord{245852c 7994:linjw.demo.launchmodedemo/u0a61}\n        Hist #1: ActivityRecord{17dd5b1 u0 linjw.demo.launchmodedemo/.FirstActivity t483}\n          Intent { cmp=linjw.demo.launchmodedemo/.FirstActivity }\n          ProcessRecord{245852c 7994:linjw.demo.launchmodedemo/u0a61}\n        Hist #0: ActivityRecord{9f195f8 u0 linjw.demo.launchmodedemo/.FirstActivity t483}\n          Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10100000 cmp=linjw.demo.launchmodedemo/.FirstActivity }\n          ProcessRecord{245852c 7994:linjw.demo.launchmodedemo/u0a61}\n    ...\n```\n\n例如Hist #0这个Activity是从桌面点击应用图标进入的,所以它的Intent带android.intent.category.LAUNCHER这个category和FLAG_ACTIVITY\\_LAUNCHED\\_FROM\\_HISTORY(0x00100000)、 FLAG\\_RECEIVER\\_FOREGROUND(0x10000000)这两个Flag,而其他的Activity都是我们通过点击按钮叫起的,我们的Intent里面没有带任何的category和Flag,所以只有cmp标识是哪个Activity。\n\n我们可以通过Intent#setFlags(int) 设置Flag、Intent#addCategory(String) 添加category\n\n有时候可以通过这个命令查看Activity的启动模式结合各种launchMode的作用来定位一些bug\n\n# standard\n\nstandard是默认的启动模式,在没有配置android:launchMode的时候就会默认用这种启动模式,当然也可以显示指定为standard。\n\n它的特点是每次都会启动一个新的Activity实例,我们连续点击第一个按钮两次然后再连续点击两次返回键,截图如下:\n\n{% img /Android温故而知新-launchMode/standard1.png %}\n\n{% img /Android温故而知新-launchMode/standard2.png %}\n\n任务栈状态图如下:\n\n{% img /Android温故而知新-launchMode/standard3.png %}\n\n\n\n# singleTop\n\n当launchMode是singleTop的时候，如果task栈的栈顶Activity和将要启动的Activity是同一个Activity的话,就不会再启动第二个Activity。我们将FirstActivity设为singleTop,在启动demo之后无论按第一个按钮多少次,任务栈里面都只会有一个FirstActivity。\n\n{% img /Android温故而知新-launchMode/singleTop1.png %}\n\n任务栈状态图如下:\n\n{% img /Android温故而知新-launchMode/singleTop2.png %}\n\n\n但是当任务栈的栈顶Activity和将要启动的Activity不是同一个Activity的时候,就会启动新的Activity,并将它压入栈顶而不管栈里面还有没有这个Activity:\n\n{% img /Android温故而知新-launchMode/singleTop3.png %}\n\n{% img /Android温故而知新-launchMode/singleTop4.png %}\n\n任务栈状态图如下:\n\n{% img /Android温故而知新-launchMode/singleTop5.png %}\n\n# singleTask\n\n我们将FirstActivity和SecondActivity的launchMode都设置为singleTask,启动demo之后先按“GOTO SECOND ACTIVITY”再按“GOTO FIRST ACTIVITY”,截图如下:\n\n{% img /Android温故而知新-launchMode/singleTask1.png %}\n\n我们可以看到在SecondActivity中启动FirstActivity,结果就返回了第一个Activity。如果这个时候再按返回键就会推出应用。\n\nsingleTask的作用就是在任务栈中寻找将要启动的Activity,如果找到的话就将它上面的Activity都弹出栈,直到它成为栈顶。\n\n任务栈状态图如下:\n\n{% img /Android温故而知新-launchMode/singleTask2.png %}\n\n# singleInstance\n\n官方文档的介绍是:\n\n> 与“singleTask\"”相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。 该 Activity 始终是其任务唯一仅有的成员。\n\n就是说系统会为singleInstance Activity单独创建一个任务栈,这个任务栈里是这个Activity独占的,不会再压入其他的Activity。而且它是系统唯一的,当singleInstance Activity已经存在于系统的某一任务栈中,就会直接跳到那个任务栈的Activity中,而不会新启动一个Activity。\n\n我们将FirstActivity设为standard, SecondActivity设为singleInstance。启动demo之后先按“GOTO SECOND ACTIVITY”再按“GOTO FIRST ACTIVITY”。然后再一直按返回键到退出应用。截图如下:\n\n{% img /Android温故而知新-launchMode/singleInstance1.png %}\n\n{% img /Android温故而知新-launchMode/singleInstance2.png %}\n\n任务栈状态图如下:\n\n{% img /Android温故而知新-launchMode/singleInstance3.png %}\n\n\n启动应用之后先点击“GOTO SECOND ACTIVITY”,这个时候系统会新建一个任务栈(Task 20)来放SecondActivity\n\n在SecondActivity中再启动FirstActivity,因为Task 20这个任务栈是SecondActivity独占的。所以不会在这个任务栈压入其他Activity,而会回到原来的任务栈上(Task 19)。又因为FirstActivity的launchMode是standard,所以不管原来的栈里面有没有FirstActivity,都会压入一个新的FirstActivity。\n\n这个时候再按返回键就不是回到SecondActivity了,因为它在其他的任务栈里面,要先将当前任务栈清空。\n\n这个时候按返回键会将当前的Activity弹出栈,于是就跳到了一开始的FirstActivity。之后再按返回键,因为Task 19这个任务栈空了,就会去到SecondActivity的栈,于是就去到了SecondActivity。最后再按返回键就会退出应用了。\n\n要再次提醒需注意的是singleInstance的Activity是系统唯一的,也就是说你在demo这里启动了这个SecondActivity的SecondActivity,然后按home键回到桌面去启动其他应用,从其他应用再启动一个SecondActivity也是去到原来的那个SecondActivity","slug":"Android温故而知新-launchMode","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2uor0047w3fybgu4ci9v"},{"title":"Android温故而知新 - Java的四种引用","date":"2017-07-05T18:59:46.000Z","_content":"java对象的引用包括强引用，软引用，弱引用，虚引用四种\n  \n# 强引用\n\n强引用是最常用的引用,我们在代码中处处可见:\n\n```\nString str = \"hello world\";\nMap<String, String> map = new HashMap<>();\nint[] arr = new int[10];\n```\n\n上面的str、map、arr都是强引用。一个对象,只要有强引用与它关联,那么JVM就不会回收它。即使是在内存不足的情况下,JVM宁愿抛出OutOfMemory的异常也不会回收它。\n\n```\npublic void function() {\n\tObject object = new Object();\n\tObject[] array = new Object[9999];\n}\n```\n\n比如上面的方法,当运行到Object[] array = new Object[9999];的时候,如果内存不够了,JVM就好抛出OutOfMemory的异常,而不会回收object的内存。所以一个强引用的内存肯定是有效的,所以java并不像c++,需要担心野指针的问题。\n\n当然,当退出function之后,object和array就都已经不存在了,所以它们所指向的内存就可以被回收了。\n\n当一个对象使用完,不会再被用到的时候,我们可以将所有指向它的强引用都赋为null。这样JVM会在合适的时机去回收它。\n\n# 软引用\n\n软引用所管理的对象在内存不足的时候,如果没有其他强引用与之管理,就会被回收。用SoftReference来表示软引用,使用方法如下:\n\n```\npublic class DemoActivity extends AppCompatActivity {\n    SoftReference<String> mStr = new SoftReference<>(new String(\"hello world\"));\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_layout);\n    }\n\n    public void onClick(View view) {\n        Log.d(\"SoftReference\", \"mStr = \" + mStr.get());\n    }\n}\n```\n\n注意的是这里不能直接new SoftReference<>(\"hello world\");因为JVM内建字符串池机制的存在会导致字符串池强引用的存在，因此不会被垃圾回收。\n\n\nstr.get()就可以获取到管理的对象,如果对象已经被回收就会返回null。\n\n我们可以用Android Studio的Monitors强制gc,释放内存,然后这个时候就能看到它返回的是null了。\n\n{% img /Android温故而知新-Java的四种引用/1.png %}\n\n值得注意的是“SoftReference所管理的对象被回收”并不代表SoftReference的内存被回收, SoftReference此时依然是一个可以使用的对象,但它已经没有使用价值了。我们需要在合适的时候将SoftReference赋值为null,释放掉它所占用的内存,避免大量无用的SoftReference存在导致内存泄漏。\n\nSoftReference也可以和ReferenceQueue一起使用。构造SoftReference的时候将ReferenceQueue传入SoftReference的构造方法。当SoftReference所管理的对象被回收的时候SoftReference就会被放到ReferenceQueue中。\n\n\n```\npublic class DemoActivity extends AppCompatActivity {\n\n    ReferenceQueue<String> mReferenceQueue = new ReferenceQueue<>();\n    SoftReference<String> mStr = new SoftReference<>(new String(\"hello world\"), mReferenceQueue);\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_layout);\n    }\n\n    public void onClick(View view) {\n        if (mStr.get() == null) {\n            Log.d(\"SoftReference\", \"mStr = \" + mStr);\n\n            mStr = null;\n            SoftReference<String> ref;\n            do {\n                ref = (SoftReference<String>) mReferenceQueue.poll();\n                Log.d(\"SoftReference\", \"ref = \" + ref);\n\n            } while (ref != null);\n        }\n    }\n}\n```\n\n软引用的特性使得它很适合用来实现数据缓存,如图片缓存,网页缓存等。在内存紧张的时候如果没有其他的强引用关联,即该资源仅仅是放在缓存中而没有被使用,就会被释放。而当内存不紧张的时候,即使没有其他强引用与之关联,JVM的垃圾回收机制也是不会回收软引用所管理的资源的。\n\n当需要使用的时候判断获取的是不是null,如果是的话证明之前内存被回收了,直接重新加载就好了。\n\n# 弱引用\n\n弱引用所管理的对象在JVM进行垃圾回收的时候,只要没有其他强引用与之关联。不管内存是否充足,都会被回收。它用WeakReference来表示。\n\n弱引用可以用在回调函数中防止内存泄漏。我们来看个典型的例子,也是一个很多人都会犯的错误:\n\n```\npublic class DemoActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_layout);\n    }\n\n    // 可能会引入内存泄漏\n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            super.handleMessage(msg);\n        }\n    };\n}\n```\n\n不知道大家有没有看过我之前写的一篇[关于Handler的博客](http://blog.islinjw.cn/2017/07/02/Android%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0-Handler/),如果没有没有看过,而对Handler又不太熟悉的同学可以去看一下。\n\n我们知道Handler是和Looper还有MessageQueue一起工作的。当安卓应用启动之后,系统会在主线程创建一个Looper和MessageQueue,它们的生命周期贯穿整个应用的生命周期。\n\nHandler在发送Message的时候会将Message传到MessageQueue里面去,而Message里面保存着Handler的引用。这样的话如果Message还没有被处理,Handler也不会被回收。\n\n而这里的Handler是DemoActivity的一个内部类。在java中,非晶体内部匿名类会持有外部类的一个隐式引用,这样就有可能导致外部类无法被垃圾回收。\n\n如果我们代码中这样写:\n\n```\npublic class DemoActivity extends AppCompatActivity {\n    private static final int MSG_DO_SOMETHING = 1;\n    \n    // 可能会引入内存泄漏\n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n        \t...\n        }\n    };\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_layout);\n\n        // 延迟十分钟发送消息\n        mHandler.sendEmptyMessageDelayed(MSG_DO_SOMETHING, 1000 * 60 * 10);\n    }\n}\n```\n\n即使退出了DemoActivity,在消息没有被处理之前, DemoActivity的内存也是不会被回收的。\n\n那要怎样解决它呢？\n\n我们可以使用静态内部类加虚引用的方式:\n\n```\npublic class DemoActivity extends AppCompatActivity {\n    private static final int MSG_DO_SOMETHING = 1;\n    // 可能会引入内存泄漏\n    private static class InnerHandler extends Handler {\n        private final WeakReference<DemoActivity> mActivity;\n\n        InnerHandler(DemoActivity activity) {\n            mActivity = new WeakReference<>(activity);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            DemoActivity activity = mActivity.get();\n            if (activity != null) {\n                ...\n            }\n        }\n    }\n\n    private final Handler mHandler = new InnerHandler(this);\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_layout);\n\n        // 延迟十分钟发送消息\n        mHandler.sendEmptyMessageDelayed(MSG_DO_SOMETHING, 1000 * 60 * 10);\n    }\n}\n```\n\n由于静态内部类不持有外部类的引用,所以现在只有虚引用关联了DemoActivity,在垃圾回收的时候,不管是否内存不足,DemoActivity都会被回收。\n\n十分钟之后当handleMessage方法被调用的时候,用WeakReference的get方法获取DemoActivity,如果返回null的话证明DemoActivity已经被回收,就不应该再做什么处理了。\n\nWeakReference同样可以在构造方法中传入ReferenceQueue。如果它所管理的对象被JVM回收，这个WeakReference就会被加入到ReferenceQueue。\n\n# 虚引用\n\n虚引用或者叫做幽灵引用在java中用PhantomReference表示。它和前面的应用都不一样,它不影响对象的生命周期,当一个对象只有虚引用与之关联的时候,就和没有任何引用一样。\n\n而且它必须与ReferenceQueue一起使用,它只有一个构造函数:\n\n```\npublic PhantomReference(T referent, ReferenceQueue<? super T> q) {\n\tsuper(referent, q);\n}\n```\n\n而且它的get方法永远返回null:\n\n```\npublic T get() {\n\treturn null;\n}\n```\n\n如果PhantomReference管理的对象只有PhantomReference与之关联,系统就会在这个时候或者一段时间之后将PhantomReference放到ReferenceQueue中。而不用等到垃圾回收的时候(参考[PhantomReference的文档](https://docs.oracle.com/javase/7/docs/api/java/lang/ref/PhantomReference.html)):\n\n> If the garbage collector determines at a certain point in time that the referent of a phantom reference is phantom reachable, then at that time or at some later time it will enqueue the reference.\n\n[这篇文章](http://www.milletblog.com/2016/09/J2SE%E8%BF%99%E6%89%8D%E6%98%AFjava%E8%99%9A%E5%BC%95%E7%94%A8PhantomReference-4/)对虚引用做了一个详细的介绍,其中对这一点他是这样解释的:\n\n> 当一个虚引用被认为是一定会被垃圾回收器回收的时候，这个虚引用才会被注册到引用队列，而不会像软引用和弱引用必须等到垃圾回收器回收之后才会被注册到引用队列\n\n对这个虚引用我其实理解的还不是很深入,查了很多的资料对它的讲解也是很模糊的。按我的理解,它应该就是单纯的用来判断一个对象是否被回收了。如果是,就进行一些清理操作。","source":"_posts/Android温故而知新-Java的四种引用.md","raw":"title: Android温故而知新 - Java的四种引用\ndate: 2017-07-06 02:59:46\ntags:\n    - 技术相关\n    - Android\n---\njava对象的引用包括强引用，软引用，弱引用，虚引用四种\n  \n# 强引用\n\n强引用是最常用的引用,我们在代码中处处可见:\n\n```\nString str = \"hello world\";\nMap<String, String> map = new HashMap<>();\nint[] arr = new int[10];\n```\n\n上面的str、map、arr都是强引用。一个对象,只要有强引用与它关联,那么JVM就不会回收它。即使是在内存不足的情况下,JVM宁愿抛出OutOfMemory的异常也不会回收它。\n\n```\npublic void function() {\n\tObject object = new Object();\n\tObject[] array = new Object[9999];\n}\n```\n\n比如上面的方法,当运行到Object[] array = new Object[9999];的时候,如果内存不够了,JVM就好抛出OutOfMemory的异常,而不会回收object的内存。所以一个强引用的内存肯定是有效的,所以java并不像c++,需要担心野指针的问题。\n\n当然,当退出function之后,object和array就都已经不存在了,所以它们所指向的内存就可以被回收了。\n\n当一个对象使用完,不会再被用到的时候,我们可以将所有指向它的强引用都赋为null。这样JVM会在合适的时机去回收它。\n\n# 软引用\n\n软引用所管理的对象在内存不足的时候,如果没有其他强引用与之管理,就会被回收。用SoftReference来表示软引用,使用方法如下:\n\n```\npublic class DemoActivity extends AppCompatActivity {\n    SoftReference<String> mStr = new SoftReference<>(new String(\"hello world\"));\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_layout);\n    }\n\n    public void onClick(View view) {\n        Log.d(\"SoftReference\", \"mStr = \" + mStr.get());\n    }\n}\n```\n\n注意的是这里不能直接new SoftReference<>(\"hello world\");因为JVM内建字符串池机制的存在会导致字符串池强引用的存在，因此不会被垃圾回收。\n\n\nstr.get()就可以获取到管理的对象,如果对象已经被回收就会返回null。\n\n我们可以用Android Studio的Monitors强制gc,释放内存,然后这个时候就能看到它返回的是null了。\n\n{% img /Android温故而知新-Java的四种引用/1.png %}\n\n值得注意的是“SoftReference所管理的对象被回收”并不代表SoftReference的内存被回收, SoftReference此时依然是一个可以使用的对象,但它已经没有使用价值了。我们需要在合适的时候将SoftReference赋值为null,释放掉它所占用的内存,避免大量无用的SoftReference存在导致内存泄漏。\n\nSoftReference也可以和ReferenceQueue一起使用。构造SoftReference的时候将ReferenceQueue传入SoftReference的构造方法。当SoftReference所管理的对象被回收的时候SoftReference就会被放到ReferenceQueue中。\n\n\n```\npublic class DemoActivity extends AppCompatActivity {\n\n    ReferenceQueue<String> mReferenceQueue = new ReferenceQueue<>();\n    SoftReference<String> mStr = new SoftReference<>(new String(\"hello world\"), mReferenceQueue);\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_layout);\n    }\n\n    public void onClick(View view) {\n        if (mStr.get() == null) {\n            Log.d(\"SoftReference\", \"mStr = \" + mStr);\n\n            mStr = null;\n            SoftReference<String> ref;\n            do {\n                ref = (SoftReference<String>) mReferenceQueue.poll();\n                Log.d(\"SoftReference\", \"ref = \" + ref);\n\n            } while (ref != null);\n        }\n    }\n}\n```\n\n软引用的特性使得它很适合用来实现数据缓存,如图片缓存,网页缓存等。在内存紧张的时候如果没有其他的强引用关联,即该资源仅仅是放在缓存中而没有被使用,就会被释放。而当内存不紧张的时候,即使没有其他强引用与之关联,JVM的垃圾回收机制也是不会回收软引用所管理的资源的。\n\n当需要使用的时候判断获取的是不是null,如果是的话证明之前内存被回收了,直接重新加载就好了。\n\n# 弱引用\n\n弱引用所管理的对象在JVM进行垃圾回收的时候,只要没有其他强引用与之关联。不管内存是否充足,都会被回收。它用WeakReference来表示。\n\n弱引用可以用在回调函数中防止内存泄漏。我们来看个典型的例子,也是一个很多人都会犯的错误:\n\n```\npublic class DemoActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_layout);\n    }\n\n    // 可能会引入内存泄漏\n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            super.handleMessage(msg);\n        }\n    };\n}\n```\n\n不知道大家有没有看过我之前写的一篇[关于Handler的博客](http://blog.islinjw.cn/2017/07/02/Android%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0-Handler/),如果没有没有看过,而对Handler又不太熟悉的同学可以去看一下。\n\n我们知道Handler是和Looper还有MessageQueue一起工作的。当安卓应用启动之后,系统会在主线程创建一个Looper和MessageQueue,它们的生命周期贯穿整个应用的生命周期。\n\nHandler在发送Message的时候会将Message传到MessageQueue里面去,而Message里面保存着Handler的引用。这样的话如果Message还没有被处理,Handler也不会被回收。\n\n而这里的Handler是DemoActivity的一个内部类。在java中,非晶体内部匿名类会持有外部类的一个隐式引用,这样就有可能导致外部类无法被垃圾回收。\n\n如果我们代码中这样写:\n\n```\npublic class DemoActivity extends AppCompatActivity {\n    private static final int MSG_DO_SOMETHING = 1;\n    \n    // 可能会引入内存泄漏\n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n        \t...\n        }\n    };\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_layout);\n\n        // 延迟十分钟发送消息\n        mHandler.sendEmptyMessageDelayed(MSG_DO_SOMETHING, 1000 * 60 * 10);\n    }\n}\n```\n\n即使退出了DemoActivity,在消息没有被处理之前, DemoActivity的内存也是不会被回收的。\n\n那要怎样解决它呢？\n\n我们可以使用静态内部类加虚引用的方式:\n\n```\npublic class DemoActivity extends AppCompatActivity {\n    private static final int MSG_DO_SOMETHING = 1;\n    // 可能会引入内存泄漏\n    private static class InnerHandler extends Handler {\n        private final WeakReference<DemoActivity> mActivity;\n\n        InnerHandler(DemoActivity activity) {\n            mActivity = new WeakReference<>(activity);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            DemoActivity activity = mActivity.get();\n            if (activity != null) {\n                ...\n            }\n        }\n    }\n\n    private final Handler mHandler = new InnerHandler(this);\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_layout);\n\n        // 延迟十分钟发送消息\n        mHandler.sendEmptyMessageDelayed(MSG_DO_SOMETHING, 1000 * 60 * 10);\n    }\n}\n```\n\n由于静态内部类不持有外部类的引用,所以现在只有虚引用关联了DemoActivity,在垃圾回收的时候,不管是否内存不足,DemoActivity都会被回收。\n\n十分钟之后当handleMessage方法被调用的时候,用WeakReference的get方法获取DemoActivity,如果返回null的话证明DemoActivity已经被回收,就不应该再做什么处理了。\n\nWeakReference同样可以在构造方法中传入ReferenceQueue。如果它所管理的对象被JVM回收，这个WeakReference就会被加入到ReferenceQueue。\n\n# 虚引用\n\n虚引用或者叫做幽灵引用在java中用PhantomReference表示。它和前面的应用都不一样,它不影响对象的生命周期,当一个对象只有虚引用与之关联的时候,就和没有任何引用一样。\n\n而且它必须与ReferenceQueue一起使用,它只有一个构造函数:\n\n```\npublic PhantomReference(T referent, ReferenceQueue<? super T> q) {\n\tsuper(referent, q);\n}\n```\n\n而且它的get方法永远返回null:\n\n```\npublic T get() {\n\treturn null;\n}\n```\n\n如果PhantomReference管理的对象只有PhantomReference与之关联,系统就会在这个时候或者一段时间之后将PhantomReference放到ReferenceQueue中。而不用等到垃圾回收的时候(参考[PhantomReference的文档](https://docs.oracle.com/javase/7/docs/api/java/lang/ref/PhantomReference.html)):\n\n> If the garbage collector determines at a certain point in time that the referent of a phantom reference is phantom reachable, then at that time or at some later time it will enqueue the reference.\n\n[这篇文章](http://www.milletblog.com/2016/09/J2SE%E8%BF%99%E6%89%8D%E6%98%AFjava%E8%99%9A%E5%BC%95%E7%94%A8PhantomReference-4/)对虚引用做了一个详细的介绍,其中对这一点他是这样解释的:\n\n> 当一个虚引用被认为是一定会被垃圾回收器回收的时候，这个虚引用才会被注册到引用队列，而不会像软引用和弱引用必须等到垃圾回收器回收之后才会被注册到引用队列\n\n对这个虚引用我其实理解的还不是很深入,查了很多的资料对它的讲解也是很模糊的。按我的理解,它应该就是单纯的用来判断一个对象是否被回收了。如果是,就进行一些清理操作。","slug":"Android温故而知新-Java的四种引用","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2uos004aw3fy4dk6i2gj"},{"title":"Android温故而知新 - Handler","date":"2017-07-01T16:13:13.000Z","_content":"\n我们都知道,安卓主线程(也就是ui线程)中不能做耗时操作,一旦主线程阻塞了超过5秒钟就会被系统强制关闭,甚至在主线程中访问网络都会直接抛异常。但是我们的ui操作又必须在主线程中进行。所以我们会在子线程中进行耗时的操作,完成之后将结果同步到主线程进行ui的刷新。\n\n而Handler机制就是谷歌用来方便我们进行线程同步的,我们可以很方便的通过它,在子线程中将ui刷新的操作同步回主线程中进行。\n\n# 使用Handler将ui刷新操作同步到主线程中进行\n\n我们先来看一个例子直观感受下如何使用Handler将ui刷新操作从子线程同步到主线程中进行:\n\n```\npublic class MainActivity extends AppCompatActivity {\n    private static final int MSG_UPDATE_PROGRESS_BAR_ABOVE = 1;\n    private static final int MSG_UPDATE_PROGRESS_BAR_BELOW = 2;\n    private ProgressBar mProgressBarAbove;\n    private ProgressBar mProgressBarBelow;\n\n    private Handler mHandler;\n\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mProgressBarAbove = (ProgressBar) findViewById(R.id.progressAbove);\n\n        mProgressBarBelow = (ProgressBar) findViewById(R.id.progressBelow);\n\n        mHandler = new Handler() {\n            @Override\n            public void handleMessage(Message msg) {\n                super.handleMessage(msg);\n\n                switch (msg.what) {\n                    case MSG_UPDATE_PROGRESS_BAR_ABOVE:\n                        mProgressBarAbove.setProgress(msg.arg1);\n                        break;\n                    case MSG_UPDATE_PROGRESS_BAR_BELOW:\n                        Bundle data = msg.getData();\n                        mProgressBarBelow.setProgress(data.getInt(\"progress\"));\n                        break;\n                }\n            }\n        };\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                int progressAbove = 0;\n                int progressBelow = 0;\n\n                while (progressAbove < 100 || progressBelow < 100) {\n                    if (progressAbove < 100) {\n                        progressAbove++;\n\n                        Message above = new Message();\n                        above.what = MSG_UPDATE_PROGRESS_BAR_ABOVE;\n                        above.arg1 = progressAbove;\n                        mHandler.sendMessage(above);\n                    }\n\n                    if (progressBelow < 100) {\n                        progressBelow += 2;\n\n                        Message below = mHandler.obtainMessage();\n                        below.what = MSG_UPDATE_PROGRESS_BAR_BELOW;\n                        Bundle data = new Bundle();\n                        data.putInt(\"progress\", progressBelow);\n                        below.setData(data);\n                        mHandler.sendMessage(below);\n                    }\n\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }).start();\n    }\n}\n```\n\n上面的例子很简单,界面有上下两条进度条,我们在子线程中使用Thread.sleep(100)模拟耗时操作,每隔100毫秒更新一下进度,上面的进度条进度每次加1,下面的进度条每次加2。\n\n{% img /Android温故而知新-Handler/1.png %}\n\n## 1.创建handler并重写handleMessage方法\n\n首先我们会创建一个Handler并重写它的handleMessage,这个方法就是在主线程中被调用的,我们通过传给这个方法的Message去刷新ui。\n\nMessage的what成员变量用来标识消息的类型,我们这里用来区分更新哪一个进度条。同时我们可以从Message中取得从子线程中传过来的进度,然后直接在handleMessage里面刷新进度条的进度。\n\n## 2.在子线程中发送Message给Handler\n\nMessage是在子线程中被创建的。如代码所示,我们可以直接将它new出来,也可以使用mHandler.obtainMessage()从mHandler的Message池中获取一个实例。\n\n<font color=#FF0000>一般推荐使用obtainMessage的方式</font>,因为Message池中的Message是可以被重复利用的,避免了创建对象申请内存的开销。\n\n在前面说过Message的what成员变量是用来标志消息的类型的,我们这里直接将MSG_UPDATE_PROGRESS_BAR_ABOVE或者MSG_UPDATE_PROGRESS_BAR_ABOVE赋值进去,在handleMessage的时候就能用它来区分到底更新哪个进度条了。\n\n消息的值也有多种赋值方式。\n\n第一种很简单,Message提供了arg1、arg2、obj、replyTo等public成员变量,可以直接将想保存的数据赋值給他们,在handleMessage方法中就能直接获取到他们了。\n\n第二种就是创建一个Bundle对象,在Bundle对象中存入数据,然后再通过setData方法传给Message,在handleMessage方法中通过getData可以获得Message中保存的Bundle对象,从而获得保存的数据。\n\n# 同步到主线程的各种姿势\n\n使用Handler将操作同步到主线程中进行有两种方式,一种是上面例子中的发送Message的方式。另一种是直接将一个Runnable传给Handler,Handler就会在主线程中执行它:\n\n- sendEmptyMessage(int what)\n- sendEmptyMessageDelayed(int what, long delayMillis)\n- sendEmptyMessageAtTime(int what, long uptimeMillis)\n- sendMessage(Message msg)\n- sendMessageDelayed(Message msg, long delayMillis)\n- sendMessageAtTime(Message msg, long uptimeMillis)\n- sendMessageAtFrontOfQueue(Message msg)\n- post(Runnable r)\n- postDelayed(Runnable r, long delayMillis)\n- postAtTime(Runnable r, long uptimeMillis)\n- postAtTime(Runnable r, Object token, long uptimeMillis)\n- postAtFrontOfQueue(Runnable r)\n\n上面就是可以使用的一些方法,send前缀的方法用于发送一个带数据的Message对象,post前缀的方法用于安排一个Runnable对象到主线程中执行。他们都有延迟发送,定时发送等姿势可以使用。\n\n当然你也可以在Message或者Runnable未同步到主线程的时候使用下面的remove方法将他们取消:\n\n- removeMessages(int what)\n- removeMessages(int what, Object object)\n- removeCallbacks(Runnable r)\n- removeCallbacks(Runnable r, Object token)\n- removeCallbacksAndMessages(Object token)\n\n实际上将Runnable post到Handler中的时候也是用Message去包装的:\n\n```\n\tpublic final boolean post(Runnable r)\n    {\n       return  sendMessageDelayed(getPostMessage(r), 0);\n    }\n\n    private static Message getPostMessage(Runnable r) {\n        Message m = Message.obtain();\n        m.callback = r;\n        return m;\n    }\n```\n\n在主线程分发消息的时候如果判断到Message有callback则会直接执行callback,否则就将消息传到handleMessage中进行处理:\n\n```\n\t/**\n     * Handle system messages here.\n     */\n    public void dispatchMessage(Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n```\n\n# Handler机制的基本原理\n\nHandler机制有四个重要的组件:\n\n- Handler\n- Message\n- MessageQueue\n- Looper\n\nHandler和Message通过前面的例子应该已经很清楚了,但是MessageQueue和Looper又是什么鬼？\n\nMessageQueue顾名思义,就是Message的队列,我们调用Handler的各种方法发送Message其实就是将Message放到MessageQueue中。\n\n而Looper就将Message从MessageQueue中拿出来。Looper有一个loop方法,它里面有个死循环,不断从MessageQueue中拿Message出来并且将它传给Handler去处理。\n\n我们在子线程中将Message放入MessageQueue,然后在主线程中运行Looper的loop方法,不断从MessageQueue中获取Message。这就是Message从子线程同步到主线程的原理。\n\n我画了一幅图来更加形象的展示这个机制:\n\n{% img /Android温故而知新-Handler/2.png %}\n\n# 主线程中的Looper\n\n有人会问了,我们也没有在主线程中中调用Looper的loop方法啊,而且再说了loop中不是一个死循环吗,如果在主线程中运行它的话不会被堵死吗？\n\n其实安卓在启动主线程的时候就会自动创建一个Looper和执行Looper.loop()的了,不需要自己去手动操作。\n\n至于第二个问题,我们可以直接看安卓的源码:\n\n一般来讲我们认为ActivityThread.main(String[] args)就是安卓程序运行的入口,也就是我们熟悉的main方法。它其实很短,我们在它的最后可以看到Looper.loop()这个方法的确是被调用了的。\n\n```\n\tpublic static void main(String[] args) {\n        SamplingProfilerIntegration.start();\n\n        // CloseGuard defaults to true and can be quite spammy.  We\n        // disable it here, but selectively enable it later (via\n        // StrictMode) on debug builds, but using DropBox, not logs.\n        CloseGuard.setEnabled(false);\n\n        Environment.initForCurrentUser();\n\n        // Set the reporter for event logging in libcore\n        EventLogger.setReporter(new EventLoggingReporter());\n\n        Security.addProvider(new AndroidKeyStoreProvider());\n\n        Process.setArgV0(\"<pre-initialized>\");\n\n        Looper.prepareMainLooper();\n\n        ActivityThread thread = new ActivityThread();\n        thread.attach(false);\n\n        if (sMainThreadHandler == null) {\n            sMainThreadHandler = thread.getHandler();\n        }\n\n        AsyncTask.init();\n\n        if (false) {\n            Looper.myLooper().setMessageLogging(new\n                    LogPrinter(Log.DEBUG, \"ActivityThread\"));\n        }\n\n        Looper.loop();\n\n        throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n    }\n```\n\n但是调用了loop方法之后,线程不就被堵住了吗？那主线程又是怎样接收到按键消息和调用各种生命周期方法的？我们可以看到代码里还有个sMainThreadHandler,这个sMainThreadHandler是个H类,它的定义如下:\n\n```\nprivate class H extends Handler {\n\tpublic void handleMessage(Message msg) {\n        if (DEBUG_MESSAGES) Slog.v(TAG, \">>> handling: \" + codeToString(msg.what));\n            switch (msg.what) {\n                case LAUNCH_ACTIVITY: {\n                    ...\n                } break;\n                case RELAUNCH_ACTIVITY: {\n                    ...\n                } break;\n                ...\n            }\n        }\n    }\n}\n```\n\n看Activity的各个生命周期，还有事件处理也是通过Handler机制实现的！\n\n# 使用Handler将消息同步到其他线程\n\n根据上面的原理,其实我们不仅可以使用Handler将消息同步到主线程中,也能用它来将消息从主线程同步到子线程中去执行。\n\n只需要在子线程中运行Looper的loop方法,让它不断获取Message,然后在主线程中发送Message就能在子线程中被处理了。\n\n代码如下\n\n```\n    private Handler mHandler;\n\n    private Thread mThread = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            Looper.prepare();\n\n            mHandler = new Handler() {\n                public void handleMessage(Message msg) {\n                    // process incoming messages here\n                }\n            };\n            Looper.loop();\n        }\n    });\n```\n\n我们在需要在子线程中先调用Looper.prepare()。这个是个静态方法它用来创建一个Looper并绑定到当前的线程中。\n\n然后创建Handler,Handler会自动绑定当前线程中的Looper。\n\n最后调用Looper.loop()就大功告成了。\n\n之后我们就能在主线程中使用mHandler将消息发送到子线程中处理了。\n\n# HandlerThread\n\n在上面一节中我们看到,在子线程中创建Handler还需要手动调用Looper.prepare()和Looper.loop()。为了简化操作,谷歌官方提供了HandlerThread给我们使用。\n\nHandlerThread是Thread的子类,当HandlerThread启动的时候会自动调用Looper.prepare()和Looper.loop(),它的run方法源码如下:\n\n```\n    public void run() {\n        mTid = Process.myTid();\n        Looper.prepare();\n        synchronized (this) {\n            mLooper = Looper.myLooper();\n            notifyAll();\n        }\n        Process.setThreadPriority(mPriority);\n        onLooperPrepared();\n        Looper.loop();\n        mTid = -1;\n    }\n```\n\n于是我们只需要在Handler构造的时候传入HandlerThread的Looper就行了:\n\n```\nHandlerThread handlerThread = new HandlerThread(\"HandlerThread\");\nhandlerThread.start();\n\nmHandler = new Handler(handlerThread.getLooper()) {\n\t@Override\n\tpublic void handleMessage(Message msg) {\n\t\tsuper.handleMessage(msg);\n\t}\n};\n```\n\n# IntentService\n\n我们知道Service的各个声明周期函数也是在主线程中执行的,它也不能直接执行耗时操作。需要将耗时操作放到子线程中进行。\n\n为了方便在Service中进行耗时操作,谷歌提供了Service的子类IntentService。它有和Service相同的生命周期,同时也提供了在子线程处理耗时操作的机制。\n\nIntentService是一个抽象类,使用的时候需要继承并实现它的onHandleIntent方法,这个方法是在子线程中执行的,可以直接在这里进行耗时操作。\n\n其实IntentService内部也是通过HandlerThread实现的,而且代码十分简单:\n\n```\npublic abstract class IntentService extends Service {\n    private volatile Looper mServiceLooper;\n    private volatile ServiceHandler mServiceHandler;\n    private String mName;\n    private boolean mRedelivery;\n\n    private final class ServiceHandler extends Handler {\n        public ServiceHandler(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            onHandleIntent((Intent)msg.obj);\n            stopSelf(msg.arg1);\n        }\n    }\n\n    public IntentService(String name) {\n        super();\n        mName = name;\n    }\n\n    public void setIntentRedelivery(boolean enabled) {\n        mRedelivery = enabled;\n    }\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        HandlerThread thread = new HandlerThread(\"IntentService[\" + mName + \"]\");\n        thread.start();\n\n        mServiceLooper = thread.getLooper();\n        mServiceHandler = new ServiceHandler(mServiceLooper);\n    }\n\n    @Override\n    public void onStart(@Nullable Intent intent, int startId) {\n        Message msg = mServiceHandler.obtainMessage();\n        msg.arg1 = startId;\n        msg.obj = intent;\n        mServiceHandler.sendMessage(msg);\n    }\n\n    @Override\n    public int onStartCommand(@Nullable Intent intent, int flags, int startId) {\n        onStart(intent, startId);\n        return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;\n    }\n\n    @Override\n    public void onDestroy() {\n        mServiceLooper.quit();\n    }\n\n    @Override\n    @Nullable\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n\n    @WorkerThread\n    protected abstract void onHandleIntent(@Nullable Intent intent);\n}\n\n```\n","source":"_posts/Android温故而知新-Handler.md","raw":"title: Android温故而知新 - Handler\ndate: 2017-07-02 00:13:13\ntags:\n    - 技术相关\n    - Android\n---\n\n我们都知道,安卓主线程(也就是ui线程)中不能做耗时操作,一旦主线程阻塞了超过5秒钟就会被系统强制关闭,甚至在主线程中访问网络都会直接抛异常。但是我们的ui操作又必须在主线程中进行。所以我们会在子线程中进行耗时的操作,完成之后将结果同步到主线程进行ui的刷新。\n\n而Handler机制就是谷歌用来方便我们进行线程同步的,我们可以很方便的通过它,在子线程中将ui刷新的操作同步回主线程中进行。\n\n# 使用Handler将ui刷新操作同步到主线程中进行\n\n我们先来看一个例子直观感受下如何使用Handler将ui刷新操作从子线程同步到主线程中进行:\n\n```\npublic class MainActivity extends AppCompatActivity {\n    private static final int MSG_UPDATE_PROGRESS_BAR_ABOVE = 1;\n    private static final int MSG_UPDATE_PROGRESS_BAR_BELOW = 2;\n    private ProgressBar mProgressBarAbove;\n    private ProgressBar mProgressBarBelow;\n\n    private Handler mHandler;\n\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mProgressBarAbove = (ProgressBar) findViewById(R.id.progressAbove);\n\n        mProgressBarBelow = (ProgressBar) findViewById(R.id.progressBelow);\n\n        mHandler = new Handler() {\n            @Override\n            public void handleMessage(Message msg) {\n                super.handleMessage(msg);\n\n                switch (msg.what) {\n                    case MSG_UPDATE_PROGRESS_BAR_ABOVE:\n                        mProgressBarAbove.setProgress(msg.arg1);\n                        break;\n                    case MSG_UPDATE_PROGRESS_BAR_BELOW:\n                        Bundle data = msg.getData();\n                        mProgressBarBelow.setProgress(data.getInt(\"progress\"));\n                        break;\n                }\n            }\n        };\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                int progressAbove = 0;\n                int progressBelow = 0;\n\n                while (progressAbove < 100 || progressBelow < 100) {\n                    if (progressAbove < 100) {\n                        progressAbove++;\n\n                        Message above = new Message();\n                        above.what = MSG_UPDATE_PROGRESS_BAR_ABOVE;\n                        above.arg1 = progressAbove;\n                        mHandler.sendMessage(above);\n                    }\n\n                    if (progressBelow < 100) {\n                        progressBelow += 2;\n\n                        Message below = mHandler.obtainMessage();\n                        below.what = MSG_UPDATE_PROGRESS_BAR_BELOW;\n                        Bundle data = new Bundle();\n                        data.putInt(\"progress\", progressBelow);\n                        below.setData(data);\n                        mHandler.sendMessage(below);\n                    }\n\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }).start();\n    }\n}\n```\n\n上面的例子很简单,界面有上下两条进度条,我们在子线程中使用Thread.sleep(100)模拟耗时操作,每隔100毫秒更新一下进度,上面的进度条进度每次加1,下面的进度条每次加2。\n\n{% img /Android温故而知新-Handler/1.png %}\n\n## 1.创建handler并重写handleMessage方法\n\n首先我们会创建一个Handler并重写它的handleMessage,这个方法就是在主线程中被调用的,我们通过传给这个方法的Message去刷新ui。\n\nMessage的what成员变量用来标识消息的类型,我们这里用来区分更新哪一个进度条。同时我们可以从Message中取得从子线程中传过来的进度,然后直接在handleMessage里面刷新进度条的进度。\n\n## 2.在子线程中发送Message给Handler\n\nMessage是在子线程中被创建的。如代码所示,我们可以直接将它new出来,也可以使用mHandler.obtainMessage()从mHandler的Message池中获取一个实例。\n\n<font color=#FF0000>一般推荐使用obtainMessage的方式</font>,因为Message池中的Message是可以被重复利用的,避免了创建对象申请内存的开销。\n\n在前面说过Message的what成员变量是用来标志消息的类型的,我们这里直接将MSG_UPDATE_PROGRESS_BAR_ABOVE或者MSG_UPDATE_PROGRESS_BAR_ABOVE赋值进去,在handleMessage的时候就能用它来区分到底更新哪个进度条了。\n\n消息的值也有多种赋值方式。\n\n第一种很简单,Message提供了arg1、arg2、obj、replyTo等public成员变量,可以直接将想保存的数据赋值給他们,在handleMessage方法中就能直接获取到他们了。\n\n第二种就是创建一个Bundle对象,在Bundle对象中存入数据,然后再通过setData方法传给Message,在handleMessage方法中通过getData可以获得Message中保存的Bundle对象,从而获得保存的数据。\n\n# 同步到主线程的各种姿势\n\n使用Handler将操作同步到主线程中进行有两种方式,一种是上面例子中的发送Message的方式。另一种是直接将一个Runnable传给Handler,Handler就会在主线程中执行它:\n\n- sendEmptyMessage(int what)\n- sendEmptyMessageDelayed(int what, long delayMillis)\n- sendEmptyMessageAtTime(int what, long uptimeMillis)\n- sendMessage(Message msg)\n- sendMessageDelayed(Message msg, long delayMillis)\n- sendMessageAtTime(Message msg, long uptimeMillis)\n- sendMessageAtFrontOfQueue(Message msg)\n- post(Runnable r)\n- postDelayed(Runnable r, long delayMillis)\n- postAtTime(Runnable r, long uptimeMillis)\n- postAtTime(Runnable r, Object token, long uptimeMillis)\n- postAtFrontOfQueue(Runnable r)\n\n上面就是可以使用的一些方法,send前缀的方法用于发送一个带数据的Message对象,post前缀的方法用于安排一个Runnable对象到主线程中执行。他们都有延迟发送,定时发送等姿势可以使用。\n\n当然你也可以在Message或者Runnable未同步到主线程的时候使用下面的remove方法将他们取消:\n\n- removeMessages(int what)\n- removeMessages(int what, Object object)\n- removeCallbacks(Runnable r)\n- removeCallbacks(Runnable r, Object token)\n- removeCallbacksAndMessages(Object token)\n\n实际上将Runnable post到Handler中的时候也是用Message去包装的:\n\n```\n\tpublic final boolean post(Runnable r)\n    {\n       return  sendMessageDelayed(getPostMessage(r), 0);\n    }\n\n    private static Message getPostMessage(Runnable r) {\n        Message m = Message.obtain();\n        m.callback = r;\n        return m;\n    }\n```\n\n在主线程分发消息的时候如果判断到Message有callback则会直接执行callback,否则就将消息传到handleMessage中进行处理:\n\n```\n\t/**\n     * Handle system messages here.\n     */\n    public void dispatchMessage(Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n```\n\n# Handler机制的基本原理\n\nHandler机制有四个重要的组件:\n\n- Handler\n- Message\n- MessageQueue\n- Looper\n\nHandler和Message通过前面的例子应该已经很清楚了,但是MessageQueue和Looper又是什么鬼？\n\nMessageQueue顾名思义,就是Message的队列,我们调用Handler的各种方法发送Message其实就是将Message放到MessageQueue中。\n\n而Looper就将Message从MessageQueue中拿出来。Looper有一个loop方法,它里面有个死循环,不断从MessageQueue中拿Message出来并且将它传给Handler去处理。\n\n我们在子线程中将Message放入MessageQueue,然后在主线程中运行Looper的loop方法,不断从MessageQueue中获取Message。这就是Message从子线程同步到主线程的原理。\n\n我画了一幅图来更加形象的展示这个机制:\n\n{% img /Android温故而知新-Handler/2.png %}\n\n# 主线程中的Looper\n\n有人会问了,我们也没有在主线程中中调用Looper的loop方法啊,而且再说了loop中不是一个死循环吗,如果在主线程中运行它的话不会被堵死吗？\n\n其实安卓在启动主线程的时候就会自动创建一个Looper和执行Looper.loop()的了,不需要自己去手动操作。\n\n至于第二个问题,我们可以直接看安卓的源码:\n\n一般来讲我们认为ActivityThread.main(String[] args)就是安卓程序运行的入口,也就是我们熟悉的main方法。它其实很短,我们在它的最后可以看到Looper.loop()这个方法的确是被调用了的。\n\n```\n\tpublic static void main(String[] args) {\n        SamplingProfilerIntegration.start();\n\n        // CloseGuard defaults to true and can be quite spammy.  We\n        // disable it here, but selectively enable it later (via\n        // StrictMode) on debug builds, but using DropBox, not logs.\n        CloseGuard.setEnabled(false);\n\n        Environment.initForCurrentUser();\n\n        // Set the reporter for event logging in libcore\n        EventLogger.setReporter(new EventLoggingReporter());\n\n        Security.addProvider(new AndroidKeyStoreProvider());\n\n        Process.setArgV0(\"<pre-initialized>\");\n\n        Looper.prepareMainLooper();\n\n        ActivityThread thread = new ActivityThread();\n        thread.attach(false);\n\n        if (sMainThreadHandler == null) {\n            sMainThreadHandler = thread.getHandler();\n        }\n\n        AsyncTask.init();\n\n        if (false) {\n            Looper.myLooper().setMessageLogging(new\n                    LogPrinter(Log.DEBUG, \"ActivityThread\"));\n        }\n\n        Looper.loop();\n\n        throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n    }\n```\n\n但是调用了loop方法之后,线程不就被堵住了吗？那主线程又是怎样接收到按键消息和调用各种生命周期方法的？我们可以看到代码里还有个sMainThreadHandler,这个sMainThreadHandler是个H类,它的定义如下:\n\n```\nprivate class H extends Handler {\n\tpublic void handleMessage(Message msg) {\n        if (DEBUG_MESSAGES) Slog.v(TAG, \">>> handling: \" + codeToString(msg.what));\n            switch (msg.what) {\n                case LAUNCH_ACTIVITY: {\n                    ...\n                } break;\n                case RELAUNCH_ACTIVITY: {\n                    ...\n                } break;\n                ...\n            }\n        }\n    }\n}\n```\n\n看Activity的各个生命周期，还有事件处理也是通过Handler机制实现的！\n\n# 使用Handler将消息同步到其他线程\n\n根据上面的原理,其实我们不仅可以使用Handler将消息同步到主线程中,也能用它来将消息从主线程同步到子线程中去执行。\n\n只需要在子线程中运行Looper的loop方法,让它不断获取Message,然后在主线程中发送Message就能在子线程中被处理了。\n\n代码如下\n\n```\n    private Handler mHandler;\n\n    private Thread mThread = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            Looper.prepare();\n\n            mHandler = new Handler() {\n                public void handleMessage(Message msg) {\n                    // process incoming messages here\n                }\n            };\n            Looper.loop();\n        }\n    });\n```\n\n我们在需要在子线程中先调用Looper.prepare()。这个是个静态方法它用来创建一个Looper并绑定到当前的线程中。\n\n然后创建Handler,Handler会自动绑定当前线程中的Looper。\n\n最后调用Looper.loop()就大功告成了。\n\n之后我们就能在主线程中使用mHandler将消息发送到子线程中处理了。\n\n# HandlerThread\n\n在上面一节中我们看到,在子线程中创建Handler还需要手动调用Looper.prepare()和Looper.loop()。为了简化操作,谷歌官方提供了HandlerThread给我们使用。\n\nHandlerThread是Thread的子类,当HandlerThread启动的时候会自动调用Looper.prepare()和Looper.loop(),它的run方法源码如下:\n\n```\n    public void run() {\n        mTid = Process.myTid();\n        Looper.prepare();\n        synchronized (this) {\n            mLooper = Looper.myLooper();\n            notifyAll();\n        }\n        Process.setThreadPriority(mPriority);\n        onLooperPrepared();\n        Looper.loop();\n        mTid = -1;\n    }\n```\n\n于是我们只需要在Handler构造的时候传入HandlerThread的Looper就行了:\n\n```\nHandlerThread handlerThread = new HandlerThread(\"HandlerThread\");\nhandlerThread.start();\n\nmHandler = new Handler(handlerThread.getLooper()) {\n\t@Override\n\tpublic void handleMessage(Message msg) {\n\t\tsuper.handleMessage(msg);\n\t}\n};\n```\n\n# IntentService\n\n我们知道Service的各个声明周期函数也是在主线程中执行的,它也不能直接执行耗时操作。需要将耗时操作放到子线程中进行。\n\n为了方便在Service中进行耗时操作,谷歌提供了Service的子类IntentService。它有和Service相同的生命周期,同时也提供了在子线程处理耗时操作的机制。\n\nIntentService是一个抽象类,使用的时候需要继承并实现它的onHandleIntent方法,这个方法是在子线程中执行的,可以直接在这里进行耗时操作。\n\n其实IntentService内部也是通过HandlerThread实现的,而且代码十分简单:\n\n```\npublic abstract class IntentService extends Service {\n    private volatile Looper mServiceLooper;\n    private volatile ServiceHandler mServiceHandler;\n    private String mName;\n    private boolean mRedelivery;\n\n    private final class ServiceHandler extends Handler {\n        public ServiceHandler(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            onHandleIntent((Intent)msg.obj);\n            stopSelf(msg.arg1);\n        }\n    }\n\n    public IntentService(String name) {\n        super();\n        mName = name;\n    }\n\n    public void setIntentRedelivery(boolean enabled) {\n        mRedelivery = enabled;\n    }\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        HandlerThread thread = new HandlerThread(\"IntentService[\" + mName + \"]\");\n        thread.start();\n\n        mServiceLooper = thread.getLooper();\n        mServiceHandler = new ServiceHandler(mServiceLooper);\n    }\n\n    @Override\n    public void onStart(@Nullable Intent intent, int startId) {\n        Message msg = mServiceHandler.obtainMessage();\n        msg.arg1 = startId;\n        msg.obj = intent;\n        mServiceHandler.sendMessage(msg);\n    }\n\n    @Override\n    public int onStartCommand(@Nullable Intent intent, int flags, int startId) {\n        onStart(intent, startId);\n        return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;\n    }\n\n    @Override\n    public void onDestroy() {\n        mServiceLooper.quit();\n    }\n\n    @Override\n    @Nullable\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n\n    @WorkerThread\n    protected abstract void onHandleIntent(@Nullable Intent intent);\n}\n\n```\n","slug":"Android温故而知新-Handler","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2uou004dw3fy9cebx5nk"},{"title":"Android温故而知新 - ClassLoader","date":"2017-09-27T18:22:09.000Z","_content":"\n安卓插件化越来越流行,其中用到的技术不外乎加载外部的资源和加载外部的代码,关于加载外部资源我之前写过一篇文章[《安卓皮肤包机制的原理》](http://blog.islinjw.cn/2017/08/01/%E5%AE%89%E5%8D%93%E7%9A%AE%E8%82%A4%E5%8C%85%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86/),感兴趣的同学可以去看一下。\n\n加载外部代码的作用在于热更新。程序主体定义接口,具体实现放在外部。只需要替换外部代码,就能修复bug甚至是更新功能。相比传统的ota手段更加省流量,用户体验也更加的好,毕竟有很多的用户是不喜欢更新的。\n\n这篇文章我想复习一下ClassLoader的相关知识,它是加载外部代码的核心原理。\n\n虽然android自己实现了一个特殊的虚拟机,它的类加载机制和普通的java程序有点区别。但是我还是想从普通的java程序讲起,一方面多知道点东西总是好的,另一方面它们的基本原理是一样的,对我们理解安卓的类加载机制也有很大的帮助。\n\n# 普通java程序的类加载机制\n\n我们都知道java代码需要先编译成class文件才能被jvm加载运行。那jvm又是如何加载class文件的呢?\n\n其实class文件是通过ClassLoader加载到jvm的。java自带了三个ClassLoader,分别是:\n\n- BootstrapClassLoader 用于加载核心类库\n- ExtClassLoader 用于加载拓展库\n- AppClassLoader 用于加载当前应用的类\n\n然后需要说明的是java类不是一次性全部加载的,而是只有在用到的时候才会去加载。\n\n因为全部加载的话会加载一些没有用到的类,造成资源的浪费。所以当程序需要用到某个类时,才会通过ClassLoader在系统的特定路径搜索这个类的class文件并将它加载到jvm去执行。\n\nExtClassLoader和AppClassLoader都是URLClassLoader的子类,他们内部保存了URL列表用于指定搜索路径。我们可以通过URLClassLoader.getURLs()方法获取到这个URL列表。\n\nBootstrapClassLoader虽然不是URLClassLoader的子类,但我们也可以从sun.misc.Launcher.getBootstrapClassPath().getURLs()方法获取到BootstrapClassLoader的搜索路径。\n\n下面的代码打印了各个ClassLoader的搜索路径:\n\n```\nimport java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class ClassLoaderURLs {\n    public static void main(String[] args) {\n        System.out.println(\"BootstrapClassLoader urls :\");\n        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();\n        for (URL url : urls) {\n            System.out.println(url);\n        }\n\n        URLClassLoader extClassLoader = (URLClassLoader) ClassLoader.getSystemClassLoader().getParent();\n        System.out.println(\"\\n\" + extClassLoader + \" urls :\");\n        urls = extClassLoader.getURLs();\n        for (URL url : urls) {\n            System.out.println(url);\n        }\n\n        URLClassLoader appClassLoader = (URLClassLoader) ClassLoader.getSystemClassLoader();\n        System.out.println(\"\\n\" + appClassLoader + \" urls :\");\n        urls = appClassLoader.getURLs();\n        for (URL url : urls) {\n            System.out.println(url);\n        }\n    }\n}\n```\n\n打印如下:\n\n```\nBootstrapClassLoader urls :\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/resources.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/rt.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/sunrsasign.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/jsse.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/jce.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/charsets.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/jfr.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/classes\n\nsun.misc.Launcher$ExtClassLoader@74a14482 urls :\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/cldrdata.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/dnsns.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/jfxrt.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/localedata.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/nashorn.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/sunec.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/zipfs.jar\nfile:/System/Library/Java/Extensions/AppleScriptEngine.jar\nfile:/System/Library/Java/Extensions/dns_sd.jar\nfile:/System/Library/Java/Extensions/j3daudio.jar\nfile:/System/Library/Java/Extensions/j3dcore.jar\nfile:/System/Library/Java/Extensions/j3dutils.jar\nfile:/System/Library/Java/Extensions/jai_codec.jar\nfile:/System/Library/Java/Extensions/jai_core.jar\nfile:/System/Library/Java/Extensions/libAppleScriptEngine.jnilib\nfile:/System/Library/Java/Extensions/libJ3D.jnilib\nfile:/System/Library/Java/Extensions/libJ3DAudio.jnilib\nfile:/System/Library/Java/Extensions/libJ3DUtils.jnilib\nfile:/System/Library/Java/Extensions/libmlib_jai.jnilib\nfile:/System/Library/Java/Extensions/mlibwrapper_jai.jar\nfile:/System/Library/Java/Extensions/MRJToolkit.jar\nfile:/System/Library/Java/Extensions/vecmath.jar\nfile:/usr/lib/java/libjdns_sd.jnilib\n\nsun.misc.Launcher$AppClassLoader@28d93b30 urls :\nfile:/Users/linjw/workspace/class_loader_demo/\n```\n\n我们可以看到这些url有指向jar包的,也有指向一个目录的(还有指向.jnilib文件的,这个我们可以不用管)。\n\nClassLoader从指定的路径下搜索class文件。而jar包其实是一个压缩包,将class文件打包在一起,所以ClassLoader也可以从jar包中搜索需要用到的class。\n\n## Java类的加载流程\n\n### ClassLoader的创建\n\n我们先从ClassLoader的创建开始说起。我们可以直接看[sun.misc.Launcher](http://www.grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/sun/misc/Launcher.java)的源码,它在构造函数中创建了ExtClassLoader和AppClassLoader:\n\n```\npublic Launcher() {\n    // Create the extension class loader\n    ClassLoader extcl;\n    try {\n        extcl = ExtClassLoader.getExtClassLoader();\n    } catch (IOException e) {\n        throw new InternalError(\n            \"Could not create extension class loader\", e);\n    }\n\n    // Now create the class loader to use to launch the application\n    try {\n        loader = AppClassLoader.getAppClassLoader(extcl);\n    } catch (IOException e) {\n        throw new InternalError(\n            \"Could not create application class loader\", e);\n    }\n\n    // Also set the context class loader for the primordial thread.\n    Thread.currentThread().setContextClassLoader(loader);\n\n\t...\n}\n```\n\nExtClassLoader.getExtClassLoader()是一个工厂方法:\n\n```\npublic static ExtClassLoader getExtClassLoader() throws IOException\n{\n    final File[] dirs = getExtDirs();\n\n    try {\n        // Prior implementations of this doPrivileged() block supplied\n        // aa synthesized ACC via a call to the private method\n        // ExtClassLoader.getContext().\n\n        return AccessController.doPrivileged(\n            new PrivilegedExceptionAction<ExtClassLoader>() {\n                public ExtClassLoader run() throws IOException {\n                    int len = dirs.length;\n                    for (int i = 0; i < len; i++) {\n                        MetaIndex.registerDirectory(dirs[i]);\n                    }\n                    return new ExtClassLoader(dirs);\n                }\n            });\n    } catch (java.security.PrivilegedActionException e) {\n        throw (IOException) e.getException();\n    }\n}\n```\n\nAppClassLoader.getAppClassLoader(final ClassLoader extcl)也是一个工厂方法,它需要传入一个ClassLoader作为AppClassLoader的父ClassLoader。而我们将ExtClassLoader传了进去,也就是说ExtClassLoader是AppClassLoader的父ClassLoader:\n\n```\npublic static ClassLoader getAppClassLoader(final ClassLoader extcl)\n    throws IOException\n{\n    final String s = System.getProperty(\"java.class.path\");\n    final File[] path = (s == null) ? new File[0] : getClassPath(s);\n\n    // Note: on bugid 4256530\n    // Prior implementations of this doPrivileged() block supplied\n    // a rather restrictive ACC via a call to the private method\n    // AppClassLoader.getContext(). This proved overly restrictive\n    // when loading  classes. Specifically it prevent\n    // accessClassInPackage.sun.* grants from being honored.\n    //\n    return AccessController.doPrivileged(\n        new PrivilegedAction<AppClassLoader>() {\n            public AppClassLoader run() {\n            URL[] urls =\n                (s == null) ? new URL[0] : pathToURLs(path);\n            return new AppClassLoader(urls, extcl);\n        }\n    });\n}\n```\n\n每一个ClassLoader都有一个父ClassLoader,我们可以通过ClassLoader.getParent()方法获取。同时我们也能使用Class.getClassLoader()获取加载这个类的ClassLoader。所以让我们来看看下面的代码:\n\n```\npublic class GetClassLoader {\n    public static void main(String[] args) {\n        ClassLoader loader = GetClassLoader.class.getClassLoader();\n        do {\n            System.out.println(loader);\n        } while ((loader = loader.getParent()) != null);\n    }\n}\n```\n\n查看打印我们可以知道, GetClassLoader是AppClassLoader加载的,而AppClassLoader的父ClassLoader是ExtClassLoader:\n\n```\nsun.misc.Launcher$AppClassLoader@28d93b30\nsun.misc.Launcher$ExtClassLoader@74a14482\n```\n\n但是如果我们查看String的ClassLoader又会发现它是null的:\n\n```\npublic class GetClassLoader {\n    public static void main(String[] args) {\n        ClassLoader loader = String.class.getClassLoader();\n        System.out.println(\"loader : \" + loader);\n    }\n}\n```\n\n```\nloader : null\n```\n\n那是不是说String不是由ClassLoader加载的?当然不是!其实String是BootstrapClassLoader加载的。BootstrapClassLoader负责加载java的核心类。\n\n但是为什么String.class.getClassLoader()拿到的是null呢？\n\n原因是BootstrapClassLoader实际上不是一个java类,它是由C/C++编写的,它本身是虚拟机的一部分。所以在java中当然没有办法获取到它的引用。\n\n### 双亲委托\n\n相信大家如果知道ClassLoader的话应该有听说过双亲委托,那下面我们就来讲一下双亲委托究竟是怎么一回事。\n\n我们知道ClassLoader.loadClass()的方法可以加载一个类,所以研究一个类的加载流程,最好的方法当然还是去看源码啦:\n\n```\nprotected Class<?> loadClass(String name, boolean resolve)\n    throws ClassNotFoundException\n{\n    synchronized (getClassLoadingLock(name)) {\n        // 首先,从缓存中查询该类是不是被加载过,如果加载过就可以直接返回\n        Class<?> c = findLoadedClass(name);\n        if (c == null) {\n            long t0 = System.nanoTime();\n            try {\n                if (parent != null) {\n            \t\t//判断它的父ClassLoader是否为空,如果不为空就调用父ClassLoader的loadClass方法去加载该类\n                    c = parent.loadClass(name, false);\n                } else {\n                \t//如果它的父ClassLoader为空,则调用BootstrapClassLoader去加载该类,所以此时从逻辑上来讲BootstrapClassLoader是父ClassLoader\n                    c = findBootstrapClassOrNull(name);\n                }\n            } catch (ClassNotFoundException e) {\n                \n            }\n\n            if (c == null) {\n                long t1 = System.nanoTime();\n                \n                //如果父ClassLoader不能加载该类才由自己去加载,这个方法从本ClassLoader的搜索路径中查找该类\n                c = findClass(name);\n                \n                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                sun.misc.PerfCounter.getFindClasses().increment();\n            }\n        }\n        if (resolve) {\n            resolveClass(c);\n        }\n        return c;\n    }\n}\n```\n\n从代码中我们可以看到,加载一个类的时候,ClassLoader先会让父类去加载,如果父类加载失败,才会由它自己去加载,这就是我们说的双亲委托。\n\n为什么类加载需要设计成双亲委托的方式呢？原因就在于双亲委托可以防止类被重复加载。如果父ClassLoader已经加载过一个类了,子ClassLoader就不会再次加载,可以防止同一个类被两个ClassLoader重复加载的问题。\n\n这里还需要说的是,当我们自定义一个ClassLoader的时候,最好将AppClassLoader设为父ClassLoader。这样的话可以保证我们自定义的ClassLoader找加载类失败的时候还能从父ClassLoader中加载这个类。\n\n双亲委托模式的流程如下图所示:\n\n\n{% img /Android温故而知新-ClassLoader/1.png %}\n\n\n## 自定义ClassLoader\n\n有时候我们可以继承ClassLoader实现自己的类加载器。自定义ClassLoader有两种方式:\n\n1. 重写loadClass方法 \n2. 重写findClass方法\n\n他们有什么区别呢,还记得上一级ClassLoader.loadClass()的源码吗？loadClass方法内会先调用父ClassLoader的loadClass方法,如果父ClassLoader没有加载过该类才会调用本ClassLoader的findClass方法去加载类。\n\n所以如果想要打破双亲委托机制的话就可以loadClass(),而如果还想继续沿用双亲委托机制的话就只需要重写findClass就好了。\n\n我们写个小例子:\n\n```\npublic class MyClassLoader extends ClassLoader {\n    public String mClassDir;\n\n    public MyClassLoader(String classDir) {\n        this.mClassDir = classDir;\n    }\n\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        File file = new File(mClassDir, getClassFileName(name));\n        if (file.exists()) {\n            try {\n                FileInputStream is = new FileInputStream(file);\n\n                ByteArrayOutputStream buf = new ByteArrayOutputStream();\n                int len;\n                while ((len = is.read()) != -1) {\n                    buf.write(len);\n                }\n\n                byte[] data = buf.toByteArray();\n                is.close();\n                buf.close();\n\n                return defineClass(name, data, 0, data.length);\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        return super.findClass(name);\n    }\n\n    private String getClassFileName(String fullName) {\n        int index = fullName.lastIndexOf(\".\");\n        if (index == -1) {\n            return fullName + \".class\";\n        } else {\n            return fullName.substring(index + 1) + \".class\";\n        }\n    }\n}\n```\n\n因为我们不需要打破双亲委托机制所以只需要重写findClass方法就可以了。我们自定义的ClassLoader会从指定的路径中搜索class文件,将它读入内存,然后通过调用ClassLoader.defineClass()方法去加载这个类。\n\n我们在/Users/linjw/workspace/class\\_loader\\_demo目录下创建了一个Test.java:\n\n```\npackage linjw.demo.classloader;\npublic class Test {\n    public String getData() {\n        return \"Hello World\";\n    }\n}\n```\n\n然后通过javac命令编译出Test.class文件,同样放在/Users/linjw/workspace/class\\_loader\\_demo目录下。\n\n然后用我们的MyClassLoader去加载它:\n\n```\nMyClassLoader loader = new MyClassLoader(\"/Users/linjw/workspace/class_loader_demo\");\nClass clazz = loader.loadClass(\"linjw.demo.classloader.Test\");\nif (clazz != null) {\n    Object obj = clazz.newInstance();\n    Method method = clazz.getDeclaredMethod(\"getData\");\n    String result = (String) method.invoke(obj);\n    System.out.println(result);\n    System.out.println(\"ClassLoader : \" + clazz.getClassLoader());\n} else {\n    System.out.println(\"can't load class\");\n}\n```\n\n可以看到下面的打印,说明我们已经成功用MyClassLoader加载了Test这个类:\n\n```\nHello World\nClassLoader : linjw.demo.classloader.MyClassLoader@66cd51c3\n```\n\n这里还有一个小的知识点,如果一个类是由某个ClassLoader加载的,那么它import的类也会由这个ClassLoader去加载。这里我们可以做一个实验:\n\n```\npackage linjw.demo.classloader;\n\nimport linjw.demo.classloader.Test;\n\npublic class Test2 {\n    public String getData(){\n        return \"Test ClassLoader : \" + Test.class.getClassLoader();\n    }\n}\n```\n\n我们写一个Test2类,它会import Test并返回Test的ClassLoader。让我们写个demo看看这个Test的ClassLoader:\n\n```\nMyClassLoader loader = new MyClassLoader(\"/Users/linjw/workspace/class_loader_demo\");\nClass clazz = loader.loadClass(\"linjw.demo.classloader.Test2\");\nif (clazz != null) {\n    Object obj = clazz.newInstance();\n    Method method = clazz.getDeclaredMethod(\"getData\");\n    String result = (String) method.invoke(obj);\n    System.out.println(result);\n} else {\n    System.out.println(\"can't load class\");\n}\n```\n\n通过打印可以知道Test也是由MyClassLoader加载的:\n\n```\nlinjw.demo.classloader.MyClassLoader@66cd51c3\n```\n\n## Context ClassLoader\n\nContext ClassLoader并不是一个实际的类,它只是Thread的一个成员变量:\n\n```\npublic class Thread implements Runnable {\n\tprivate ClassLoader contextClassLoader;\n\n\tprivate void init2(Thread parent) {\n        this.contextClassLoader = parent.getContextClassLoader();\n        ...\n    }\n\n    public ClassLoader getContextClassLoader() {\n        return contextClassLoader;\n    }\n\n    public void setContextClassLoader(ClassLoader cl) {\n        contextClassLoader = cl;\n    }\n    \n    ...\n}\n```\n\n每个Thread都有一个相关联的ClassLoader,子线程默认使用父线程的ClassLoader。\n\n而线程的默认ClassLoader是AppClassLoader:\n\n```\npublic Launcher() {\n    ...\n    \n    try {\n        loader = AppClassLoader.getAppClassLoader(extcl);\n    } catch (IOException e) {\n        throw new InternalError(\n            \"Could not create application class loader\", e);\n    }\n    \n    //设置AppClassLoader为当前线程的Context ClassLoader\n    Thread.currentThread().setContextClassLoader(loader);\n\n\t...\n}\n```\n\nContext ClassLoader的存在是为了解决使用双亲委托机制下父ClassLoader无法找到子ClassLoader的问题。假如有下面的委托链:\n\nClassLoaderA -> AppClassLoader -> ExtClassLoader -> BootstrapClassLoader\n\n那么委派链左边的ClassLoader就可以很自然的使用右边的ClassLoader所加载的类。 \n\n但如果是右边的ClassLoader想要反过来使用左边的ClassLoader所加载的类就无能为力了。\n\n这个时候如果使用Context ClassLoader就能从线程中获得左边的ClassLoader了。\n\n那什么时候会出现右边的ClassLoader想要反过来使用左边的ClassLoader所加载的类的情况呢？\n\n我们上一节刚刚说过:“如果一个类是由某个ClassLoader加载的,那么它import的类也会由这个ClassLoader去加载”。\n\n举个例子,Java 提供了很多服务提供者接口（Service Provider Interface，SPI）,允许第三方为这些接口提供实现。如JAXP(XML处理的Java API)的SPI__接口__定义包含在 javax.xml.parsers包中，它是由BootstrapClassLoader加载的。\n\n但是它的实现代码很可能是作为Java应用所依赖的jar包被包含进来,如实现了JAXP SPI的Apache Xerces所包含的jar包,它由AppClassLoader加载。\n\n我们用javax.xml.parsers.DocumentBuilderFactory类中的newInstance()方法用来生成一个新的DocumentBuilderFactory的实例, DocumentBuilderFactory是一个抽象类,它定是java核心库的一部分,由BootstrapClassLoader去加载。因此,DocumentBuilderFactory里面import的类都由BootstrapClassLoader去加载。\n\n但是DocumentBuilderFactory的实现类却是在org.apache.xerces.jaxp.DocumentBuilderFactoryImpl中定义的, BootstrapClassLoader无法加载它。这个时候就需要在DocumentBuilderFactory. newInstance()的代码中使用Context ClassLoader，找到AppClassLoader去加载DocumentBuilderFactoryImpl这个实现类。\n\n\n# 安卓中的ClassLoader\n\n安卓的的类也是通过ClassLoader加载的,但是并不是java中的BootstrapClassLoader、 ExtClassLoader或者AppClassLoader。写个小demo看看安卓中加载类的是哪些ClassLoader:\n\n```\nLog.d(\"DxClassLoader\", \"BootClassLoader :\" + String.class.getClassLoader());\n\nClassLoader loader = MainActivity.class.getClassLoader();\ndo {\n\tLog.d(\"DxClassLoader\", \"loader :\" + loader);\n} while ((loader = loader.getParent()) != null);\n```\n\n打印如下:\n\n```\n09-27 23:11:03.432 21151-21151/? D/DxClassLoader: BootClassLoader :java.lang.BootClassLoader@ad96016\n09-27 23:11:03.432 21151-21151/? D/DxClassLoader: loader :dalvik.system.PathClassLoader[DexPathList[[zip file \"/data/app/linjw.demo.classloader-2/base.apk\"],nativeLibraryDirectories=[/data/app/linjw.demo.classloader-2/lib/arm64, /vendor/lib64, /system/lib64]]]\n09-27 23:11:03.433 21151-21151/? D/DxClassLoader: loader :java.lang.BootClassLoader@ad96016\n```\n\n我们可以看到安卓中用的了PathClassLoader和BootClassLoader两个ClassLoader,其中BootClassLoader是PathClassLoader的parent。\n\n而和在java程序不同的是String是由BootClassLoader加载的。安卓的BootClassLoader其实就相当于java的BootstrapClassLoader,只不过它是由java实现的而不是由c/c++实现的。\n\n## PathClassLoader\n\n我们在上一节中将PathClassLoader打印出来的时候可以看到一个apk路径:\n\n```\n[zip file \"/data/app/linjw.demo.classloader-2/base.apk\"]\n```\n\napk其实是一个也是一个zip压缩包,我们可以将一个apk文件后缀改成.zip然后就可以直接解压了。PathClassLoader的作用其实就是在这个zip包中加载dex文件,我们通过它甚至可以加载其他应用的代码,但它只能加载已安装的应用。\n\n例如我们可以新建一个ext工程,它的包名为linjw.demo.classloader.ext,然后在里面创建Test类:\n\n```\npackage linjw.demo.classloader.ext;\n\npublic class Test {\n    public String getData() {\n        return \"Hello World\";\n    }\n}\n```\n\n然后编译出apk来,并且安装。之后就能从这个apk中加载出Test类了:\n\n```\nString path = null;\nPackageManager pm = getPackageManager();\ntry {\n    path = pm.getApplicationInfo(\"linjw.demo.classloader.ext\", 0).sourceDir;\n} catch (PackageManager.NameNotFoundException e) {\n    e.printStackTrace();\n}\n\nPathClassLoader loader = new PathClassLoader(path, ClassLoader.getSystemClassLoader());\n\ntry {\n    Class clazz = loader.loadClass(\"linjw.demo.classloader.ext.Test\");\n\n    if (clazz != null) {\n        Object obj = clazz.newInstance();\n        Method method = clazz.getDeclaredMethod(\"getData\");\n        String result = (String) method.invoke(obj);\n        Log.d(\"DxClassLoader\", result);\n    } else {\n        Log.d(\"DxClassLoader\", \"can't load class\");\n    }\n} catch (ClassNotFoundException e) {\n    e.printStackTrace();\n} catch (NoSuchMethodException e) {\n    e.printStackTrace();\n} catch (InstantiationException e) {\n    e.printStackTrace();\n} catch (IllegalAccessException e) {\n    e.printStackTrace();\n} catch (InvocationTargetException e) {\n    e.printStackTrace();\n}\n```\n\n可以得到打印:\n\n```\n09-27 23:39:16.571 24077-24077/? D/DxClassLoader: Hello World\n```\n\n## DexClassLoader\n\nPathClassLoader只能加载已经安装的应用里面的类,但是DexClassLoader却能加载未安装的应用里面的类。例如我们将apk放到存储卡目录下而不去安装它:\n\n```\nString dir = Environment.getExternalStorageDirectory().getAbsolutePath();\nFile apk = new File(dir, \"Ext.apk\");\nFile dexOutputDir = this.getDir(\"dex\", 0);\nDexClassLoader loader = new DexClassLoader(\n        apk.getAbsolutePath(),\n        dexOutputDir.getAbsolutePath(),\n        null, getClassLoader());\n\ntry {\n    Class clazz = loader.loadClass(\"linjw.demo.classloader.ext.Test\");\n\n    if (clazz != null) {\n        Object obj = clazz.newInstance();\n        Method method = clazz.getDeclaredMethod(\"getData\");\n        String result = (String) method.invoke(obj);\n        Log.d(\"DxClassLoader\", result);\n    } else {\n        Log.d(\"DxClassLoader\", \"can't load class\");\n    }\n} catch (ClassNotFoundException e) {\n    e.printStackTrace();\n} catch (NoSuchMethodException e) {\n    e.printStackTrace();\n} catch (InstantiationException e) {\n    e.printStackTrace();\n} catch (IllegalAccessException e) {\n    e.printStackTrace();\n} catch (InvocationTargetException e) {\n    e.printStackTrace();\n}\n```\n\n同样可以得到打印:\n\n```\n09-27 23:54:29.206 25472-25472/? D/DxClassLoader: Hello World\n```\n\n我们可以看到, DexClassLoader的构造函数的参数比PathClassLoader的要多出一个optimizedDirectory:\n\n```\npublic class DexClassLoader extends BaseDexClassLoader {\n    public DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) {\n        super((String)null, (File)null, (String)null, (ClassLoader)null);\n        throw new RuntimeException(\"Stub!\");\n    }\n}\n```\n\n```\npublic class PathClassLoader extends BaseDexClassLoader {\n    public PathClassLoader(String dexPath, ClassLoader parent) {\n        super((String)null, (File)null, (String)null, (ClassLoader)null);\n        throw new RuntimeException(\"Stub!\");\n    }\n\n    public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) {\n        super((String)null, (File)null, (String)null, (ClassLoader)null);\n        throw new RuntimeException(\"Stub!\");\n    }\n}\n```\n\n那这个optimizedDirectory到底有什么作用呢?其实optimizedDirectory是用来存放从apk中解压出来的dex文件的。\n\nDexClassLoader和PathClassLoader其实归根结底都是通过DexFile这个类去加载的dex文件,并不是直接读取的apk。因为如果每次都需要解压才能加载代码的话效率实在太低了。\n\nDexClassLoader可以主动解压apk,所以可以加载未安装的应用中的代码。但PathClassLoader不会主动解压apk,它是读取的已经安装的apk在cache中存在缓存的dex文件,所以它只能加载已安装应用中的代码。\n\n## 生成dex文件\n\nDexClassLoader和PathClassLoader最后都是加载的dex文件。所以我们可以直接将dex文件的路径传给他们去加载。但dex文件又是个什么东西呢？\n\n普通的java程序中,JVM虚拟机可以通过ClassLoader去加载jar到的加载类的目的。但是android使用的Dalvik/ART虚拟机不能直接加载jar包,需要把.jar文件优化成.dex文件才能加载。所以实际上dex文件是优化过的jar包。\n\n我们可以用Android SDK提供的DX工具把.jar文件优化成.dex文件。我们用之前的Test.java做例子,具体步骤如下:\n\n1.使用javac命令编译Test.java得到Test.class文件(我这边的java环境是1.8的,如果不指定用1.7的话生成dex也会失败,报__com.android.dx.cf.iface.ParseException: bad class file magic (cafebabe) or version (0034.0000)__)\n\n```\njavac -source 1.7 -target 1.7 Test.java\n```\n\n2.将创建目录子目录linjw/demo/classloader/ext并将Test.class移动到子目录中(因为Test的package是linjw.demo.classloader.ext,所以要根据它生成同样的目录,要不然生成dex会失败)\n\n```\nmkdir -p linjw/demo/classloader/ext\nmv Test.class linjw/demo/classloader/ext\n```\n\n3.使用jar命令将linjw目录打包成jar包\n\n```\njar -cf Test.jar linjw\n```\n\n4.用dx工具将jar包优化成dex包\n\n```\n/Users/linjw/androidsdk/android-sdk-macosx/build-tools/19.1.0/dx --dex --output=Test.dex Test.jar\n```\n\n## 动态加载dex文件\n\n然后我们就能将它放到存储卡中用DexClassLoader或者PathClassLoader去加载了。\n\n### 使用反射的反射加载\n\n```\n\nString dir = Environment.getExternalStorageDirectory().getAbsolutePath();\nFile dex = new File(dir, \"Test.dex\");\nFile dexOutputDir = this.getDir(\"dex\", 0);\n\n//使用PathClassLoader加载dex\n//PathClassLoader loader = new PathClassLoader(dex.getAbsolutePath(), getClassLoader());\n\n//使用DexClassLoader加载dex\nDexClassLoader loader = new DexClassLoader(\n        dex.getAbsolutePath(),\n        dexOutputDir.getAbsolutePath(),\n        null,\n        getClassLoader());\n\ntry {\n    Class clazz = loader.loadClass(\"linjw.demo.classloader.ext.Test\");\n\n    if (clazz != null) {\n        Object obj = clazz.newInstance();\n        Method method = clazz.getDeclaredMethod(\"getData\");\n        String result = (String) method.invoke(obj);\n        Log.d(\"DxClassLoader\", result);\n    } else {\n        Log.d(\"DxClassLoader\", \"can't load class\");\n    }\n} catch (ClassNotFoundException e) {\n    e.printStackTrace();\n} catch (NoSuchMethodException e) {\n    e.printStackTrace();\n} catch (InstantiationException e) {\n    e.printStackTrace();\n} catch (IllegalAccessException e) {\n    e.printStackTrace();\n} catch (InvocationTargetException e) {\n    e.printStackTrace();\n}\n```\n\n\n### 使用接口的方式加载\n\n或者我们也可以使用接口的方式:\n\n1.添加ITest接口:\n\n```\npackage linjw.demo.classloader.ext;\n\npublic interface ITest {\n    String getData();\n}\n```\n\n2.Test类实现ITest接口:\n\n```\npackage linjw.demo.classloader.ext;\n\npublic class Test implements ITest {\n    @Override\n    public String getData() {\n        return \"Hello World\";\n    }\n}\n```\n\n3.将它们一起打包到Test.dex\n\n```\njavac -source 1.7 -target 1.7 Test.java ITest.java\n\nmkdir -p linjw/demo/classloader/ext\n\nmv Test.class linjw/demo/classloader/ext\n\nmv Test.class linjw/demo/classloader\n\njar -cf Test.jar linjw\n\n/Users/linjw/androidsdk/android-sdk-macosx/build-tools/19.1.0/dx --dex --output=Test.dex Test.jar\n```\n\n4.在安卓项目中导入ITest接口并调整代码:\n\n```\nString dir = Environment.getExternalStorageDirectory().getAbsolutePath();\nFile dex = new File(dir, \"Test.dex\");\nFile dexOutputDir = this.getDir(\"dex\", 0);\n\n//使用PathClassLoader加载dex\n//PathClassLoader loader = new PathClassLoader(dex.getAbsolutePath(), getClassLoader());\n\n//使用DexClassLoader加载dex\nDexClassLoader loader = new DexClassLoader(\n    dex.getAbsolutePath(),\n    dexOutputDir.getAbsolutePath(),\n    null,\n    getClassLoader());\n\ntry {\nClass clazz = loader.loadClass(\"linjw.demo.classloader.ext.Test\");\n\nif (clazz != null) {\n    //注意这里,使用的是ITest\n    ITest obj = (ITest) clazz.newInstance();\n    String result = obj.getData();\n    Log.d(\"DxClassLoader\", result);\n} else {\n    Log.d(\"DxClassLoader\", \"can't load class\");\n}\n} catch (ClassNotFoundException e) {\ne.printStackTrace();\n} catch (InstantiationException e) {\ne.printStackTrace();\n} catch (IllegalAccessException e) {\ne.printStackTrace();\n}\n```\n\n其实我比较推荐使用在程序主体中定义接口,加载外部实现代码的这种方法。一方面它比反射的效率高,另一方面也比较容易阅读。\n","source":"_posts/Android温故而知新-ClassLoader.md","raw":"title: Android温故而知新 - ClassLoader\ndate: 2017-09-28 02:22:09\ntags:\n    - 技术相关\n    - Android\n---\n\n安卓插件化越来越流行,其中用到的技术不外乎加载外部的资源和加载外部的代码,关于加载外部资源我之前写过一篇文章[《安卓皮肤包机制的原理》](http://blog.islinjw.cn/2017/08/01/%E5%AE%89%E5%8D%93%E7%9A%AE%E8%82%A4%E5%8C%85%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86/),感兴趣的同学可以去看一下。\n\n加载外部代码的作用在于热更新。程序主体定义接口,具体实现放在外部。只需要替换外部代码,就能修复bug甚至是更新功能。相比传统的ota手段更加省流量,用户体验也更加的好,毕竟有很多的用户是不喜欢更新的。\n\n这篇文章我想复习一下ClassLoader的相关知识,它是加载外部代码的核心原理。\n\n虽然android自己实现了一个特殊的虚拟机,它的类加载机制和普通的java程序有点区别。但是我还是想从普通的java程序讲起,一方面多知道点东西总是好的,另一方面它们的基本原理是一样的,对我们理解安卓的类加载机制也有很大的帮助。\n\n# 普通java程序的类加载机制\n\n我们都知道java代码需要先编译成class文件才能被jvm加载运行。那jvm又是如何加载class文件的呢?\n\n其实class文件是通过ClassLoader加载到jvm的。java自带了三个ClassLoader,分别是:\n\n- BootstrapClassLoader 用于加载核心类库\n- ExtClassLoader 用于加载拓展库\n- AppClassLoader 用于加载当前应用的类\n\n然后需要说明的是java类不是一次性全部加载的,而是只有在用到的时候才会去加载。\n\n因为全部加载的话会加载一些没有用到的类,造成资源的浪费。所以当程序需要用到某个类时,才会通过ClassLoader在系统的特定路径搜索这个类的class文件并将它加载到jvm去执行。\n\nExtClassLoader和AppClassLoader都是URLClassLoader的子类,他们内部保存了URL列表用于指定搜索路径。我们可以通过URLClassLoader.getURLs()方法获取到这个URL列表。\n\nBootstrapClassLoader虽然不是URLClassLoader的子类,但我们也可以从sun.misc.Launcher.getBootstrapClassPath().getURLs()方法获取到BootstrapClassLoader的搜索路径。\n\n下面的代码打印了各个ClassLoader的搜索路径:\n\n```\nimport java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class ClassLoaderURLs {\n    public static void main(String[] args) {\n        System.out.println(\"BootstrapClassLoader urls :\");\n        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();\n        for (URL url : urls) {\n            System.out.println(url);\n        }\n\n        URLClassLoader extClassLoader = (URLClassLoader) ClassLoader.getSystemClassLoader().getParent();\n        System.out.println(\"\\n\" + extClassLoader + \" urls :\");\n        urls = extClassLoader.getURLs();\n        for (URL url : urls) {\n            System.out.println(url);\n        }\n\n        URLClassLoader appClassLoader = (URLClassLoader) ClassLoader.getSystemClassLoader();\n        System.out.println(\"\\n\" + appClassLoader + \" urls :\");\n        urls = appClassLoader.getURLs();\n        for (URL url : urls) {\n            System.out.println(url);\n        }\n    }\n}\n```\n\n打印如下:\n\n```\nBootstrapClassLoader urls :\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/resources.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/rt.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/sunrsasign.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/jsse.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/jce.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/charsets.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/jfr.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/classes\n\nsun.misc.Launcher$ExtClassLoader@74a14482 urls :\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/cldrdata.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/dnsns.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/jfxrt.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/localedata.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/nashorn.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/sunec.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/zipfs.jar\nfile:/System/Library/Java/Extensions/AppleScriptEngine.jar\nfile:/System/Library/Java/Extensions/dns_sd.jar\nfile:/System/Library/Java/Extensions/j3daudio.jar\nfile:/System/Library/Java/Extensions/j3dcore.jar\nfile:/System/Library/Java/Extensions/j3dutils.jar\nfile:/System/Library/Java/Extensions/jai_codec.jar\nfile:/System/Library/Java/Extensions/jai_core.jar\nfile:/System/Library/Java/Extensions/libAppleScriptEngine.jnilib\nfile:/System/Library/Java/Extensions/libJ3D.jnilib\nfile:/System/Library/Java/Extensions/libJ3DAudio.jnilib\nfile:/System/Library/Java/Extensions/libJ3DUtils.jnilib\nfile:/System/Library/Java/Extensions/libmlib_jai.jnilib\nfile:/System/Library/Java/Extensions/mlibwrapper_jai.jar\nfile:/System/Library/Java/Extensions/MRJToolkit.jar\nfile:/System/Library/Java/Extensions/vecmath.jar\nfile:/usr/lib/java/libjdns_sd.jnilib\n\nsun.misc.Launcher$AppClassLoader@28d93b30 urls :\nfile:/Users/linjw/workspace/class_loader_demo/\n```\n\n我们可以看到这些url有指向jar包的,也有指向一个目录的(还有指向.jnilib文件的,这个我们可以不用管)。\n\nClassLoader从指定的路径下搜索class文件。而jar包其实是一个压缩包,将class文件打包在一起,所以ClassLoader也可以从jar包中搜索需要用到的class。\n\n## Java类的加载流程\n\n### ClassLoader的创建\n\n我们先从ClassLoader的创建开始说起。我们可以直接看[sun.misc.Launcher](http://www.grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/sun/misc/Launcher.java)的源码,它在构造函数中创建了ExtClassLoader和AppClassLoader:\n\n```\npublic Launcher() {\n    // Create the extension class loader\n    ClassLoader extcl;\n    try {\n        extcl = ExtClassLoader.getExtClassLoader();\n    } catch (IOException e) {\n        throw new InternalError(\n            \"Could not create extension class loader\", e);\n    }\n\n    // Now create the class loader to use to launch the application\n    try {\n        loader = AppClassLoader.getAppClassLoader(extcl);\n    } catch (IOException e) {\n        throw new InternalError(\n            \"Could not create application class loader\", e);\n    }\n\n    // Also set the context class loader for the primordial thread.\n    Thread.currentThread().setContextClassLoader(loader);\n\n\t...\n}\n```\n\nExtClassLoader.getExtClassLoader()是一个工厂方法:\n\n```\npublic static ExtClassLoader getExtClassLoader() throws IOException\n{\n    final File[] dirs = getExtDirs();\n\n    try {\n        // Prior implementations of this doPrivileged() block supplied\n        // aa synthesized ACC via a call to the private method\n        // ExtClassLoader.getContext().\n\n        return AccessController.doPrivileged(\n            new PrivilegedExceptionAction<ExtClassLoader>() {\n                public ExtClassLoader run() throws IOException {\n                    int len = dirs.length;\n                    for (int i = 0; i < len; i++) {\n                        MetaIndex.registerDirectory(dirs[i]);\n                    }\n                    return new ExtClassLoader(dirs);\n                }\n            });\n    } catch (java.security.PrivilegedActionException e) {\n        throw (IOException) e.getException();\n    }\n}\n```\n\nAppClassLoader.getAppClassLoader(final ClassLoader extcl)也是一个工厂方法,它需要传入一个ClassLoader作为AppClassLoader的父ClassLoader。而我们将ExtClassLoader传了进去,也就是说ExtClassLoader是AppClassLoader的父ClassLoader:\n\n```\npublic static ClassLoader getAppClassLoader(final ClassLoader extcl)\n    throws IOException\n{\n    final String s = System.getProperty(\"java.class.path\");\n    final File[] path = (s == null) ? new File[0] : getClassPath(s);\n\n    // Note: on bugid 4256530\n    // Prior implementations of this doPrivileged() block supplied\n    // a rather restrictive ACC via a call to the private method\n    // AppClassLoader.getContext(). This proved overly restrictive\n    // when loading  classes. Specifically it prevent\n    // accessClassInPackage.sun.* grants from being honored.\n    //\n    return AccessController.doPrivileged(\n        new PrivilegedAction<AppClassLoader>() {\n            public AppClassLoader run() {\n            URL[] urls =\n                (s == null) ? new URL[0] : pathToURLs(path);\n            return new AppClassLoader(urls, extcl);\n        }\n    });\n}\n```\n\n每一个ClassLoader都有一个父ClassLoader,我们可以通过ClassLoader.getParent()方法获取。同时我们也能使用Class.getClassLoader()获取加载这个类的ClassLoader。所以让我们来看看下面的代码:\n\n```\npublic class GetClassLoader {\n    public static void main(String[] args) {\n        ClassLoader loader = GetClassLoader.class.getClassLoader();\n        do {\n            System.out.println(loader);\n        } while ((loader = loader.getParent()) != null);\n    }\n}\n```\n\n查看打印我们可以知道, GetClassLoader是AppClassLoader加载的,而AppClassLoader的父ClassLoader是ExtClassLoader:\n\n```\nsun.misc.Launcher$AppClassLoader@28d93b30\nsun.misc.Launcher$ExtClassLoader@74a14482\n```\n\n但是如果我们查看String的ClassLoader又会发现它是null的:\n\n```\npublic class GetClassLoader {\n    public static void main(String[] args) {\n        ClassLoader loader = String.class.getClassLoader();\n        System.out.println(\"loader : \" + loader);\n    }\n}\n```\n\n```\nloader : null\n```\n\n那是不是说String不是由ClassLoader加载的?当然不是!其实String是BootstrapClassLoader加载的。BootstrapClassLoader负责加载java的核心类。\n\n但是为什么String.class.getClassLoader()拿到的是null呢？\n\n原因是BootstrapClassLoader实际上不是一个java类,它是由C/C++编写的,它本身是虚拟机的一部分。所以在java中当然没有办法获取到它的引用。\n\n### 双亲委托\n\n相信大家如果知道ClassLoader的话应该有听说过双亲委托,那下面我们就来讲一下双亲委托究竟是怎么一回事。\n\n我们知道ClassLoader.loadClass()的方法可以加载一个类,所以研究一个类的加载流程,最好的方法当然还是去看源码啦:\n\n```\nprotected Class<?> loadClass(String name, boolean resolve)\n    throws ClassNotFoundException\n{\n    synchronized (getClassLoadingLock(name)) {\n        // 首先,从缓存中查询该类是不是被加载过,如果加载过就可以直接返回\n        Class<?> c = findLoadedClass(name);\n        if (c == null) {\n            long t0 = System.nanoTime();\n            try {\n                if (parent != null) {\n            \t\t//判断它的父ClassLoader是否为空,如果不为空就调用父ClassLoader的loadClass方法去加载该类\n                    c = parent.loadClass(name, false);\n                } else {\n                \t//如果它的父ClassLoader为空,则调用BootstrapClassLoader去加载该类,所以此时从逻辑上来讲BootstrapClassLoader是父ClassLoader\n                    c = findBootstrapClassOrNull(name);\n                }\n            } catch (ClassNotFoundException e) {\n                \n            }\n\n            if (c == null) {\n                long t1 = System.nanoTime();\n                \n                //如果父ClassLoader不能加载该类才由自己去加载,这个方法从本ClassLoader的搜索路径中查找该类\n                c = findClass(name);\n                \n                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                sun.misc.PerfCounter.getFindClasses().increment();\n            }\n        }\n        if (resolve) {\n            resolveClass(c);\n        }\n        return c;\n    }\n}\n```\n\n从代码中我们可以看到,加载一个类的时候,ClassLoader先会让父类去加载,如果父类加载失败,才会由它自己去加载,这就是我们说的双亲委托。\n\n为什么类加载需要设计成双亲委托的方式呢？原因就在于双亲委托可以防止类被重复加载。如果父ClassLoader已经加载过一个类了,子ClassLoader就不会再次加载,可以防止同一个类被两个ClassLoader重复加载的问题。\n\n这里还需要说的是,当我们自定义一个ClassLoader的时候,最好将AppClassLoader设为父ClassLoader。这样的话可以保证我们自定义的ClassLoader找加载类失败的时候还能从父ClassLoader中加载这个类。\n\n双亲委托模式的流程如下图所示:\n\n\n{% img /Android温故而知新-ClassLoader/1.png %}\n\n\n## 自定义ClassLoader\n\n有时候我们可以继承ClassLoader实现自己的类加载器。自定义ClassLoader有两种方式:\n\n1. 重写loadClass方法 \n2. 重写findClass方法\n\n他们有什么区别呢,还记得上一级ClassLoader.loadClass()的源码吗？loadClass方法内会先调用父ClassLoader的loadClass方法,如果父ClassLoader没有加载过该类才会调用本ClassLoader的findClass方法去加载类。\n\n所以如果想要打破双亲委托机制的话就可以loadClass(),而如果还想继续沿用双亲委托机制的话就只需要重写findClass就好了。\n\n我们写个小例子:\n\n```\npublic class MyClassLoader extends ClassLoader {\n    public String mClassDir;\n\n    public MyClassLoader(String classDir) {\n        this.mClassDir = classDir;\n    }\n\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        File file = new File(mClassDir, getClassFileName(name));\n        if (file.exists()) {\n            try {\n                FileInputStream is = new FileInputStream(file);\n\n                ByteArrayOutputStream buf = new ByteArrayOutputStream();\n                int len;\n                while ((len = is.read()) != -1) {\n                    buf.write(len);\n                }\n\n                byte[] data = buf.toByteArray();\n                is.close();\n                buf.close();\n\n                return defineClass(name, data, 0, data.length);\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        return super.findClass(name);\n    }\n\n    private String getClassFileName(String fullName) {\n        int index = fullName.lastIndexOf(\".\");\n        if (index == -1) {\n            return fullName + \".class\";\n        } else {\n            return fullName.substring(index + 1) + \".class\";\n        }\n    }\n}\n```\n\n因为我们不需要打破双亲委托机制所以只需要重写findClass方法就可以了。我们自定义的ClassLoader会从指定的路径中搜索class文件,将它读入内存,然后通过调用ClassLoader.defineClass()方法去加载这个类。\n\n我们在/Users/linjw/workspace/class\\_loader\\_demo目录下创建了一个Test.java:\n\n```\npackage linjw.demo.classloader;\npublic class Test {\n    public String getData() {\n        return \"Hello World\";\n    }\n}\n```\n\n然后通过javac命令编译出Test.class文件,同样放在/Users/linjw/workspace/class\\_loader\\_demo目录下。\n\n然后用我们的MyClassLoader去加载它:\n\n```\nMyClassLoader loader = new MyClassLoader(\"/Users/linjw/workspace/class_loader_demo\");\nClass clazz = loader.loadClass(\"linjw.demo.classloader.Test\");\nif (clazz != null) {\n    Object obj = clazz.newInstance();\n    Method method = clazz.getDeclaredMethod(\"getData\");\n    String result = (String) method.invoke(obj);\n    System.out.println(result);\n    System.out.println(\"ClassLoader : \" + clazz.getClassLoader());\n} else {\n    System.out.println(\"can't load class\");\n}\n```\n\n可以看到下面的打印,说明我们已经成功用MyClassLoader加载了Test这个类:\n\n```\nHello World\nClassLoader : linjw.demo.classloader.MyClassLoader@66cd51c3\n```\n\n这里还有一个小的知识点,如果一个类是由某个ClassLoader加载的,那么它import的类也会由这个ClassLoader去加载。这里我们可以做一个实验:\n\n```\npackage linjw.demo.classloader;\n\nimport linjw.demo.classloader.Test;\n\npublic class Test2 {\n    public String getData(){\n        return \"Test ClassLoader : \" + Test.class.getClassLoader();\n    }\n}\n```\n\n我们写一个Test2类,它会import Test并返回Test的ClassLoader。让我们写个demo看看这个Test的ClassLoader:\n\n```\nMyClassLoader loader = new MyClassLoader(\"/Users/linjw/workspace/class_loader_demo\");\nClass clazz = loader.loadClass(\"linjw.demo.classloader.Test2\");\nif (clazz != null) {\n    Object obj = clazz.newInstance();\n    Method method = clazz.getDeclaredMethod(\"getData\");\n    String result = (String) method.invoke(obj);\n    System.out.println(result);\n} else {\n    System.out.println(\"can't load class\");\n}\n```\n\n通过打印可以知道Test也是由MyClassLoader加载的:\n\n```\nlinjw.demo.classloader.MyClassLoader@66cd51c3\n```\n\n## Context ClassLoader\n\nContext ClassLoader并不是一个实际的类,它只是Thread的一个成员变量:\n\n```\npublic class Thread implements Runnable {\n\tprivate ClassLoader contextClassLoader;\n\n\tprivate void init2(Thread parent) {\n        this.contextClassLoader = parent.getContextClassLoader();\n        ...\n    }\n\n    public ClassLoader getContextClassLoader() {\n        return contextClassLoader;\n    }\n\n    public void setContextClassLoader(ClassLoader cl) {\n        contextClassLoader = cl;\n    }\n    \n    ...\n}\n```\n\n每个Thread都有一个相关联的ClassLoader,子线程默认使用父线程的ClassLoader。\n\n而线程的默认ClassLoader是AppClassLoader:\n\n```\npublic Launcher() {\n    ...\n    \n    try {\n        loader = AppClassLoader.getAppClassLoader(extcl);\n    } catch (IOException e) {\n        throw new InternalError(\n            \"Could not create application class loader\", e);\n    }\n    \n    //设置AppClassLoader为当前线程的Context ClassLoader\n    Thread.currentThread().setContextClassLoader(loader);\n\n\t...\n}\n```\n\nContext ClassLoader的存在是为了解决使用双亲委托机制下父ClassLoader无法找到子ClassLoader的问题。假如有下面的委托链:\n\nClassLoaderA -> AppClassLoader -> ExtClassLoader -> BootstrapClassLoader\n\n那么委派链左边的ClassLoader就可以很自然的使用右边的ClassLoader所加载的类。 \n\n但如果是右边的ClassLoader想要反过来使用左边的ClassLoader所加载的类就无能为力了。\n\n这个时候如果使用Context ClassLoader就能从线程中获得左边的ClassLoader了。\n\n那什么时候会出现右边的ClassLoader想要反过来使用左边的ClassLoader所加载的类的情况呢？\n\n我们上一节刚刚说过:“如果一个类是由某个ClassLoader加载的,那么它import的类也会由这个ClassLoader去加载”。\n\n举个例子,Java 提供了很多服务提供者接口（Service Provider Interface，SPI）,允许第三方为这些接口提供实现。如JAXP(XML处理的Java API)的SPI__接口__定义包含在 javax.xml.parsers包中，它是由BootstrapClassLoader加载的。\n\n但是它的实现代码很可能是作为Java应用所依赖的jar包被包含进来,如实现了JAXP SPI的Apache Xerces所包含的jar包,它由AppClassLoader加载。\n\n我们用javax.xml.parsers.DocumentBuilderFactory类中的newInstance()方法用来生成一个新的DocumentBuilderFactory的实例, DocumentBuilderFactory是一个抽象类,它定是java核心库的一部分,由BootstrapClassLoader去加载。因此,DocumentBuilderFactory里面import的类都由BootstrapClassLoader去加载。\n\n但是DocumentBuilderFactory的实现类却是在org.apache.xerces.jaxp.DocumentBuilderFactoryImpl中定义的, BootstrapClassLoader无法加载它。这个时候就需要在DocumentBuilderFactory. newInstance()的代码中使用Context ClassLoader，找到AppClassLoader去加载DocumentBuilderFactoryImpl这个实现类。\n\n\n# 安卓中的ClassLoader\n\n安卓的的类也是通过ClassLoader加载的,但是并不是java中的BootstrapClassLoader、 ExtClassLoader或者AppClassLoader。写个小demo看看安卓中加载类的是哪些ClassLoader:\n\n```\nLog.d(\"DxClassLoader\", \"BootClassLoader :\" + String.class.getClassLoader());\n\nClassLoader loader = MainActivity.class.getClassLoader();\ndo {\n\tLog.d(\"DxClassLoader\", \"loader :\" + loader);\n} while ((loader = loader.getParent()) != null);\n```\n\n打印如下:\n\n```\n09-27 23:11:03.432 21151-21151/? D/DxClassLoader: BootClassLoader :java.lang.BootClassLoader@ad96016\n09-27 23:11:03.432 21151-21151/? D/DxClassLoader: loader :dalvik.system.PathClassLoader[DexPathList[[zip file \"/data/app/linjw.demo.classloader-2/base.apk\"],nativeLibraryDirectories=[/data/app/linjw.demo.classloader-2/lib/arm64, /vendor/lib64, /system/lib64]]]\n09-27 23:11:03.433 21151-21151/? D/DxClassLoader: loader :java.lang.BootClassLoader@ad96016\n```\n\n我们可以看到安卓中用的了PathClassLoader和BootClassLoader两个ClassLoader,其中BootClassLoader是PathClassLoader的parent。\n\n而和在java程序不同的是String是由BootClassLoader加载的。安卓的BootClassLoader其实就相当于java的BootstrapClassLoader,只不过它是由java实现的而不是由c/c++实现的。\n\n## PathClassLoader\n\n我们在上一节中将PathClassLoader打印出来的时候可以看到一个apk路径:\n\n```\n[zip file \"/data/app/linjw.demo.classloader-2/base.apk\"]\n```\n\napk其实是一个也是一个zip压缩包,我们可以将一个apk文件后缀改成.zip然后就可以直接解压了。PathClassLoader的作用其实就是在这个zip包中加载dex文件,我们通过它甚至可以加载其他应用的代码,但它只能加载已安装的应用。\n\n例如我们可以新建一个ext工程,它的包名为linjw.demo.classloader.ext,然后在里面创建Test类:\n\n```\npackage linjw.demo.classloader.ext;\n\npublic class Test {\n    public String getData() {\n        return \"Hello World\";\n    }\n}\n```\n\n然后编译出apk来,并且安装。之后就能从这个apk中加载出Test类了:\n\n```\nString path = null;\nPackageManager pm = getPackageManager();\ntry {\n    path = pm.getApplicationInfo(\"linjw.demo.classloader.ext\", 0).sourceDir;\n} catch (PackageManager.NameNotFoundException e) {\n    e.printStackTrace();\n}\n\nPathClassLoader loader = new PathClassLoader(path, ClassLoader.getSystemClassLoader());\n\ntry {\n    Class clazz = loader.loadClass(\"linjw.demo.classloader.ext.Test\");\n\n    if (clazz != null) {\n        Object obj = clazz.newInstance();\n        Method method = clazz.getDeclaredMethod(\"getData\");\n        String result = (String) method.invoke(obj);\n        Log.d(\"DxClassLoader\", result);\n    } else {\n        Log.d(\"DxClassLoader\", \"can't load class\");\n    }\n} catch (ClassNotFoundException e) {\n    e.printStackTrace();\n} catch (NoSuchMethodException e) {\n    e.printStackTrace();\n} catch (InstantiationException e) {\n    e.printStackTrace();\n} catch (IllegalAccessException e) {\n    e.printStackTrace();\n} catch (InvocationTargetException e) {\n    e.printStackTrace();\n}\n```\n\n可以得到打印:\n\n```\n09-27 23:39:16.571 24077-24077/? D/DxClassLoader: Hello World\n```\n\n## DexClassLoader\n\nPathClassLoader只能加载已经安装的应用里面的类,但是DexClassLoader却能加载未安装的应用里面的类。例如我们将apk放到存储卡目录下而不去安装它:\n\n```\nString dir = Environment.getExternalStorageDirectory().getAbsolutePath();\nFile apk = new File(dir, \"Ext.apk\");\nFile dexOutputDir = this.getDir(\"dex\", 0);\nDexClassLoader loader = new DexClassLoader(\n        apk.getAbsolutePath(),\n        dexOutputDir.getAbsolutePath(),\n        null, getClassLoader());\n\ntry {\n    Class clazz = loader.loadClass(\"linjw.demo.classloader.ext.Test\");\n\n    if (clazz != null) {\n        Object obj = clazz.newInstance();\n        Method method = clazz.getDeclaredMethod(\"getData\");\n        String result = (String) method.invoke(obj);\n        Log.d(\"DxClassLoader\", result);\n    } else {\n        Log.d(\"DxClassLoader\", \"can't load class\");\n    }\n} catch (ClassNotFoundException e) {\n    e.printStackTrace();\n} catch (NoSuchMethodException e) {\n    e.printStackTrace();\n} catch (InstantiationException e) {\n    e.printStackTrace();\n} catch (IllegalAccessException e) {\n    e.printStackTrace();\n} catch (InvocationTargetException e) {\n    e.printStackTrace();\n}\n```\n\n同样可以得到打印:\n\n```\n09-27 23:54:29.206 25472-25472/? D/DxClassLoader: Hello World\n```\n\n我们可以看到, DexClassLoader的构造函数的参数比PathClassLoader的要多出一个optimizedDirectory:\n\n```\npublic class DexClassLoader extends BaseDexClassLoader {\n    public DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) {\n        super((String)null, (File)null, (String)null, (ClassLoader)null);\n        throw new RuntimeException(\"Stub!\");\n    }\n}\n```\n\n```\npublic class PathClassLoader extends BaseDexClassLoader {\n    public PathClassLoader(String dexPath, ClassLoader parent) {\n        super((String)null, (File)null, (String)null, (ClassLoader)null);\n        throw new RuntimeException(\"Stub!\");\n    }\n\n    public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) {\n        super((String)null, (File)null, (String)null, (ClassLoader)null);\n        throw new RuntimeException(\"Stub!\");\n    }\n}\n```\n\n那这个optimizedDirectory到底有什么作用呢?其实optimizedDirectory是用来存放从apk中解压出来的dex文件的。\n\nDexClassLoader和PathClassLoader其实归根结底都是通过DexFile这个类去加载的dex文件,并不是直接读取的apk。因为如果每次都需要解压才能加载代码的话效率实在太低了。\n\nDexClassLoader可以主动解压apk,所以可以加载未安装的应用中的代码。但PathClassLoader不会主动解压apk,它是读取的已经安装的apk在cache中存在缓存的dex文件,所以它只能加载已安装应用中的代码。\n\n## 生成dex文件\n\nDexClassLoader和PathClassLoader最后都是加载的dex文件。所以我们可以直接将dex文件的路径传给他们去加载。但dex文件又是个什么东西呢？\n\n普通的java程序中,JVM虚拟机可以通过ClassLoader去加载jar到的加载类的目的。但是android使用的Dalvik/ART虚拟机不能直接加载jar包,需要把.jar文件优化成.dex文件才能加载。所以实际上dex文件是优化过的jar包。\n\n我们可以用Android SDK提供的DX工具把.jar文件优化成.dex文件。我们用之前的Test.java做例子,具体步骤如下:\n\n1.使用javac命令编译Test.java得到Test.class文件(我这边的java环境是1.8的,如果不指定用1.7的话生成dex也会失败,报__com.android.dx.cf.iface.ParseException: bad class file magic (cafebabe) or version (0034.0000)__)\n\n```\njavac -source 1.7 -target 1.7 Test.java\n```\n\n2.将创建目录子目录linjw/demo/classloader/ext并将Test.class移动到子目录中(因为Test的package是linjw.demo.classloader.ext,所以要根据它生成同样的目录,要不然生成dex会失败)\n\n```\nmkdir -p linjw/demo/classloader/ext\nmv Test.class linjw/demo/classloader/ext\n```\n\n3.使用jar命令将linjw目录打包成jar包\n\n```\njar -cf Test.jar linjw\n```\n\n4.用dx工具将jar包优化成dex包\n\n```\n/Users/linjw/androidsdk/android-sdk-macosx/build-tools/19.1.0/dx --dex --output=Test.dex Test.jar\n```\n\n## 动态加载dex文件\n\n然后我们就能将它放到存储卡中用DexClassLoader或者PathClassLoader去加载了。\n\n### 使用反射的反射加载\n\n```\n\nString dir = Environment.getExternalStorageDirectory().getAbsolutePath();\nFile dex = new File(dir, \"Test.dex\");\nFile dexOutputDir = this.getDir(\"dex\", 0);\n\n//使用PathClassLoader加载dex\n//PathClassLoader loader = new PathClassLoader(dex.getAbsolutePath(), getClassLoader());\n\n//使用DexClassLoader加载dex\nDexClassLoader loader = new DexClassLoader(\n        dex.getAbsolutePath(),\n        dexOutputDir.getAbsolutePath(),\n        null,\n        getClassLoader());\n\ntry {\n    Class clazz = loader.loadClass(\"linjw.demo.classloader.ext.Test\");\n\n    if (clazz != null) {\n        Object obj = clazz.newInstance();\n        Method method = clazz.getDeclaredMethod(\"getData\");\n        String result = (String) method.invoke(obj);\n        Log.d(\"DxClassLoader\", result);\n    } else {\n        Log.d(\"DxClassLoader\", \"can't load class\");\n    }\n} catch (ClassNotFoundException e) {\n    e.printStackTrace();\n} catch (NoSuchMethodException e) {\n    e.printStackTrace();\n} catch (InstantiationException e) {\n    e.printStackTrace();\n} catch (IllegalAccessException e) {\n    e.printStackTrace();\n} catch (InvocationTargetException e) {\n    e.printStackTrace();\n}\n```\n\n\n### 使用接口的方式加载\n\n或者我们也可以使用接口的方式:\n\n1.添加ITest接口:\n\n```\npackage linjw.demo.classloader.ext;\n\npublic interface ITest {\n    String getData();\n}\n```\n\n2.Test类实现ITest接口:\n\n```\npackage linjw.demo.classloader.ext;\n\npublic class Test implements ITest {\n    @Override\n    public String getData() {\n        return \"Hello World\";\n    }\n}\n```\n\n3.将它们一起打包到Test.dex\n\n```\njavac -source 1.7 -target 1.7 Test.java ITest.java\n\nmkdir -p linjw/demo/classloader/ext\n\nmv Test.class linjw/demo/classloader/ext\n\nmv Test.class linjw/demo/classloader\n\njar -cf Test.jar linjw\n\n/Users/linjw/androidsdk/android-sdk-macosx/build-tools/19.1.0/dx --dex --output=Test.dex Test.jar\n```\n\n4.在安卓项目中导入ITest接口并调整代码:\n\n```\nString dir = Environment.getExternalStorageDirectory().getAbsolutePath();\nFile dex = new File(dir, \"Test.dex\");\nFile dexOutputDir = this.getDir(\"dex\", 0);\n\n//使用PathClassLoader加载dex\n//PathClassLoader loader = new PathClassLoader(dex.getAbsolutePath(), getClassLoader());\n\n//使用DexClassLoader加载dex\nDexClassLoader loader = new DexClassLoader(\n    dex.getAbsolutePath(),\n    dexOutputDir.getAbsolutePath(),\n    null,\n    getClassLoader());\n\ntry {\nClass clazz = loader.loadClass(\"linjw.demo.classloader.ext.Test\");\n\nif (clazz != null) {\n    //注意这里,使用的是ITest\n    ITest obj = (ITest) clazz.newInstance();\n    String result = obj.getData();\n    Log.d(\"DxClassLoader\", result);\n} else {\n    Log.d(\"DxClassLoader\", \"can't load class\");\n}\n} catch (ClassNotFoundException e) {\ne.printStackTrace();\n} catch (InstantiationException e) {\ne.printStackTrace();\n} catch (IllegalAccessException e) {\ne.printStackTrace();\n}\n```\n\n其实我比较推荐使用在程序主体中定义接口,加载外部实现代码的这种方法。一方面它比反射的效率高,另一方面也比较容易阅读。\n","slug":"Android温故而知新-ClassLoader","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2uoy004gw3fybvtrkg5a"},{"title":"Android温故而知新 - AIDL","date":"2017-09-25T17:13:29.000Z","_content":"\n这篇文章让我们一起来复习一下aidl\n\n# aidl的简单用法\n\naidl的用法是很简单的。首先创建IDemoAidlInterface.aidl文件(在服务端工程和客户端工程中需要分别定义一个相同的aidl文件):\n\n```\npackage linjw.demo.aidldemo;\n\ninterface IDemoAidlInterface {\n    int add(int a, int b);\n}\n```\n\n然后在service.onBind()中创建一个IDemoAidlInterface.Stub返回:\n\n```\npublic class DemoService extends Service {\n    @Nullable\n    @Override\n    public IBinder onBind(Intent intent) {\n        return new IDemoAidlInterface.Stub() {\n            @Override\n            public int add(int a, int b) throws RemoteException {\n                return a + b;\n            }\n        };\n    }\n}\n```\n\n这样在bindService的时候就能获得一个IDemoAidlInterface,就可以通过它去调用其他进程中的方法获取数据了:\n\n```\npublic class MainActivity extends AppCompatActivity {\n    public static final String TAG = \"AIDLDemo\";\n    private ServiceConnection mConnection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            IDemoAidlInterface aidl = IDemoAidlInterface.Stub.asInterface(service);\n            try {\n                Log.d(TAG, \"1 + 2 = \" + aidl.add(1, 2));\n            } catch (RemoteException e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n\n        }\n    };\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Intent intent = new Intent(this, DemoService.class);\n        bindService(intent, mConnection, BIND_AUTO_CREATE);\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        unbindService(mConnection);\n    }\n}\n```\n\n# aidl的原理\n\n但是aidl文件又是个什么东西？aidl又到底是怎样工作的呢？\n\naidl是Android Interface definition language的缩写,实际上它是一中领域特定语言即domain-specific languages，简称DSL,aidl的作用领域是定义安卓接口。感兴趣的同学可以自己去找一下DSL的相关概念,这里就不展开讨论了。\n\naidl底层是通过binder机制实现的,而且不同需求的binder通信实际上代码是有很大的相似性的。厉害的程序员通常是懒惰的程序员,好的ide通常也会提供各种强大的功能帮助程序员去偷懒。\n\naidl就是一种帮助我们简化安卓进程间通信代码的工具。android studio会根据aidl定义的接口,帮我们自动生成安卓进程间通信的代码,而我们只需要直接使用它生成的代码就好了,而不用自己去写。\n\n让我们看看aidl究竟帮我们生成了什么样的代码:\n\n```\npublic interface IDemoAidlInterface extends android.os.IInterface {\n    /**\n     * Local-side IPC implementation stub class.\n     */\n    public static abstract class Stub extends android.os.Binder implements linjw.demo.aidldemo.IDemoAidlInterface {\n        private static final java.lang.String DESCRIPTOR = \"linjw.demo.aidldemo.IDemoAidlInterface\";\n\n        /**\n         * Construct the stub at attach it to the interface.\n         */\n        public Stub() {\n            this.attachInterface(this, DESCRIPTOR);\n        }\n\n        /**\n         * Cast an IBinder object into an linjw.demo.aidldemo.IDemoAidlInterface interface,\n         * generating a proxy if needed.\n         */\n        public static linjw.demo.aidldemo.IDemoAidlInterface asInterface(android.os.IBinder obj) {\n            if ((obj == null)) {\n                return null;\n            }\n            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);\n            if (((iin != null) && (iin instanceof linjw.demo.aidldemo.IDemoAidlInterface))) {\n                return ((linjw.demo.aidldemo.IDemoAidlInterface) iin);\n            }\n            return new linjw.demo.aidldemo.IDemoAidlInterface.Stub.Proxy(obj);\n        }\n\n        @Override\n        public android.os.IBinder asBinder() {\n            return this;\n        }\n\n        @Override\n        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {\n            switch (code) {\n                case INTERFACE_TRANSACTION: {\n                    reply.writeString(DESCRIPTOR);\n                    return true;\n                }\n                case TRANSACTION_add: {\n                    data.enforceInterface(DESCRIPTOR);\n                    int _arg0;\n                    _arg0 = data.readInt();\n                    int _arg1;\n                    _arg1 = data.readInt();\n                    int _result = this.add(_arg0, _arg1);\n                    reply.writeNoException();\n                    reply.writeInt(_result);\n                    return true;\n                }\n            }\n            return super.onTransact(code, data, reply, flags);\n        }\n\n        private static class Proxy implements linjw.demo.aidldemo.IDemoAidlInterface {\n            private android.os.IBinder mRemote;\n\n            Proxy(android.os.IBinder remote) {\n                mRemote = remote;\n            }\n\n            @Override\n            public android.os.IBinder asBinder() {\n                return mRemote;\n            }\n\n            public java.lang.String getInterfaceDescriptor() {\n                return DESCRIPTOR;\n            }\n\n            @Override\n            public int add(int a, int b) throws android.os.RemoteException {\n                android.os.Parcel _data = android.os.Parcel.obtain();\n                android.os.Parcel _reply = android.os.Parcel.obtain();\n                int _result;\n                try {\n                    _data.writeInterfaceToken(DESCRIPTOR);\n                    _data.writeInt(a);\n                    _data.writeInt(b);\n                    mRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0);\n                    _reply.readException();\n                    _result = _reply.readInt();\n                } finally {\n                    _reply.recycle();\n                    _data.recycle();\n                }\n                return _result;\n            }\n        }\n\n        static final int TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);\n    }\n\n    public int add(int a, int b) throws android.os.RemoteException;\n}\n```\n\n它帮忙我们生成了我们在aidl中定义的IDemoAidlInterface接口,并且生成了一个抽象内部类IDemoAidlInterface.Stub去实现和安卓进程间通信相关的代码。而我们只需要继承IDemoAidlInterface.Stub实现具体的业务代码(add方法)就好:\n\n```\npublic interface IDemoAidlInterface extends android.os.IInterface {\n    public static abstract class Stub\n            extends android.os.Binder\n            implements linjw.demo.aidldemo.IDemoAidlInterface {\n    \t...\n    }\n    public int add(int a, int b) throws android.os.RemoteException;\n}\n\n```\n\n## 服务端通信原理\n\n在服务端,我们只需要继承IDemoAidlInterface.Stub并完成add方法的功能代码就可以了。当客户端通过aidl调用服务端代码的时候,服务端的add方法就会被调用:\n\n```\npublic IBinder onBind(Intent intent) {\n    return new IDemoAidlInterface.Stub() {\n        @Override\n        public int add(int a, int b) throws RemoteException {\n            return a + b;\n        }\n    };\n}\n```\n\n但是add究竟是为什么会被调用的呢？奥秘就在IDemoAidlInterface.Stub.onTransact()方法中。onTransact是android.os.Binder的一个方法。客户端将想要调用的服务端的方法、参数等序列化之后通过系统级别的Binder驱动程序传给服务端,然后服务端在将它们反序列化获取想要调用的方法还有传入的参数。而onTransact就是这个反序列化的方法:\n\n```\npublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {\n    switch (code) {\n        case INTERFACE_TRANSACTION: {\n            reply.writeString(DESCRIPTOR);\n            return true;\n        }\n        case TRANSACTION_add: {\n            data.enforceInterface(DESCRIPTOR);\n            int _arg0;\n            _arg0 = data.readInt();\n            int _arg1;\n            _arg1 = data.readInt();\n            int _result = this.add(_arg0, _arg1);\n            reply.writeNoException();\n            reply.writeInt(_result);\n            return true;\n        }\n    }\n    return super.onTransact(code, data, reply, flags);\n}\n```\n\ncode就代表了客户端想要执行的操作,当它是TRANSACTION_add的时候就代表客户端想调用服务端的add方法。可以从传过来的Parcel中反序列化出传入的两个相加数,然后调用实际的add方法,即this.add(\\_arg0, \\_arg1),最后将计算出来的值写入reply中序列化之后传回给客户端。客户端就可以从这个reply中反序列化中出计算的结果。\n\nTRANSACTION_add是一个int,是IDemoAidlInterface接口定义的第一个方法:\n\n```\nstatic final int TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);\n```\n\n## 客户端原理\n\n客户端的代码比服务端会复杂一点点。首先从IDemoAidlInterface.Stub.asInterface方法开始看,我们可以通过它获取到一个IDemoAidlInterface:\n\n```\nIDemoAidlInterface aidl = IDemoAidlInterface.Stub.asInterface(service);\n```\n\n它的代码是这样的:\n\n```\npublic static linjw.demo.aidldemo.IDemoAidlInterface asInterface(android.os.IBinder obj) {\n    if ((obj == null)) {\n        return null;\n    }\n    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);\n    if (((iin != null) && (iin instanceof linjw.demo.aidldemo.IDemoAidlInterface))) {\n        return ((linjw.demo.aidldemo.IDemoAidlInterface) iin);\n    }\n    return new linjw.demo.aidldemo.IDemoAidlInterface.Stub.Proxy(obj);\n}\n```\n\n它会判断传进来的IBinder是不是IDemoAidlInterface的一个实例,如果是的话就直接将它返回,不是的会就会用它去创建一个代理。\n\n但这个判断有什么用呢？什么时候IBinder它会是一个IDemoAidlInterface的实例什么时候又不是呢？\n\n我们写的service不外乎给其他应用使用和给应用内部使用。给其他应用使用的service因为进程不同不能直接传递对象,所以需要将一个对象先序列化再反序列化去实现进程间的传递。但是有一些服务比如播放器的播放服务,很多时候就只是应用内部在使用而已,是进程内的通信(或者说只是线程间的通信)。其实不涉及跨进程通信,可以直接传递,不用经过序列化和反序列化这样耗时的操作。\n\n如果是进程内的通信,传入的IBinder其实是IDemoAidlInterface的一个实例,所以直接返回将它返回就好。但如果是进程间的通信,就不会是是IDemoAidlInterface的实例了,而是一个用于进程间通信的对象了(具体是什么我们可以不用关心)。这个对象没有实现IDemoAidlInterface.add()方法,所以需要通过一些特殊的手段调用到服务端的add方法:\n\n```\nprivate static class Proxy implements linjw.demo.aidldemo.IDemoAidlInterface {\n        private android.os.IBinder mRemote;\n\n        Proxy(android.os.IBinder remote) {\n            mRemote = remote;\n        }\n\n        @Override\n        public android.os.IBinder asBinder() {\n            return mRemote;\n        }\n\n        public java.lang.String getInterfaceDescriptor() {\n            return DESCRIPTOR;\n        }\n\n        @Override\n        public int add(int a, int b) throws android.os.RemoteException {\n            android.os.Parcel _data = android.os.Parcel.obtain();\n            android.os.Parcel _reply = android.os.Parcel.obtain();\n            int _result;\n            try {\n                _data.writeInterfaceToken(DESCRIPTOR);\n                _data.writeInt(a);\n                _data.writeInt(b);\n                mRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0);\n                _reply.readException();\n                _result = _reply.readInt();\n            } finally {\n                _reply.recycle();\n                _data.recycle();\n            }\n            return _result;\n        }\n    }\n\n    static final int TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);\n}\n```\n\n它最重要的代码是IDemoAidlInterface.Stub.Proxy.add()这个方法。它将传入的a、b参数序列化到\\_data这个Parcel中,然后再通过之前传入的IBinder的transact()将它们传递到service中。注意看,我们还指定了调用Stub.TRANSACTION_add这个方法。上一节服务端获取到的code就是这里指定的。然后服务端将计算到的结果序列化到\\_reply中,客户的这里再将\\_reply反序列化得到计算结果返回。\n\n## aidl原理图\n\naidl的原理可以用下面的图来表示:\n\n{% img /Android温故而知新-AIDL/1.png %}\n\n# 使用aidl传递复杂数据类型\n\n有时候我需要传递一些复杂的数据类型比如自定义的类,aidl也是支持的。但是因为aidl传递数据都是通过序列化实现的,所以aidl要求传递的类必须实现Parcelable接口。比如我们定义一个Data类:\n\n```\npublic class Data implements Parcelable {\n    public String data;\n\n    public Data() {\n    }\n\n    public Data(String data) {\n        this.data = data;\n    }\n\n    protected Data(Parcel in) {\n        data = in.readString();\n    }\n\n    public static final Creator<Data> CREATOR = new Creator<Data>() {\n        @Override\n        public Data createFromParcel(Parcel in) {\n            return new Data(in);\n        }\n\n        @Override\n        public Data[] newArray(int size) {\n            return new Data[size];\n        }\n    };\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n    }\n\n    public void readFromParcel(Parcel in) {\n        data = in.readString();\n    }\n}\n```\n\n然后需要新建一个Data.aidl文件声明这个类:\n\n```\npackage linjw.demo.aidldemo;\nparcelable Data;\n```\n\n最后在IDemoAidlInterface.aidl中添加接口:\n\n```\npackage linjw.demo.aidldemo;\nimport linjw.demo.aidldemo.Data;\n\ninterface IDemoAidlInterface {\n    int add(int a, int b);\n\n    void setData(in Data data);\n\n    void getData(out Data data);\n}\n```\n\n## 输入参数和输出参数\n\n相信大家都看到了in、out这两个关键字了,他们是用来标识这个参数是输入参数还是输出参数的。我们直接可以看一下生成的代码可以很容易看出他们的作用,先看看服务端的Stub. onTransact()方法:\n\n```\npublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {\n    switch (code) {\n        case INTERFACE_TRANSACTION: {\n            reply.writeString(DESCRIPTOR);\n            return true;\n        }\n        case TRANSACTION_add: {\n            data.enforceInterface(DESCRIPTOR);\n            int _arg0;\n            _arg0 = data.readInt();\n            int _arg1;\n            _arg1 = data.readInt();\n            int _result = this.add(_arg0, _arg1);\n            reply.writeNoException();\n            reply.writeInt(_result);\n            return true;\n        }\n        case TRANSACTION_setData: {\n            data.enforceInterface(DESCRIPTOR);\n            linjw.demo.aidldemo.Data _arg0;\n            if ((0 != data.readInt())) {\n                _arg0 = linjw.demo.aidldemo.Data.CREATOR.createFromParcel(data);\n            } else {\n                _arg0 = null;\n            }\n            this.setData(_arg0);\n            reply.writeNoException();\n            return true;\n        }\n        case TRANSACTION_getData: {\n            data.enforceInterface(DESCRIPTOR);\n            linjw.demo.aidldemo.Data _arg0;\n            _arg0 = new linjw.demo.aidldemo.Data();\n            this.getData(_arg0);\n            reply.writeNoException();\n            if ((_arg0 != null)) {\n                reply.writeInt(1);\n                _arg0.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);\n            } else {\n                reply.writeInt(0);\n            }\n            return true;\n        }\n    }\n    return super.onTransact(code, data, reply, flags);\n}\n```\n\nsetData只是简单的将参数返序列化出来传给功能代码,但是getData除了调用功能代码之外,还会将返回值写入reply中传回给客户端。\n\n同时我们也注意到了服务端所有的调用都是在onTransact中分配的,所以需要一个code去标识客户端到底想要调用的是哪一个方法。\n\n我们再来看看客户端的生成代码,也能看到getData方法有从_reply中反序列化出Data来:\n\n``` \nprivate static class Proxy implements linjw.demo.aidldemo.IDemoAidlInterface {\n    \n    ...\n    \n    @Override\n    public void setData(linjw.demo.aidldemo.Data data) throws android.os.RemoteException {\n        android.os.Parcel _data = android.os.Parcel.obtain();\n        android.os.Parcel _reply = android.os.Parcel.obtain();\n        try {\n            _data.writeInterfaceToken(DESCRIPTOR);\n            if ((data != null)) {\n                _data.writeInt(1);\n                data.writeToParcel(_data, 0);\n            } else {\n                _data.writeInt(0);\n            }\n            mRemote.transact(Stub.TRANSACTION_setData, _data, _reply, 0);\n            _reply.readException();\n        } finally {\n            _reply.recycle();\n            _data.recycle();\n        }\n    }\n\n    @Override\n    public void getData(linjw.demo.aidldemo.Data data) throws android.os.RemoteException {\n        android.os.Parcel _data = android.os.Parcel.obtain();\n        android.os.Parcel _reply = android.os.Parcel.obtain();\n        try {\n            _data.writeInterfaceToken(DESCRIPTOR);\n            mRemote.transact(Stub.TRANSACTION_getData, _data, _reply, 0);\n            _reply.readException();\n            if ((0 != _reply.readInt())) {\n                data.readFromParcel(_reply);\n            }\n        } finally {\n            _reply.recycle();\n            _data.recycle();\n        }\n    }\n}\n```","source":"_posts/Android温故而知新-AIDL.md","raw":"title: Android温故而知新 - AIDL\ndate: 2017-09-26 01:13:29\ntags:\n    - 技术相关\n    - Android\n---\n\n这篇文章让我们一起来复习一下aidl\n\n# aidl的简单用法\n\naidl的用法是很简单的。首先创建IDemoAidlInterface.aidl文件(在服务端工程和客户端工程中需要分别定义一个相同的aidl文件):\n\n```\npackage linjw.demo.aidldemo;\n\ninterface IDemoAidlInterface {\n    int add(int a, int b);\n}\n```\n\n然后在service.onBind()中创建一个IDemoAidlInterface.Stub返回:\n\n```\npublic class DemoService extends Service {\n    @Nullable\n    @Override\n    public IBinder onBind(Intent intent) {\n        return new IDemoAidlInterface.Stub() {\n            @Override\n            public int add(int a, int b) throws RemoteException {\n                return a + b;\n            }\n        };\n    }\n}\n```\n\n这样在bindService的时候就能获得一个IDemoAidlInterface,就可以通过它去调用其他进程中的方法获取数据了:\n\n```\npublic class MainActivity extends AppCompatActivity {\n    public static final String TAG = \"AIDLDemo\";\n    private ServiceConnection mConnection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            IDemoAidlInterface aidl = IDemoAidlInterface.Stub.asInterface(service);\n            try {\n                Log.d(TAG, \"1 + 2 = \" + aidl.add(1, 2));\n            } catch (RemoteException e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n\n        }\n    };\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Intent intent = new Intent(this, DemoService.class);\n        bindService(intent, mConnection, BIND_AUTO_CREATE);\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        unbindService(mConnection);\n    }\n}\n```\n\n# aidl的原理\n\n但是aidl文件又是个什么东西？aidl又到底是怎样工作的呢？\n\naidl是Android Interface definition language的缩写,实际上它是一中领域特定语言即domain-specific languages，简称DSL,aidl的作用领域是定义安卓接口。感兴趣的同学可以自己去找一下DSL的相关概念,这里就不展开讨论了。\n\naidl底层是通过binder机制实现的,而且不同需求的binder通信实际上代码是有很大的相似性的。厉害的程序员通常是懒惰的程序员,好的ide通常也会提供各种强大的功能帮助程序员去偷懒。\n\naidl就是一种帮助我们简化安卓进程间通信代码的工具。android studio会根据aidl定义的接口,帮我们自动生成安卓进程间通信的代码,而我们只需要直接使用它生成的代码就好了,而不用自己去写。\n\n让我们看看aidl究竟帮我们生成了什么样的代码:\n\n```\npublic interface IDemoAidlInterface extends android.os.IInterface {\n    /**\n     * Local-side IPC implementation stub class.\n     */\n    public static abstract class Stub extends android.os.Binder implements linjw.demo.aidldemo.IDemoAidlInterface {\n        private static final java.lang.String DESCRIPTOR = \"linjw.demo.aidldemo.IDemoAidlInterface\";\n\n        /**\n         * Construct the stub at attach it to the interface.\n         */\n        public Stub() {\n            this.attachInterface(this, DESCRIPTOR);\n        }\n\n        /**\n         * Cast an IBinder object into an linjw.demo.aidldemo.IDemoAidlInterface interface,\n         * generating a proxy if needed.\n         */\n        public static linjw.demo.aidldemo.IDemoAidlInterface asInterface(android.os.IBinder obj) {\n            if ((obj == null)) {\n                return null;\n            }\n            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);\n            if (((iin != null) && (iin instanceof linjw.demo.aidldemo.IDemoAidlInterface))) {\n                return ((linjw.demo.aidldemo.IDemoAidlInterface) iin);\n            }\n            return new linjw.demo.aidldemo.IDemoAidlInterface.Stub.Proxy(obj);\n        }\n\n        @Override\n        public android.os.IBinder asBinder() {\n            return this;\n        }\n\n        @Override\n        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {\n            switch (code) {\n                case INTERFACE_TRANSACTION: {\n                    reply.writeString(DESCRIPTOR);\n                    return true;\n                }\n                case TRANSACTION_add: {\n                    data.enforceInterface(DESCRIPTOR);\n                    int _arg0;\n                    _arg0 = data.readInt();\n                    int _arg1;\n                    _arg1 = data.readInt();\n                    int _result = this.add(_arg0, _arg1);\n                    reply.writeNoException();\n                    reply.writeInt(_result);\n                    return true;\n                }\n            }\n            return super.onTransact(code, data, reply, flags);\n        }\n\n        private static class Proxy implements linjw.demo.aidldemo.IDemoAidlInterface {\n            private android.os.IBinder mRemote;\n\n            Proxy(android.os.IBinder remote) {\n                mRemote = remote;\n            }\n\n            @Override\n            public android.os.IBinder asBinder() {\n                return mRemote;\n            }\n\n            public java.lang.String getInterfaceDescriptor() {\n                return DESCRIPTOR;\n            }\n\n            @Override\n            public int add(int a, int b) throws android.os.RemoteException {\n                android.os.Parcel _data = android.os.Parcel.obtain();\n                android.os.Parcel _reply = android.os.Parcel.obtain();\n                int _result;\n                try {\n                    _data.writeInterfaceToken(DESCRIPTOR);\n                    _data.writeInt(a);\n                    _data.writeInt(b);\n                    mRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0);\n                    _reply.readException();\n                    _result = _reply.readInt();\n                } finally {\n                    _reply.recycle();\n                    _data.recycle();\n                }\n                return _result;\n            }\n        }\n\n        static final int TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);\n    }\n\n    public int add(int a, int b) throws android.os.RemoteException;\n}\n```\n\n它帮忙我们生成了我们在aidl中定义的IDemoAidlInterface接口,并且生成了一个抽象内部类IDemoAidlInterface.Stub去实现和安卓进程间通信相关的代码。而我们只需要继承IDemoAidlInterface.Stub实现具体的业务代码(add方法)就好:\n\n```\npublic interface IDemoAidlInterface extends android.os.IInterface {\n    public static abstract class Stub\n            extends android.os.Binder\n            implements linjw.demo.aidldemo.IDemoAidlInterface {\n    \t...\n    }\n    public int add(int a, int b) throws android.os.RemoteException;\n}\n\n```\n\n## 服务端通信原理\n\n在服务端,我们只需要继承IDemoAidlInterface.Stub并完成add方法的功能代码就可以了。当客户端通过aidl调用服务端代码的时候,服务端的add方法就会被调用:\n\n```\npublic IBinder onBind(Intent intent) {\n    return new IDemoAidlInterface.Stub() {\n        @Override\n        public int add(int a, int b) throws RemoteException {\n            return a + b;\n        }\n    };\n}\n```\n\n但是add究竟是为什么会被调用的呢？奥秘就在IDemoAidlInterface.Stub.onTransact()方法中。onTransact是android.os.Binder的一个方法。客户端将想要调用的服务端的方法、参数等序列化之后通过系统级别的Binder驱动程序传给服务端,然后服务端在将它们反序列化获取想要调用的方法还有传入的参数。而onTransact就是这个反序列化的方法:\n\n```\npublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {\n    switch (code) {\n        case INTERFACE_TRANSACTION: {\n            reply.writeString(DESCRIPTOR);\n            return true;\n        }\n        case TRANSACTION_add: {\n            data.enforceInterface(DESCRIPTOR);\n            int _arg0;\n            _arg0 = data.readInt();\n            int _arg1;\n            _arg1 = data.readInt();\n            int _result = this.add(_arg0, _arg1);\n            reply.writeNoException();\n            reply.writeInt(_result);\n            return true;\n        }\n    }\n    return super.onTransact(code, data, reply, flags);\n}\n```\n\ncode就代表了客户端想要执行的操作,当它是TRANSACTION_add的时候就代表客户端想调用服务端的add方法。可以从传过来的Parcel中反序列化出传入的两个相加数,然后调用实际的add方法,即this.add(\\_arg0, \\_arg1),最后将计算出来的值写入reply中序列化之后传回给客户端。客户端就可以从这个reply中反序列化中出计算的结果。\n\nTRANSACTION_add是一个int,是IDemoAidlInterface接口定义的第一个方法:\n\n```\nstatic final int TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);\n```\n\n## 客户端原理\n\n客户端的代码比服务端会复杂一点点。首先从IDemoAidlInterface.Stub.asInterface方法开始看,我们可以通过它获取到一个IDemoAidlInterface:\n\n```\nIDemoAidlInterface aidl = IDemoAidlInterface.Stub.asInterface(service);\n```\n\n它的代码是这样的:\n\n```\npublic static linjw.demo.aidldemo.IDemoAidlInterface asInterface(android.os.IBinder obj) {\n    if ((obj == null)) {\n        return null;\n    }\n    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);\n    if (((iin != null) && (iin instanceof linjw.demo.aidldemo.IDemoAidlInterface))) {\n        return ((linjw.demo.aidldemo.IDemoAidlInterface) iin);\n    }\n    return new linjw.demo.aidldemo.IDemoAidlInterface.Stub.Proxy(obj);\n}\n```\n\n它会判断传进来的IBinder是不是IDemoAidlInterface的一个实例,如果是的话就直接将它返回,不是的会就会用它去创建一个代理。\n\n但这个判断有什么用呢？什么时候IBinder它会是一个IDemoAidlInterface的实例什么时候又不是呢？\n\n我们写的service不外乎给其他应用使用和给应用内部使用。给其他应用使用的service因为进程不同不能直接传递对象,所以需要将一个对象先序列化再反序列化去实现进程间的传递。但是有一些服务比如播放器的播放服务,很多时候就只是应用内部在使用而已,是进程内的通信(或者说只是线程间的通信)。其实不涉及跨进程通信,可以直接传递,不用经过序列化和反序列化这样耗时的操作。\n\n如果是进程内的通信,传入的IBinder其实是IDemoAidlInterface的一个实例,所以直接返回将它返回就好。但如果是进程间的通信,就不会是是IDemoAidlInterface的实例了,而是一个用于进程间通信的对象了(具体是什么我们可以不用关心)。这个对象没有实现IDemoAidlInterface.add()方法,所以需要通过一些特殊的手段调用到服务端的add方法:\n\n```\nprivate static class Proxy implements linjw.demo.aidldemo.IDemoAidlInterface {\n        private android.os.IBinder mRemote;\n\n        Proxy(android.os.IBinder remote) {\n            mRemote = remote;\n        }\n\n        @Override\n        public android.os.IBinder asBinder() {\n            return mRemote;\n        }\n\n        public java.lang.String getInterfaceDescriptor() {\n            return DESCRIPTOR;\n        }\n\n        @Override\n        public int add(int a, int b) throws android.os.RemoteException {\n            android.os.Parcel _data = android.os.Parcel.obtain();\n            android.os.Parcel _reply = android.os.Parcel.obtain();\n            int _result;\n            try {\n                _data.writeInterfaceToken(DESCRIPTOR);\n                _data.writeInt(a);\n                _data.writeInt(b);\n                mRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0);\n                _reply.readException();\n                _result = _reply.readInt();\n            } finally {\n                _reply.recycle();\n                _data.recycle();\n            }\n            return _result;\n        }\n    }\n\n    static final int TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);\n}\n```\n\n它最重要的代码是IDemoAidlInterface.Stub.Proxy.add()这个方法。它将传入的a、b参数序列化到\\_data这个Parcel中,然后再通过之前传入的IBinder的transact()将它们传递到service中。注意看,我们还指定了调用Stub.TRANSACTION_add这个方法。上一节服务端获取到的code就是这里指定的。然后服务端将计算到的结果序列化到\\_reply中,客户的这里再将\\_reply反序列化得到计算结果返回。\n\n## aidl原理图\n\naidl的原理可以用下面的图来表示:\n\n{% img /Android温故而知新-AIDL/1.png %}\n\n# 使用aidl传递复杂数据类型\n\n有时候我需要传递一些复杂的数据类型比如自定义的类,aidl也是支持的。但是因为aidl传递数据都是通过序列化实现的,所以aidl要求传递的类必须实现Parcelable接口。比如我们定义一个Data类:\n\n```\npublic class Data implements Parcelable {\n    public String data;\n\n    public Data() {\n    }\n\n    public Data(String data) {\n        this.data = data;\n    }\n\n    protected Data(Parcel in) {\n        data = in.readString();\n    }\n\n    public static final Creator<Data> CREATOR = new Creator<Data>() {\n        @Override\n        public Data createFromParcel(Parcel in) {\n            return new Data(in);\n        }\n\n        @Override\n        public Data[] newArray(int size) {\n            return new Data[size];\n        }\n    };\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n    }\n\n    public void readFromParcel(Parcel in) {\n        data = in.readString();\n    }\n}\n```\n\n然后需要新建一个Data.aidl文件声明这个类:\n\n```\npackage linjw.demo.aidldemo;\nparcelable Data;\n```\n\n最后在IDemoAidlInterface.aidl中添加接口:\n\n```\npackage linjw.demo.aidldemo;\nimport linjw.demo.aidldemo.Data;\n\ninterface IDemoAidlInterface {\n    int add(int a, int b);\n\n    void setData(in Data data);\n\n    void getData(out Data data);\n}\n```\n\n## 输入参数和输出参数\n\n相信大家都看到了in、out这两个关键字了,他们是用来标识这个参数是输入参数还是输出参数的。我们直接可以看一下生成的代码可以很容易看出他们的作用,先看看服务端的Stub. onTransact()方法:\n\n```\npublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {\n    switch (code) {\n        case INTERFACE_TRANSACTION: {\n            reply.writeString(DESCRIPTOR);\n            return true;\n        }\n        case TRANSACTION_add: {\n            data.enforceInterface(DESCRIPTOR);\n            int _arg0;\n            _arg0 = data.readInt();\n            int _arg1;\n            _arg1 = data.readInt();\n            int _result = this.add(_arg0, _arg1);\n            reply.writeNoException();\n            reply.writeInt(_result);\n            return true;\n        }\n        case TRANSACTION_setData: {\n            data.enforceInterface(DESCRIPTOR);\n            linjw.demo.aidldemo.Data _arg0;\n            if ((0 != data.readInt())) {\n                _arg0 = linjw.demo.aidldemo.Data.CREATOR.createFromParcel(data);\n            } else {\n                _arg0 = null;\n            }\n            this.setData(_arg0);\n            reply.writeNoException();\n            return true;\n        }\n        case TRANSACTION_getData: {\n            data.enforceInterface(DESCRIPTOR);\n            linjw.demo.aidldemo.Data _arg0;\n            _arg0 = new linjw.demo.aidldemo.Data();\n            this.getData(_arg0);\n            reply.writeNoException();\n            if ((_arg0 != null)) {\n                reply.writeInt(1);\n                _arg0.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);\n            } else {\n                reply.writeInt(0);\n            }\n            return true;\n        }\n    }\n    return super.onTransact(code, data, reply, flags);\n}\n```\n\nsetData只是简单的将参数返序列化出来传给功能代码,但是getData除了调用功能代码之外,还会将返回值写入reply中传回给客户端。\n\n同时我们也注意到了服务端所有的调用都是在onTransact中分配的,所以需要一个code去标识客户端到底想要调用的是哪一个方法。\n\n我们再来看看客户端的生成代码,也能看到getData方法有从_reply中反序列化出Data来:\n\n``` \nprivate static class Proxy implements linjw.demo.aidldemo.IDemoAidlInterface {\n    \n    ...\n    \n    @Override\n    public void setData(linjw.demo.aidldemo.Data data) throws android.os.RemoteException {\n        android.os.Parcel _data = android.os.Parcel.obtain();\n        android.os.Parcel _reply = android.os.Parcel.obtain();\n        try {\n            _data.writeInterfaceToken(DESCRIPTOR);\n            if ((data != null)) {\n                _data.writeInt(1);\n                data.writeToParcel(_data, 0);\n            } else {\n                _data.writeInt(0);\n            }\n            mRemote.transact(Stub.TRANSACTION_setData, _data, _reply, 0);\n            _reply.readException();\n        } finally {\n            _reply.recycle();\n            _data.recycle();\n        }\n    }\n\n    @Override\n    public void getData(linjw.demo.aidldemo.Data data) throws android.os.RemoteException {\n        android.os.Parcel _data = android.os.Parcel.obtain();\n        android.os.Parcel _reply = android.os.Parcel.obtain();\n        try {\n            _data.writeInterfaceToken(DESCRIPTOR);\n            mRemote.transact(Stub.TRANSACTION_getData, _data, _reply, 0);\n            _reply.readException();\n            if ((0 != _reply.readInt())) {\n                data.readFromParcel(_reply);\n            }\n        } finally {\n            _reply.recycle();\n            _data.recycle();\n        }\n    }\n}\n```","slug":"Android温故而知新-AIDL","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2up0004jw3fylqzunz1y"},{"title":"Activity是如何画到屏幕上的","date":"2018-02-28T15:38:14.000Z","_content":"\n# Activity是如何管理布局的\n\n一切从setContentView说起。安卓中最常用的代码可能就是setContentView了，但大家有没有想过这个方法的背后到底做了些什么？\n\n```\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n}\n```\n\n直接跳转到Activity的源码我们可以看到,Activity.setContentView实际上调用了PhoneWindow.setContentView:\n\n```\nfinal void attach(Context context, ActivityThread aThread,\n        Instrumentation instr, IBinder token, int ident,\n        Application application, Intent intent, ActivityInfo info,\n        CharSequence title, Activity parent, String id,\n        NonConfigurationInstances lastNonConfigurationInstances,\n        Configuration config, String referrer, IVoiceInteractor voiceInteractor,\n        Window window) {\n     ...\n     mWindow = new PhoneWindow(this, window);\n     ...\n}\n\npublic Window getWindow() {\n    return mWindow;\n}\n\npublic void setContentView(@LayoutRes int layoutResID) {\n    getWindow().setContentView(layoutResID);\n    initWindowDecorActionBar();\n}\n```\n\n我们继续跟踪PhoneWindow的源码,可以发现最终layoutResID被inflate出来之后是成为了mDecor这个DecorView的子view。而DecorView实际上是一个FrameLayout:\n\n```\npublic void setContentView(int layoutResID) {\n     if (mContentParent == null) {\n          installDecor();\n     } else {\n          mContentParent.removeAllViews();\n     }\n     mLayoutInflater.inflate(layoutResID, mContentParent);\n     final Callback cb = getCallback();\n     if (cb != null && !isDestroyed()) {\n          cb.onContentChanged();\n     }\n}\n\nprivate void installDecor() {\n     if (mDecor == null) {\n          mDecor = generateDecor();\n          ...\n     }\n     if (mContentParent == null) {\n          //mContentParent 实际上是mDecor的一个子view\n          mContentParent = generateLayout(mDecor);\n          ...\n     }\n     ...\n}\n\nprotected DecorView generateDecor() {\n     return new DecorView(getContext(), -1);\n}\n\nprivate final class DecorView extends FrameLayout implements RootViewSurfaceTaker {\n     ...\n}\n```\n\n\n这里的generateLayout比较重要，它实际上是根据window的各种属性inflate出不同的layout挂到DecorView下面,而mContentParent是这个layout中的一个子ViewGroup。如果我们没有对window的属性进行设置就会使用默认的com.android.internal.R.layout.screen_simple这个layout:\n\n```\nprotected ViewGroup generateLayout(DecorView decor) {    \n     ...\n     if ((features & ((1 << FEATURE_LEFT_ICON) | (1 << FEATURE_RIGHT_ICON))) != 0) {\n          ...\n          layoutResource = com.android.internal.R.layout.screen_title_icons;\n          ...\n     } else if ((features & ((1 << FEATURE_PROGRESS) | (1 << FEATURE_INDETERMINATE_PROGRESS))) != 0\n  && (features & (1 << FEATURE_ACTION_BAR)) == 0) {\n          layoutResource = com.android.internal.R.layout.screen_progress;\n     } else if ((features & (1 << FEATURE_CUSTOM_TITLE)) != 0) {\n          ...\n          layoutResource = com.android.internal.R.layout.screen_custom_title;\n          ...\n     } ... else{\n          layoutResource = com.android.internal.R.layout.screen_simple;\n     }\n     ...\n     View in = mLayoutInflater.inflate(layoutResource, null);\n     decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));\n     ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);\n     ...\n     return contentParent;\n}\n```\n\n我们可以在AndroidSdk根目录/platforms/android-19/data/res/layout/下面找到这些layout xml,例如screen_simple,这是个竖直的LinearLayout,由上方的ActionBar和下方的content FrameLayout组成。它就是我们最常见的带ActionBar的activity样式:\n\n```\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:fitsSystemWindows=\"true\"\n  android:orientation=\"vertical\">\n  <ViewStub android:id=\"@+id/action_mode_bar_stub\"\n    android:inflatedId=\"@+id/action_mode_bar\"\n    android:layout=\"@layout/action_mode_bar\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\" />\n  <FrameLayout\n    android:id=\"@android:id/content\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:foregroundInsidePadding=\"false\"\n    android:foregroundGravity=\"fill_horizontal|top\"\n    android:foreground=\"?android:attr/windowContentOverlay\" />\n</LinearLayout>\n```\n\n我们可以用一张图片来总结下Activity是如何管理布局的(这里假设DecorView里面添加了screen_simple这个布局):\n\n{% img /Activity是如何画到屏幕上的/1.png %}\n\n# Activity的布局是怎样被系统渲染的\n\n在上一节中我们已经知道了Activity是怎样管理布局的。接着我们来看看Activity中的布局是如何渲染到系统的。\n\nActivityThread用于管理Activity的声明周期,之后我会专门写一篇文章来讲它。我们直接看ActivityThread.handleResumeActivity方法:\n\n```\nfinal void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) {\n  ...\n  //performResumeActivity方法会调用Activity.onResume\n  ActivityClientRecord r = performResumeActivity(token, clearHide);\n  ...\n  r.window = r.activity.getWindow();\n  View decor = r.window.getDecorView();\n  decor.setVisibility(View.INVISIBLE);\n  ViewManager wm = a.getWindowManager();\n  WindowManager.LayoutParams l = r.window.getAttributes();\n  a.mDecor = decor;\n  l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;\n  l.softInputMode |= forwardBit;\n  if (a.mVisibleFromClient) {\n    a.mWindowAdded = true;\n    wm.addView(decor, l);\n  }\n  ...\n}\n```\n\n可以看到它在Activity.onResume之后从Activity中获取了Window,然后又从window中获取了DecorView。最后使用WindowManager.addView将DecorView添加到了WindowManager中。这样就将DecorView在手机上渲染了出来。\n\nWindowManager.addView方法可以将一个view渲染到手机界面上。不知道大家有没有做过类似悬浮球的应用,就是用WindowManager.addView去实现的。这里就不再展开了，大家有兴趣的话可以自己去搜索一下。\n\n\n# 为什么不能在子线程中操作view\n\n我们都知道,在安卓中必须在ui线程中操作ui,不能在子线程中对view进行操作,否则或抛出CalledFromWrongThreadException异常。但是在子线程中操作view是不是真的就一定会出现异常呢?让我们运行下面的代码:\n\n```\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                ((TextView)findViewById(R.id.textView)).setText(\"子线程中操作view\");\n            }\n        }).start();\n    }\n}\n```\n\n我们可以看到实际上在onCreate的时候直接启动子线程去修改TextView的文字是可以正常运行的,且文字也是显示正常的:\n\n\n{% img /Activity是如何画到屏幕上的/2.png %}\n\n\n让我们加1秒的延迟再试一下:\n\n```\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                ((TextView)findViewById(R.id.textView)).setText(\"子线程中操作view\");\n            }\n        }).start();\n    }\n}\n```\n\n运行之后就能看到熟悉的崩溃日志了:\n\n```\n02-28 22:36:48.550  3780  3817 E AndroidRuntime: FATAL EXCEPTION: Thread-5\n02-28 22:36:48.550  3780  3817 E AndroidRuntime: Process: com.example.linjw.myapplication, PID: 3780\n02-28 22:36:48.550  3780  3817 E AndroidRuntime: android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:6987)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.view.ViewRootImpl.requestLayout(ViewRootImpl.java:1104)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.view.View.requestLayout(View.java:19807)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.view.View.requestLayout(View.java:19807)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.view.View.requestLayout(View.java:19807)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.view.View.requestLayout(View.java:19807)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.support.constraint.ConstraintLayout.requestLayout(ConstraintLayout.java:874)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.view.View.requestLayout(View.java:19807)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.widget.TextView.checkForRelayout(TextView.java:7375)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.widget.TextView.setText(TextView.java:4487)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.widget.TextView.setText(TextView.java:4344)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.widget.TextView.setText(TextView.java:4319)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at com.example.linjw.myapplication.MainActivity$1.run(MainActivity.java:20)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at java.lang.Thread.run(Thread.java:760)\n```\n\n为什么延迟1秒之后就能看到异常被抛出了呢?本着寻根问底的精神,我们直接扣ViewRootImpl的源码看看CalledFromWrongThreadException异常是怎么被抛出的:\n\n```\npublic ViewRootImpl(Context context, Display display) {\n    ...\n    mThread = Thread.currentThread();\n    ...\n}\n\nvoid checkThread() {\n    if (mThread != Thread.currentThread()) {\n        throw new CalledFromWrongThreadException(\n                \"Only the original thread that created a view hierarchy can touch its views.\");\n    }\n}\n\npublic void requestLayout() {\n   if (!mHandlingLayoutInLayoutRequest) {\n       checkThread();\n       mLayoutRequested = true;\n       scheduleTraversals();\n   }\n}\n```\n\n在View.requestLayout方法中会调用ViewRootImpl.requestLayout,然后在ViewRootImpl.requestLayout里面会调用ViewRootImpl.checkThread去判断当前线程和创建ViewRootImpl的线程是不是同一个线程。如果不是的话就抛出CalledFromWrongThreadException异常。\n\n那ViewRootImpl又是在哪个线程中被创建的呢?还记得上一节中讲到的ActivityThread.handleResumeActivity方法中将DecorView添加到WindowManager中吗?WindowManager实际上是WindowManagerImpl实例:\n\n```\npublic final class WindowManagerImpl implements WindowManager {\n  private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();\n  ...\n  public void addView(View view, ViewGroup.LayoutParams params) {\n      mGlobal.addView(view, params, mDisplay, mParentWindow);\n  }\n  ...\n}\n```\n\n我们可以看到WindowManagerImpl.addView实际上是调到了WindowManagerGlobal.addView:\n\n```\npublic final class WindowManagerGlobal {\n  public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) {\n    ...\n    ViewRootImpl root;\n    ...\n    root = new ViewRootImpl(view.getContext(), display);\n    ...\n  }    \n}          \n```\n\n所以ViewRootImpl是在handleResumeActivity的线程中被创建的,我们都知道onResume是在主线程中被调用的,所以ViewRootImpl是在主线程中被调用的。所以只要在非主线程中调用ViewRootImpl.requestLayout就会抛出CalledFromWrongThreadException异常。\n\n\n那回到最初的问题,为什么我们在onCreate的时候直接起子线程去修改TextView的文字,不会抛出CalledFromWrongThreadException异常?因为ViewRootImpl是在onResume中创建的,在onCreate的时候它就还没有被创建,所以就不会抛出CalledFromWrongThreadException异常。\n\n等到onResume的时候ViewRootImpl被创建,会进行第一次layout,这个时候才会检查是否在主线程中操作ui。\n","source":"_posts/Activity是如何画到屏幕上的.md","raw":"title: Activity是如何画到屏幕上的\ndate: 2018-02-28 23:38:14\ntags:\n\t- 技术相关\n  - Android\n---\n\n# Activity是如何管理布局的\n\n一切从setContentView说起。安卓中最常用的代码可能就是setContentView了，但大家有没有想过这个方法的背后到底做了些什么？\n\n```\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n}\n```\n\n直接跳转到Activity的源码我们可以看到,Activity.setContentView实际上调用了PhoneWindow.setContentView:\n\n```\nfinal void attach(Context context, ActivityThread aThread,\n        Instrumentation instr, IBinder token, int ident,\n        Application application, Intent intent, ActivityInfo info,\n        CharSequence title, Activity parent, String id,\n        NonConfigurationInstances lastNonConfigurationInstances,\n        Configuration config, String referrer, IVoiceInteractor voiceInteractor,\n        Window window) {\n     ...\n     mWindow = new PhoneWindow(this, window);\n     ...\n}\n\npublic Window getWindow() {\n    return mWindow;\n}\n\npublic void setContentView(@LayoutRes int layoutResID) {\n    getWindow().setContentView(layoutResID);\n    initWindowDecorActionBar();\n}\n```\n\n我们继续跟踪PhoneWindow的源码,可以发现最终layoutResID被inflate出来之后是成为了mDecor这个DecorView的子view。而DecorView实际上是一个FrameLayout:\n\n```\npublic void setContentView(int layoutResID) {\n     if (mContentParent == null) {\n          installDecor();\n     } else {\n          mContentParent.removeAllViews();\n     }\n     mLayoutInflater.inflate(layoutResID, mContentParent);\n     final Callback cb = getCallback();\n     if (cb != null && !isDestroyed()) {\n          cb.onContentChanged();\n     }\n}\n\nprivate void installDecor() {\n     if (mDecor == null) {\n          mDecor = generateDecor();\n          ...\n     }\n     if (mContentParent == null) {\n          //mContentParent 实际上是mDecor的一个子view\n          mContentParent = generateLayout(mDecor);\n          ...\n     }\n     ...\n}\n\nprotected DecorView generateDecor() {\n     return new DecorView(getContext(), -1);\n}\n\nprivate final class DecorView extends FrameLayout implements RootViewSurfaceTaker {\n     ...\n}\n```\n\n\n这里的generateLayout比较重要，它实际上是根据window的各种属性inflate出不同的layout挂到DecorView下面,而mContentParent是这个layout中的一个子ViewGroup。如果我们没有对window的属性进行设置就会使用默认的com.android.internal.R.layout.screen_simple这个layout:\n\n```\nprotected ViewGroup generateLayout(DecorView decor) {    \n     ...\n     if ((features & ((1 << FEATURE_LEFT_ICON) | (1 << FEATURE_RIGHT_ICON))) != 0) {\n          ...\n          layoutResource = com.android.internal.R.layout.screen_title_icons;\n          ...\n     } else if ((features & ((1 << FEATURE_PROGRESS) | (1 << FEATURE_INDETERMINATE_PROGRESS))) != 0\n  && (features & (1 << FEATURE_ACTION_BAR)) == 0) {\n          layoutResource = com.android.internal.R.layout.screen_progress;\n     } else if ((features & (1 << FEATURE_CUSTOM_TITLE)) != 0) {\n          ...\n          layoutResource = com.android.internal.R.layout.screen_custom_title;\n          ...\n     } ... else{\n          layoutResource = com.android.internal.R.layout.screen_simple;\n     }\n     ...\n     View in = mLayoutInflater.inflate(layoutResource, null);\n     decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));\n     ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);\n     ...\n     return contentParent;\n}\n```\n\n我们可以在AndroidSdk根目录/platforms/android-19/data/res/layout/下面找到这些layout xml,例如screen_simple,这是个竖直的LinearLayout,由上方的ActionBar和下方的content FrameLayout组成。它就是我们最常见的带ActionBar的activity样式:\n\n```\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:fitsSystemWindows=\"true\"\n  android:orientation=\"vertical\">\n  <ViewStub android:id=\"@+id/action_mode_bar_stub\"\n    android:inflatedId=\"@+id/action_mode_bar\"\n    android:layout=\"@layout/action_mode_bar\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\" />\n  <FrameLayout\n    android:id=\"@android:id/content\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:foregroundInsidePadding=\"false\"\n    android:foregroundGravity=\"fill_horizontal|top\"\n    android:foreground=\"?android:attr/windowContentOverlay\" />\n</LinearLayout>\n```\n\n我们可以用一张图片来总结下Activity是如何管理布局的(这里假设DecorView里面添加了screen_simple这个布局):\n\n{% img /Activity是如何画到屏幕上的/1.png %}\n\n# Activity的布局是怎样被系统渲染的\n\n在上一节中我们已经知道了Activity是怎样管理布局的。接着我们来看看Activity中的布局是如何渲染到系统的。\n\nActivityThread用于管理Activity的声明周期,之后我会专门写一篇文章来讲它。我们直接看ActivityThread.handleResumeActivity方法:\n\n```\nfinal void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) {\n  ...\n  //performResumeActivity方法会调用Activity.onResume\n  ActivityClientRecord r = performResumeActivity(token, clearHide);\n  ...\n  r.window = r.activity.getWindow();\n  View decor = r.window.getDecorView();\n  decor.setVisibility(View.INVISIBLE);\n  ViewManager wm = a.getWindowManager();\n  WindowManager.LayoutParams l = r.window.getAttributes();\n  a.mDecor = decor;\n  l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;\n  l.softInputMode |= forwardBit;\n  if (a.mVisibleFromClient) {\n    a.mWindowAdded = true;\n    wm.addView(decor, l);\n  }\n  ...\n}\n```\n\n可以看到它在Activity.onResume之后从Activity中获取了Window,然后又从window中获取了DecorView。最后使用WindowManager.addView将DecorView添加到了WindowManager中。这样就将DecorView在手机上渲染了出来。\n\nWindowManager.addView方法可以将一个view渲染到手机界面上。不知道大家有没有做过类似悬浮球的应用,就是用WindowManager.addView去实现的。这里就不再展开了，大家有兴趣的话可以自己去搜索一下。\n\n\n# 为什么不能在子线程中操作view\n\n我们都知道,在安卓中必须在ui线程中操作ui,不能在子线程中对view进行操作,否则或抛出CalledFromWrongThreadException异常。但是在子线程中操作view是不是真的就一定会出现异常呢?让我们运行下面的代码:\n\n```\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                ((TextView)findViewById(R.id.textView)).setText(\"子线程中操作view\");\n            }\n        }).start();\n    }\n}\n```\n\n我们可以看到实际上在onCreate的时候直接启动子线程去修改TextView的文字是可以正常运行的,且文字也是显示正常的:\n\n\n{% img /Activity是如何画到屏幕上的/2.png %}\n\n\n让我们加1秒的延迟再试一下:\n\n```\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                ((TextView)findViewById(R.id.textView)).setText(\"子线程中操作view\");\n            }\n        }).start();\n    }\n}\n```\n\n运行之后就能看到熟悉的崩溃日志了:\n\n```\n02-28 22:36:48.550  3780  3817 E AndroidRuntime: FATAL EXCEPTION: Thread-5\n02-28 22:36:48.550  3780  3817 E AndroidRuntime: Process: com.example.linjw.myapplication, PID: 3780\n02-28 22:36:48.550  3780  3817 E AndroidRuntime: android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:6987)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.view.ViewRootImpl.requestLayout(ViewRootImpl.java:1104)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.view.View.requestLayout(View.java:19807)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.view.View.requestLayout(View.java:19807)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.view.View.requestLayout(View.java:19807)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.view.View.requestLayout(View.java:19807)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.support.constraint.ConstraintLayout.requestLayout(ConstraintLayout.java:874)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.view.View.requestLayout(View.java:19807)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.widget.TextView.checkForRelayout(TextView.java:7375)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.widget.TextView.setText(TextView.java:4487)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.widget.TextView.setText(TextView.java:4344)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.widget.TextView.setText(TextView.java:4319)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at com.example.linjw.myapplication.MainActivity$1.run(MainActivity.java:20)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at java.lang.Thread.run(Thread.java:760)\n```\n\n为什么延迟1秒之后就能看到异常被抛出了呢?本着寻根问底的精神,我们直接扣ViewRootImpl的源码看看CalledFromWrongThreadException异常是怎么被抛出的:\n\n```\npublic ViewRootImpl(Context context, Display display) {\n    ...\n    mThread = Thread.currentThread();\n    ...\n}\n\nvoid checkThread() {\n    if (mThread != Thread.currentThread()) {\n        throw new CalledFromWrongThreadException(\n                \"Only the original thread that created a view hierarchy can touch its views.\");\n    }\n}\n\npublic void requestLayout() {\n   if (!mHandlingLayoutInLayoutRequest) {\n       checkThread();\n       mLayoutRequested = true;\n       scheduleTraversals();\n   }\n}\n```\n\n在View.requestLayout方法中会调用ViewRootImpl.requestLayout,然后在ViewRootImpl.requestLayout里面会调用ViewRootImpl.checkThread去判断当前线程和创建ViewRootImpl的线程是不是同一个线程。如果不是的话就抛出CalledFromWrongThreadException异常。\n\n那ViewRootImpl又是在哪个线程中被创建的呢?还记得上一节中讲到的ActivityThread.handleResumeActivity方法中将DecorView添加到WindowManager中吗?WindowManager实际上是WindowManagerImpl实例:\n\n```\npublic final class WindowManagerImpl implements WindowManager {\n  private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();\n  ...\n  public void addView(View view, ViewGroup.LayoutParams params) {\n      mGlobal.addView(view, params, mDisplay, mParentWindow);\n  }\n  ...\n}\n```\n\n我们可以看到WindowManagerImpl.addView实际上是调到了WindowManagerGlobal.addView:\n\n```\npublic final class WindowManagerGlobal {\n  public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) {\n    ...\n    ViewRootImpl root;\n    ...\n    root = new ViewRootImpl(view.getContext(), display);\n    ...\n  }    \n}          \n```\n\n所以ViewRootImpl是在handleResumeActivity的线程中被创建的,我们都知道onResume是在主线程中被调用的,所以ViewRootImpl是在主线程中被调用的。所以只要在非主线程中调用ViewRootImpl.requestLayout就会抛出CalledFromWrongThreadException异常。\n\n\n那回到最初的问题,为什么我们在onCreate的时候直接起子线程去修改TextView的文字,不会抛出CalledFromWrongThreadException异常?因为ViewRootImpl是在onResume中创建的,在onCreate的时候它就还没有被创建,所以就不会抛出CalledFromWrongThreadException异常。\n\n等到onResume的时候ViewRootImpl被创建,会进行第一次layout,这个时候才会检查是否在主线程中操作ui。\n","slug":"Activity是如何画到屏幕上的","published":1,"updated":"2018-09-21T11:19:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmbx2up2004mw3fy448q425r"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjmbx2uly0003w3fyu385owcq","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2um30006w3fy3xdpcnq5"},{"post_id":"cjmbx2uly0003w3fyu385owcq","tag_id":"cjmbx2um30005w3fy54yl7u7s","_id":"cjmbx2um30007w3fy2az9cf9z"},{"post_id":"cjmbx2um50008w3fy7y1xk2yn","tag_id":"cjmbx2um60009w3fypin7jl4q","_id":"cjmbx2um6000aw3fyhebihlaj"},{"post_id":"cjmbx2um7000bw3fy1pk2qhdp","tag_id":"cjmbx2um60009w3fypin7jl4q","_id":"cjmbx2um7000cw3fyqbwv677j"},{"post_id":"cjmbx2um8000dw3fygp5mqe0p","tag_id":"cjmbx2um60009w3fypin7jl4q","_id":"cjmbx2um9000ew3fy1w42q6sm"},{"post_id":"cjmbx2um9000fw3fybyn4dva2","tag_id":"cjmbx2um60009w3fypin7jl4q","_id":"cjmbx2uma000gw3fytcd2tf1e"},{"post_id":"cjmbx2umb000hw3fyizrxr687","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2umc000kw3fyonhp5won"},{"post_id":"cjmbx2umb000hw3fyizrxr687","tag_id":"cjmbx2umc000iw3fyomj23qu8","_id":"cjmbx2umc000lw3fyd50t7in5"},{"post_id":"cjmbx2umb000hw3fyizrxr687","tag_id":"cjmbx2umc000jw3fy1vsc2f95","_id":"cjmbx2umc000mw3fyihc0bwfp"},{"post_id":"cjmbx2umd000nw3fy4povqv3c","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2ume000ow3fyzget76yl"},{"post_id":"cjmbx2umd000nw3fy4povqv3c","tag_id":"cjmbx2umc000iw3fyomj23qu8","_id":"cjmbx2ume000pw3fys7cft5jy"},{"post_id":"cjmbx2umg000qw3fyc72htxei","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2umg000sw3fy99bdipyo"},{"post_id":"cjmbx2umg000qw3fyc72htxei","tag_id":"cjmbx2umg000rw3fykagoyw5z","_id":"cjmbx2umh000tw3fyklf3r62o"},{"post_id":"cjmbx2umi000uw3fymzm5tc7v","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2umi000vw3fy027ipo3n"},{"post_id":"cjmbx2umj000ww3fy76qe8x7c","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2umk000xw3fywxyb0lc2"},{"post_id":"cjmbx2umj000ww3fy76qe8x7c","tag_id":"cjmbx2umc000iw3fyomj23qu8","_id":"cjmbx2umk000yw3fy8bwivf6y"},{"post_id":"cjmbx2uml000zw3fymd9mgtnf","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2uml0010w3fyg5muc2ju"},{"post_id":"cjmbx2uml000zw3fymd9mgtnf","tag_id":"cjmbx2umc000iw3fyomj23qu8","_id":"cjmbx2uml0011w3fyn3v1qxt7"},{"post_id":"cjmbx2umm0012w3fytll975ee","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2umn0013w3fy4nbbetmb"},{"post_id":"cjmbx2umm0012w3fytll975ee","tag_id":"cjmbx2umc000iw3fyomj23qu8","_id":"cjmbx2umn0014w3fyt4f367z2"},{"post_id":"cjmbx2umo0015w3fye3gp7fm7","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2ump0017w3fyspdgf3xq"},{"post_id":"cjmbx2umo0015w3fye3gp7fm7","tag_id":"cjmbx2ump0016w3fy8fbcr2xs","_id":"cjmbx2ump0018w3fy2eirfizo"},{"post_id":"cjmbx2umr0019w3fyrompof00","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2umr001aw3fy16v03uzl"},{"post_id":"cjmbx2umr0019w3fyrompof00","tag_id":"cjmbx2ump0016w3fy8fbcr2xs","_id":"cjmbx2umr001bw3fyp83xlb20"},{"post_id":"cjmbx2ums001cw3fynglhhp7s","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2umu001dw3fy0qtowax0"},{"post_id":"cjmbx2ums001cw3fynglhhp7s","tag_id":"cjmbx2umc000iw3fyomj23qu8","_id":"cjmbx2umu001ew3fy367hkiwn"},{"post_id":"cjmbx2umv001fw3fyjlbscvp1","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2umv001gw3fyicr755pa"},{"post_id":"cjmbx2umv001fw3fyjlbscvp1","tag_id":"cjmbx2umc000iw3fyomj23qu8","_id":"cjmbx2umw001hw3fyjwaz6sdm"},{"post_id":"cjmbx2umx001iw3fyrsv8a321","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2umx001jw3fykiovumti"},{"post_id":"cjmbx2umx001iw3fyrsv8a321","tag_id":"cjmbx2umc000iw3fyomj23qu8","_id":"cjmbx2umx001kw3fyb0yhwho8"},{"post_id":"cjmbx2umz001lw3fyp86migbh","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2un1001nw3fydzz7kke1"},{"post_id":"cjmbx2umz001lw3fyp86migbh","tag_id":"cjmbx2umc000iw3fyomj23qu8","_id":"cjmbx2un1001ow3fy3rqlhfxb"},{"post_id":"cjmbx2umz001lw3fyp86migbh","tag_id":"cjmbx2un0001mw3fylefixbrj","_id":"cjmbx2un1001pw3fyfen515s2"},{"post_id":"cjmbx2un3001qw3fy4i5wy3k6","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2un4001rw3fyy6v0geob"},{"post_id":"cjmbx2un3001qw3fy4i5wy3k6","tag_id":"cjmbx2umg000rw3fykagoyw5z","_id":"cjmbx2un4001sw3fyl8v0zxjh"},{"post_id":"cjmbx2un5001tw3fy8yq4wjdo","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2un7001vw3fyqmlg9qzp"},{"post_id":"cjmbx2un5001tw3fy8yq4wjdo","tag_id":"cjmbx2un7001uw3fy6cbiwkns","_id":"cjmbx2un7001ww3fy9e1hdqyx"},{"post_id":"cjmbx2un9001xw3fyg0asrsd2","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2un9001yw3fyk6dovjxp"},{"post_id":"cjmbx2un9001xw3fyg0asrsd2","tag_id":"cjmbx2umc000iw3fyomj23qu8","_id":"cjmbx2un9001zw3fyux9uzee6"},{"post_id":"cjmbx2una0020w3fyhiqohuu6","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2unb0021w3fy0bv8373i"},{"post_id":"cjmbx2una0020w3fyhiqohuu6","tag_id":"cjmbx2umc000iw3fyomj23qu8","_id":"cjmbx2unb0022w3fyrbljrt00"},{"post_id":"cjmbx2unc0023w3fy9wdhiem0","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2und0025w3fyl7h406gy"},{"post_id":"cjmbx2unc0023w3fy9wdhiem0","tag_id":"cjmbx2und0024w3fy6yi16gl2","_id":"cjmbx2und0026w3fy52t3p9eo"},{"post_id":"cjmbx2une0027w3fydib615dm","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2une0028w3fy6tt1ypgh"},{"post_id":"cjmbx2une0027w3fydib615dm","tag_id":"cjmbx2und0024w3fy6yi16gl2","_id":"cjmbx2une0029w3fynov6un6u"},{"post_id":"cjmbx2unf002aw3fyhjxekgru","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2ung002bw3fy3i2ho40w"},{"post_id":"cjmbx2unf002aw3fyhjxekgru","tag_id":"cjmbx2und0024w3fy6yi16gl2","_id":"cjmbx2ung002cw3fy5kvrimk7"},{"post_id":"cjmbx2unh002dw3fy743muq5g","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2uni002fw3fy8uv9vu8n"},{"post_id":"cjmbx2unh002dw3fy743muq5g","tag_id":"cjmbx2uni002ew3fys0usu1o2","_id":"cjmbx2uni002gw3fya1f10wkw"},{"post_id":"cjmbx2unk002hw3fyqfnzmwph","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2unk002iw3fylku5wvkw"},{"post_id":"cjmbx2unk002hw3fyqfnzmwph","tag_id":"cjmbx2umg000rw3fykagoyw5z","_id":"cjmbx2unk002jw3fy4xyjhuco"},{"post_id":"cjmbx2unl002kw3fypydl5xex","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2unm002lw3fyba6vuoja"},{"post_id":"cjmbx2unl002kw3fypydl5xex","tag_id":"cjmbx2un0001mw3fylefixbrj","_id":"cjmbx2unm002mw3fy3d0531wx"},{"post_id":"cjmbx2unn002nw3fyc8sr2g16","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2uno002pw3fyhj7559dx"},{"post_id":"cjmbx2unn002nw3fyc8sr2g16","tag_id":"cjmbx2uno002ow3fy3tqvjw0u","_id":"cjmbx2uno002qw3fy284l18cu"},{"post_id":"cjmbx2unp002rw3fyg5scrcnp","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2unq002sw3fylgpes8ud"},{"post_id":"cjmbx2unp002rw3fyg5scrcnp","tag_id":"cjmbx2uno002ow3fy3tqvjw0u","_id":"cjmbx2unq002tw3fycv5i67uo"},{"post_id":"cjmbx2unr002uw3fy13riwbn4","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2uns002vw3fygtz4l2yu"},{"post_id":"cjmbx2unr002uw3fy13riwbn4","tag_id":"cjmbx2uno002ow3fy3tqvjw0u","_id":"cjmbx2uns002ww3fy1luy0r7g"},{"post_id":"cjmbx2unt002xw3fyslozod29","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2unu002yw3fy6c8szypm"},{"post_id":"cjmbx2unt002xw3fyslozod29","tag_id":"cjmbx2uno002ow3fy3tqvjw0u","_id":"cjmbx2unu002zw3fycjce3oy9"},{"post_id":"cjmbx2unw0030w3fytq2ahq7n","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2unw0031w3fy709b4cil"},{"post_id":"cjmbx2unw0030w3fytq2ahq7n","tag_id":"cjmbx2umc000iw3fyomj23qu8","_id":"cjmbx2unw0032w3fyyeuchiwc"},{"post_id":"cjmbx2unz0033w3fyvidxkwt1","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2uo00034w3fyvg962tsc"},{"post_id":"cjmbx2unz0033w3fyvidxkwt1","tag_id":"cjmbx2umc000iw3fyomj23qu8","_id":"cjmbx2uo00035w3fyzdu0wjhk"},{"post_id":"cjmbx2uo20036w3fyp3jldgq4","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2uo30037w3fymm6kd9p0"},{"post_id":"cjmbx2uo20036w3fyp3jldgq4","tag_id":"cjmbx2umc000iw3fyomj23qu8","_id":"cjmbx2uo30038w3fyoxa1kd1y"},{"post_id":"cjmbx2uo20036w3fyp3jldgq4","tag_id":"cjmbx2un0001mw3fylefixbrj","_id":"cjmbx2uo40039w3fydt4wd885"},{"post_id":"cjmbx2uo5003aw3fysz9r6oki","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2uo6003bw3fyv2p61rvc"},{"post_id":"cjmbx2uo5003aw3fysz9r6oki","tag_id":"cjmbx2umc000iw3fyomj23qu8","_id":"cjmbx2uo6003cw3fyiqkg1wq9"},{"post_id":"cjmbx2uo7003dw3fyjum8ri7q","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2uo7003ew3fyol9lptpy"},{"post_id":"cjmbx2uo7003dw3fyjum8ri7q","tag_id":"cjmbx2umg000rw3fykagoyw5z","_id":"cjmbx2uo7003fw3fyoypdsxu8"},{"post_id":"cjmbx2uo9003gw3fy2b5d2el8","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2uoa003hw3fyorslajyv"},{"post_id":"cjmbx2uo9003gw3fy2b5d2el8","tag_id":"cjmbx2umg000rw3fykagoyw5z","_id":"cjmbx2uoa003iw3fyh1o5ojfd"},{"post_id":"cjmbx2uod003jw3fyzp0embo6","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2uod003kw3fyu28wzekb"},{"post_id":"cjmbx2uod003jw3fyzp0embo6","tag_id":"cjmbx2umg000rw3fykagoyw5z","_id":"cjmbx2uoe003lw3fyavup8lnl"},{"post_id":"cjmbx2uof003mw3fy149zgs2g","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2uof003nw3fy59w3b7r9"},{"post_id":"cjmbx2uof003mw3fy149zgs2g","tag_id":"cjmbx2umg000rw3fykagoyw5z","_id":"cjmbx2uof003ow3fy0s5epalm"},{"post_id":"cjmbx2uog003pw3fypssoih65","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2uoh003qw3fybj2tuoxh"},{"post_id":"cjmbx2uog003pw3fypssoih65","tag_id":"cjmbx2umg000rw3fykagoyw5z","_id":"cjmbx2uoi003rw3fyr5djb4zp"},{"post_id":"cjmbx2uoj003sw3fy38pti8g8","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2uoj003tw3fyc674za9y"},{"post_id":"cjmbx2uoj003sw3fy38pti8g8","tag_id":"cjmbx2umc000jw3fy1vsc2f95","_id":"cjmbx2uoj003uw3fy5ihj7ma3"},{"post_id":"cjmbx2uok003vw3fy99o472lm","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2uol003ww3fyk1cu7x58"},{"post_id":"cjmbx2uok003vw3fy99o472lm","tag_id":"cjmbx2umc000jw3fy1vsc2f95","_id":"cjmbx2uol003xw3fy45znpjeq"},{"post_id":"cjmbx2uol003yw3fyrchf16qo","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2uon003zw3fyx5usx02w"},{"post_id":"cjmbx2uol003yw3fyrchf16qo","tag_id":"cjmbx2umc000iw3fyomj23qu8","_id":"cjmbx2uon0040w3fyhibtynph"},{"post_id":"cjmbx2uoo0041w3fyigrtzpmm","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2uop0042w3fyasmma5h3"},{"post_id":"cjmbx2uoo0041w3fyigrtzpmm","tag_id":"cjmbx2umc000iw3fyomj23qu8","_id":"cjmbx2uop0043w3fyapr4e7em"},{"post_id":"cjmbx2uop0044w3fywgr1cnpd","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2uoq0045w3fyl9vjt91p"},{"post_id":"cjmbx2uop0044w3fywgr1cnpd","tag_id":"cjmbx2umc000iw3fyomj23qu8","_id":"cjmbx2uoq0046w3fyj356s1oh"},{"post_id":"cjmbx2uor0047w3fybgu4ci9v","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2uor0048w3fyhlp4lzm2"},{"post_id":"cjmbx2uor0047w3fybgu4ci9v","tag_id":"cjmbx2umc000iw3fyomj23qu8","_id":"cjmbx2uos0049w3fyh6jhpbm9"},{"post_id":"cjmbx2uos004aw3fy4dk6i2gj","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2uot004bw3fyu0ahr4sr"},{"post_id":"cjmbx2uos004aw3fy4dk6i2gj","tag_id":"cjmbx2umc000iw3fyomj23qu8","_id":"cjmbx2uot004cw3fyay3rb8hs"},{"post_id":"cjmbx2uou004dw3fy9cebx5nk","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2uow004ew3fy77haux3q"},{"post_id":"cjmbx2uou004dw3fy9cebx5nk","tag_id":"cjmbx2umc000iw3fyomj23qu8","_id":"cjmbx2uow004fw3fyzdye9tkv"},{"post_id":"cjmbx2uoy004gw3fybvtrkg5a","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2uoz004hw3fy6x3y9u4u"},{"post_id":"cjmbx2uoy004gw3fybvtrkg5a","tag_id":"cjmbx2umc000iw3fyomj23qu8","_id":"cjmbx2uoz004iw3fyivl921c0"},{"post_id":"cjmbx2up0004jw3fylqzunz1y","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2up1004kw3fyfzo1jzf1"},{"post_id":"cjmbx2up0004jw3fylqzunz1y","tag_id":"cjmbx2umc000iw3fyomj23qu8","_id":"cjmbx2up1004lw3fychtw1t4a"},{"post_id":"cjmbx2up2004mw3fy448q425r","tag_id":"cjmbx2um20004w3fyfa7z0t84","_id":"cjmbx2up2004nw3fyvulebbks"},{"post_id":"cjmbx2up2004mw3fy448q425r","tag_id":"cjmbx2umc000iw3fyomj23qu8","_id":"cjmbx2up2004ow3fytoz7mq9b"}],"Tag":[{"name":"技术相关","_id":"cjmbx2um20004w3fyfa7z0t84"},{"name":"设计模式","_id":"cjmbx2um30005w3fy54yl7u7s"},{"name":"读书笔记","_id":"cjmbx2um60009w3fypin7jl4q"},{"name":"Android","_id":"cjmbx2umc000iw3fyomj23qu8"},{"name":"单元测试","_id":"cjmbx2umc000jw3fy1vsc2f95"},{"name":"java","_id":"cjmbx2umg000rw3fykagoyw5z"},{"name":"Http协议","_id":"cjmbx2ump0016w3fy8fbcr2xs"},{"name":"C/C++","_id":"cjmbx2un0001mw3fylefixbrj"},{"name":"hexo","_id":"cjmbx2un7001uw3fy6cbiwkns"},{"name":"lua","_id":"cjmbx2und0024w3fy6yi16gl2"},{"name":"kotlin","_id":"cjmbx2uni002ew3fys0usu1o2"},{"name":"编译相关","_id":"cjmbx2uno002ow3fy3tqvjw0u"}]}}