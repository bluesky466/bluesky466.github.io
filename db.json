{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0},{"_id":"source/责任链模式/链式结构.png","path":"责任链模式/链式结构.png","modified":0},{"_id":"source/责任链模式/Touch事件传递过程.png","path":"责任链模式/Touch事件传递过程.png","modified":0},{"_id":"source/责任链模式/Touch事件传递机制例子.png","path":"责任链模式/Touch事件传递机制例子.png","modified":0},{"_id":"source/学习HTTP协议-用socket实现http访问/7.jpg","path":"学习HTTP协议-用socket实现http访问/7.jpg","modified":0},{"_id":"source/学习HTTP协议-用socket实现http访问/6.jpg","path":"学习HTTP协议-用socket实现http访问/6.jpg","modified":0},{"_id":"source/学习HTTP协议-用socket实现http访问/5.jpg","path":"学习HTTP协议-用socket实现http访问/5.jpg","modified":0},{"_id":"source/学习HTTP协议-用socket实现http访问/4.jpg","path":"学习HTTP协议-用socket实现http访问/4.jpg","modified":0},{"_id":"source/学习HTTP协议-用socket实现http访问/3.jpg","path":"学习HTTP协议-用socket实现http访问/3.jpg","modified":0},{"_id":"source/学习HTTP协议-用socket实现http访问/2.jpg","path":"学习HTTP协议-用socket实现http访问/2.jpg","modified":0},{"_id":"source/学习HTTP协议-用socket实现http访问/1.jpg","path":"学习HTTP协议-用socket实现http访问/1.jpg","modified":0},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/9.jpg","path":"学习HTTP协议-在安卓上的使用Cookie与Session/9.jpg","modified":0},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/8.jpg","path":"学习HTTP协议-在安卓上的使用Cookie与Session/8.jpg","modified":0},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/7.jpg","path":"学习HTTP协议-在安卓上的使用Cookie与Session/7.jpg","modified":0},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/6.jpg","path":"学习HTTP协议-在安卓上的使用Cookie与Session/6.jpg","modified":0},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/5.jpg","path":"学习HTTP协议-在安卓上的使用Cookie与Session/5.jpg","modified":0},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/4.jpg","path":"学习HTTP协议-在安卓上的使用Cookie与Session/4.jpg","modified":0},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/3.jpg","path":"学习HTTP协议-在安卓上的使用Cookie与Session/3.jpg","modified":0},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/2.jpg","path":"学习HTTP协议-在安卓上的使用Cookie与Session/2.jpg","modified":0},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/1.jpg","path":"学习HTTP协议-在安卓上的使用Cookie与Session/1.jpg","modified":0},{"_id":"source/在android上使用grpc/proto_gen.jpeg","path":"在android上使用grpc/proto_gen.jpeg","modified":0},{"_id":"themes/fexo/source/sass/styles.scss","path":"sass/styles.scss","modified":0},{"_id":"source/head.jpg","path":"head.jpg","modified":0},{"_id":"themes/fexo/source/sass/component/prev-net.scss","path":"sass/component/prev-net.scss","modified":0},{"_id":"themes/fexo/source/js/zenscroll.js","path":"js/zenscroll.js","modified":0},{"_id":"themes/fexo/source/js/util.js","path":"js/util.js","modified":0},{"_id":"themes/fexo/source/js/scroll-spy.js","path":"js/scroll-spy.js","modified":0},{"_id":"themes/fexo/source/js/fastclick.js","path":"js/fastclick.js","modified":0},{"_id":"themes/fexo/source/js/bundle.js","path":"js/bundle.js","modified":0},{"_id":"themes/fexo/source/js/app.js","path":"js/app.js","modified":0},{"_id":"themes/fexo/source/images/avatar.jpeg","path":"images/avatar.jpeg","modified":0},{"_id":"themes/fexo/source/fonts/fontello.woff2","path":"fonts/fontello.woff2","modified":0},{"_id":"themes/fexo/source/fonts/fontello.woff","path":"fonts/fontello.woff","modified":0},{"_id":"themes/fexo/source/fonts/fontello.ttf","path":"fonts/fontello.ttf","modified":0},{"_id":"themes/fexo/source/fonts/fontello.svg","path":"fonts/fontello.svg","modified":0},{"_id":"themes/fexo/source/fonts/fontello.eot","path":"fonts/fontello.eot","modified":0},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff2","path":"fonts/calligraffitti-regular-webfont.woff2","modified":0},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff","path":"fonts/calligraffitti-regular-webfont.woff","modified":0},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.ttf","path":"fonts/calligraffitti-regular-webfont.ttf","modified":0},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.svg","path":"fonts/calligraffitti-regular-webfont.svg","modified":0},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.eot","path":"fonts/calligraffitti-regular-webfont.eot","modified":0},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.woff","path":"fonts/PoiretOne-Regular.woff","modified":0},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.ttf","path":"fonts/PoiretOne-Regular.ttf","modified":0},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.svg","path":"fonts/PoiretOne-Regular.svg","modified":0},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.eot","path":"fonts/PoiretOne-Regular.eot","modified":0},{"_id":"themes/fexo/source/fonts/Lobster-Regular.woff","path":"fonts/Lobster-Regular.woff","modified":0},{"_id":"themes/fexo/source/fonts/Lobster-Regular.ttf","path":"fonts/Lobster-Regular.ttf","modified":0},{"_id":"themes/fexo/source/fonts/Lobster-Regular.svg","path":"fonts/Lobster-Regular.svg","modified":0},{"_id":"themes/fexo/source/fonts/Lobster-Regular.eot","path":"fonts/Lobster-Regular.eot","modified":0},{"_id":"themes/fexo/source/css/styles.css.map","path":"css/styles.css.map","modified":0},{"_id":"themes/fexo/source/css/styles.css","path":"css/styles.css","modified":0},{"_id":"source/ToolBar-学习笔记/5.jpg","path":"ToolBar-学习笔记/5.jpg","modified":0},{"_id":"source/ToolBar-学习笔记/4.jpg","path":"ToolBar-学习笔记/4.jpg","modified":0},{"_id":"source/ToolBar-学习笔记/3.jpg","path":"ToolBar-学习笔记/3.jpg","modified":0},{"_id":"source/ToolBar-学习笔记/2.jpg","path":"ToolBar-学习笔记/2.jpg","modified":0},{"_id":"source/ToolBar-学习笔记/1.jpg","path":"ToolBar-学习笔记/1.jpg","modified":0},{"_id":"source/Retrofit-学习笔记/8.jpg","path":"Retrofit-学习笔记/8.jpg","modified":0},{"_id":"source/Retrofit-学习笔记/7.jpg","path":"Retrofit-学习笔记/7.jpg","modified":0},{"_id":"source/Retrofit-学习笔记/6.jpg","path":"Retrofit-学习笔记/6.jpg","modified":0},{"_id":"source/Retrofit-学习笔记/5.jpg","path":"Retrofit-学习笔记/5.jpg","modified":0},{"_id":"source/Retrofit-学习笔记/4.jpg","path":"Retrofit-学习笔记/4.jpg","modified":0},{"_id":"source/Retrofit-学习笔记/3.jpg","path":"Retrofit-学习笔记/3.jpg","modified":0},{"_id":"source/Retrofit-学习笔记/2.jpg","path":"Retrofit-学习笔记/2.jpg","modified":0},{"_id":"source/Retrofit-学习笔记/1.jpg","path":"Retrofit-学习笔记/1.jpg","modified":0},{"_id":"source/GTest实例解析/1.jpg","path":"GTest实例解析/1.jpg","modified":0},{"_id":"source/DrawerLayout-学习笔记/7.jpg","path":"DrawerLayout-学习笔记/7.jpg","modified":0},{"_id":"source/DrawerLayout-学习笔记/6.jpg","path":"DrawerLayout-学习笔记/6.jpg","modified":0},{"_id":"source/DrawerLayout-学习笔记/5.jpg","path":"DrawerLayout-学习笔记/5.jpg","modified":0},{"_id":"source/DrawerLayout-学习笔记/4.jpg","path":"DrawerLayout-学习笔记/4.jpg","modified":0},{"_id":"source/DrawerLayout-学习笔记/3.jpg","path":"DrawerLayout-学习笔记/3.jpg","modified":0},{"_id":"source/DrawerLayout-学习笔记/2.jpg","path":"DrawerLayout-学习笔记/2.jpg","modified":0},{"_id":"source/DrawerLayout-学习笔记/1.jpg","path":"DrawerLayout-学习笔记/1.jpg","modified":0}],"Cache":[{"_id":"source/CNAME","shasum":"c7cb3d91a694837c9e8ffb170e337117ff6ce49d","modified":1494631153524},{"_id":"source/DrawerLayout-学习笔记/1.jpg","shasum":"1a1368dfbac23b479812fe84f102184d549a4c98","modified":1494631153524},{"_id":"source/DrawerLayout-学习笔记/2.jpg","shasum":"8d7c95ce009525f48e47a6de17e8f4d96347068b","modified":1494631153524},{"_id":"source/DrawerLayout-学习笔记/3.jpg","shasum":"bd3d95b33b66306f61cfed5a869a5091496a2f08","modified":1494631153524},{"_id":"source/DrawerLayout-学习笔记/6.jpg","shasum":"8c9fe475e5beb5b877886843d335cab1449df347","modified":1494631153524},{"_id":"source/DrawerLayout-学习笔记/4.jpg","shasum":"d64e85ba03bd98399ac3b6b68d99ef30da19b3b1","modified":1494631153524},{"_id":"source/DrawerLayout-学习笔记/5.jpg","shasum":"d830ab772f92330b2c5e7476dc6ca3fec343d550","modified":1494631153524},{"_id":"source/DrawerLayout-学习笔记/7.jpg","shasum":"180a84f0559f14906d924067241ea5b74ee27e39","modified":1494631153524},{"_id":"source/Retrofit-学习笔记/2.jpg","shasum":"1577be4677801ddbbc25c5af5d1466f04a10f0cb","modified":1494631153524},{"_id":"source/Retrofit-学习笔记/3.jpg","shasum":"4646315828e672833e42450949da1d5f99897907","modified":1494631153524},{"_id":"source/Retrofit-学习笔记/4.jpg","shasum":"7d9ba9c23107656f00ade70544658e96f72c1453","modified":1494631153524},{"_id":"source/Retrofit-学习笔记/5.jpg","shasum":"7147cb1e0ed1d771d71cda564af15369e32c82cc","modified":1494631153528},{"_id":"source/Retrofit-学习笔记/6.jpg","shasum":"af52d69d5bca71994c2818df74b1985c3077748b","modified":1494631153528},{"_id":"source/Retrofit-学习笔记/7.jpg","shasum":"5bbb31731860d741fc6440e00af04e2d171ef6f4","modified":1494631153528},{"_id":"source/Retrofit-学习笔记/8.jpg","shasum":"a9b081cbf55a638728dfa4a220ab3e53525bba7d","modified":1494631153528},{"_id":"source/ToolBar-学习笔记/1.jpg","shasum":"25a1dfbe2965580783076680941c4d25f252c512","modified":1494631153528},{"_id":"source/ToolBar-学习笔记/2.jpg","shasum":"3fb70bb82f049f3ab465b87cb6e07e9036fc4f36","modified":1494631153528},{"_id":"source/ToolBar-学习笔记/3.jpg","shasum":"714276352a2a1c690098d9843740503b27623fbd","modified":1494631153528},{"_id":"source/_posts/CNAME","shasum":"c7cb3d91a694837c9e8ffb170e337117ff6ce49d","modified":1494631153528},{"_id":"source/ToolBar-学习笔记/4.jpg","shasum":"17a1219db2c52dfa273a46a8593e55bfe3631d92","modified":1494631153528},{"_id":"source/ToolBar-学习笔记/5.jpg","shasum":"574f078706926749984a044666681d08529a6a72","modified":1494631153528},{"_id":"source/_posts/DrawerLayout-学习笔记.md","shasum":"9849e8e69f74ce45ef5ff2e9893c5939dcff5e6b","modified":1494631153528},{"_id":"source/_posts/GTest实例解析.md","shasum":"aa7f06092fdd08bf50ea677f4ee4c45705a81d9c","modified":1494631153528},{"_id":"source/_posts/GTest源码剖析-测试代码的注册.md","shasum":"8c7d4c54b4eef28f141bb3b65e1147171b390ade","modified":1494631153528},{"_id":"source/_posts/Java自定义注解和动态代理.md","shasum":"d394fe80690fae1b38266601ebf4dacc6999eb97","modified":1494631153528},{"_id":"source/_posts/Retrofit-学习笔记.md","shasum":"ba9ef61e736ea0b47d05379b6bef87d543adfdd9","modified":1494631153528},{"_id":"source/_posts/automake学习笔记-helloworld.md","shasum":"06587fcda8edeee57cc48b8f868628af47b8d7f7","modified":1494631153528},{"_id":"source/_posts/ToolBar-学习笔记.md","shasum":"e1cfa7f36e8699ec06afaf84c48f96bda5a1c910","modified":1494631153528},{"_id":"source/_posts/automake学习笔记-交叉编译.md","shasum":"c7381d6f35b5d0a3261c3220dd64707199fa7f54","modified":1494631153528},{"_id":"source/_posts/automake学习笔记-安装与发布.md","shasum":"23ec0d4e5bea91372bd2b5f5da2858b6a728029e","modified":1494631153528},{"_id":"source/_posts/lua元表.md","shasum":"e86dc72e42c907c3e5df2d160871824b170a3377","modified":1494631153528},{"_id":"source/_posts/lua泛型for的原理.md","shasum":"11a8c82e136bb0201f695ba76fc2fdba262ec429","modified":1494631153528},{"_id":"source/_posts/automake学习笔记-模块化编译.md","shasum":"fd7f2322a06dd2eddea3b9bb8dc2618f73624531","modified":1494631153528},{"_id":"source/_posts/lua面向对象编程.md","shasum":"690559730552eeedda2ffafcb6d0663b39ab53af","modified":1494631153528},{"_id":"source/_posts/使用hexo搭建个人博客.md","shasum":"6762d527a4ee975d2483f44a738ba6176794ee09","modified":1494631153528},{"_id":"source/_posts/在android上使用grpc.md","shasum":"37a83a7ea28c74db374c72723281d25bb5778758","modified":1494631153528},{"_id":"source/_posts/学习HTTP协议-在安卓上的使用Cookie与Session.md","shasum":"7917d8d7633df60e909423f3049e85ee325f0958","modified":1494631153528},{"_id":"source/_posts/读书笔记-《代码整洁之道》.md","shasum":"dacdb73f75fdcf62e6889877b6adff75cc496fb5","modified":1494631153532},{"_id":"source/_posts/读书笔记-《第一行代码——Android》.md","shasum":"44cc0d3e1d57a7cc8caa85a00907e876fa664890","modified":1494631153532},{"_id":"source/_posts/学习HTTP协议-用socket实现http访问.md","shasum":"b0db2869ccd84aa78032a55bdc634c3b7932fbbe","modified":1494631153528},{"_id":"source/_posts/读书笔记-《道法自然—面向对象实践指南》.md","shasum":"4f91e87b0681c97b835afece0c10d3adc816fa63","modified":1494631153532},{"_id":"source/_posts/读书笔记-《黑客与画家》.md","shasum":"6e80889acc4b826130c4d6b3682173c2b70e4e06","modified":1494631153532},{"_id":"source/about/index.md","shasum":"bc1e33abe97db8273e6b12f35bb578534dde20a2","modified":1494631153532},{"_id":"source/head.jpg","shasum":"02cfa3e329a8fff4756f336b15488a3f6fa0e783","modified":1494631153532},{"_id":"source/link/index.md","shasum":"357e194d549590b0ff8dcf404137578b10530196","modified":1494631153532},{"_id":"source/_posts/责任链模式.md","shasum":"0189e326bde002d983bfd4634074946b756e5614","modified":1494631153532},{"_id":"source/tag/index.md","shasum":"34c7b76f347ad9f82a1b085bc6691d24c8fb126b","modified":1494631153532},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/4.jpg","shasum":"3a79ec8254a714302c108f80edf52eb34f97ba76","modified":1494631153532},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/2.jpg","shasum":"37042f8420bb0d38c2b8829b8921907ab3b7ba75","modified":1494631153532},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/5.jpg","shasum":"48bb3883ee86eaef233065c106e6cb681df4fcee","modified":1494631153532},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/6.jpg","shasum":"fcbaab58a97f22457892caf6e7549a34ce6ce242","modified":1494631153532},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/3.jpg","shasum":"a4cd99529e06cde03c86de83ad798981c8a916ac","modified":1494631153532},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/9.jpg","shasum":"cd77fb9f1242143d8430958a0b19fea94f1f5c4a","modified":1494631153532},{"_id":"source/_posts/Dagger2学习笔记-一.md","shasum":"f5af195534613cd8e21cd199cf2930f776b6331a","modified":1494945920762},{"_id":"source/学习HTTP协议-用socket实现http访问/3.jpg","shasum":"745d3eb20e1d42ed0ccad9596d5efe2c59f619a7","modified":1494631153536},{"_id":"source/学习HTTP协议-用socket实现http访问/4.jpg","shasum":"f84a7d6674febbe035a6dccdd311dd5e406b5dc4","modified":1494631153536},{"_id":"source/学习HTTP协议-用socket实现http访问/5.jpg","shasum":"5c8d09c4b8742d59d7c7b72c5a9c46b5c7b372a4","modified":1494631153536},{"_id":"source/学习HTTP协议-用socket实现http访问/6.jpg","shasum":"6ca6b0a230be1d9f4c16beccfcbb2b144a7a08b0","modified":1494631153536},{"_id":"source/学习HTTP协议-用socket实现http访问/7.jpg","shasum":"d76e0337a125de3fca3c520dec0bcdfd8464872c","modified":1494631153540},{"_id":"source/责任链模式/Touch事件传递机制例子.png","shasum":"0e3c89ec086baf4bbf09c3f4059c1144858f48ad","modified":1494631153540},{"_id":"source/责任链模式/链式结构.png","shasum":"3f6938381305c17724f5fa9bf3a5eed0ffe7bfbb","modified":1494631153540},{"_id":"source/GTest实例解析/1.jpg","shasum":"b93eed3e0078af4a801df5f03e05e60ee5818e31","modified":1494631153524},{"_id":"source/Retrofit-学习笔记/1.jpg","shasum":"df6d9b6866a07723a2d9ae476e0678da06c34b6c","modified":1494631153524},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/1.jpg","shasum":"01fee1734f999cf6907e7363bf940f259cdbd096","modified":1494631153532},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/7.jpg","shasum":"ccd9492ddd2c01bb6e23bdea7fb5b0c564ead0b5","modified":1494631153532},{"_id":"source/学习HTTP协议-在安卓上的使用Cookie与Session/8.jpg","shasum":"0603ad18102173f78c6171a464409a354360f5d6","modified":1494631153532},{"_id":"source/责任链模式/Touch事件传递过程.png","shasum":"62b88092173964ebd41fc77e4e6fcacdb506e3fc","modified":1494631153540},{"_id":"source/在android上使用grpc/proto_gen.jpeg","shasum":"d8115287cbf64e80bf258adef0d9ba51c033733d","modified":1494631153532},{"_id":"themes/fexo/source/sass/pages/_tag.scss","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1494631153552},{"_id":"source/学习HTTP协议-用socket实现http访问/1.jpg","shasum":"300cc7098c616d5c2e0b28db47d2dc8b1732ef75","modified":1494631153536},{"_id":"themes/fexo/LICENSE","shasum":"db4cb5aef6072a96721b5428fdd999647c049d55","modified":1494631153540},{"_id":"themes/fexo/README.md","shasum":"35cd346c229e17ed83609ee94b5d6493c4ab9982","modified":1494631153540},{"_id":"themes/fexo/_config.yml","shasum":"8fd881533d6ae95165480fe83d43f29e54056352","modified":1494631153540},{"_id":"themes/fexo/languages/default.yml","shasum":"1a6762d52295b0f7586f40c35e713c0fd33c2a2b","modified":1494631153540},{"_id":"themes/fexo/gulpfile.js","shasum":"5995b9c4e8e18d1670ad30b2881d49fa17e56415","modified":1494631153540},{"_id":"themes/fexo/languages/en.yml","shasum":"b58364c7dfac61eddd64510f74ca7516da48f0cf","modified":1494631153540},{"_id":"themes/fexo/languages/no.yml","shasum":"bf11017d77f64fbafb9c99ac219d076b20d53afc","modified":1494631153540},{"_id":"themes/fexo/languages/zh-CN.yml","shasum":"1a6762d52295b0f7586f40c35e713c0fd33c2a2b","modified":1494631153540},{"_id":"themes/fexo/languages/zh-TW.yml","shasum":"6141b4c7a094c74bd9df7c08908d92b561c1a0c0","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/article.ejs","shasum":"ab0adc8f18a96eab18bb584233c0e8d4ddba71fc","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/baidu-analytics.ejs","shasum":"c19e4abec19c23840fff7f8a51f4aefbb2b7e8ca","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/component/back-top.ejs","shasum":"47f2b8306b901f0fffc6aa0cfa40db697a0c5aff","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/component/category-box.ejs","shasum":"f18e08e5c8718d5cd6672fc01e25ba457db0a385","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/component/category.ejs","shasum":"2429158ff177b8876de765498b54d0c91b3fc551","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/baidu-push.ejs","shasum":"6950255d74efac8811d5b05d0d7a263c3c96486d","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/component/comments.ejs","shasum":"043ed1e5625860696fe42bb88c998668faf71449","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/component/date.ejs","shasum":"163fbd874481cb9e2b6da5282701a3fbaa4e367a","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/component/disqus.ejs","shasum":"21de7498d235a52337335108fce7446e1a21ea1c","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/component/donation.ejs","shasum":"65bf93ad8e149033e6f93d673cc85ee223615589","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/component/duoshuo.ejs","shasum":"b732200315e4c82e92bc7bd0ad33eb171d246e26","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/component/gentie.ejs","shasum":"9b78a138fb93a71b481ab25c8dea2e082e5e9d6c","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/component/item-category-name.ejs","shasum":"8ab52c9b5d5db1d3c1d343ecb405c4e15cd144ac","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/component/item-post.ejs","shasum":"722e5dbde2d4683eea08f2af922358db45b253b1","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/component/item-tag.ejs","shasum":"1b4c4e090c33ccfd44b531a5de9af16eec266512","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/component/item-year.ejs","shasum":"906a6aea44a30e83c4c4e449294c7e4d831c188e","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/component/modal.ejs","shasum":"8edceb2fd6c770691bd5cf4a35236c1def8410fe","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/component/page-header.ejs","shasum":"14bad32082d87d7eeb45c0e9079e72f0ae65dbf4","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/component/pagination.ejs","shasum":"ffbb548aee6e15cae924ee7f922f28b2403e8e45","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/component/prev-net.ejs","shasum":"d1cb2e61814bcbd25ccb1628f99b18316e029892","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/component/tag-box.ejs","shasum":"d648ea91ec9dc72bca80d70fbb66f7655bd0ea12","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/component/tag-list.ejs","shasum":"8535c40b573744ced738b051383c0feca80eb0e9","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/component/title.ejs","shasum":"e2fcdd904123186648513cfca4c7ad04921d2d57","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/component/toc.ejs","shasum":"000be428e925f5595af29eeba37ba6111f7f6511","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/component/toolbox.ejs","shasum":"fcfcccc5b231c4050f1a665b70f7738f9d070541","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/google-analytics.ejs","shasum":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/head.ejs","shasum":"794916e761ea82fb606a2173af68e9bf524f6efb","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/home.ejs","shasum":"225b8a001c7aace46f2b39676e968e7cba9a4277","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/load-script.ejs","shasum":"4675c917548817118f4a3c5d84acc98d6c61a1d8","modified":1494631153540},{"_id":"themes/fexo/layout/_partial/style.ejs","shasum":"d1e80d7cf8b22929f5c6d8590eac38b069ea055d","modified":1494631153540},{"_id":"themes/fexo/layout/about.ejs","shasum":"f1f06842f3fac2c7dd74811722431c5720e6cf8d","modified":1494631153540},{"_id":"themes/fexo/layout/archive.ejs","shasum":"9c22251c328e937c444a9f5d4b324f97a78d324f","modified":1494631153540},{"_id":"themes/fexo/layout/category.ejs","shasum":"6d7f43a3d3180e7eb120601bae701664911cf8e6","modified":1494631153540},{"_id":"themes/fexo/layout/index.ejs","shasum":"9d33cd03e7a8adf8bbc124c248def36c15e681d0","modified":1494631153540},{"_id":"themes/fexo/layout/layout.ejs","shasum":"ae485be0f6c0c431245e0cac21dc109c9d0125e8","modified":1494631153540},{"_id":"themes/fexo/layout/link.ejs","shasum":"0144bdb1bc5f19763535b79b3302bf85bc0afbff","modified":1494631153540},{"_id":"themes/fexo/layout/post.ejs","shasum":"8cf15be489f8f3c11ac0215c16cbce36c854555f","modified":1494631153540},{"_id":"themes/fexo/layout/project.ejs","shasum":"6648041e1319c8ee3e16c882b33bb457c67a9527","modified":1494631153540},{"_id":"themes/fexo/layout/search.ejs","shasum":"8c6fc59bed1facf14dd6a48bdf8dd44452583f4d","modified":1494631153540},{"_id":"themes/fexo/layout/tag.ejs","shasum":"2cadf0acdf7c8e76bd4f27c6d7fe97eefe42ef5e","modified":1494631153540},{"_id":"themes/fexo/package.json","shasum":"351b5b21f5ea8851103ee1891248be43f3c27027","modified":1494631153540},{"_id":"themes/fexo/source/css/styles.css","shasum":"c4d6a1f5403cf2fe2674ba82eb2b32b0fd7dfdb8","modified":1494631153540},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.eot","shasum":"2a4ef0d00fb77d16e37c3da429698b029e7d2d2f","modified":1494631153548},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.ttf","shasum":"2b186ce205301f7f3abd441f0372b72adcd2aee3","modified":1494631153548},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.woff","shasum":"1cebcedde2c52261591bc322b176638798336a24","modified":1494631153548},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.eot","shasum":"4c7bcece73621f648fa71d58fa13c28670fed8ca","modified":1494631153548},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff","shasum":"1364845a3815740c572e29c83fd8d54f1c1ef5de","modified":1494631153552},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff2","shasum":"ba50c427166090361b0dab4c72136c7b451e86d4","modified":1494631153552},{"_id":"themes/fexo/source/fonts/fontello.eot","shasum":"7732065eeaec4614e9548955d9bd30ccd7b149c1","modified":1494631153552},{"_id":"themes/fexo/source/fonts/fontello.svg","shasum":"33a984f4482a5ba5e7bc67d82e8db63cda4e3ae1","modified":1494631153552},{"_id":"themes/fexo/source/fonts/fontello.ttf","shasum":"e255d37ca14348e9a8532667a757ab552e58caff","modified":1494631153552},{"_id":"themes/fexo/source/fonts/fontello.woff","shasum":"45737fea847f3942ef405f00ea4df940fbb6bbd9","modified":1494631153552},{"_id":"themes/fexo/source/fonts/fontello.woff2","shasum":"1dfbc23328582f7cd9bcbe538224f6c762023e43","modified":1494631153552},{"_id":"themes/fexo/source/js/app.js","shasum":"a6d6e7fba3d69d0dec2c4d18debe0dc4cc7ab319","modified":1494631153552},{"_id":"themes/fexo/source/images/avatar.jpeg","shasum":"8070d5f8c87a105b50bb28500c0c1237fae57afb","modified":1494631153552},{"_id":"themes/fexo/source/js/bundle.js","shasum":"7da160b15a43ce19273ec85204828bd42628546f","modified":1494631153552},{"_id":"themes/fexo/source/js/scroll-spy.js","shasum":"81b81362fcd63592045a673b54ce1edb7a6e3028","modified":1494631153552},{"_id":"themes/fexo/source/js/util.js","shasum":"8136da2bec1faf5fe3e14fa436f501292fca8c07","modified":1494631153552},{"_id":"themes/fexo/source/js/fastclick.js","shasum":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1494631153552},{"_id":"themes/fexo/source/sass/_animate.scss","shasum":"8de97c948cb4b9c9b7a87c0f7332ed534c378e26","modified":1494631153552},{"_id":"themes/fexo/source/js/zenscroll.js","shasum":"bea2a3571555fdae64e8fc56f161f9a4f427b335","modified":1494631153552},{"_id":"themes/fexo/source/sass/_base.scss","shasum":"83f01dbe82e47ce781c6e7eb8a793d95d97e168b","modified":1494631153552},{"_id":"themes/fexo/source/sass/_common.scss","shasum":"b1fc97d6d24a92a9a7a9d39be4fe844f5c0f6d44","modified":1494631153552},{"_id":"themes/fexo/source/sass/_fonts.scss","shasum":"10e188d379782ae2ee10427544919557036d0137","modified":1494631153552},{"_id":"themes/fexo/source/sass/_fontello.scss","shasum":"f2d6b86bb63459884cf63e8c045fd10c827396eb","modified":1494631153552},{"_id":"themes/fexo/source/sass/_highlight-js.scss","shasum":"38a5c4d9f3a2943aff9bde1d624d710587e3bc05","modified":1494631153552},{"_id":"themes/fexo/source/sass/_type.scss","shasum":"cc7a25654593030f5214d5adf85f12a954c373c5","modified":1494631153552},{"_id":"themes/fexo/source/sass/_variable.scss","shasum":"7b05581ef035a88bd1191914ff992103c7812bdf","modified":1494631153552},{"_id":"themes/fexo/source/sass/_normalize.scss","shasum":"e58275a588bb631a37a2988145eea231ed23176b","modified":1494631153552},{"_id":"themes/fexo/source/sass/component/_back-top.scss","shasum":"1c67da7007f4b9d8c65deea3d82c0f579e65f2c2","modified":1494631153552},{"_id":"themes/fexo/source/sass/component/_category-box.scss","shasum":"a807145b74d1b98270ea19ae35edd25b4c448bfa","modified":1494631153552},{"_id":"themes/fexo/source/sass/component/_comments.scss","shasum":"3e9b61bc08f38f947f54e942986a19a7f95ce723","modified":1494631153552},{"_id":"themes/fexo/source/sass/component/_donation.scss","shasum":"172a3d5f747ba028d7e10e6f03ebc1db4d487a54","modified":1494631153552},{"_id":"themes/fexo/source/sass/component/_hint.scss","shasum":"2812b4e10313168f2e082b740c60d64a151d94c8","modified":1494631153552},{"_id":"themes/fexo/source/sass/component/_index.scss","shasum":"a741a0bfb47d0acdef12cdeb968c104bb002f86d","modified":1494631153552},{"_id":"themes/fexo/source/sass/component/_item-category-name.scss","shasum":"119840d160cd263b57e79e2099a81079d7eeee3d","modified":1494631153552},{"_id":"themes/fexo/source/sass/component/_item-post.scss","shasum":"1fb2e9be2d2edbb538cfbce7c80d5847f88e2f05","modified":1494631153552},{"_id":"themes/fexo/source/sass/component/_item-title.scss","shasum":"cdaca2858abc9428ef01103a7fbea8f095d856aa","modified":1494631153552},{"_id":"themes/fexo/source/sass/component/_item-year.scss","shasum":"12c147dd4ab9587cd622083c86c2f6cf07d8e26a","modified":1494631153552},{"_id":"themes/fexo/source/sass/component/_list-post.scss","shasum":"43564f6443385bf34e15672d1477d1c7560f5563","modified":1494631153552},{"_id":"themes/fexo/source/sass/component/_page-header.scss","shasum":"893d0595ef48323dce449ef0d17308ce02b36087","modified":1494631153552},{"_id":"themes/fexo/source/sass/component/_modal.scss","shasum":"2f0ed96df388ec28445b1ce5c6a61a0a697f9a68","modified":1494631153552},{"_id":"themes/fexo/source/sass/component/_table.scss","shasum":"4899fb31d1be8d5c9c397fcbcfc2ff0c5b2e7f7f","modified":1494631153552},{"_id":"themes/fexo/source/sass/component/_pagination.scss","shasum":"12c1880c518aee2e3ccf59661d01c308639f8a9e","modified":1494631153552},{"_id":"themes/fexo/source/sass/component/_tag-box.scss","shasum":"7601951d09a75a7c39493bfa1b1da5ac989d9cda","modified":1494631153552},{"_id":"themes/fexo/source/sass/component/_toc.scss","shasum":"3b4c083cb2ba4a88ca35b6d8259ee991c83b3406","modified":1494631153552},{"_id":"themes/fexo/source/sass/component/_toolbox-mobile.scss","shasum":"f15b215b9bb103ee1773a01d8badd81bb7643710","modified":1494631153552},{"_id":"themes/fexo/source/sass/component/prev-net.scss","shasum":"2a5befab6cef93c9023a548422d5af4ab614f84d","modified":1494631153552},{"_id":"themes/fexo/source/sass/component/_toolbox.scss","shasum":"964a480d4e7fad100463195cde2a3f67f9765c23","modified":1494631153552},{"_id":"themes/fexo/source/sass/pages/_about.scss","shasum":"7d61e627ea5376390081e0b93db426ffc6c4dee8","modified":1494631153552},{"_id":"themes/fexo/source/sass/pages/_category.scss","shasum":"713242d10c0c8687c9e2f287f1beeb38de6cdbad","modified":1494631153552},{"_id":"themes/fexo/source/sass/pages/_index.scss","shasum":"d9fe73a87585abad06a7dd77b67ec7ce6c24402c","modified":1494631153552},{"_id":"themes/fexo/source/sass/pages/_link.scss","shasum":"d3a249423c7ee88d1cb3a12e03f6c42a0a4d45a1","modified":1494631153552},{"_id":"themes/fexo/source/sass/pages/_post.scss","shasum":"c6f694568af362f9fe1e7e2b9909e47303178116","modified":1494631153552},{"_id":"themes/fexo/source/sass/pages/_project.scss","shasum":"bcbaded3d378bbaa1497f4c3843994ea589f3149","modified":1494631153552},{"_id":"themes/fexo/source/sass/pages/_search.scss","shasum":"fd28f01829628c9d21f9391d5067ddcd836dad13","modified":1494631153552},{"_id":"themes/fexo/source/sass/styles.scss","shasum":"86ebe05d6a2931dd6fceef1e50c31ca996dc20be","modified":1494631153552},{"_id":"source/学习HTTP协议-用socket实现http访问/2.jpg","shasum":"35480d5b35636ab51af44e48ca77c057bf4e771f","modified":1494631153536},{"_id":"themes/fexo/source/css/styles.css.map","shasum":"8153b0247617810c1333dbd40840975e0b966ecb","modified":1494631153540},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.ttf","shasum":"4688935c427ae40dcbf16523bc11d9fc10e359b5","modified":1494631153552},{"_id":"themes/fexo/source/sass/pages/_archive.scss","shasum":"fefd54282a42ebb68b711f1cfefa1f67abbde05b","modified":1494631153552},{"_id":"themes/fexo/source/sass/pages/_home.scss","shasum":"b65bb069ed28fbf223c5bb7e760882f79d20fa46","modified":1494631153552},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.svg","shasum":"e21109783f218cb7849b12e867e0b775ce3fadda","modified":1494631153548},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.svg","shasum":"76e1e4cee6f2b5d596c635631938ee5eb6ab3e67","modified":1494631153552},{"_id":"source/_posts/npm-debug.log","shasum":"edfa7584626fa0d4a031a9f753e1424e9e77b1c4","modified":1494631153528},{"_id":"themes/fexo/source/fonts/Lobster-Regular.eot","shasum":"4f0c85f63beb0d95610317e16f1d4acdd2962eee","modified":1494631153544},{"_id":"themes/fexo/source/fonts/Lobster-Regular.ttf","shasum":"50a84291b7012bfdcf9ff5116d6c7aa3f257f37f","modified":1494631153548},{"_id":"themes/fexo/source/fonts/Lobster-Regular.woff","shasum":"298b80b1c9f694e1a055d62a5d809863c89baf50","modified":1494631153548},{"_id":"themes/fexo/source/fonts/Lobster-Regular.svg","shasum":"be1cab622c673942fb4d11a23c012227938b4792","modified":1494631153548},{"_id":"public/CNAME","modified":1494946097202,"shasum":"c7cb3d91a694837c9e8ffb170e337117ff6ce49d"},{"_id":"public/责任链模式/链式结构.png","modified":1494946097208,"shasum":"3f6938381305c17724f5fa9bf3a5eed0ffe7bfbb"},{"_id":"public/责任链模式/Touch事件传递过程.png","modified":1494946097212,"shasum":"62b88092173964ebd41fc77e4e6fcacdb506e3fc"},{"_id":"public/责任链模式/Touch事件传递机制例子.png","modified":1494946097215,"shasum":"0e3c89ec086baf4bbf09c3f4059c1144858f48ad"},{"_id":"public/学习HTTP协议-用socket实现http访问/7.jpg","modified":1494946097217,"shasum":"d76e0337a125de3fca3c520dec0bcdfd8464872c"},{"_id":"public/学习HTTP协议-用socket实现http访问/6.jpg","modified":1494946097219,"shasum":"6ca6b0a230be1d9f4c16beccfcbb2b144a7a08b0"},{"_id":"public/学习HTTP协议-用socket实现http访问/5.jpg","modified":1494946097221,"shasum":"5c8d09c4b8742d59d7c7b72c5a9c46b5c7b372a4"},{"_id":"public/学习HTTP协议-用socket实现http访问/4.jpg","modified":1494946097224,"shasum":"f84a7d6674febbe035a6dccdd311dd5e406b5dc4"},{"_id":"public/学习HTTP协议-用socket实现http访问/3.jpg","modified":1494946097227,"shasum":"745d3eb20e1d42ed0ccad9596d5efe2c59f619a7"},{"_id":"public/学习HTTP协议-用socket实现http访问/2.jpg","modified":1494946097230,"shasum":"35480d5b35636ab51af44e48ca77c057bf4e771f"},{"_id":"public/学习HTTP协议-用socket实现http访问/1.jpg","modified":1494946097234,"shasum":"300cc7098c616d5c2e0b28db47d2dc8b1732ef75"},{"_id":"public/学习HTTP协议-在安卓上的使用Cookie与Session/9.jpg","modified":1494946097237,"shasum":"cd77fb9f1242143d8430958a0b19fea94f1f5c4a"},{"_id":"public/学习HTTP协议-在安卓上的使用Cookie与Session/8.jpg","modified":1494946097240,"shasum":"0603ad18102173f78c6171a464409a354360f5d6"},{"_id":"public/学习HTTP协议-在安卓上的使用Cookie与Session/7.jpg","modified":1494946097244,"shasum":"ccd9492ddd2c01bb6e23bdea7fb5b0c564ead0b5"},{"_id":"public/学习HTTP协议-在安卓上的使用Cookie与Session/6.jpg","modified":1494946097246,"shasum":"fcbaab58a97f22457892caf6e7549a34ce6ce242"},{"_id":"public/学习HTTP协议-在安卓上的使用Cookie与Session/5.jpg","modified":1494946097248,"shasum":"48bb3883ee86eaef233065c106e6cb681df4fcee"},{"_id":"public/学习HTTP协议-在安卓上的使用Cookie与Session/4.jpg","modified":1494946097250,"shasum":"3a79ec8254a714302c108f80edf52eb34f97ba76"},{"_id":"public/学习HTTP协议-在安卓上的使用Cookie与Session/3.jpg","modified":1494946097252,"shasum":"a4cd99529e06cde03c86de83ad798981c8a916ac"},{"_id":"public/学习HTTP协议-在安卓上的使用Cookie与Session/2.jpg","modified":1494946097254,"shasum":"37042f8420bb0d38c2b8829b8921907ab3b7ba75"},{"_id":"public/学习HTTP协议-在安卓上的使用Cookie与Session/1.jpg","modified":1494946097259,"shasum":"01fee1734f999cf6907e7363bf940f259cdbd096"},{"_id":"public/在android上使用grpc/proto_gen.jpeg","modified":1494946097261,"shasum":"d8115287cbf64e80bf258adef0d9ba51c033733d"},{"_id":"public/sass/styles.scss","modified":1494946097264,"shasum":"86ebe05d6a2931dd6fceef1e50c31ca996dc20be"},{"_id":"public/head.jpg","modified":1494946097265,"shasum":"02cfa3e329a8fff4756f336b15488a3f6fa0e783"},{"_id":"public/sass/component/prev-net.scss","modified":1494946097270,"shasum":"2a5befab6cef93c9023a548422d5af4ab614f84d"},{"_id":"public/js/zenscroll.js","modified":1494946097273,"shasum":"bea2a3571555fdae64e8fc56f161f9a4f427b335"},{"_id":"public/js/util.js","modified":1494946097275,"shasum":"8136da2bec1faf5fe3e14fa436f501292fca8c07"},{"_id":"public/js/scroll-spy.js","modified":1494946097276,"shasum":"81b81362fcd63592045a673b54ce1edb7a6e3028"},{"_id":"public/js/fastclick.js","modified":1494946097278,"shasum":"06cef196733a710e77ad7e386ced6963f092dc55"},{"_id":"public/js/bundle.js","modified":1494946097281,"shasum":"7da160b15a43ce19273ec85204828bd42628546f"},{"_id":"public/js/app.js","modified":1494946097282,"shasum":"a6d6e7fba3d69d0dec2c4d18debe0dc4cc7ab319"},{"_id":"public/images/avatar.jpeg","modified":1494946097284,"shasum":"8070d5f8c87a105b50bb28500c0c1237fae57afb"},{"_id":"public/fonts/fontello.woff2","modified":1494946097285,"shasum":"1dfbc23328582f7cd9bcbe538224f6c762023e43"},{"_id":"public/fonts/fontello.woff","modified":1494946097287,"shasum":"45737fea847f3942ef405f00ea4df940fbb6bbd9"},{"_id":"public/fonts/fontello.ttf","modified":1494946097289,"shasum":"e255d37ca14348e9a8532667a757ab552e58caff"},{"_id":"public/fonts/fontello.svg","modified":1494946097291,"shasum":"33a984f4482a5ba5e7bc67d82e8db63cda4e3ae1"},{"_id":"public/fonts/fontello.eot","modified":1494946097294,"shasum":"7732065eeaec4614e9548955d9bd30ccd7b149c1"},{"_id":"public/fonts/calligraffitti-regular-webfont.woff2","modified":1494946097298,"shasum":"ba50c427166090361b0dab4c72136c7b451e86d4"},{"_id":"public/fonts/calligraffitti-regular-webfont.woff","modified":1494946097300,"shasum":"1364845a3815740c572e29c83fd8d54f1c1ef5de"},{"_id":"public/fonts/calligraffitti-regular-webfont.ttf","modified":1494946097302,"shasum":"4688935c427ae40dcbf16523bc11d9fc10e359b5"},{"_id":"public/fonts/calligraffitti-regular-webfont.svg","modified":1494946097304,"shasum":"76e1e4cee6f2b5d596c635631938ee5eb6ab3e67"},{"_id":"public/fonts/calligraffitti-regular-webfont.eot","modified":1494946097306,"shasum":"4c7bcece73621f648fa71d58fa13c28670fed8ca"},{"_id":"public/fonts/PoiretOne-Regular.woff","modified":1494946097308,"shasum":"1cebcedde2c52261591bc322b176638798336a24"},{"_id":"public/fonts/PoiretOne-Regular.ttf","modified":1494946097309,"shasum":"2b186ce205301f7f3abd441f0372b72adcd2aee3"},{"_id":"public/fonts/PoiretOne-Regular.svg","modified":1494946097311,"shasum":"e21109783f218cb7849b12e867e0b775ce3fadda"},{"_id":"public/fonts/PoiretOne-Regular.eot","modified":1494946097312,"shasum":"2a4ef0d00fb77d16e37c3da429698b029e7d2d2f"},{"_id":"public/fonts/Lobster-Regular.woff","modified":1494946097316,"shasum":"298b80b1c9f694e1a055d62a5d809863c89baf50"},{"_id":"public/fonts/Lobster-Regular.ttf","modified":1494946097323,"shasum":"50a84291b7012bfdcf9ff5116d6c7aa3f257f37f"},{"_id":"public/fonts/Lobster-Regular.svg","modified":1494946097329,"shasum":"be1cab622c673942fb4d11a23c012227938b4792"},{"_id":"public/fonts/Lobster-Regular.eot","modified":1494946097332,"shasum":"4f0c85f63beb0d95610317e16f1d4acdd2962eee"},{"_id":"public/css/styles.css.map","modified":1494946097335,"shasum":"8153b0247617810c1333dbd40840975e0b966ecb"},{"_id":"public/css/styles.css","modified":1494946097337,"shasum":"c4d6a1f5403cf2fe2674ba82eb2b32b0fd7dfdb8"},{"_id":"public/ToolBar-学习笔记/5.jpg","modified":1494946097339,"shasum":"574f078706926749984a044666681d08529a6a72"},{"_id":"public/ToolBar-学习笔记/4.jpg","modified":1494946097341,"shasum":"17a1219db2c52dfa273a46a8593e55bfe3631d92"},{"_id":"public/ToolBar-学习笔记/3.jpg","modified":1494946097343,"shasum":"714276352a2a1c690098d9843740503b27623fbd"},{"_id":"public/ToolBar-学习笔记/2.jpg","modified":1494946097344,"shasum":"3fb70bb82f049f3ab465b87cb6e07e9036fc4f36"},{"_id":"public/ToolBar-学习笔记/1.jpg","modified":1494946097346,"shasum":"25a1dfbe2965580783076680941c4d25f252c512"},{"_id":"public/Retrofit-学习笔记/8.jpg","modified":1494946097347,"shasum":"a9b081cbf55a638728dfa4a220ab3e53525bba7d"},{"_id":"public/Retrofit-学习笔记/7.jpg","modified":1494946097351,"shasum":"5bbb31731860d741fc6440e00af04e2d171ef6f4"},{"_id":"public/Retrofit-学习笔记/6.jpg","modified":1494946097353,"shasum":"af52d69d5bca71994c2818df74b1985c3077748b"},{"_id":"public/Retrofit-学习笔记/5.jpg","modified":1494946097356,"shasum":"7147cb1e0ed1d771d71cda564af15369e32c82cc"},{"_id":"public/Retrofit-学习笔记/4.jpg","modified":1494946097357,"shasum":"7d9ba9c23107656f00ade70544658e96f72c1453"},{"_id":"public/Retrofit-学习笔记/3.jpg","modified":1494946097358,"shasum":"4646315828e672833e42450949da1d5f99897907"},{"_id":"public/Retrofit-学习笔记/2.jpg","modified":1494946097360,"shasum":"1577be4677801ddbbc25c5af5d1466f04a10f0cb"},{"_id":"public/Retrofit-学习笔记/1.jpg","modified":1494946097363,"shasum":"df6d9b6866a07723a2d9ae476e0678da06c34b6c"},{"_id":"public/GTest实例解析/1.jpg","modified":1494946097365,"shasum":"b93eed3e0078af4a801df5f03e05e60ee5818e31"},{"_id":"public/DrawerLayout-学习笔记/7.jpg","modified":1494946097367,"shasum":"180a84f0559f14906d924067241ea5b74ee27e39"},{"_id":"public/DrawerLayout-学习笔记/6.jpg","modified":1494946097371,"shasum":"8c9fe475e5beb5b877886843d335cab1449df347"},{"_id":"public/DrawerLayout-学习笔记/5.jpg","modified":1494946097373,"shasum":"d830ab772f92330b2c5e7476dc6ca3fec343d550"},{"_id":"public/DrawerLayout-学习笔记/4.jpg","modified":1494946097374,"shasum":"d64e85ba03bd98399ac3b6b68d99ef30da19b3b1"},{"_id":"public/DrawerLayout-学习笔记/3.jpg","modified":1494946097376,"shasum":"bd3d95b33b66306f61cfed5a869a5091496a2f08"},{"_id":"public/DrawerLayout-学习笔记/2.jpg","modified":1494946097377,"shasum":"8d7c95ce009525f48e47a6de17e8f4d96347068b"},{"_id":"public/DrawerLayout-学习笔记/1.jpg","modified":1494946097378,"shasum":"1a1368dfbac23b479812fe84f102184d549a4c98"},{"_id":"public/tag/index.html","modified":1494946097461,"shasum":"7f6d4bdcfd80f2f0149c4b7d31504db20c72969c"},{"_id":"public/link/index.html","modified":1494946097470,"shasum":"e90117d7d0b82608d224cff055601f1ec1730f44"},{"_id":"public/about/index.html","modified":1494946097479,"shasum":"9e9ddd85397b159a15a9cea112b1ce542ac0439d"},{"_id":"public/2017/05/13/Dagger2学习笔记-一/index.html","modified":1494946097527,"shasum":"0b18a5f660ba2e0c7f11e41d0aa6f7f4d83fe988"},{"_id":"public/2017/04/02/automake学习笔记-交叉编译/index.html","modified":1494946097545,"shasum":"2ee82e4198e5c7c64e02fb5833d111eb9064f8e1"},{"_id":"public/2017/03/26/automake学习笔记-安装与发布/index.html","modified":1494946097570,"shasum":"36b50a7cc15071a5c06ce0e53a7286bb3e68f429"},{"_id":"public/2017/03/21/automake学习笔记-模块化编译/index.html","modified":1494946097587,"shasum":"32b30f7b67e34afda8e197168f9a251fca323b5c"},{"_id":"public/2017/03/17/automake学习笔记-helloworld/index.html","modified":1494946097610,"shasum":"463624731586a177fc0eaca78e822988e7c0de04"},{"_id":"public/2017/03/03/在android上使用grpc/index.html","modified":1494946097658,"shasum":"bba86d2d4179aa8e670a58326b2c3f25310311b5"},{"_id":"public/2016/11/18/责任链模式/index.html","modified":1494946097692,"shasum":"b9dcaa912045a2cf42dff973004884f7a8baeebf"},{"_id":"public/2016/11/16/lua面向对象编程/index.html","modified":1494946097722,"shasum":"e2afca5fc4c831560189c19e28f712474263db60"},{"_id":"public/2016/10/28/lua元表/index.html","modified":1494946097753,"shasum":"7f555b8e2d2cdb45e2ecad9468b8c1d9de0cfb59"},{"_id":"public/2016/10/23/lua泛型for的原理/index.html","modified":1494946097770,"shasum":"c32ed2efa1cc155f857e9ffa6b9b74f2d029dbfb"},{"_id":"public/2016/05/27/Java自定义注解和动态代理/index.html","modified":1494946097815,"shasum":"c5a99c9747255cfcc1c1e5136eae44f78eb56801"},{"_id":"public/2016/03/04/学习HTTP协议-用socket实现http访问/index.html","modified":1494946097865,"shasum":"70cb28cafd6f012057d8bfaf0ea5d142f499ea4a"},{"_id":"public/2016/03/03/学习HTTP协议-在安卓上的使用Cookie与Session/index.html","modified":1494946097900,"shasum":"6c8bca4a93ed2a0a97243161f5d7f10e2c5aa020"},{"_id":"public/2016/02/22/Retrofit-学习笔记/index.html","modified":1494946097952,"shasum":"010c6e7969fc558e68054aeaf571eab9ed386450"},{"_id":"public/2016/02/15/GTest源码剖析-测试代码的注册/index.html","modified":1494946097987,"shasum":"3a9fec3c9801c31d2791fe1c4244080e46f5998d"},{"_id":"public/2016/02/11/读书笔记-《黑客与画家》/index.html","modified":1494946097994,"shasum":"9f6007bd62f9296ada87fb1cb787f041a0c3eb7b"},{"_id":"public/2016/02/10/读书笔记-《第一行代码——Android》/index.html","modified":1494946098001,"shasum":"2ebd18130e2d1e0bc654c8464fcd2bf38d42f52d"},{"_id":"public/2016/02/08/GTest实例解析/index.html","modified":1494946098041,"shasum":"e67114aba1552a79de696b698f4cd91981efd6cb"},{"_id":"public/2016/01/30/读书笔记-《代码整洁之道》/index.html","modified":1494946098048,"shasum":"4e4ac066a6734f29e63817bdbcf18c9bceff42c2"},{"_id":"public/2016/01/27/DrawerLayout-学习笔记/index.html","modified":1494946098080,"shasum":"5954a8e33b92ce7c8d5e38140152eeaab8673e34"},{"_id":"public/2016/01/25/ToolBar-学习笔记/index.html","modified":1494946098117,"shasum":"c66476ed62c9f16c2aa398f737444af26275872f"},{"_id":"public/2016/01/21/读书笔记-《道法自然—面向对象实践指南》/index.html","modified":1494946098124,"shasum":"f1a67c289c8a0293535a3156ec92ab05c4d14495"},{"_id":"public/2016/01/19/使用hexo搭建个人博客/index.html","modified":1494946098133,"shasum":"30e210c60196f265105e41674077eca8544d102c"},{"_id":"public/archives/index.html","modified":1494946098148,"shasum":"8780adf9a94721b67eaeef1b7f70b543d403e20b"},{"_id":"public/archives/page/2/index.html","modified":1494946098160,"shasum":"810bb36f5d91ead4cbaca8de15da53cab2a59d5a"},{"_id":"public/archives/page/3/index.html","modified":1494946098167,"shasum":"3ebbafaa4da1fd8724acfd6e4f094c9f56f4a973"},{"_id":"public/archives/2016/index.html","modified":1494946098178,"shasum":"01ea71a00ef460693269b54d483d0b80e482e829"},{"_id":"public/archives/2016/page/2/index.html","modified":1494946098187,"shasum":"844ff3f44b1bbcf4a3004b0ba75efee7969924ae"},{"_id":"public/archives/2016/01/index.html","modified":1494946098205,"shasum":"30339d5b881f71e817a9d04eccdb536401df6816"},{"_id":"public/archives/2016/02/index.html","modified":1494946098213,"shasum":"877a58bc228e1f4478f75c8fcc73cc66d016305e"},{"_id":"public/archives/2016/03/index.html","modified":1494946098219,"shasum":"5b5e3b12124c325fba6c1fcb377a5873c2bf93be"},{"_id":"public/archives/2016/05/index.html","modified":1494946098224,"shasum":"3aecd5e6bbe18684474b94e93122c1c5d7856868"},{"_id":"public/archives/2016/10/index.html","modified":1494946098230,"shasum":"b0bfcf95409f443fb162cbde7a252358ec63d37d"},{"_id":"public/archives/2016/11/index.html","modified":1494946098236,"shasum":"9b5edb8b1039a2a55a0a022b99016102d94cd5e1"},{"_id":"public/archives/2017/index.html","modified":1494946098245,"shasum":"633c262f264c77f5a746a122569a4ad1c1cde8b6"},{"_id":"public/archives/2017/03/index.html","modified":1494946098256,"shasum":"e2e05887e215c9eb87caccab0f93f0b2b7308d1f"},{"_id":"public/archives/2017/04/index.html","modified":1494946098261,"shasum":"c713823a276a4bff4bbe3f87635907300df98d6c"},{"_id":"public/archives/2017/05/index.html","modified":1494946098266,"shasum":"cb922e6f3a7638d6e5d5cfcaea64f755b0cf854f"},{"_id":"public/index.html","modified":1494946098279,"shasum":"305509f5cc62d9b13ffd618a28c769e9e3bc12fc"},{"_id":"public/page/2/index.html","modified":1494946098290,"shasum":"b77b4283a9b1b3d92f2757720271e2ea91a45851"},{"_id":"public/page/3/index.html","modified":1494946098296,"shasum":"a4379c1b5a291c3825f85053c66b3b08646d8ef8"},{"_id":"public/tags/技术相关/index.html","modified":1494946098339,"shasum":"a9137720542c31573bab231f6a29ac9e1bc14e1b"},{"_id":"public/tags/技术相关/page/2/index.html","modified":1494946098380,"shasum":"078c65bbb72d98be4c7a04f84dad583f63b7ba89"},{"_id":"public/tags/设计模式/index.html","modified":1494946098426,"shasum":"608dc5da383ced45ce0eb58d27c4fd78b9e8ff0e"},{"_id":"public/tags/读书笔记/index.html","modified":1494946098467,"shasum":"99780e75f5766c5943cbab9bdb5668d2c92fea3d"},{"_id":"public/tags/Http协议/index.html","modified":1494946098511,"shasum":"496a20366611c3013220f1b31323900762dfeb3a"},{"_id":"public/tags/Android/index.html","modified":1494946098548,"shasum":"41fb2114626db883e72c5eda18b40a70ba14774b"},{"_id":"public/tags/hexo/index.html","modified":1494946098591,"shasum":"1e78eb5a7f0250042e5fce9e6fe0ce6b0a93d089"},{"_id":"public/tags/lua/index.html","modified":1494946098630,"shasum":"540c0e36244924fdbaa2e22028dc5a09912bf82c"},{"_id":"public/tags/编译相关/index.html","modified":1494946098670,"shasum":"08737b2bb677b1c9a71b2c42079ff4d5e113f7ed"},{"_id":"public/tags/java/index.html","modified":1494946098708,"shasum":"e514083ec95f4c3fa1298d722583c843a426d234"},{"_id":"public/tags/单元测试/index.html","modified":1494946098750,"shasum":"eb9c4f38118c33746b6ee8b9966d2b4420b6ef48"}],"Category":[],"Data":[],"Page":[{"title":"tag","layout":"tag","comments":0,"_content":"","source":"tag/index.md","raw":"---\ntitle: tag\nlayout: tag\ncomments: false\n---\n","date":"2017-05-12T23:19:13.532Z","updated":"2017-05-12T23:19:13.532Z","path":"tag/index.html","_id":"cj2ro85bb00004kr445nucn3a"},{"title":"link","layout":"link","comments":0,"_content":"","source":"link/index.md","raw":"---\ntitle: link\nlayout: link\ncomments: false\n---\n","date":"2017-05-12T23:19:13.532Z","updated":"2017-05-12T23:19:13.532Z","path":"link/index.html","_id":"cj2ro85bf00014kr49x2xl9az"},{"title":"about","layout":"about","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: about\nlayout: about\ncomments: false\n---\n","date":"2017-05-12T23:19:13.532Z","updated":"2017-05-12T23:19:13.532Z","path":"about/index.html","_id":"cj2ro85bt00024kr4se0vfi8a"}],"Post":[{"title":"责任链模式","date":"2016-11-17T18:01:31.000Z","_content":"# 什么是责任链模式\n\n责任链模式是一种对象的行为模式，它包含了一些命令对象和一系列的处理对象。是一种链型的结构，每个处理对象可以处理特定的命令对象，当遇到不能处理的命令对象的时候，就会把它传递给下一个处理对象，直到没有最后一个处理对象。\n\n{% img /责任链模式/链式结构.png %}\n\n# 责任链模式的实现\n\n从责任链模式的定义来看，使用单链表去实现它是一种最容易想到和最形象的做法。假设我们有一个解压程序，它可以解压多种不同的压缩格式。\n\n数据定义成下面的样子:\n\n```cpp\nstruct Data{\n    Data(unsigned char* data, int size) :data(data), size(size) {}\n\n    unsigned char* data;\n    unsigned int size;\n};\n```\n\n每个解压器类根据自己是否能够解压接收到的数据，判断应该直接解压数据还是传递给下一个解压器程序去解压。所以将这一逻辑抽象出来，我们可以得到下面的抽象基类:\n\n```cpp\nclass Decompressor{\npublic:\n    Decompressor() : mSuccessor(0){}\n    Decompressor(const Decompressor* successor) : mSuccessor(successor){}\n\n    void setSuccessor(const Decompressor* successor){\n        mSuccessor = successor;\n    }\n\n    Data decompress(const Data& data) const{\n        if(canDecompress(data)){\n            return doDecompress(data);\n        }else if(mSuccessor!=0){\n            return mSuccessor->decompress(data);\n        }\n        return Data(0, 0);\n    }\n\nprivate:\n    const Decompressor* mSuccessor;\n\n    virtual bool canDecompress(const Data& data)const = 0;\n    virtual Data doDecompress(const Data& data)const = 0;\n};\n```\n\n我们模拟三种数据的解压器:\n\n```cpp\nclass GZipDecompressor : public Decompressor{\npublic:\n    GZipDecompressor() { }\n    GZipDecompressor(Decompressor* successor):Decompressor(successor) { }\n\nprivate:\n    virtual bool canDecompress(const Data& data)const{\n        cout<<\"GZipDecompressor:canDecompress\"<<endl;\n        const char* d = (const char*)data.data;\n        return d && 0==strncmp(d, \"gzip\", strlen(\"gzip\"));\n    }\n\n    virtual Data doDecompress(const Data& data)const{\n        cout<<\"GZipDecompressor:doDecompress\"<<endl;\n        const char* d = \"doDecompress by GZipDecompressor\";\n        return Data((unsigned char*)d, strlen(d));\n    }\n};\n```\n\n```cpp\nclass RarDecompressor : public Decompressor{\npublic:\n    RarDecompressor() { }\n    RarDecompressor(Decompressor* successor):Decompressor(successor) { }\n\nprivate:\n    virtual bool canDecompress(const Data& data)const{\n        cout<<\"RarDecompressor:canDecompress\"<<endl;\n        const char* d = (const char*)data.data;\n        return d && 0==strncmp(d, \"rar\", strlen(\"rar\"));\n    }\n\n    virtual Data doDecompress(const Data& data)const{\n        cout<<\"RarDecompressor:doDecompress\"<<endl;\n        const char* d = \"doDecompress by RarDecompressor\";\n        return Data((unsigned char*)d, strlen(d));\n    }\n};\n```\n\n```cpp\nclass ZipDecompressor : public Decompressor{\npublic:\n    ZipDecompressor() { }\n    ZipDecompressor(Decompressor* successor):Decompressor(successor) { }\n\nprivate:\n    virtual bool canDecompress(const Data& data)const{\n        cout<<\"ZipDecompressor:canDecompress\"<<endl;\n        const char* d = (const char*)data.data;\n        return d && 0==strncmp(d, \"zip\", strlen(\"zip\"));\n    }\n\n    virtual Data doDecompress(const Data& data)const{\n        cout<<\"ZipDecompressor:doDecompress\"<<endl;\n        const char* d = \"doDecompress by ZipDecompressor\";\n        return Data((unsigned char*)d, strlen(d));\n    }\n};\n```\n\n嗯哼，是否直观的实现方式。最后是main函数和输出结果:\n\n```cpp\nint main(){\n    RarDecompressor rarDecompressor;\n    GZipDecompressor gzipDecompressor(&rarDecompressor);\n    ZipDecompressor zipDecompressor(&gzipDecompressor);\n\n    Data input((unsigned char*)\"gzip\",strlen(\"gzip\"));\n    Data output = zipDecompressor.decompress(input);\n\n    if(output.data){\n        const char* out = (const char*)output.data;\n        cout<<\"result : \"<<out<<endl;\n    }else{\n        cout<<\"result : null\"<<endl;\n    }\n\n    return 0;\n}\n```\n\n> ZipDecompressor:canDecompress  \n> GZipDecompressor:canDecompress  \n> GZipDecompressor:doDecompress  \n> result : doDecompress by GZipDecompressor\n\n可以看到，数据经过了ZipDecompressor和GZipDecompressor，最后由GZipDecompressor解压处理，整个过程没有经过RarDecompressor\n\n当然为了使代码可维护性更高，我们可以再编写一个SuperDecompressor类来包装解压操作:\n\n```cpp\nclass SuperDecompressor{\npublic:\n    Data decompressCompressedFile(const Data& data);\n\nprivate:\n    ZipDecompressor mZipDecompressor;\n    RarDecompressor mRarDecompressor;\n    GZipDecompressor mGZipDecompressor;\n};\n\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    mZipDecompressor.setSuccessor(&mGZipDecompressor);\n    mGZipDecompressor.setSuccessor(&mRarDecompressor);\n    mRarDecompressor.setSuccessor(0);\n\n    return mZipDecompressor.decompress(data);\n}\n```\n\n这个时候main函数会显得比较简单:\n\n```cpp\nint main(){\n    SuperDecompressor decompressor;\n\n    Data input((unsigned char*)\"gzip\",strlen(\"gzip\"));\n    Data output = decompressor.decompressCompressedFile(input);\n\n    if(output.data){\n        const char* out = (const char*)output.data;\n        cout<<\"result : \"<<out<<endl;\n    }else{\n        cout<<\"result : null\"<<endl;\n    }\n\n    return 0;\n}\n```\n\n输出的结果是一样的:\n> ZipDecompressor:canDecompress  \n> GZipDecompressor:canDecompress  \n> GZipDecompressor:doDecompress  \n> result : doDecompress by GZipDecompressor\n\n# 优化\n\n依靠我们程序员的直觉，下面两段代码都是很容易出错的，尤其是当Decompressor的数目很多的时候。\n\n```cpp\nint main(){\n\t //下面的三行代码容易出错\n    RarDecompressor rarDecompressor;\n    GZipDecompressor gzipDecompressor(&rarDecompressor);\n    ZipDecompressor zipDecompressor(&gzipDecompressor);\n\n    Data input((unsigned char*)\"gzip\",strlen(\"gzip\"));\n    Data output = zipDecompressor.decompress(input);\n\n    if(output.data){\n        const char* out = (const char*)output.data;\n        cout<<\"result : \"<<out<<endl;\n    }else{\n        cout<<\"result : null\"<<endl;\n    }\n\n    return 0;\n}\n```\n\n```cpp\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    mZipDecompressor.setSuccessor(&mGZipDecompressor);\n    mGZipDecompressor.setSuccessor(&mRarDecompressor);\n    mRarDecompressor.setSuccessor(0);\n\n    return mZipDecompressor.decompress(data);\n}\n```\n\n其实使用构造函数和setter方法设置下一个处理类有一个很大的问题，就是在编码的时候很容易就写错了，会出现一些意想不到的bug，而且比较难发现。同时，每次需要修改处理类的顺序或者删除其中的一个或几个处理类，都需要使用setter方法对处理链进行修改，不仅繁琐，而且也比较容易出错。\n\n基于以上的原因，我们会去想，有没有一种更加灵活的实现方式，使得构建处理链不容易出错，而且也能很简单而且很安全的修改处理链呢？\n\n其实我们可以用下面的链式结构去优化:\n\n```cpp\nclass Decompressor{\npublic:\n    Decompressor() : mSuccessor(0){}\n\n    Decompressor& next(Decompressor& successor){\n        mSuccessor = &successor;\n        successor.setSuccessor(0);\n        return successor;\n    }\n\n    Data decompress(const Data& data) const{\n        if(canDecompress(data)){\n            return doDecompress(data);\n        }else if(mSuccessor!=0){\n            return mSuccessor->decompress(data);\n        }\n        return Data(0, 0);\n    }\n\nprivate:\n    const Decompressor* mSuccessor;\n\n    virtual bool canDecompress(const Data& data)const = 0;\n    virtual Data doDecompress(const Data& data)const = 0;\n\n    void setSuccessor(const Decompressor* successor){\n        mSuccessor = successor;\n    }\n};\n```\n\n在这里，我们添加了一个next方法，同时把setSuccessor设为private,于是使用的方法就会变得简洁了许多。\n\n```cpp\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    mZipDecompressor.next(mGZipDecompressor).next(mRarDecompressor);\n    return mZipDecompressor.decompress(data);\n}\n```\n\n# 另一种灵活的实现方式\n\n\n联想一下linux的管道机制：__前一个命令的结果会传递给后一个命令__。\n\n是不是可以从中得到启发呢？是不是可以有一种架构可以使得通过下面的形式就能得到最终处理后的结果？\n\n```cpp\n\tData decompressedData = compressedData | mZipDecompressor | mGZipDecompressor | mRarDecompressor;\n```\n\n首先，很容易想到我们需要通过重载操作符去实现这种机制。我们可以重载 \"|\" 操作符，将Data和Decompressor作为参数传入，再将处理后或者没有处理的Data作为返回值返回，传到下一个Decompressor那里去。\n\n基本的思想是这样的，但是这里有个很重要的问题要处理：我们如何知道上一个Decompressor有没有解压过数据？\n\n当然可以直接调用Decompressor::canDecompress看看是否是可解压的就能知道上一个Decompressor有没有处理过数据。但是这样的处理模式有一些风险，而且也比较浪费资源，明明前一个Decompressor已经解压完成了，但是后面的Decompressor还回去判断是否可以解压，这个判断可能比较复杂。\n\n第二种解决方案就是拓展Data结构体，添加一个是否已经解压字段。这样能够完美的解决问题，但是Data的职责就变重了，他不仅要保存数据，还要知道保存的数据究竟是解压过的还是没有解压过的。而且这个标志字段只有在解压的过程中才有用，因为一般数据在存储的时候我们已经知道它是否被压缩过了，我们总不会会将未解压和解压过的数据混在一起存放的。\n\n其实还有第三种解决方法:\n\n```cpp\nstruct DataWrapper{\n    DataWrapper(const Data& data) : data(data),isDecompressed(false) {}\n\n    Data data;\n    bool isDecompressed;\n};\n```\n在DataWrapper添加了一个属性isDecompressed来标志数据是否已经解压。这个Wrapper可以只在解压过程中临时使用，不影响数据的存储。\n\n然后实现的重点就是重载操作符了，其实它的实现很简单:\n\n```cpp\nDataWrapper& operator | (DataWrapper& data, const Decompressor& decompressor){\n    if(!data.isDecompressed && decompressor.canDecompress(data.data)){\n        data.data = decompressor.doDecompress(data.data);\n        data.isDecompressed = true;\n    }\n\n    return data;\n}\n```\n\n现在Decompressor就只需要提供判断是否可以解压和进行解压的功能。所以我们可以将Decompressor基类简化下面这样。其实这样的Decompressor就相当于java里面的接口了，面向接口编程可以使得业务逻辑更加清晰，而且也更易于维护。\n\n```cpp\nclass Decompressor{\npublic:\n    virtual bool canDecompress(const Data& data)const = 0;\n    virtual Data doDecompress(const Data& data)const = 0;\n};\n```\n\n所以我们的SuperDecompressor类就可以写成下面的样子:\n\n```cpp\nclass SuperDecompressor{\npublic:\n    Data decompressCompressedFile(const Data& data);\n\nprivate:\n    ZipDecompressor mZipDecompressor;\n    RarDecompressor mRarDecompressor;\n    GZipDecompressor mGZipDecompressor;\n};\n\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mZipDecompressor | mGZipDecompressor | mRarDecompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n```\n\n而main函数是一样的:\n\n```cpp\nint main(){\n    SuperDecompressor decompressor;\n\n    Data input((unsigned char*)\"gzip\",strlen(\"gzip\"));\n\n    Data output = decompressor.decompressCompressedFile(input);\n\n    if(output.data){\n        const char* out = (const char*)output.data;\n        cout<<\"result : \"<<out<<endl;\n    }else{\n        cout<<\"result : null\"<<endl;\n    }\n\n    return 0;\n}\n```\n\n输出结果如下:\n\n> ZipDecompressor:canDecompress  \n> GZipDecompressor:canDecompress  \n> GZipDecompressor:doDecompress  \n> result : doDecompress by GZipDecompressor  \n\n所以如果我们现在需要将SuperDecompressor拓展成一个真正万能的解压类，不仅能解压压缩文件，也能解压图片，还能解压Base64编码的超级解压类也很简单了:\n\n```cpp\nclass SuperDecompressor{\n    Data decompressUnknowType(const Data& data);\n    Data decompressImage(const Data& data);\n    Data decompressCompressedFile(const Data& data);\n    Data decompressBase64(const Data& data);\n\nprivate:\n    ZipDecompressor mZipDecompressor;\n    RarDecompressor mRarDecompressor;\n    GZipDecompressor mGZipDecompressor;\n\n    JpgDecompressor mJpgDecompressor;\n    PngDecompressor mPngDecompressor;\n\n    Base64Decompressor mBase64Decompressor;\n};\n\nData SuperDecompressor::decompressUnknowType(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mZipDecompressor | mRarDecompressor | mGZipDecompressor\n            | mJpgDecompressor | mPngDecompressor\n            | mBase64Decompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n\nData SuperDecompressor::decompressImage(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mJpgDecompressor | mPngDecompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mZipDecompressor | mRarDecompressor | mGZipDecompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n\nData SuperDecompressor::decompressBase64(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mBase64Decompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n```\n\n当然，这种处理方式在数据已经被解压的情况下依然会传给下一个解压器，直到经过了整条处理链。所以会造成一定的资源浪费。\n\n# 责任链模式的实际应用场景\n\n责任链模式的实际应用，最广为人知的就是安卓View的Touch事件的传递机制了。其实这是一种双向的责任链模式。在接收到Touch事件的时候，父View会通知子View，如果子View不处理，父View才去处理。光说可能有点难懂，我们直接看源码吧:\n\n```java\npublic boolean dispatchTouchEvent(MotionEvent ev) {\n    boolean result = false;             // 默认状态为没有消费过\n\n    if (!onInterceptTouchEvent(ev)) {   // 如果没有拦截交给子View\n        result = child.dispatchTouchEvent(ev);\n    }\n\n    if (!result) {                      // 如果事件没有被消费,询问自身onTouchEvent\n        result = onTouchEvent(ev);\n    }\n\n    return result;\n}\n```\n\n代码看起来也不好懂？没关系，我用个实际的例子解释一下就明白了。首先我们有下面的一个Activity:\n\n{% img /责任链模式/Touch事件传递机制例子.png %}\n\n当我们点击最中间的那个View的时候Touch事件的传递过程如下图:\n\n{% img /责任链模式/Touch事件传递过程.png %}\n\nTouch事件通过Activity、ViewGroup1、ViewGroup2的dispatchTouchEvent方法最后到达View的dispatchTouchEvent方法，在View被处理，所以返回true。于是Activity、ViewGroup1、ViewGroup2的dispatchTouchEvent方法都会直接返回，而不会调用处理方法onTouchEvent\n\n\n# 总结\n\n这一部分本来应该讲一讲责任链模式的优缺点的，但是我自己其实不太喜欢这样的总结性的东西。所以还是留给读者自己体会吧。\n","source":"_posts/责任链模式.md","raw":"title: 责任链模式\ndate: 2016-11-18 02:01:31\ntags:\n    - 技术相关\n    - 设计模式\n---\n# 什么是责任链模式\n\n责任链模式是一种对象的行为模式，它包含了一些命令对象和一系列的处理对象。是一种链型的结构，每个处理对象可以处理特定的命令对象，当遇到不能处理的命令对象的时候，就会把它传递给下一个处理对象，直到没有最后一个处理对象。\n\n{% img /责任链模式/链式结构.png %}\n\n# 责任链模式的实现\n\n从责任链模式的定义来看，使用单链表去实现它是一种最容易想到和最形象的做法。假设我们有一个解压程序，它可以解压多种不同的压缩格式。\n\n数据定义成下面的样子:\n\n```cpp\nstruct Data{\n    Data(unsigned char* data, int size) :data(data), size(size) {}\n\n    unsigned char* data;\n    unsigned int size;\n};\n```\n\n每个解压器类根据自己是否能够解压接收到的数据，判断应该直接解压数据还是传递给下一个解压器程序去解压。所以将这一逻辑抽象出来，我们可以得到下面的抽象基类:\n\n```cpp\nclass Decompressor{\npublic:\n    Decompressor() : mSuccessor(0){}\n    Decompressor(const Decompressor* successor) : mSuccessor(successor){}\n\n    void setSuccessor(const Decompressor* successor){\n        mSuccessor = successor;\n    }\n\n    Data decompress(const Data& data) const{\n        if(canDecompress(data)){\n            return doDecompress(data);\n        }else if(mSuccessor!=0){\n            return mSuccessor->decompress(data);\n        }\n        return Data(0, 0);\n    }\n\nprivate:\n    const Decompressor* mSuccessor;\n\n    virtual bool canDecompress(const Data& data)const = 0;\n    virtual Data doDecompress(const Data& data)const = 0;\n};\n```\n\n我们模拟三种数据的解压器:\n\n```cpp\nclass GZipDecompressor : public Decompressor{\npublic:\n    GZipDecompressor() { }\n    GZipDecompressor(Decompressor* successor):Decompressor(successor) { }\n\nprivate:\n    virtual bool canDecompress(const Data& data)const{\n        cout<<\"GZipDecompressor:canDecompress\"<<endl;\n        const char* d = (const char*)data.data;\n        return d && 0==strncmp(d, \"gzip\", strlen(\"gzip\"));\n    }\n\n    virtual Data doDecompress(const Data& data)const{\n        cout<<\"GZipDecompressor:doDecompress\"<<endl;\n        const char* d = \"doDecompress by GZipDecompressor\";\n        return Data((unsigned char*)d, strlen(d));\n    }\n};\n```\n\n```cpp\nclass RarDecompressor : public Decompressor{\npublic:\n    RarDecompressor() { }\n    RarDecompressor(Decompressor* successor):Decompressor(successor) { }\n\nprivate:\n    virtual bool canDecompress(const Data& data)const{\n        cout<<\"RarDecompressor:canDecompress\"<<endl;\n        const char* d = (const char*)data.data;\n        return d && 0==strncmp(d, \"rar\", strlen(\"rar\"));\n    }\n\n    virtual Data doDecompress(const Data& data)const{\n        cout<<\"RarDecompressor:doDecompress\"<<endl;\n        const char* d = \"doDecompress by RarDecompressor\";\n        return Data((unsigned char*)d, strlen(d));\n    }\n};\n```\n\n```cpp\nclass ZipDecompressor : public Decompressor{\npublic:\n    ZipDecompressor() { }\n    ZipDecompressor(Decompressor* successor):Decompressor(successor) { }\n\nprivate:\n    virtual bool canDecompress(const Data& data)const{\n        cout<<\"ZipDecompressor:canDecompress\"<<endl;\n        const char* d = (const char*)data.data;\n        return d && 0==strncmp(d, \"zip\", strlen(\"zip\"));\n    }\n\n    virtual Data doDecompress(const Data& data)const{\n        cout<<\"ZipDecompressor:doDecompress\"<<endl;\n        const char* d = \"doDecompress by ZipDecompressor\";\n        return Data((unsigned char*)d, strlen(d));\n    }\n};\n```\n\n嗯哼，是否直观的实现方式。最后是main函数和输出结果:\n\n```cpp\nint main(){\n    RarDecompressor rarDecompressor;\n    GZipDecompressor gzipDecompressor(&rarDecompressor);\n    ZipDecompressor zipDecompressor(&gzipDecompressor);\n\n    Data input((unsigned char*)\"gzip\",strlen(\"gzip\"));\n    Data output = zipDecompressor.decompress(input);\n\n    if(output.data){\n        const char* out = (const char*)output.data;\n        cout<<\"result : \"<<out<<endl;\n    }else{\n        cout<<\"result : null\"<<endl;\n    }\n\n    return 0;\n}\n```\n\n> ZipDecompressor:canDecompress  \n> GZipDecompressor:canDecompress  \n> GZipDecompressor:doDecompress  \n> result : doDecompress by GZipDecompressor\n\n可以看到，数据经过了ZipDecompressor和GZipDecompressor，最后由GZipDecompressor解压处理，整个过程没有经过RarDecompressor\n\n当然为了使代码可维护性更高，我们可以再编写一个SuperDecompressor类来包装解压操作:\n\n```cpp\nclass SuperDecompressor{\npublic:\n    Data decompressCompressedFile(const Data& data);\n\nprivate:\n    ZipDecompressor mZipDecompressor;\n    RarDecompressor mRarDecompressor;\n    GZipDecompressor mGZipDecompressor;\n};\n\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    mZipDecompressor.setSuccessor(&mGZipDecompressor);\n    mGZipDecompressor.setSuccessor(&mRarDecompressor);\n    mRarDecompressor.setSuccessor(0);\n\n    return mZipDecompressor.decompress(data);\n}\n```\n\n这个时候main函数会显得比较简单:\n\n```cpp\nint main(){\n    SuperDecompressor decompressor;\n\n    Data input((unsigned char*)\"gzip\",strlen(\"gzip\"));\n    Data output = decompressor.decompressCompressedFile(input);\n\n    if(output.data){\n        const char* out = (const char*)output.data;\n        cout<<\"result : \"<<out<<endl;\n    }else{\n        cout<<\"result : null\"<<endl;\n    }\n\n    return 0;\n}\n```\n\n输出的结果是一样的:\n> ZipDecompressor:canDecompress  \n> GZipDecompressor:canDecompress  \n> GZipDecompressor:doDecompress  \n> result : doDecompress by GZipDecompressor\n\n# 优化\n\n依靠我们程序员的直觉，下面两段代码都是很容易出错的，尤其是当Decompressor的数目很多的时候。\n\n```cpp\nint main(){\n\t //下面的三行代码容易出错\n    RarDecompressor rarDecompressor;\n    GZipDecompressor gzipDecompressor(&rarDecompressor);\n    ZipDecompressor zipDecompressor(&gzipDecompressor);\n\n    Data input((unsigned char*)\"gzip\",strlen(\"gzip\"));\n    Data output = zipDecompressor.decompress(input);\n\n    if(output.data){\n        const char* out = (const char*)output.data;\n        cout<<\"result : \"<<out<<endl;\n    }else{\n        cout<<\"result : null\"<<endl;\n    }\n\n    return 0;\n}\n```\n\n```cpp\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    mZipDecompressor.setSuccessor(&mGZipDecompressor);\n    mGZipDecompressor.setSuccessor(&mRarDecompressor);\n    mRarDecompressor.setSuccessor(0);\n\n    return mZipDecompressor.decompress(data);\n}\n```\n\n其实使用构造函数和setter方法设置下一个处理类有一个很大的问题，就是在编码的时候很容易就写错了，会出现一些意想不到的bug，而且比较难发现。同时，每次需要修改处理类的顺序或者删除其中的一个或几个处理类，都需要使用setter方法对处理链进行修改，不仅繁琐，而且也比较容易出错。\n\n基于以上的原因，我们会去想，有没有一种更加灵活的实现方式，使得构建处理链不容易出错，而且也能很简单而且很安全的修改处理链呢？\n\n其实我们可以用下面的链式结构去优化:\n\n```cpp\nclass Decompressor{\npublic:\n    Decompressor() : mSuccessor(0){}\n\n    Decompressor& next(Decompressor& successor){\n        mSuccessor = &successor;\n        successor.setSuccessor(0);\n        return successor;\n    }\n\n    Data decompress(const Data& data) const{\n        if(canDecompress(data)){\n            return doDecompress(data);\n        }else if(mSuccessor!=0){\n            return mSuccessor->decompress(data);\n        }\n        return Data(0, 0);\n    }\n\nprivate:\n    const Decompressor* mSuccessor;\n\n    virtual bool canDecompress(const Data& data)const = 0;\n    virtual Data doDecompress(const Data& data)const = 0;\n\n    void setSuccessor(const Decompressor* successor){\n        mSuccessor = successor;\n    }\n};\n```\n\n在这里，我们添加了一个next方法，同时把setSuccessor设为private,于是使用的方法就会变得简洁了许多。\n\n```cpp\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    mZipDecompressor.next(mGZipDecompressor).next(mRarDecompressor);\n    return mZipDecompressor.decompress(data);\n}\n```\n\n# 另一种灵活的实现方式\n\n\n联想一下linux的管道机制：__前一个命令的结果会传递给后一个命令__。\n\n是不是可以从中得到启发呢？是不是可以有一种架构可以使得通过下面的形式就能得到最终处理后的结果？\n\n```cpp\n\tData decompressedData = compressedData | mZipDecompressor | mGZipDecompressor | mRarDecompressor;\n```\n\n首先，很容易想到我们需要通过重载操作符去实现这种机制。我们可以重载 \"|\" 操作符，将Data和Decompressor作为参数传入，再将处理后或者没有处理的Data作为返回值返回，传到下一个Decompressor那里去。\n\n基本的思想是这样的，但是这里有个很重要的问题要处理：我们如何知道上一个Decompressor有没有解压过数据？\n\n当然可以直接调用Decompressor::canDecompress看看是否是可解压的就能知道上一个Decompressor有没有处理过数据。但是这样的处理模式有一些风险，而且也比较浪费资源，明明前一个Decompressor已经解压完成了，但是后面的Decompressor还回去判断是否可以解压，这个判断可能比较复杂。\n\n第二种解决方案就是拓展Data结构体，添加一个是否已经解压字段。这样能够完美的解决问题，但是Data的职责就变重了，他不仅要保存数据，还要知道保存的数据究竟是解压过的还是没有解压过的。而且这个标志字段只有在解压的过程中才有用，因为一般数据在存储的时候我们已经知道它是否被压缩过了，我们总不会会将未解压和解压过的数据混在一起存放的。\n\n其实还有第三种解决方法:\n\n```cpp\nstruct DataWrapper{\n    DataWrapper(const Data& data) : data(data),isDecompressed(false) {}\n\n    Data data;\n    bool isDecompressed;\n};\n```\n在DataWrapper添加了一个属性isDecompressed来标志数据是否已经解压。这个Wrapper可以只在解压过程中临时使用，不影响数据的存储。\n\n然后实现的重点就是重载操作符了，其实它的实现很简单:\n\n```cpp\nDataWrapper& operator | (DataWrapper& data, const Decompressor& decompressor){\n    if(!data.isDecompressed && decompressor.canDecompress(data.data)){\n        data.data = decompressor.doDecompress(data.data);\n        data.isDecompressed = true;\n    }\n\n    return data;\n}\n```\n\n现在Decompressor就只需要提供判断是否可以解压和进行解压的功能。所以我们可以将Decompressor基类简化下面这样。其实这样的Decompressor就相当于java里面的接口了，面向接口编程可以使得业务逻辑更加清晰，而且也更易于维护。\n\n```cpp\nclass Decompressor{\npublic:\n    virtual bool canDecompress(const Data& data)const = 0;\n    virtual Data doDecompress(const Data& data)const = 0;\n};\n```\n\n所以我们的SuperDecompressor类就可以写成下面的样子:\n\n```cpp\nclass SuperDecompressor{\npublic:\n    Data decompressCompressedFile(const Data& data);\n\nprivate:\n    ZipDecompressor mZipDecompressor;\n    RarDecompressor mRarDecompressor;\n    GZipDecompressor mGZipDecompressor;\n};\n\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mZipDecompressor | mGZipDecompressor | mRarDecompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n```\n\n而main函数是一样的:\n\n```cpp\nint main(){\n    SuperDecompressor decompressor;\n\n    Data input((unsigned char*)\"gzip\",strlen(\"gzip\"));\n\n    Data output = decompressor.decompressCompressedFile(input);\n\n    if(output.data){\n        const char* out = (const char*)output.data;\n        cout<<\"result : \"<<out<<endl;\n    }else{\n        cout<<\"result : null\"<<endl;\n    }\n\n    return 0;\n}\n```\n\n输出结果如下:\n\n> ZipDecompressor:canDecompress  \n> GZipDecompressor:canDecompress  \n> GZipDecompressor:doDecompress  \n> result : doDecompress by GZipDecompressor  \n\n所以如果我们现在需要将SuperDecompressor拓展成一个真正万能的解压类，不仅能解压压缩文件，也能解压图片，还能解压Base64编码的超级解压类也很简单了:\n\n```cpp\nclass SuperDecompressor{\n    Data decompressUnknowType(const Data& data);\n    Data decompressImage(const Data& data);\n    Data decompressCompressedFile(const Data& data);\n    Data decompressBase64(const Data& data);\n\nprivate:\n    ZipDecompressor mZipDecompressor;\n    RarDecompressor mRarDecompressor;\n    GZipDecompressor mGZipDecompressor;\n\n    JpgDecompressor mJpgDecompressor;\n    PngDecompressor mPngDecompressor;\n\n    Base64Decompressor mBase64Decompressor;\n};\n\nData SuperDecompressor::decompressUnknowType(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mZipDecompressor | mRarDecompressor | mGZipDecompressor\n            | mJpgDecompressor | mPngDecompressor\n            | mBase64Decompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n\nData SuperDecompressor::decompressImage(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mJpgDecompressor | mPngDecompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mZipDecompressor | mRarDecompressor | mGZipDecompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n\nData SuperDecompressor::decompressBase64(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mBase64Decompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n```\n\n当然，这种处理方式在数据已经被解压的情况下依然会传给下一个解压器，直到经过了整条处理链。所以会造成一定的资源浪费。\n\n# 责任链模式的实际应用场景\n\n责任链模式的实际应用，最广为人知的就是安卓View的Touch事件的传递机制了。其实这是一种双向的责任链模式。在接收到Touch事件的时候，父View会通知子View，如果子View不处理，父View才去处理。光说可能有点难懂，我们直接看源码吧:\n\n```java\npublic boolean dispatchTouchEvent(MotionEvent ev) {\n    boolean result = false;             // 默认状态为没有消费过\n\n    if (!onInterceptTouchEvent(ev)) {   // 如果没有拦截交给子View\n        result = child.dispatchTouchEvent(ev);\n    }\n\n    if (!result) {                      // 如果事件没有被消费,询问自身onTouchEvent\n        result = onTouchEvent(ev);\n    }\n\n    return result;\n}\n```\n\n代码看起来也不好懂？没关系，我用个实际的例子解释一下就明白了。首先我们有下面的一个Activity:\n\n{% img /责任链模式/Touch事件传递机制例子.png %}\n\n当我们点击最中间的那个View的时候Touch事件的传递过程如下图:\n\n{% img /责任链模式/Touch事件传递过程.png %}\n\nTouch事件通过Activity、ViewGroup1、ViewGroup2的dispatchTouchEvent方法最后到达View的dispatchTouchEvent方法，在View被处理，所以返回true。于是Activity、ViewGroup1、ViewGroup2的dispatchTouchEvent方法都会直接返回，而不会调用处理方法onTouchEvent\n\n\n# 总结\n\n这一部分本来应该讲一讲责任链模式的优缺点的，但是我自己其实不太喜欢这样的总结性的东西。所以还是留给读者自己体会吧。\n","slug":"责任链模式","published":1,"updated":"2017-05-12T23:19:13.532Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2ro85bx00034kr46uuj46cg"},{"title":"读书笔记 -《黑客与画家》","date":"2016-02-11T12:22:40.000Z","_content":"这本书是一本文集，也有点像paul graham的自传。以成长的各个阶段为引子，讲到了paul graham对书呆子、优秀程序员、创业和编程语言等的观点看法。\n\n其实不太适合这个阶段的我读，创业、程序语言的设计这些离我还太遥远。不像书中的”黑客“从初中高中就开始学习编程，在大学时期甚至更早之前就能做出一些很厉害的东西。我经历的实际项目一个巴掌都数的过来，甚至还不知道书中“黑客”推崇备至的lisp代码到底长什么样子，很多东西看来了不能产生太深的感悟。\n\n但换个角度，把它当成一本闲时读物，用来拓展眼界还是极好的。\n\n以前我不明白为什么公司里面的项目组普遍在十人左右，现在才知道小团体和可测量性之间的关系，组织机构越精简往往能提供越大的生产力。\n\n书中对现存编程语言的解析还有对未来编程语言的预测也让我大开眼界，了解到了一些以前从来没有去注意的细节之处。\n\n而要说最大的收获的话，应该就是对于编写代码的方式有了和以前不太一样的理解了。刚学编程那会儿，总是直接上手敲代码，完全没有事前的思考，所以总会写出一堆不堪入目的东西。之后看受一些书本和前辈的影响，又总是喜欢做一些“完美”的设计。通常是考虑了一堆多余的东西，到了真正要编码的时候又发现能力不足以把这些东西都实现，其实就是陷入了“过早优化”。\n\n这本书和《道法自然》的建议有点类似，设计的时候只需要考虑必须实现的功能就可以了。“把整个程序想清楚的时间点，应该是在编写代码的同时，而不是在编写代码之前，这与作家、画家和建筑师的做法完全一样”。人们往往很难在没有实际编码之前就将遇到的问题和未知的需求都考虑在内，所以一开始的设计不应该是一种解决所有问题的方案，不应该太早的决定一个程序应该怎么做。而应该设计一种灵活可变的方案，类似打草稿、画轮廓，然后在编写代码的时候再慢慢修改和填充。\n\n最近看书有点急。大概是以前看的书太少了，好不容易有时间，有心情去看书，所以才看得那么匆忙，一本还没看完就开另一本，同时实际动手敲代码的时间也少的可怜。时间还剩下一个月左右，是该调整一下了，书还是得看仔细点，代码也应该敲多点。\n","source":"_posts/读书笔记-《黑客与画家》.md","raw":"title: 读书笔记 -《黑客与画家》\ndate: 2016-02-11 20:22:40\ntags:\n\t- 读书笔记\n---\n这本书是一本文集，也有点像paul graham的自传。以成长的各个阶段为引子，讲到了paul graham对书呆子、优秀程序员、创业和编程语言等的观点看法。\n\n其实不太适合这个阶段的我读，创业、程序语言的设计这些离我还太遥远。不像书中的”黑客“从初中高中就开始学习编程，在大学时期甚至更早之前就能做出一些很厉害的东西。我经历的实际项目一个巴掌都数的过来，甚至还不知道书中“黑客”推崇备至的lisp代码到底长什么样子，很多东西看来了不能产生太深的感悟。\n\n但换个角度，把它当成一本闲时读物，用来拓展眼界还是极好的。\n\n以前我不明白为什么公司里面的项目组普遍在十人左右，现在才知道小团体和可测量性之间的关系，组织机构越精简往往能提供越大的生产力。\n\n书中对现存编程语言的解析还有对未来编程语言的预测也让我大开眼界，了解到了一些以前从来没有去注意的细节之处。\n\n而要说最大的收获的话，应该就是对于编写代码的方式有了和以前不太一样的理解了。刚学编程那会儿，总是直接上手敲代码，完全没有事前的思考，所以总会写出一堆不堪入目的东西。之后看受一些书本和前辈的影响，又总是喜欢做一些“完美”的设计。通常是考虑了一堆多余的东西，到了真正要编码的时候又发现能力不足以把这些东西都实现，其实就是陷入了“过早优化”。\n\n这本书和《道法自然》的建议有点类似，设计的时候只需要考虑必须实现的功能就可以了。“把整个程序想清楚的时间点，应该是在编写代码的同时，而不是在编写代码之前，这与作家、画家和建筑师的做法完全一样”。人们往往很难在没有实际编码之前就将遇到的问题和未知的需求都考虑在内，所以一开始的设计不应该是一种解决所有问题的方案，不应该太早的决定一个程序应该怎么做。而应该设计一种灵活可变的方案，类似打草稿、画轮廓，然后在编写代码的时候再慢慢修改和填充。\n\n最近看书有点急。大概是以前看的书太少了，好不容易有时间，有心情去看书，所以才看得那么匆忙，一本还没看完就开另一本，同时实际动手敲代码的时间也少的可怜。时间还剩下一个月左右，是该调整一下了，书还是得看仔细点，代码也应该敲多点。\n","slug":"读书笔记-《黑客与画家》","published":1,"updated":"2017-05-12T23:19:13.532Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2ro85c700084kr43h1ef662"},{"title":"读书笔记 -《道法自然—面向对象实践指南》","date":"2016-01-21T08:59:47.000Z","_content":"\n不可否认，我一开始是被这本书的名字吸引才去读的。《道法自然》，这名字逼格真心不要太高。但真的开始阅读，你就会发现它绝对不是标题党。依稀记得那天凌晨4点多睡不着，刷知乎看到有人推荐这本书，于是冲着标题去下载来看。结果一发不可收拾，那一天我就没干别的事，都被它吸引住了。\n\n之前也看过不少讲设计模式的书，像什么《大话设计模式》、《head first设计模式》、《设计模式之禅》等等。当然它们也是好书。尤其是《设计模式之禅》，在读《道法自然》之前我最推崇的讲设计模式的书就是它了。但相比起来，我还是觉得《道法自然》讲的更加的透彻和易于理解。\n\n《道法自然—面向对象实践指南》这本书真要算起来其实并不是严格意义上的讲设计模式的书籍。它以实际的开发案例--FishGUI项目为主线，从立项到需求分析，再到架构设计，最后到编码和优化。通过文字，将整个项目的流程一点不漏的展现在读者面前。在实际编码那几章，通过分析项目的需求，确定使用的设计模式，分析为什么要使用这种模式，有什么优缺点，又谈到怎么去应用到FishGUI这个框架中。有时候甚至会对比其他的框架的源代码讲到多种设计之间的差异和优缺点，例如书中在消息机制那里就分析了MFC、.net和java AWT的设计。相比起其他讲设计模式的书，它更加贴合实际开发，也讲到更加的透彻。毕竟是通过一个实际的项目去讲，能让人更透彻的取理解所讲到的模式。\n\n这本书还有一个吸引我的地方，之前读到的关于设计模式的书籍，要不是用的c#要不用的是java，但这本书使用的编程语言是c\\+\\+，也不是说其他语言不好，但作为一个大部分时间都在学习c\\+\\+的人来说，看c\\+\\+语言更有一种亲切感。同时这本书在最后的一章里面还讲到了在FishGUI这个项目中使用c\\+\\+时遇到的坑。对于c\\+\\+程序员来说，这本书真心不能错过。\n\n读完这本书，除了对于一些设计模式理解的更为透彻之外，我认为更重要的收获是对编程思想或者编程习惯的培养：\n\n1. 实际编码之前一定要有分析和设计的阶段\n2. 只实现你真正需要的东西 \n2. 面向接口编程而不是面向实现编程\n3. 边编码边做一些优化性的重构\n\n我想这本书我以后肯定会再读的，因为现在的项目经验还不足，相信做多几个实际的项目之后再看一遍，肯定会有不一样的见解和更多的收获。\n\n看这本书总共花了10天左右的时间吧，其实这个过程中也发现了自己在读书方面的缺点。就是后劲不足，在刚刚开始的时候每天都很有热情的去阅读，速度很快，看到也很仔细，但读了一半热情下来之后就没有之前那么入神了。这也是我接下来必须改进的地方，以前读的书太少，2016年有太多的书想要读。这是今年读完的第一本书，希望有始有终，之后的日子可以培养起看书的好习惯。  \n\n","source":"_posts/读书笔记-《道法自然—面向对象实践指南》.md","raw":"title: 读书笔记 -《道法自然—面向对象实践指南》\ndate: 2016-01-21 16:59:47\ntags:\n    - 读书笔记 \n---\n\n不可否认，我一开始是被这本书的名字吸引才去读的。《道法自然》，这名字逼格真心不要太高。但真的开始阅读，你就会发现它绝对不是标题党。依稀记得那天凌晨4点多睡不着，刷知乎看到有人推荐这本书，于是冲着标题去下载来看。结果一发不可收拾，那一天我就没干别的事，都被它吸引住了。\n\n之前也看过不少讲设计模式的书，像什么《大话设计模式》、《head first设计模式》、《设计模式之禅》等等。当然它们也是好书。尤其是《设计模式之禅》，在读《道法自然》之前我最推崇的讲设计模式的书就是它了。但相比起来，我还是觉得《道法自然》讲的更加的透彻和易于理解。\n\n《道法自然—面向对象实践指南》这本书真要算起来其实并不是严格意义上的讲设计模式的书籍。它以实际的开发案例--FishGUI项目为主线，从立项到需求分析，再到架构设计，最后到编码和优化。通过文字，将整个项目的流程一点不漏的展现在读者面前。在实际编码那几章，通过分析项目的需求，确定使用的设计模式，分析为什么要使用这种模式，有什么优缺点，又谈到怎么去应用到FishGUI这个框架中。有时候甚至会对比其他的框架的源代码讲到多种设计之间的差异和优缺点，例如书中在消息机制那里就分析了MFC、.net和java AWT的设计。相比起其他讲设计模式的书，它更加贴合实际开发，也讲到更加的透彻。毕竟是通过一个实际的项目去讲，能让人更透彻的取理解所讲到的模式。\n\n这本书还有一个吸引我的地方，之前读到的关于设计模式的书籍，要不是用的c#要不用的是java，但这本书使用的编程语言是c\\+\\+，也不是说其他语言不好，但作为一个大部分时间都在学习c\\+\\+的人来说，看c\\+\\+语言更有一种亲切感。同时这本书在最后的一章里面还讲到了在FishGUI这个项目中使用c\\+\\+时遇到的坑。对于c\\+\\+程序员来说，这本书真心不能错过。\n\n读完这本书，除了对于一些设计模式理解的更为透彻之外，我认为更重要的收获是对编程思想或者编程习惯的培养：\n\n1. 实际编码之前一定要有分析和设计的阶段\n2. 只实现你真正需要的东西 \n2. 面向接口编程而不是面向实现编程\n3. 边编码边做一些优化性的重构\n\n我想这本书我以后肯定会再读的，因为现在的项目经验还不足，相信做多几个实际的项目之后再看一遍，肯定会有不一样的见解和更多的收获。\n\n看这本书总共花了10天左右的时间吧，其实这个过程中也发现了自己在读书方面的缺点。就是后劲不足，在刚刚开始的时候每天都很有热情的去阅读，速度很快，看到也很仔细，但读了一半热情下来之后就没有之前那么入神了。这也是我接下来必须改进的地方，以前读的书太少，2016年有太多的书想要读。这是今年读完的第一本书，希望有始有终，之后的日子可以培养起看书的好习惯。  \n\n","slug":"读书笔记-《道法自然—面向对象实践指南》","published":1,"updated":"2017-05-12T23:19:13.532Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2ro85ca000b4kr40kjtx1c4"},{"title":"读书笔记 -《第一行代码——Android》","date":"2016-02-10T14:29:03.000Z","_content":"\n很久之前就打算学安卓了，但总被各种事情干扰，一直断断续续。这本书是我第一本真正读完的安卓入门教程。\n\n这本书不愧被称为“Android初学者的最佳入门书”。它涵盖了安卓软件开发的方方面面，不仅讲到了四大组件、UI、碎片、广播机制、数据存储、服务、多媒体、网络、定位服务、传感器这些安卓开发知识，也讲简单提到了git和安卓测试工程的使用。在书本的最后还通过一个比较完整的天气app把书中大部分的内容以实际项目的形式回顾了一遍。\n\n我觉得这本书最大的优点就是点到为止，不像之前读过的那些书，用大篇幅去把各个部件属性和控件都不厌其烦的描述一遍。因为很多东西只要知道有这个东西，知道它的部分关键属性，其他的到需要用到的时候在去查看文档就可以了。\n\n但这本书又不仅是简单的介绍安卓那些组件和类的使用方法，它还介绍了listview加载数据的优化方法、全局获取Context的技巧和制定自己的Log类等实用的安卓编程技巧。虽然由于安卓版本更新太快，有部分代码已经过时，但对于善于使用搜索引擎的程序员来说也不是什么大问题。\n\n总的来说，这本书除了每节末尾的不太相关的RPG剧情描述之外，其它都很合我口味，很幸运可以在入门的阶段遇到这本书。\n\n经过这一段时间的学习，也对安卓编程有了一点心得，接下来就可以正式开始我的毕业设计手机端部分了。边编码，边深入学习java、安卓编程和单元测试等知识。希望在大学的最后一段时间，能够学多点东西，提高自己的编程能力。","source":"_posts/读书笔记-《第一行代码——Android》.md","raw":"title: 读书笔记 -《第一行代码——Android》\ndate: 2016-02-10 22:29:03\ntags:\n\t- 读书笔记\n---\n\n很久之前就打算学安卓了，但总被各种事情干扰，一直断断续续。这本书是我第一本真正读完的安卓入门教程。\n\n这本书不愧被称为“Android初学者的最佳入门书”。它涵盖了安卓软件开发的方方面面，不仅讲到了四大组件、UI、碎片、广播机制、数据存储、服务、多媒体、网络、定位服务、传感器这些安卓开发知识，也讲简单提到了git和安卓测试工程的使用。在书本的最后还通过一个比较完整的天气app把书中大部分的内容以实际项目的形式回顾了一遍。\n\n我觉得这本书最大的优点就是点到为止，不像之前读过的那些书，用大篇幅去把各个部件属性和控件都不厌其烦的描述一遍。因为很多东西只要知道有这个东西，知道它的部分关键属性，其他的到需要用到的时候在去查看文档就可以了。\n\n但这本书又不仅是简单的介绍安卓那些组件和类的使用方法，它还介绍了listview加载数据的优化方法、全局获取Context的技巧和制定自己的Log类等实用的安卓编程技巧。虽然由于安卓版本更新太快，有部分代码已经过时，但对于善于使用搜索引擎的程序员来说也不是什么大问题。\n\n总的来说，这本书除了每节末尾的不太相关的RPG剧情描述之外，其它都很合我口味，很幸运可以在入门的阶段遇到这本书。\n\n经过这一段时间的学习，也对安卓编程有了一点心得，接下来就可以正式开始我的毕业设计手机端部分了。边编码，边深入学习java、安卓编程和单元测试等知识。希望在大学的最后一段时间，能够学多点东西，提高自己的编程能力。","slug":"读书笔记-《第一行代码——Android》","published":1,"updated":"2017-05-12T23:19:13.532Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2ro85cc000d4kr4021vli6f"},{"title":"读书笔记 -《代码整洁之道》","date":"2016-01-30T07:22:14.000Z","_content":"\n长呼一口气，终于看完了。明明就只有300多页，但这本《代码整洁之道》还真是难啃啊。\n\n书是好书，讲的也十分细致。就连命名、方法定义的顺序、注释这些小细节都用了不少的文字去强调。虽然有些观点我不太认同（比如我觉得类成员变量就应该多一个字符m或者下划线去和临时变量做区别）但绝大部分的建议和条款我觉得都讲的十分有道理。总结了几个自认为最重要的点：\n\n1. 不管是变量还是函数，命名都应该有意义且名副其实\n1. 应该按照垂直格式摆放函数定义\n1. 注释应该正确且有用\n1. 函数应该只做一件事，且应该尽量短小\n1. 模块不应该了解它所操作的对象的内部情形\n\n\n作者对于代码的要求堪称苛刻，看他写代码的过程真的可以算是精雕细琢，最终呈现的代码可谓优雅。虽然我也不能指望自己通过读完一本书，写代码的能力就有质的飞跃。但这本书起码提醒了我一些以前没有注意到的地方，以后写代码的时候试试提醒自己，能有所提高也就不负我这几天的努力了。\n\n要说这本书难啃也是真的。中间有大量的代码实例，而且很多都是著名的开源框架的源码（如Tomcat、Spring和JUnit），在阅读这本书的过程中大部分时间我是花在理解这些代码上的。因为对java不太熟悉，这些框架更是一个都没有用过，所以读起来十分的痛苦，中间好几次都想放弃了。\n\n多亏最终坚持了下来，我还得到了一些以后的学习道路的启示：\n\n一是java还需要重新好好学一遍。毕竟现在正在学安卓，我的java基础实在弱的可以，尤其是并发编程相关的知识可以说就是一张白纸。\n\n二是需要学习一下测试驱动开发（TDD）相关的知识。我发现最近看的书，都把测试放在了很重要的位置上。以前写代码就没有做过单元测试，所以拿到测试部门的时候总会出现这样那样不应该出现的问题。java方面jUnit是一定要去学习的，而c\\+\\+其实也有类似googletest这样的测试框架。为了写出高质量的代码，这部分的知识也应该去好好补一补了。\n\n所以我下一步打算找找java还有测试相关的书籍来看看。\n","source":"_posts/读书笔记-《代码整洁之道》.md","raw":"title: 读书笔记 -《代码整洁之道》\ndate: 2016-01-30 15:22:14\ntags:\n\t- 读书笔记\n---\n\n长呼一口气，终于看完了。明明就只有300多页，但这本《代码整洁之道》还真是难啃啊。\n\n书是好书，讲的也十分细致。就连命名、方法定义的顺序、注释这些小细节都用了不少的文字去强调。虽然有些观点我不太认同（比如我觉得类成员变量就应该多一个字符m或者下划线去和临时变量做区别）但绝大部分的建议和条款我觉得都讲的十分有道理。总结了几个自认为最重要的点：\n\n1. 不管是变量还是函数，命名都应该有意义且名副其实\n1. 应该按照垂直格式摆放函数定义\n1. 注释应该正确且有用\n1. 函数应该只做一件事，且应该尽量短小\n1. 模块不应该了解它所操作的对象的内部情形\n\n\n作者对于代码的要求堪称苛刻，看他写代码的过程真的可以算是精雕细琢，最终呈现的代码可谓优雅。虽然我也不能指望自己通过读完一本书，写代码的能力就有质的飞跃。但这本书起码提醒了我一些以前没有注意到的地方，以后写代码的时候试试提醒自己，能有所提高也就不负我这几天的努力了。\n\n要说这本书难啃也是真的。中间有大量的代码实例，而且很多都是著名的开源框架的源码（如Tomcat、Spring和JUnit），在阅读这本书的过程中大部分时间我是花在理解这些代码上的。因为对java不太熟悉，这些框架更是一个都没有用过，所以读起来十分的痛苦，中间好几次都想放弃了。\n\n多亏最终坚持了下来，我还得到了一些以后的学习道路的启示：\n\n一是java还需要重新好好学一遍。毕竟现在正在学安卓，我的java基础实在弱的可以，尤其是并发编程相关的知识可以说就是一张白纸。\n\n二是需要学习一下测试驱动开发（TDD）相关的知识。我发现最近看的书，都把测试放在了很重要的位置上。以前写代码就没有做过单元测试，所以拿到测试部门的时候总会出现这样那样不应该出现的问题。java方面jUnit是一定要去学习的，而c\\+\\+其实也有类似googletest这样的测试框架。为了写出高质量的代码，这部分的知识也应该去好好补一补了。\n\n所以我下一步打算找找java还有测试相关的书籍来看看。\n","slug":"读书笔记-《代码整洁之道》","published":1,"updated":"2017-05-12T23:19:13.532Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2ro85cf000f4kr49itwlm48"},{"title":"学习HTTP协议-用socket实现http访问","date":"2016-03-04T14:16:30.000Z","_content":"\n相信大家都知道 http 报文这东西吧？http 报文分两种，请求报文和响应报文。\n\n## __请求报文__\n\n客户端向服务端发送的就是请求报文，它可告诉服务端自己需要什么样的资源，也可以将一些文件或者数据上传给服务端。\n\n请求报文格式如下：\n\n{% img /学习HTTP协议-用socket实现http访问/1.jpg %}\n\n请求报文分为三个部分：\n\n- 请求行，如：\n\n> GET / HTTP/1.1\n\n这个请求行表明了这次请求使用的是 GET 方法，访问的是网站的根目录，使用的 HTTP 协议版本是 1.1。\n\n- 请求头部，如：\n\n> Host: www.baidu.com\n> Connection: keep-alive\n\n- 请求包体\n\n用来携带数据\n\n### _GET 方法_\n\nGET 方法是 HTTP 中最基础的方法，我们在浏览器地址栏输入网站浏览网页使用的都是 GET 方法：\n\n> http://www.islinjw.cn/okhttp_cookie_demo/checkverifycode.php\n\n当然有时候服务器需要根据用户传递的信息去返回对应的数据，GET 方法用下面的形式传递信息给服务器：\n\n> http://www.islinjw.cn/okhttp_cookie_demo/checkverifycode.php?verifycode=qwjuy&format=json\n\n这里告诉给服务器 verifycode=qwjuy 和 format=json ，服务器会根据用户传过来的信息返回不同的数据。\n\n这个时候的请求行长这个样子，URL 上就携带了 GET 传递的数据：\n\n> GET /okhttp_cookie_demo/checkverifycode.php?verifycode=qwjuy&format=json HTTP/1.1\n\n这里再说一句题外话，并不是说如果在 URL 里面没有见到 “?” 这个符号，客户端就没有传递数据给服务器。有一种叫做网页伪静态化的技术可以实现不带问号的 URL 使用 GET 方法传递数据。\n\n### _POST 方法_\n\nGET 方法的参数都显示在 URl 上，这样对于诸如账户密码的敏感信息来说太不安全，而且也很难传递想图片这样的数据。所以就有了 POST 方法。\n\n使用 POST 方法传递的数据并不会显示在 URL 上，而是保存在请求包体中，当然 HTTP 协议是明文传输的，所以把账户密码直接用 POST 传递也是不安全的，需要程序员自己进行加密处理。\n\n### _HTTP 协议方法列表_\n\n|序号 |方法 |描述|\n|---|---|---|\n|1 |GET |请求指定的页面信息，并返回实体主体。|\n|2 |HEAD |类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头|\n|3 |POST |向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。|\n|4 |PUT |从客户端向服务器传送的数据取代指定的文档的内容。|\n|5 |DELETE |请求服务器删除指定的页面。|\n|6 |CONNECT |HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。|\n|7 |OPTIONS\t|允许客户端查看服务器的性能。|\n|8 |TRACE |回显服务器收到的请求，主要用于测试或诊断。|\n|9 |PATCH |实体中包含一个表，表中说明与该URI所表示的原内容的区别。|\n|10 |MOVE |请求服务器将指定的页面移至另一个网络地址。|\n|11\t|COPY |请求服务器将指定的页面拷贝至另一个网络地址。|\n|12\t|LINK |请求服务器建立链接关系。|\n|13\t|UNLINK |断开链接关系。|\n|14\t|WRAPPED |允许客户端发送经过封装的请求。|\n|15\t|Extension-mothed |在不改动协议的前提下，可增加另外的方法。|\n\n## __响应报文__\n\n服务端接收到请求报文之后，了解到客户端需要什么样的服务之后就会返回响应报文给客户端。\n\n响应报文格式如下：\n\n{% img /学习HTTP协议-用socket实现http访问/2.jpg %}\n\n- 状态行，如：\n\n> HTTP/1.1 200 OK\n\n- 响应头部，如：\n\n> Date: Fri, 04 Mar 2016 11:04:01 GMT\n> Server: Apache/2.4.7 (Ubuntu)\n> X-Powered-By: PHP/5.5.9-1ubuntu4.14\n> Expires: Thu, 19 Nov 1981 08:52:00 GMT\n> Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0\n> Pragma: no-cache\n> Content-Length: 20\n> Keep-Alive: timeout=5, max=100\n> Connection: Keep-Alive\n> Content-Type: text/html\n\n- 响应包体，即页面显示的内容，如：\n\n> {\"result\":\"success\"}\n\n### _状态码_\n\n状态码由三位数字组成，第一位数字表示响应的类型，常用的状态码有五大类如下所示：\n\n　　1xx：表示服务器已接收了客户端请求，客户端可继续发送请求;\n\n　　2xx：表示服务器已成功接收到请求并进行处理;\n\n　　3xx：表示服务器要求客户端重定向;\n\n　　4xx：表示客户端的请求有非法内容;\n\n　　5xx：表示服务器未能正常处理客户端的请求而出现意外错误;\n\n## __使用 Socket 发送 HTTP 请求报文__\n\n我们知道 HTTP 协议是基于 TCP 的，而我们可以使用 Socket 进行 TCP 连接，所以在充分理解 HTTP 报文之后我们就可以用 socket 实现自己的 HTTP 访问了。\n\n### _访问网页_\n\n首先我们看看怎样用 socket 实现 http 访问网页,这里我们尝试使用 GET 方法访问 [www.islinjw.cn](http://www.islinjw.cn)。\n\n流程如下：\n1. 使用 socket 连接服务器\n2. 发送请求报文\n3. 接收响应报文\n4. 断开 socket 连接\n\n重点在于发送请求报文，其他步骤和一般的 socket 程序是没有什么区别的。\n\n请求报文分为三个部分还记得吗？\n\n- 请求行\n使用 HTTP/1.1 协议的 GET 方法访问网站的根目录：\n\n> GET / HTTP/1.1\n\n- 请求头部\nHost 是请求头部唯一必须携带的数据，要不然能接收到数据，但服务器返回302、400这样的错误代码。原因是服务器可能使用了虚拟服务器技术，一台服务器托管了多个网站，即多个网站通过dns解析到同样的ip地址。像这里我们访问 www.islinjw.cn 主机：\n\n> Host: www.islinjw.cn\n\n- 请求实体：\n但我们这里因为只是单纯的获取页面，并没有传递数据给服务器，所以报文实体为空。\n\n每个部分之间使用 \"\\\\r\\\\n\" 分割。但需要在请求报文的最后加多一个 \"\\\\n\"。为什么？还记得请求头部和请求实体之间有一个什么东西吗？对，空行！因为这里没有请求实体，所以报文最后就是一个空行。如果没有它，服务器不会返回响应报文，程序就会一直阻塞在那里。\n\n所以最终发送的报文就是:\n\n> GET / HTTP/1.1\\r\\nHost: www.islinjw.cn\\r\\n\\n\n\n代码如下：\n\n```cpp\n    void TestRequest(){\n        void TestRequest(){\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string data = \"\";\n\n        //请求行\n        data += \"GET / HTTP/1.1\\r\\n\";\n\n        //请求头部\n        data += \"Host: www.islinjw.cn\\r\\n\\n\";\n\n        send(sock_client,data.c_str(),data.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n```\n\n服务器返回的响应报文如下（对，这个网站就是一个 hello world 在那里而已）：\n\n{% img /学习HTTP协议-用socket实现http访问/3.jpg %}\n\n### _使用 GET 方法_\n\n为了验证是否真的传送了数据给服务器，我写了一个 demo 页面 [www.islinjw.cn/http_packet_demo/demo.php](http://www.islinjw.cn/http_packet_demo/demo.php)。这个页面的功能很简单，就是把接收到的 GET 数据和 POST 数据通过 json 格式打印出而已：\n\n{% img /学习HTTP协议-用socket实现http访问/4.jpg %}\n\n我们首先写一个函数用来把 map 转化成 GET 方法的参数格式：\n\n```cpp\n    string MsgToString(const map<string,string>& msg){\n        string result = \"\";\n        map<string,string>::const_iterator i = msg.begin();\n        while(i!=msg.end()){\n            result += i->first + \"=\" + i->second;\n            i++;\n            if(i!=msg.end()){\n                result += \"&\";\n            }\n        }\n        return result;\n    }\n```\n\n之前提到，GET 方法的数据是通过 URL 来传递的，所以只需要把得到的 GET 方法参数拼接到请求行的 URL 后面就行了：\n\n```cpp\n\tstring url = \"/http_packet_demo/demo.php\";\n\turl += \"?\" + MsgToString(msg);\n    cout<<\"url : \"<<url<<endl;\n\n\tstring packet = \"\";\n\n\t//请求行\n\tpacket += \"GET \" + url + \" HTTP/1.1\\r\\n\";\n```\n\n其他的和刚刚讲的访问网页的方式一模一样：\n\n```cpp\n\tvoid TestGet(const map<string,string>& msg){\n        //连接服务器主机\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string url = \"/http_packet_demo/demo.php\";\n        url += \"?\" + MsgToString(msg);\n\n        cout<<\"url : \"<<url<<endl;\n\n        string packet = \"\";\n\n        //请求行\n        packet += \"GET \" + url + \" HTTP/1.1\\r\\n\";\n\n        //请求头部\n        packet += \"Host: www.baidu.com\\r\\n\";\n\n        //空行\n        packet += \"\\n\";\n\n        send(sock_client, packet.c_str(), packet.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n```\n\n我们这样调用:\n\n```cpp\n\tmap<string,string> msg;\n\tmsg[\"abc\"] = \"123\";\n\tmsg[\"def\"] = \"456\";\n\n\tTestGet(msg);\n```\n\nURL 长这个样子：\n\n{% img /学习HTTP协议-用socket实现http访问/5.jpg %}\n\n服务器返回的响应报文如下：：\n\n{% img /学习HTTP协议-用socket实现http访问/6.jpg %}\n\n### _使用 POST 方法_\n\n使用 POST 方法会复杂那么一点点。首先请求行没有什么特别的，就是指定了 POST 方法和我们的页面，而且 URL 没有带数据:\n\n```cpp\n\tstring url = \"/http_packet_demo/demo.php\";\n\n\tstring packet = \"\";\n\n\t//请求行\n\tpacket += \"POST \" + url + \" HTTP/1.1\\r\\n\";\n```\n\n但因为 POST 携带的数据不一定是字符串，有可能是图片等二进制图片，所以就需要在请求头部告诉服务器携带的数据的类型和数据的长度:\n\n```cpp\n\t//请求头部\n\tpacket += \"Host: www.islinjw.cn\\r\\n\";\n\tpacket += \"Content-Type:application/x-www-form-urlencoded\\r\\n\"; //指定post传递的数据类型\n\tpacket += \"Content-Length: \" + ss.str() + \"\\r\\n\"; //标记post传递的数据的长度\n```\n\n之后就是一个空行和携带了数据的请求实体了：\n\n```cpp\n\t//空行\n\tpacket += \"\\n\";\n\n\t//post数据\n\tpacket += data;\n```\n\n所以整个方法长这个样子:\n\n```cpp\n    void TestPost(const map<string,string>& msg){\n        string data = MsgToString(msg);\n\n        stringstream ss;\n        ss<<data.length();\n\n        //连接服务器主机\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string url = \"/http_packet_demo/demo.php\";\n\n        string packet = \"\";\n\n        //请求行\n        packet += \"POST \" + url + \" HTTP/1.1\\r\\n\";\n\n        //请求头部\n        packet += \"Host: www.islinjw.cn\\r\\n\";\n        packet += \"Content-Type:application/x-www-form-urlencoded\\r\\n\"; //指定post传递的数据类型\n        packet += \"Content-Length: \" + ss.str() + \"\\r\\n\"; //标记post传递的数据的长度\n\n        //空行\n        packet += \"\\n\";\n\n        //post数据\n        packet += data;\n\n        send(sock_client, packet.c_str(), packet.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n```\n\n发送的数据如下：\n\n```cpp\n\tmap<string,string> msg;\n\tmsg[\"abc\"] = \"123\";\n\tmsg[\"def\"] = \"456\";\n\n\tTestPost(msg);\n```\n\n服务器返回的响应实体如下：\n\n{% img /学习HTTP协议-用socket实现http访问/7.jpg %}\n\n## __demo 完整代码__\n\n```cpp\n    #include \"stdafx.h\"\n\n    #include <Winsock2.h>\n    #include <iostream>\n    #include <map>\n    #include <string>\n    #include <sstream>\n\n    #pragma comment( lib, \"ws2_32.lib\" )\n\n    using namespace std;\n\n    const string SERVER_IP = \"182.254.231.66\";\n\n    SOCKET Connect(const char* ip){\n\n        //固定格式\n        WORD wVersionRequested;\n        WSADATA wsaData;\n        int err;\n\n        wVersionRequested = MAKEWORD( 1, 1 );\n\n        err = WSAStartup( wVersionRequested, &wsaData );\n        if ( err != 0 ) {\n            return INVALID_SOCKET;\n        }\n\n\n        if ( LOBYTE( wsaData.wVersion ) != 1 ||\n            HIBYTE( wsaData.wVersion ) != 1 ) {\n            WSACleanup( );\n            return INVALID_SOCKET;\n        }\n\n        SOCKET sock_client=socket(AF_INET,SOCK_STREAM,0);\n\n        SOCKADDR_IN addrSrv;\n        addrSrv.sin_addr.S_un.S_addr=inet_addr(ip);\n        addrSrv.sin_family=AF_INET;\n        addrSrv.sin_port=htons(80);//http端口为80\n        connect(sock_client,(SOCKADDR*)&addrSrv,sizeof(SOCKADDR));\n\n        return sock_client;\n    }\n\n    void Disconnect(SOCKET sock_client){\n        closesocket(sock_client);\n        WSACleanup();\n    }\n\n    void PrintRecvData(SOCKET sock_client){\n        cout<<\"Recv data :\"<<endl;\n\n        int len = 0;\n        char recvBuf[1024];\n        while((len = recv(sock_client,recvBuf,1023,0))>0){\n            recvBuf[len] = '\\0';\n            cout<<recvBuf;\n        }\n        cout<<endl;\n    }\n\n    void TestRequest(){\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        //最后必须多一个空行（\\n），要不然会阻塞住\n        //这个空行其实是报文首部和报文主体的分割符号，但这里请求不需要报文主体，所以是请求报文的结束\n        //string data = \"GET / HTTP/1.1\\r\\nHost: www.islinjw.cn\\r\\n\";\n\n        //HOST也是必须的，要不然能接收到数据，但服务器返回302、400这样的错误代码\n        //原因是服务器可能使用了虚拟服务器技术，一台服务器托管了多个网站，即多个网站通过dns解析到同样的ip地址\n        //所以在发送http请求时必须带上HOST\n        //string data = \"GET / HTTP/1.1\\r\\n\\n\";\n\n        string data = \"\";\n\n        //请求行\n        data += \"GET / HTTP/1.1\\r\\n\";\n\n        //请求头部\n        data += \"Host: www.islinjw.cn\\r\\n\\n\";\n\n        send(sock_client,data.c_str(),data.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n\n    string MsgToString(const map<string,string>& msg){\n        string result = \"\";\n        map<string,string>::const_iterator i = msg.begin();\n        while(i!=msg.end()){\n            result += i->first + \"=\" + i->second;\n            i++;\n            if(i!=msg.end()){\n                result += \"&\";\n            }\n        }\n        return result;\n    }\n\n    void TestGet(const map<string,string>& msg){\n        //连接服务器主机\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string url = \"/http_packet_demo/demo.php\";\n        url += \"?\" + MsgToString(msg);\n\n        cout<<\"url : \"<<url<<endl;\n\n        string packet = \"\";\n\n        //请求行\n        packet += \"GET \" + url + \" HTTP/1.1\\r\\n\";\n\n        //请求头部\n        packet += \"Host: www.baidu.com\\r\\n\";\n\n        //空行\n        packet += \"\\n\";\n\n        send(sock_client, packet.c_str(), packet.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n\n    void TestPost(const map<string,string>& msg){\n        string data = MsgToString(msg);\n\n        stringstream ss;\n        ss<<data.length();\n\n        //连接服务器主机\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string url = \"/http_packet_demo/demo.php\";\n\n        string packet = \"\";\n\n        //请求行\n        packet += \"POST \" + url + \" HTTP/1.1\\r\\n\";\n\n        //请求头部\n        packet += \"Host: www.islinjw.cn\\r\\n\";\n        packet += \"Content-Type:application/x-www-form-urlencoded\\r\\n\"; //指定post传递的数据类型\n        packet += \"Content-Length: \" + ss.str() + \"\\r\\n\"; //标记post传递的数据的长度\n\n        //空行\n        packet += \"\\n\";\n\n        //post数据\n        packet += data;\n\n        send(sock_client, packet.c_str(), packet.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n\n    int main(int argc, char* argv[])\n    {\n        map<string,string> msg;\n        msg[\"abc\"] = \"123\";\n        msg[\"def\"] = \"456\";\n\n        TestRequest();\n        cout<<\"\\n\\n\\n\"<<endl;\n        TestGet(msg);\n        cout<<\"\\n\\n\\n\"<<endl;\n        TestPost(msg);\n\n        return 0;\n    }\n\n\n\n```\n","source":"_posts/学习HTTP协议-用socket实现http访问.md","raw":"title: 学习HTTP协议-用socket实现http访问\ndate: 2016-03-04 22:16:30\ntags:\n\t- 技术相关\n\t- Http协议\n---\n\n相信大家都知道 http 报文这东西吧？http 报文分两种，请求报文和响应报文。\n\n## __请求报文__\n\n客户端向服务端发送的就是请求报文，它可告诉服务端自己需要什么样的资源，也可以将一些文件或者数据上传给服务端。\n\n请求报文格式如下：\n\n{% img /学习HTTP协议-用socket实现http访问/1.jpg %}\n\n请求报文分为三个部分：\n\n- 请求行，如：\n\n> GET / HTTP/1.1\n\n这个请求行表明了这次请求使用的是 GET 方法，访问的是网站的根目录，使用的 HTTP 协议版本是 1.1。\n\n- 请求头部，如：\n\n> Host: www.baidu.com\n> Connection: keep-alive\n\n- 请求包体\n\n用来携带数据\n\n### _GET 方法_\n\nGET 方法是 HTTP 中最基础的方法，我们在浏览器地址栏输入网站浏览网页使用的都是 GET 方法：\n\n> http://www.islinjw.cn/okhttp_cookie_demo/checkverifycode.php\n\n当然有时候服务器需要根据用户传递的信息去返回对应的数据，GET 方法用下面的形式传递信息给服务器：\n\n> http://www.islinjw.cn/okhttp_cookie_demo/checkverifycode.php?verifycode=qwjuy&format=json\n\n这里告诉给服务器 verifycode=qwjuy 和 format=json ，服务器会根据用户传过来的信息返回不同的数据。\n\n这个时候的请求行长这个样子，URL 上就携带了 GET 传递的数据：\n\n> GET /okhttp_cookie_demo/checkverifycode.php?verifycode=qwjuy&format=json HTTP/1.1\n\n这里再说一句题外话，并不是说如果在 URL 里面没有见到 “?” 这个符号，客户端就没有传递数据给服务器。有一种叫做网页伪静态化的技术可以实现不带问号的 URL 使用 GET 方法传递数据。\n\n### _POST 方法_\n\nGET 方法的参数都显示在 URl 上，这样对于诸如账户密码的敏感信息来说太不安全，而且也很难传递想图片这样的数据。所以就有了 POST 方法。\n\n使用 POST 方法传递的数据并不会显示在 URL 上，而是保存在请求包体中，当然 HTTP 协议是明文传输的，所以把账户密码直接用 POST 传递也是不安全的，需要程序员自己进行加密处理。\n\n### _HTTP 协议方法列表_\n\n|序号 |方法 |描述|\n|---|---|---|\n|1 |GET |请求指定的页面信息，并返回实体主体。|\n|2 |HEAD |类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头|\n|3 |POST |向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。|\n|4 |PUT |从客户端向服务器传送的数据取代指定的文档的内容。|\n|5 |DELETE |请求服务器删除指定的页面。|\n|6 |CONNECT |HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。|\n|7 |OPTIONS\t|允许客户端查看服务器的性能。|\n|8 |TRACE |回显服务器收到的请求，主要用于测试或诊断。|\n|9 |PATCH |实体中包含一个表，表中说明与该URI所表示的原内容的区别。|\n|10 |MOVE |请求服务器将指定的页面移至另一个网络地址。|\n|11\t|COPY |请求服务器将指定的页面拷贝至另一个网络地址。|\n|12\t|LINK |请求服务器建立链接关系。|\n|13\t|UNLINK |断开链接关系。|\n|14\t|WRAPPED |允许客户端发送经过封装的请求。|\n|15\t|Extension-mothed |在不改动协议的前提下，可增加另外的方法。|\n\n## __响应报文__\n\n服务端接收到请求报文之后，了解到客户端需要什么样的服务之后就会返回响应报文给客户端。\n\n响应报文格式如下：\n\n{% img /学习HTTP协议-用socket实现http访问/2.jpg %}\n\n- 状态行，如：\n\n> HTTP/1.1 200 OK\n\n- 响应头部，如：\n\n> Date: Fri, 04 Mar 2016 11:04:01 GMT\n> Server: Apache/2.4.7 (Ubuntu)\n> X-Powered-By: PHP/5.5.9-1ubuntu4.14\n> Expires: Thu, 19 Nov 1981 08:52:00 GMT\n> Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0\n> Pragma: no-cache\n> Content-Length: 20\n> Keep-Alive: timeout=5, max=100\n> Connection: Keep-Alive\n> Content-Type: text/html\n\n- 响应包体，即页面显示的内容，如：\n\n> {\"result\":\"success\"}\n\n### _状态码_\n\n状态码由三位数字组成，第一位数字表示响应的类型，常用的状态码有五大类如下所示：\n\n　　1xx：表示服务器已接收了客户端请求，客户端可继续发送请求;\n\n　　2xx：表示服务器已成功接收到请求并进行处理;\n\n　　3xx：表示服务器要求客户端重定向;\n\n　　4xx：表示客户端的请求有非法内容;\n\n　　5xx：表示服务器未能正常处理客户端的请求而出现意外错误;\n\n## __使用 Socket 发送 HTTP 请求报文__\n\n我们知道 HTTP 协议是基于 TCP 的，而我们可以使用 Socket 进行 TCP 连接，所以在充分理解 HTTP 报文之后我们就可以用 socket 实现自己的 HTTP 访问了。\n\n### _访问网页_\n\n首先我们看看怎样用 socket 实现 http 访问网页,这里我们尝试使用 GET 方法访问 [www.islinjw.cn](http://www.islinjw.cn)。\n\n流程如下：\n1. 使用 socket 连接服务器\n2. 发送请求报文\n3. 接收响应报文\n4. 断开 socket 连接\n\n重点在于发送请求报文，其他步骤和一般的 socket 程序是没有什么区别的。\n\n请求报文分为三个部分还记得吗？\n\n- 请求行\n使用 HTTP/1.1 协议的 GET 方法访问网站的根目录：\n\n> GET / HTTP/1.1\n\n- 请求头部\nHost 是请求头部唯一必须携带的数据，要不然能接收到数据，但服务器返回302、400这样的错误代码。原因是服务器可能使用了虚拟服务器技术，一台服务器托管了多个网站，即多个网站通过dns解析到同样的ip地址。像这里我们访问 www.islinjw.cn 主机：\n\n> Host: www.islinjw.cn\n\n- 请求实体：\n但我们这里因为只是单纯的获取页面，并没有传递数据给服务器，所以报文实体为空。\n\n每个部分之间使用 \"\\\\r\\\\n\" 分割。但需要在请求报文的最后加多一个 \"\\\\n\"。为什么？还记得请求头部和请求实体之间有一个什么东西吗？对，空行！因为这里没有请求实体，所以报文最后就是一个空行。如果没有它，服务器不会返回响应报文，程序就会一直阻塞在那里。\n\n所以最终发送的报文就是:\n\n> GET / HTTP/1.1\\r\\nHost: www.islinjw.cn\\r\\n\\n\n\n代码如下：\n\n```cpp\n    void TestRequest(){\n        void TestRequest(){\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string data = \"\";\n\n        //请求行\n        data += \"GET / HTTP/1.1\\r\\n\";\n\n        //请求头部\n        data += \"Host: www.islinjw.cn\\r\\n\\n\";\n\n        send(sock_client,data.c_str(),data.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n```\n\n服务器返回的响应报文如下（对，这个网站就是一个 hello world 在那里而已）：\n\n{% img /学习HTTP协议-用socket实现http访问/3.jpg %}\n\n### _使用 GET 方法_\n\n为了验证是否真的传送了数据给服务器，我写了一个 demo 页面 [www.islinjw.cn/http_packet_demo/demo.php](http://www.islinjw.cn/http_packet_demo/demo.php)。这个页面的功能很简单，就是把接收到的 GET 数据和 POST 数据通过 json 格式打印出而已：\n\n{% img /学习HTTP协议-用socket实现http访问/4.jpg %}\n\n我们首先写一个函数用来把 map 转化成 GET 方法的参数格式：\n\n```cpp\n    string MsgToString(const map<string,string>& msg){\n        string result = \"\";\n        map<string,string>::const_iterator i = msg.begin();\n        while(i!=msg.end()){\n            result += i->first + \"=\" + i->second;\n            i++;\n            if(i!=msg.end()){\n                result += \"&\";\n            }\n        }\n        return result;\n    }\n```\n\n之前提到，GET 方法的数据是通过 URL 来传递的，所以只需要把得到的 GET 方法参数拼接到请求行的 URL 后面就行了：\n\n```cpp\n\tstring url = \"/http_packet_demo/demo.php\";\n\turl += \"?\" + MsgToString(msg);\n    cout<<\"url : \"<<url<<endl;\n\n\tstring packet = \"\";\n\n\t//请求行\n\tpacket += \"GET \" + url + \" HTTP/1.1\\r\\n\";\n```\n\n其他的和刚刚讲的访问网页的方式一模一样：\n\n```cpp\n\tvoid TestGet(const map<string,string>& msg){\n        //连接服务器主机\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string url = \"/http_packet_demo/demo.php\";\n        url += \"?\" + MsgToString(msg);\n\n        cout<<\"url : \"<<url<<endl;\n\n        string packet = \"\";\n\n        //请求行\n        packet += \"GET \" + url + \" HTTP/1.1\\r\\n\";\n\n        //请求头部\n        packet += \"Host: www.baidu.com\\r\\n\";\n\n        //空行\n        packet += \"\\n\";\n\n        send(sock_client, packet.c_str(), packet.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n```\n\n我们这样调用:\n\n```cpp\n\tmap<string,string> msg;\n\tmsg[\"abc\"] = \"123\";\n\tmsg[\"def\"] = \"456\";\n\n\tTestGet(msg);\n```\n\nURL 长这个样子：\n\n{% img /学习HTTP协议-用socket实现http访问/5.jpg %}\n\n服务器返回的响应报文如下：：\n\n{% img /学习HTTP协议-用socket实现http访问/6.jpg %}\n\n### _使用 POST 方法_\n\n使用 POST 方法会复杂那么一点点。首先请求行没有什么特别的，就是指定了 POST 方法和我们的页面，而且 URL 没有带数据:\n\n```cpp\n\tstring url = \"/http_packet_demo/demo.php\";\n\n\tstring packet = \"\";\n\n\t//请求行\n\tpacket += \"POST \" + url + \" HTTP/1.1\\r\\n\";\n```\n\n但因为 POST 携带的数据不一定是字符串，有可能是图片等二进制图片，所以就需要在请求头部告诉服务器携带的数据的类型和数据的长度:\n\n```cpp\n\t//请求头部\n\tpacket += \"Host: www.islinjw.cn\\r\\n\";\n\tpacket += \"Content-Type:application/x-www-form-urlencoded\\r\\n\"; //指定post传递的数据类型\n\tpacket += \"Content-Length: \" + ss.str() + \"\\r\\n\"; //标记post传递的数据的长度\n```\n\n之后就是一个空行和携带了数据的请求实体了：\n\n```cpp\n\t//空行\n\tpacket += \"\\n\";\n\n\t//post数据\n\tpacket += data;\n```\n\n所以整个方法长这个样子:\n\n```cpp\n    void TestPost(const map<string,string>& msg){\n        string data = MsgToString(msg);\n\n        stringstream ss;\n        ss<<data.length();\n\n        //连接服务器主机\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string url = \"/http_packet_demo/demo.php\";\n\n        string packet = \"\";\n\n        //请求行\n        packet += \"POST \" + url + \" HTTP/1.1\\r\\n\";\n\n        //请求头部\n        packet += \"Host: www.islinjw.cn\\r\\n\";\n        packet += \"Content-Type:application/x-www-form-urlencoded\\r\\n\"; //指定post传递的数据类型\n        packet += \"Content-Length: \" + ss.str() + \"\\r\\n\"; //标记post传递的数据的长度\n\n        //空行\n        packet += \"\\n\";\n\n        //post数据\n        packet += data;\n\n        send(sock_client, packet.c_str(), packet.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n```\n\n发送的数据如下：\n\n```cpp\n\tmap<string,string> msg;\n\tmsg[\"abc\"] = \"123\";\n\tmsg[\"def\"] = \"456\";\n\n\tTestPost(msg);\n```\n\n服务器返回的响应实体如下：\n\n{% img /学习HTTP协议-用socket实现http访问/7.jpg %}\n\n## __demo 完整代码__\n\n```cpp\n    #include \"stdafx.h\"\n\n    #include <Winsock2.h>\n    #include <iostream>\n    #include <map>\n    #include <string>\n    #include <sstream>\n\n    #pragma comment( lib, \"ws2_32.lib\" )\n\n    using namespace std;\n\n    const string SERVER_IP = \"182.254.231.66\";\n\n    SOCKET Connect(const char* ip){\n\n        //固定格式\n        WORD wVersionRequested;\n        WSADATA wsaData;\n        int err;\n\n        wVersionRequested = MAKEWORD( 1, 1 );\n\n        err = WSAStartup( wVersionRequested, &wsaData );\n        if ( err != 0 ) {\n            return INVALID_SOCKET;\n        }\n\n\n        if ( LOBYTE( wsaData.wVersion ) != 1 ||\n            HIBYTE( wsaData.wVersion ) != 1 ) {\n            WSACleanup( );\n            return INVALID_SOCKET;\n        }\n\n        SOCKET sock_client=socket(AF_INET,SOCK_STREAM,0);\n\n        SOCKADDR_IN addrSrv;\n        addrSrv.sin_addr.S_un.S_addr=inet_addr(ip);\n        addrSrv.sin_family=AF_INET;\n        addrSrv.sin_port=htons(80);//http端口为80\n        connect(sock_client,(SOCKADDR*)&addrSrv,sizeof(SOCKADDR));\n\n        return sock_client;\n    }\n\n    void Disconnect(SOCKET sock_client){\n        closesocket(sock_client);\n        WSACleanup();\n    }\n\n    void PrintRecvData(SOCKET sock_client){\n        cout<<\"Recv data :\"<<endl;\n\n        int len = 0;\n        char recvBuf[1024];\n        while((len = recv(sock_client,recvBuf,1023,0))>0){\n            recvBuf[len] = '\\0';\n            cout<<recvBuf;\n        }\n        cout<<endl;\n    }\n\n    void TestRequest(){\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        //最后必须多一个空行（\\n），要不然会阻塞住\n        //这个空行其实是报文首部和报文主体的分割符号，但这里请求不需要报文主体，所以是请求报文的结束\n        //string data = \"GET / HTTP/1.1\\r\\nHost: www.islinjw.cn\\r\\n\";\n\n        //HOST也是必须的，要不然能接收到数据，但服务器返回302、400这样的错误代码\n        //原因是服务器可能使用了虚拟服务器技术，一台服务器托管了多个网站，即多个网站通过dns解析到同样的ip地址\n        //所以在发送http请求时必须带上HOST\n        //string data = \"GET / HTTP/1.1\\r\\n\\n\";\n\n        string data = \"\";\n\n        //请求行\n        data += \"GET / HTTP/1.1\\r\\n\";\n\n        //请求头部\n        data += \"Host: www.islinjw.cn\\r\\n\\n\";\n\n        send(sock_client,data.c_str(),data.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n\n    string MsgToString(const map<string,string>& msg){\n        string result = \"\";\n        map<string,string>::const_iterator i = msg.begin();\n        while(i!=msg.end()){\n            result += i->first + \"=\" + i->second;\n            i++;\n            if(i!=msg.end()){\n                result += \"&\";\n            }\n        }\n        return result;\n    }\n\n    void TestGet(const map<string,string>& msg){\n        //连接服务器主机\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string url = \"/http_packet_demo/demo.php\";\n        url += \"?\" + MsgToString(msg);\n\n        cout<<\"url : \"<<url<<endl;\n\n        string packet = \"\";\n\n        //请求行\n        packet += \"GET \" + url + \" HTTP/1.1\\r\\n\";\n\n        //请求头部\n        packet += \"Host: www.baidu.com\\r\\n\";\n\n        //空行\n        packet += \"\\n\";\n\n        send(sock_client, packet.c_str(), packet.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n\n    void TestPost(const map<string,string>& msg){\n        string data = MsgToString(msg);\n\n        stringstream ss;\n        ss<<data.length();\n\n        //连接服务器主机\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string url = \"/http_packet_demo/demo.php\";\n\n        string packet = \"\";\n\n        //请求行\n        packet += \"POST \" + url + \" HTTP/1.1\\r\\n\";\n\n        //请求头部\n        packet += \"Host: www.islinjw.cn\\r\\n\";\n        packet += \"Content-Type:application/x-www-form-urlencoded\\r\\n\"; //指定post传递的数据类型\n        packet += \"Content-Length: \" + ss.str() + \"\\r\\n\"; //标记post传递的数据的长度\n\n        //空行\n        packet += \"\\n\";\n\n        //post数据\n        packet += data;\n\n        send(sock_client, packet.c_str(), packet.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n\n    int main(int argc, char* argv[])\n    {\n        map<string,string> msg;\n        msg[\"abc\"] = \"123\";\n        msg[\"def\"] = \"456\";\n\n        TestRequest();\n        cout<<\"\\n\\n\\n\"<<endl;\n        TestGet(msg);\n        cout<<\"\\n\\n\\n\"<<endl;\n        TestPost(msg);\n\n        return 0;\n    }\n\n\n\n```\n","slug":"学习HTTP协议-用socket实现http访问","published":1,"updated":"2017-05-12T23:19:13.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2ro85ci000h4kr4ii1l51im"},{"title":"学习HTTP协议-在安卓上的使用Cookie与Session","date":"2016-03-03T12:43:26.000Z","_content":"\n大三的时候写过一段时间的 php ，那时候已经对 html、css、js、cookie、session 这些东西了一点认知，但基本都是浮于表面，知其然而不知其所以然。于是这几天翻了翻《图解http》，书上的知识和自己的以前的理解结合起来，感觉对于 http 协议有了一些比较深刻的理解。\n\n在这里把那些知识点整理记录一下，而因为 HTTP 协议的知识点较多，所以会有一个系列的博客去介绍。这篇文章就先讲一下 Cookie 和 Session 吧。\n\n## __Cookie & Session__\n\n毕业设计有个功能是实现用户的注册登录，而注册账号的时候需要有输入验证码的功能。\n\n众所周知，HTTP 协议是无状态协议，即协议对于事务处理没有记忆能力。但就像这里，我们需要实现一个验证码功能，我们从服务器获取验证码的图片，然后再将用户输入的验证码传回服务器进行对比，这就要求服务器记录之前随机生成的验证码了。于是，两种用于保持HTTP连接状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session。\n\n### _Cookie_\n\nCookie 是由服务器端生成，发送给 User-Agent（一般是浏览器），浏览器会将 Cookie 的 key/value 保存到某个目录下的文本文件内，下次请求同一网站时就发送该 Cookie 给服务器（前提是浏览器设置为启用 cookie ）。\n\n我们可以在 chrome 浏览器页面按 F12 打开控制台，选择 Network 标签查看与网站进行 HTTP 协议交流的数据。\n\n这里我们看看登录[B站](http://www.bilibili.tv)的时候究竟发生了什么事情：\n\n首先我们输入账号密码和验证码之后点击登陆，浏览器会发生账号密码等数据给服务器,之后服务器返回数据。我们查看返回报文的 header 可以看到一堆的 Set-Cookie 字段：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/1.jpg %}\n\n客户端会把这些 cookie 记录下来，在下次访问服务器的时候就会把它们传回给服务器，这样就能实现数据的保持：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/2.jpg %}\n\n### _Session_\n\n但 Cookie 的数据都是保存在客户端的，客户端很容易就能查看和修改 cookie，十分不安全。例如 chrome 有一个 EditThisCookie 插件，就能直接查看修改网页的 cookie：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/3.jpg %}\n\n所以就有了存放在服务器端的内存中的 sessio，session可以看作一个存放在服务器的键值对集。\n\n当服务器创建一个 session 对象的时候，就会对应的生成一个sessionId，服务器可以在 session 中写入数据，但它不会将session 的内容告诉客户端，它只会将生成的 sessionId 以 cookie 的方式传给客户端，而客户端在下次访问服务器的时候把 sessionId 又传回给服务器，这样服务器就能找到之前保存的数据了。\n\n在 php 中这个 sessionid 的名字默认叫做 PHPSESSID，当然也能在php.ini中修改。\n\n因为 session 保存在服务器中，所以安全性比 cookie 高的多。\n\n关于 Cookie 和 Session，各位有兴趣的话可以自己去网上搜索一下，或者希望对 HTTP 协议有更深入的理解的话可以去读一下《图解http》。最近就在读这本书，等读完我会写一篇博客，介绍一些 HTTP 协议的重点知识，这里就不再多说了。\n\n## __okHttp3 使用 Cookie__\n\nokHttp3 的 cookie 管理方式对比 okHttp2 有了很大的变化，这里有一篇博客专门介绍[OkHttp3实现Cookies管理及持久化](http://www.codeceo.com/article/okhttp3-cookies-manage.html)。希望各位在读我这篇博客之前先浏览一下。\n\nokHttp3 使用 CookieJar 接口来管理 Cookie：\n\n```java\n\tpublic interface CookieJar {\n  \t/** A cookie jar that never accepts any cookies. */\n  \tCookieJar NO_COOKIES = new CookieJar() {\n    @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {\n    }\n\n    @Override public List<Cookie> loadForRequest(HttpUrl url) {\n      return Collections.emptyList();\n    }\n  \t};\n```\n\n我们只要在创建 OkHttpClient 的时候指定我们自己的 CookieJar 就能让 OkHttpClient 实现 Cookie 的自动管理：\n\n```java\n\tpublic class MainActivity extends AppCompatActivity {\n    \tprivate Map<String, List<Cookie>> mCookieStore;\n        ...\n        private OkHttpClient createHttpClient() {\n            CookieJar cookieJar = new CookieJar() {\n                @Override\n                public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {\n                    mCookieStore.put(url.host(), cookies);\n                }\n\n                @Override\n                public List<Cookie> loadForRequest(HttpUrl url) {\n                    List list = mCookieStore.get(url.host());\n                    return list != null ? list : new ArrayList<Cookie>();\n                }\n            };\n            return new OkHttpClient.Builder()\n                    .cookieJar(cookieJar)\n                    .build();\n        }\n        ...\n\t}\n```\n\n这里有点要注意，我们是拿 host 作 map 的 key 值，[《OkHttp3实现Cookies管理及持久化》](http://www.codeceo.com/article/okhttp3-cookies-manage.html)这篇博文直接用 url 当 key 值，这样的话该 Cookie 就只能在当前页面可用了，而我们是整个网站可用。\n\n## __Retrofit 使用 Cookie__\n\n在 Retrofit 中使用 Cookie 就更加简单了，因为它内部使用 OkHttp3，只要把之前设置了 CookieJar 的 OkHttpClient 设置给它就可以了：\n\n```java\n\tHttpService service = new Retrofit.Builder()\n                .client(mHttpClient) //OkHttpClient 指定了 CookieJar，这样 Retrofit 也能使用 Cookie 了\n                .baseUrl(mBaseUrl)\n                .addConverterFactory(GsonConverterFactory.create())\n                .build()\n                .create(HttpService.class);\n```\n\n## __验证码小 Demo__\n\n现状我们用一个实现了验证码功能的小 Demo 来更加深刻的理解之前所讲的知识。\n\n首先我写了两个页面：\n\n- 生成验证码的页面 ： http://www.islinjw.cn/okhttp_cookie_demo/verifycode.php\n- 检查验证码的页面 ： http://www.islinjw.cn/okhttp_cookie_demo/checkverifycode.php\n\n访问第一个页面能获得一张随机的验证码图片，而第二个页面使用 GET 方法来检测验证码（键值为 verifycode）。\n\n### _获取验证码图片_\n\n首先我们使用 OkHttp3 访问第一个页面，下载一张验证码图片，将它显示在 ImageView 中：\n\n```java\n\tprivate void loadVerifyCode(final ImageView imageView, final HttpUrl url) {\n        final Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    okhttp3.Response response = mHttpClient.newCall(request).execute();\n\n                    //创建bitmap\n                    InputStream is = response.body().byteStream();\n                    final Bitmap bm = BitmapFactory.decodeStream(is);\n\n                    //加载到ImageView中\n                    runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            imageView.setImageBitmap(bm);\n                        }\n                    });\n\n                    //打印cookie信息\n                    List<Cookie> cookies = Cookie.parseAll(request.url(), response.headers());\n                    for (int i = 0; i < cookies.size(); i++) {\n                        Log.d(\"cookie\", \"request headers: \" + cookies.get(i).toString());\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n```\n\n运行程序可以看到验证码被显示出来：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/5.jpg %}\n\n我们还能能看到服务器返回的 Cookie 信息，因为我的网页使用 php 写的，所以它返回了一个 PHPSESSID ，用来标记服务器保存的 Session 对象。服务器的 Session 对象里面就保存了验证码的值。之后我们把用户输入的验证码传会服务器的时候只要把这个 PHPSESSID 一同传过去，服务器就能找到之前生成的验证码的值，并和用户所输入的进行对比了:\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/6.jpg %}\n\n### _发送用户输入的验证码_\n\n这里我们直接使用 Retrofit 将用户输入的验证码传给服务器：\n\n```java\n\tpublic void onClick(View v) {\n        HttpService service = new Retrofit.Builder()\n                .client(mHttpClient)  //OkHttpClient 指定了 CookieJar，这样 Retrofit 也能使用 Cookie 了\n                .baseUrl(mBaseUrl)\n                .addConverterFactory(GsonConverterFactory.create())\n                .build()\n                .create(HttpService.class);\n\n        String verifyCode = mEditText.getText().toString();\n        if (verifyCode == null) {\n            return;\n        }\n\n        Call<VerifyCodeResult> call = service.getResult(verifyCode);\n        call.enqueue(new Callback<VerifyCodeResult>() {\n            @Override\n            public void onResponse(Call<VerifyCodeResult> call, Response<VerifyCodeResult> response) {\n                Log.d(\"cookie\", \"request headers: \" + call.request().headers().toString());\n                Toast.makeText(MainActivity.this, response.body().getResult(), Toast.LENGTH_SHORT).show();\n            }\n\n            @Override\n            public void onFailure(Call<VerifyCodeResult> call, Throwable t) {\n            }\n        });\n```\n\n```java\n    public interface HttpService {\n        @GET(\"okhttp_cookie_demo/checkverifycode.php\")\n        Call<VerifyCodeResult> getResult(@Query(\"verifycode\") String yam);\n    }\n```\n\n```java\n    public class VerifyCodeResult {\n        private String result;\n\n        public String getResult() {\n            return result;\n        }\n\n        public void setResult(String result) {\n            this.result = result;\n        }\n    }\n```\n\n运行程序，输入验证码可以看到结果：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/7.jpg %}\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/8.jpg %}\n\n程序正常运行，但看 log 输出，Request 并没有把 PHPSESSID 传过去。这是怎么回事？没有传 PHPSESSID，服务器又怎么能知道之前生成的验证码是什么？\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/9.jpg %}\n\n在 CookieJar 的 loadForRequest 方法设置断点，可以发现在发送验证码的时候确实有调用，随之运行到 HttpEngine 的源码，发现原来框架创建了个新的 Resquest 副本，将 Cookie 传入这个新的副本中去连接服务器：\n\n```java\n    public void sendRequest() throws RequestException, RouteException, IOException {\n        ...\n        Request request = networkRequest(userRequest);\n\t\t...\n    }\n\t...\n    private Request networkRequest(Request request) throws IOException {\n        Request.Builder result = request.newBuilder();\n\n        if (request.header(\"Host\") == null) {\n          result.header(\"Host\", hostHeader(request.url()));\n        }\n\n        if (request.header(\"Connection\") == null) {\n          result.header(\"Connection\", \"Keep-Alive\");\n        }\n\n        if (request.header(\"Accept-Encoding\") == null) {\n          transparentGzip = true;\n          result.header(\"Accept-Encoding\", \"gzip\");\n        }\n\n\t\t//看这里，其实是有设置 CookieJar 中的 Cookie 的\n        //也就是说 PHPSESSID 有传回去给服务器\n        List<Cookie> cookies = client.cookieJar().loadForRequest(request.url());\n        if (!cookies.isEmpty()) {\n          result.header(\"Cookie\", cookieHeader(cookies));\n        }\n\n        if (request.header(\"User-Agent\") == null) {\n          result.header(\"User-Agent\", Version.userAgent());\n        }\n\n        return result.build();\n      }\n```\n\n原来如此，操作都使用了副本 Request 去执行，怪不得我们直接用下面的代码输出，请求头部不能看到 PHPSESSID 的 Cookie 值：\n\n```java\n\t@Override\n    public void onResponse(Call<VerifyCodeResult> call, Response<VerifyCodeResult> response) {\n        Log.d(\"cookie\", \"request headers: \" + call.request().headers().toString());\n        Toast.makeText(MainActivity.this, response.body().getResult(), Toast.LENGTH_SHORT).show();\n    }\n```\n\n## __Glide 使用 Cookie__\n\nGlide 是Google推荐的图片加载库，用来加载图片十分之方便，最少只需要三行代码就能将网络图片加载到 ImageView 上。\n\n我有在 Glide 的文档上看到它也能使用 OkHttp3，理论上应该也能使用设置 OkHttpClient 的方法使用 Cookie。\n\n但弄了很久还是没有搞定，等以后有时间找到实现方法再把这一节补全。\n\n## __Demo 完整代码__\n\nMainActivity:\n\n```java\n\tpublic class MainActivity extends AppCompatActivity {\n    private static final String mBaseUrl = \"http://www.islinjw.cn\";\n    private static final String mVerifyCideUrl = \"http://www.islinjw.cn/okhttp_cookie_demo/verifycode.php\";\n\n    private OkHttpClient mHttpClient;\n    private EditText mEditText;\n    private ImageView mImageView;\n    private Map<String, List<Cookie>> mCookieStore;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mEditText = (EditText) findViewById(R.id.input);\n        mImageView = (ImageView) findViewById(R.id.yzm);\n        mCookieStore = new HashMap<>();\n        mHttpClient = createHttpClient();\n\n        loadVerifyCode(mImageView, HttpUrl.parse(mVerifyCideUrl));\n    }\n\n    private OkHttpClient createHttpClient() {\n        CookieJar cookieJar = new CookieJar() {\n            @Override\n            public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {\n                mCookieStore.put(url.host(), cookies);\n            }\n\n            @Override\n            public List<Cookie> loadForRequest(HttpUrl url) {\n                List list = mCookieStore.get(url.host());\n                return list != null ? list : new ArrayList<Cookie>();\n            }\n        };\n        return new OkHttpClient.Builder()\n                .cookieJar(cookieJar)\n                .build();\n    }\n\n    private void loadVerifyCode(final ImageView imageView, final HttpUrl url) {\n        final Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    okhttp3.Response response = mHttpClient.newCall(request).execute();\n\n                    //创建bitmap\n                    InputStream is = response.body().byteStream();\n                    final Bitmap bm = BitmapFactory.decodeStream(is);\n\n                    //加载到ImageView中\n                    runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            imageView.setImageBitmap(bm);\n                        }\n                    });\n\n                    //打印cookie信息\n                    List<Cookie> cookies = Cookie.parseAll(request.url(), response.headers());\n                    for (int i = 0; i < cookies.size(); i++) {\n                        Log.d(\"cookie\", \"response headers: \" + cookies.get(i).toString());\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n\n    public void onClick(View v) {\n        HttpService service = new Retrofit.Builder()\n                .client(mHttpClient)  //OkHttpClient 指定了 CookieJar，这样 Retrofit 也能使用 Cookie 了\n                .baseUrl(mBaseUrl)\n                .addConverterFactory(GsonConverterFactory.create())\n                .build()\n                .create(HttpService.class);\n\n        String verifyCode = mEditText.getText().toString();\n        if (verifyCode == null) {\n            return;\n        }\n\n        Call<VerifyCodeResult> call = service.getResult(verifyCode);\n        call.enqueue(new Callback<VerifyCodeResult>() {\n            @Override\n            public void onResponse(Call<VerifyCodeResult> call, Response<VerifyCodeResult> response) {\n                Log.d(\"cookie\", \"request headers: \" + call.request().headers().toString());\n                Toast.makeText(MainActivity.this, response.body().getResult(), Toast.LENGTH_SHORT).show();\n            }\n\n            @Override\n            public void onFailure(Call<VerifyCodeResult> call, Throwable t) {\n            }\n        });\n    }\n}\n```\n\nHttpService:\n\n```java\n\tpublic interface HttpService {\n        @GET(\"okhttp_cookie_demo/checkverifycode.php\")\n        Call<VerifyCodeResult> getResult(@Query(\"verifycode\") String yam);\n    }\n```\n\n```java\n\tpublic class VerifyCodeResult {\n        private String result;\n\n        public String getResult() {\n            return result;\n        }\n\n        public void setResult(String result) {\n            this.result = result;\n        }\n    }\n```\n","source":"_posts/学习HTTP协议-在安卓上的使用Cookie与Session.md","raw":"title: 学习HTTP协议-在安卓上的使用Cookie与Session\ndate: 2016-03-03 20:43:26\ntags:\n\t- 技术相关\n\t- Http协议\n---\n\n大三的时候写过一段时间的 php ，那时候已经对 html、css、js、cookie、session 这些东西了一点认知，但基本都是浮于表面，知其然而不知其所以然。于是这几天翻了翻《图解http》，书上的知识和自己的以前的理解结合起来，感觉对于 http 协议有了一些比较深刻的理解。\n\n在这里把那些知识点整理记录一下，而因为 HTTP 协议的知识点较多，所以会有一个系列的博客去介绍。这篇文章就先讲一下 Cookie 和 Session 吧。\n\n## __Cookie & Session__\n\n毕业设计有个功能是实现用户的注册登录，而注册账号的时候需要有输入验证码的功能。\n\n众所周知，HTTP 协议是无状态协议，即协议对于事务处理没有记忆能力。但就像这里，我们需要实现一个验证码功能，我们从服务器获取验证码的图片，然后再将用户输入的验证码传回服务器进行对比，这就要求服务器记录之前随机生成的验证码了。于是，两种用于保持HTTP连接状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session。\n\n### _Cookie_\n\nCookie 是由服务器端生成，发送给 User-Agent（一般是浏览器），浏览器会将 Cookie 的 key/value 保存到某个目录下的文本文件内，下次请求同一网站时就发送该 Cookie 给服务器（前提是浏览器设置为启用 cookie ）。\n\n我们可以在 chrome 浏览器页面按 F12 打开控制台，选择 Network 标签查看与网站进行 HTTP 协议交流的数据。\n\n这里我们看看登录[B站](http://www.bilibili.tv)的时候究竟发生了什么事情：\n\n首先我们输入账号密码和验证码之后点击登陆，浏览器会发生账号密码等数据给服务器,之后服务器返回数据。我们查看返回报文的 header 可以看到一堆的 Set-Cookie 字段：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/1.jpg %}\n\n客户端会把这些 cookie 记录下来，在下次访问服务器的时候就会把它们传回给服务器，这样就能实现数据的保持：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/2.jpg %}\n\n### _Session_\n\n但 Cookie 的数据都是保存在客户端的，客户端很容易就能查看和修改 cookie，十分不安全。例如 chrome 有一个 EditThisCookie 插件，就能直接查看修改网页的 cookie：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/3.jpg %}\n\n所以就有了存放在服务器端的内存中的 sessio，session可以看作一个存放在服务器的键值对集。\n\n当服务器创建一个 session 对象的时候，就会对应的生成一个sessionId，服务器可以在 session 中写入数据，但它不会将session 的内容告诉客户端，它只会将生成的 sessionId 以 cookie 的方式传给客户端，而客户端在下次访问服务器的时候把 sessionId 又传回给服务器，这样服务器就能找到之前保存的数据了。\n\n在 php 中这个 sessionid 的名字默认叫做 PHPSESSID，当然也能在php.ini中修改。\n\n因为 session 保存在服务器中，所以安全性比 cookie 高的多。\n\n关于 Cookie 和 Session，各位有兴趣的话可以自己去网上搜索一下，或者希望对 HTTP 协议有更深入的理解的话可以去读一下《图解http》。最近就在读这本书，等读完我会写一篇博客，介绍一些 HTTP 协议的重点知识，这里就不再多说了。\n\n## __okHttp3 使用 Cookie__\n\nokHttp3 的 cookie 管理方式对比 okHttp2 有了很大的变化，这里有一篇博客专门介绍[OkHttp3实现Cookies管理及持久化](http://www.codeceo.com/article/okhttp3-cookies-manage.html)。希望各位在读我这篇博客之前先浏览一下。\n\nokHttp3 使用 CookieJar 接口来管理 Cookie：\n\n```java\n\tpublic interface CookieJar {\n  \t/** A cookie jar that never accepts any cookies. */\n  \tCookieJar NO_COOKIES = new CookieJar() {\n    @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {\n    }\n\n    @Override public List<Cookie> loadForRequest(HttpUrl url) {\n      return Collections.emptyList();\n    }\n  \t};\n```\n\n我们只要在创建 OkHttpClient 的时候指定我们自己的 CookieJar 就能让 OkHttpClient 实现 Cookie 的自动管理：\n\n```java\n\tpublic class MainActivity extends AppCompatActivity {\n    \tprivate Map<String, List<Cookie>> mCookieStore;\n        ...\n        private OkHttpClient createHttpClient() {\n            CookieJar cookieJar = new CookieJar() {\n                @Override\n                public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {\n                    mCookieStore.put(url.host(), cookies);\n                }\n\n                @Override\n                public List<Cookie> loadForRequest(HttpUrl url) {\n                    List list = mCookieStore.get(url.host());\n                    return list != null ? list : new ArrayList<Cookie>();\n                }\n            };\n            return new OkHttpClient.Builder()\n                    .cookieJar(cookieJar)\n                    .build();\n        }\n        ...\n\t}\n```\n\n这里有点要注意，我们是拿 host 作 map 的 key 值，[《OkHttp3实现Cookies管理及持久化》](http://www.codeceo.com/article/okhttp3-cookies-manage.html)这篇博文直接用 url 当 key 值，这样的话该 Cookie 就只能在当前页面可用了，而我们是整个网站可用。\n\n## __Retrofit 使用 Cookie__\n\n在 Retrofit 中使用 Cookie 就更加简单了，因为它内部使用 OkHttp3，只要把之前设置了 CookieJar 的 OkHttpClient 设置给它就可以了：\n\n```java\n\tHttpService service = new Retrofit.Builder()\n                .client(mHttpClient) //OkHttpClient 指定了 CookieJar，这样 Retrofit 也能使用 Cookie 了\n                .baseUrl(mBaseUrl)\n                .addConverterFactory(GsonConverterFactory.create())\n                .build()\n                .create(HttpService.class);\n```\n\n## __验证码小 Demo__\n\n现状我们用一个实现了验证码功能的小 Demo 来更加深刻的理解之前所讲的知识。\n\n首先我写了两个页面：\n\n- 生成验证码的页面 ： http://www.islinjw.cn/okhttp_cookie_demo/verifycode.php\n- 检查验证码的页面 ： http://www.islinjw.cn/okhttp_cookie_demo/checkverifycode.php\n\n访问第一个页面能获得一张随机的验证码图片，而第二个页面使用 GET 方法来检测验证码（键值为 verifycode）。\n\n### _获取验证码图片_\n\n首先我们使用 OkHttp3 访问第一个页面，下载一张验证码图片，将它显示在 ImageView 中：\n\n```java\n\tprivate void loadVerifyCode(final ImageView imageView, final HttpUrl url) {\n        final Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    okhttp3.Response response = mHttpClient.newCall(request).execute();\n\n                    //创建bitmap\n                    InputStream is = response.body().byteStream();\n                    final Bitmap bm = BitmapFactory.decodeStream(is);\n\n                    //加载到ImageView中\n                    runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            imageView.setImageBitmap(bm);\n                        }\n                    });\n\n                    //打印cookie信息\n                    List<Cookie> cookies = Cookie.parseAll(request.url(), response.headers());\n                    for (int i = 0; i < cookies.size(); i++) {\n                        Log.d(\"cookie\", \"request headers: \" + cookies.get(i).toString());\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n```\n\n运行程序可以看到验证码被显示出来：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/5.jpg %}\n\n我们还能能看到服务器返回的 Cookie 信息，因为我的网页使用 php 写的，所以它返回了一个 PHPSESSID ，用来标记服务器保存的 Session 对象。服务器的 Session 对象里面就保存了验证码的值。之后我们把用户输入的验证码传会服务器的时候只要把这个 PHPSESSID 一同传过去，服务器就能找到之前生成的验证码的值，并和用户所输入的进行对比了:\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/6.jpg %}\n\n### _发送用户输入的验证码_\n\n这里我们直接使用 Retrofit 将用户输入的验证码传给服务器：\n\n```java\n\tpublic void onClick(View v) {\n        HttpService service = new Retrofit.Builder()\n                .client(mHttpClient)  //OkHttpClient 指定了 CookieJar，这样 Retrofit 也能使用 Cookie 了\n                .baseUrl(mBaseUrl)\n                .addConverterFactory(GsonConverterFactory.create())\n                .build()\n                .create(HttpService.class);\n\n        String verifyCode = mEditText.getText().toString();\n        if (verifyCode == null) {\n            return;\n        }\n\n        Call<VerifyCodeResult> call = service.getResult(verifyCode);\n        call.enqueue(new Callback<VerifyCodeResult>() {\n            @Override\n            public void onResponse(Call<VerifyCodeResult> call, Response<VerifyCodeResult> response) {\n                Log.d(\"cookie\", \"request headers: \" + call.request().headers().toString());\n                Toast.makeText(MainActivity.this, response.body().getResult(), Toast.LENGTH_SHORT).show();\n            }\n\n            @Override\n            public void onFailure(Call<VerifyCodeResult> call, Throwable t) {\n            }\n        });\n```\n\n```java\n    public interface HttpService {\n        @GET(\"okhttp_cookie_demo/checkverifycode.php\")\n        Call<VerifyCodeResult> getResult(@Query(\"verifycode\") String yam);\n    }\n```\n\n```java\n    public class VerifyCodeResult {\n        private String result;\n\n        public String getResult() {\n            return result;\n        }\n\n        public void setResult(String result) {\n            this.result = result;\n        }\n    }\n```\n\n运行程序，输入验证码可以看到结果：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/7.jpg %}\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/8.jpg %}\n\n程序正常运行，但看 log 输出，Request 并没有把 PHPSESSID 传过去。这是怎么回事？没有传 PHPSESSID，服务器又怎么能知道之前生成的验证码是什么？\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/9.jpg %}\n\n在 CookieJar 的 loadForRequest 方法设置断点，可以发现在发送验证码的时候确实有调用，随之运行到 HttpEngine 的源码，发现原来框架创建了个新的 Resquest 副本，将 Cookie 传入这个新的副本中去连接服务器：\n\n```java\n    public void sendRequest() throws RequestException, RouteException, IOException {\n        ...\n        Request request = networkRequest(userRequest);\n\t\t...\n    }\n\t...\n    private Request networkRequest(Request request) throws IOException {\n        Request.Builder result = request.newBuilder();\n\n        if (request.header(\"Host\") == null) {\n          result.header(\"Host\", hostHeader(request.url()));\n        }\n\n        if (request.header(\"Connection\") == null) {\n          result.header(\"Connection\", \"Keep-Alive\");\n        }\n\n        if (request.header(\"Accept-Encoding\") == null) {\n          transparentGzip = true;\n          result.header(\"Accept-Encoding\", \"gzip\");\n        }\n\n\t\t//看这里，其实是有设置 CookieJar 中的 Cookie 的\n        //也就是说 PHPSESSID 有传回去给服务器\n        List<Cookie> cookies = client.cookieJar().loadForRequest(request.url());\n        if (!cookies.isEmpty()) {\n          result.header(\"Cookie\", cookieHeader(cookies));\n        }\n\n        if (request.header(\"User-Agent\") == null) {\n          result.header(\"User-Agent\", Version.userAgent());\n        }\n\n        return result.build();\n      }\n```\n\n原来如此，操作都使用了副本 Request 去执行，怪不得我们直接用下面的代码输出，请求头部不能看到 PHPSESSID 的 Cookie 值：\n\n```java\n\t@Override\n    public void onResponse(Call<VerifyCodeResult> call, Response<VerifyCodeResult> response) {\n        Log.d(\"cookie\", \"request headers: \" + call.request().headers().toString());\n        Toast.makeText(MainActivity.this, response.body().getResult(), Toast.LENGTH_SHORT).show();\n    }\n```\n\n## __Glide 使用 Cookie__\n\nGlide 是Google推荐的图片加载库，用来加载图片十分之方便，最少只需要三行代码就能将网络图片加载到 ImageView 上。\n\n我有在 Glide 的文档上看到它也能使用 OkHttp3，理论上应该也能使用设置 OkHttpClient 的方法使用 Cookie。\n\n但弄了很久还是没有搞定，等以后有时间找到实现方法再把这一节补全。\n\n## __Demo 完整代码__\n\nMainActivity:\n\n```java\n\tpublic class MainActivity extends AppCompatActivity {\n    private static final String mBaseUrl = \"http://www.islinjw.cn\";\n    private static final String mVerifyCideUrl = \"http://www.islinjw.cn/okhttp_cookie_demo/verifycode.php\";\n\n    private OkHttpClient mHttpClient;\n    private EditText mEditText;\n    private ImageView mImageView;\n    private Map<String, List<Cookie>> mCookieStore;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mEditText = (EditText) findViewById(R.id.input);\n        mImageView = (ImageView) findViewById(R.id.yzm);\n        mCookieStore = new HashMap<>();\n        mHttpClient = createHttpClient();\n\n        loadVerifyCode(mImageView, HttpUrl.parse(mVerifyCideUrl));\n    }\n\n    private OkHttpClient createHttpClient() {\n        CookieJar cookieJar = new CookieJar() {\n            @Override\n            public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {\n                mCookieStore.put(url.host(), cookies);\n            }\n\n            @Override\n            public List<Cookie> loadForRequest(HttpUrl url) {\n                List list = mCookieStore.get(url.host());\n                return list != null ? list : new ArrayList<Cookie>();\n            }\n        };\n        return new OkHttpClient.Builder()\n                .cookieJar(cookieJar)\n                .build();\n    }\n\n    private void loadVerifyCode(final ImageView imageView, final HttpUrl url) {\n        final Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    okhttp3.Response response = mHttpClient.newCall(request).execute();\n\n                    //创建bitmap\n                    InputStream is = response.body().byteStream();\n                    final Bitmap bm = BitmapFactory.decodeStream(is);\n\n                    //加载到ImageView中\n                    runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            imageView.setImageBitmap(bm);\n                        }\n                    });\n\n                    //打印cookie信息\n                    List<Cookie> cookies = Cookie.parseAll(request.url(), response.headers());\n                    for (int i = 0; i < cookies.size(); i++) {\n                        Log.d(\"cookie\", \"response headers: \" + cookies.get(i).toString());\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n\n    public void onClick(View v) {\n        HttpService service = new Retrofit.Builder()\n                .client(mHttpClient)  //OkHttpClient 指定了 CookieJar，这样 Retrofit 也能使用 Cookie 了\n                .baseUrl(mBaseUrl)\n                .addConverterFactory(GsonConverterFactory.create())\n                .build()\n                .create(HttpService.class);\n\n        String verifyCode = mEditText.getText().toString();\n        if (verifyCode == null) {\n            return;\n        }\n\n        Call<VerifyCodeResult> call = service.getResult(verifyCode);\n        call.enqueue(new Callback<VerifyCodeResult>() {\n            @Override\n            public void onResponse(Call<VerifyCodeResult> call, Response<VerifyCodeResult> response) {\n                Log.d(\"cookie\", \"request headers: \" + call.request().headers().toString());\n                Toast.makeText(MainActivity.this, response.body().getResult(), Toast.LENGTH_SHORT).show();\n            }\n\n            @Override\n            public void onFailure(Call<VerifyCodeResult> call, Throwable t) {\n            }\n        });\n    }\n}\n```\n\nHttpService:\n\n```java\n\tpublic interface HttpService {\n        @GET(\"okhttp_cookie_demo/checkverifycode.php\")\n        Call<VerifyCodeResult> getResult(@Query(\"verifycode\") String yam);\n    }\n```\n\n```java\n\tpublic class VerifyCodeResult {\n        private String result;\n\n        public String getResult() {\n            return result;\n        }\n\n        public void setResult(String result) {\n            this.result = result;\n        }\n    }\n```\n","slug":"学习HTTP协议-在安卓上的使用Cookie与Session","published":1,"updated":"2017-05-12T23:19:13.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2ro85cm000l4kr4j7ftelgu"},{"title":"在android上使用grpc","date":"2017-03-03T01:49:37.000Z","_content":"\n最近的一个项目使用到了grpc实现跨平台的远程调用，在安卓端使用的时候遇到了一些坑，这里记录一下。\n\n首先根据grpc android的[官方Demo](https://github.com/grpc/grpc-java/tree/v1.0.0/examples/android)配置grpc依赖，测试它的hello world工程。\n\n# 编译谷歌官方的helloworld工程\n\n### 添加rotobuf-gradle-plugin插件\n首先添加rotobuf-gradle-plugin插件，他是用来从proto文件自动生成java代码的:\n\n```\n//Project的build.gradle中添加rotobuf-gradle-plugin插件\nbuildscript {\n    ...\n    dependencies {\n        ...\n        classpath \"com.google.protobuf:protobuf-gradle-plugin:0.8.0\"\n        ...\n    }\n    ...\n}\n```\n\n```\n//App的build.gradle中添加下面配置\napply plugin: 'com.google.protobuf'\n\nprotobuf {\n    protoc {\n        artifact = 'com.google.protobuf:protoc:3.0.0'\n    }\n    plugins {\n        javalite {\n            artifact = \"com.google.protobuf:protoc-gen-javalite:3.0.0\"\n        }\n        grpc {\n            artifact = 'io.grpc:protoc-gen-grpc-java:1.0.0' // CURRENT_GRPC_VERSION\n        }\n    }\n    generateProtoTasks {\n        all().each { task ->\n            task.plugins {\n                javalite {}\n                grpc {\n                    // Options added to --grpc_out\n                    option 'lite'\n                }\n            }\n        }\n    }\n}\n```\n\n### 添加proto文件并自动生成java代码\n\n在src/main/目录下创建一个proto目录，并将官方的[helloworld.proto](https://github.com/grpc/grpc-java/blob/v1.0.0/examples/android/helloworld/app/src/main/proto/helloworld.proto)放到proto目录下\n\n之后只需要rebuild一下就能看到build/generated/source/proto/目录下根据helloworld.proto生成了几个Java类\n\n\n{% img /在android上使用grpc/proto_gen.jpeg %}\n\n### 添加安卓端grpc的依赖\n\n```\n//App的build.gradle中添加下面配置\n dependencies {\n    ...\n    compile 'io.grpc:grpc-okhttp:1.1.2'\n    compile 'io.grpc:grpc-protobuf-lite:1.1.2'\n    compile 'io.grpc:grpc-stub:1.1.2'\n    compile 'javax.annotation:javax.annotation-api:1.2'\n    ...\n}\n```\n\n```\nconfigurations.all {\n        resolutionStrategy.force 'com.google.code.findbugs:jsr305:3.0.1'\n    }\n```\n\n我这个时候报了这个错误\n\n> Warning:Conflict with dependency 'com.google.code.findbugs:jsr305'. Resolved versions for app (3.0.0) and test app (2.0.1) differ. See http://g.co/androidstudio/app-test-app-conflict for details.\n\n这是因为com.google.code.findbugs:jsr305的版本不一致导致的\n\n可以在App的build.gradle的android标签中配置一下解决\n\n```\nandroid {\n    ...\n    configurations.all {\n        resolutionStrategy.force 'com.google.code.findbugs:jsr305:3.0.1'\n    }\n    ...\n}\n```\n\n### 编写demo代码\n\n```\npublic class MainActivity extends AppCompatActivity {\n    private static final String TAG = \"GrpcDemo\";\n\n    private static final int PROT = 55055;\n    private static final String NAME = \"linjw\";\n    private static final String HOST = \"localhost\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        startServer(PROT);\n        startClient(HOST, PROT, NAME);\n    }\n\n    private void startServer(int port){\n        try {\n            Server server = ServerBuilder.forPort(port)\n                    .addService(new GreeterImpl())\n                    .build()\n                    .start();\n        } catch (IOException e) {\n            e.printStackTrace();\n            Log.d(TAG, e.getMessage());\n        }\n    }\n\n    private void startClient(String host, int port, String name){\n        new GrpcTask(host, port, name).execute();\n    }\n\n    private class GreeterImpl extends GreeterGrpc.GreeterImplBase {\n        public void sayHello(HelloRequest request, StreamObserver<HelloReply> responseObserver) {\n            responseObserver.onNext(sayHello(request));\n            responseObserver.onCompleted();\n        }\n\n        private HelloReply sayHello(HelloRequest request) {\n            return HelloReply.newBuilder()\n                    .setMessage(\"hello \"+ request.getName())\n                    .build();\n        }\n    }\n\n    private class GrpcTask extends AsyncTask<Void, Void, String> {\n        private String mHost;\n        private String mName;\n        private int mPort;\n        private ManagedChannel mChannel;\n\n        public GrpcTask(String host, int port, String name) {\n            this.mHost = host;\n            this.mName = name;\n            this.mPort = port;\n        }\n\n        @Override\n        protected void onPreExecute() {\n        }\n\n        @Override\n        protected String doInBackground(Void... nothing) {\n            try {\n                mChannel = ManagedChannelBuilder.forAddress(mHost, mPort)\n                        .usePlaintext(true)\n                        .build();\n                GreeterGrpc.GreeterBlockingStub stub = GreeterGrpc.newBlockingStub(mChannel);\n                HelloRequest message = HelloRequest.newBuilder().setName(mName).build();\n                HelloReply reply = stub.sayHello(message);\n                return reply.getMessage();\n            } catch (Exception e) {\n                StringWriter sw = new StringWriter();\n                PrintWriter pw = new PrintWriter(sw);\n                e.printStackTrace(pw);\n                pw.flush();\n                return \"Failed... : \" + System.lineSeparator() + sw;\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            try {\n                mChannel.shutdown().awaitTermination(1, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            Log.d(TAG, result);\n        }\n    }\n}\n\n```\n\n这段代码运行会崩溃:\n\n> Caused by: io.grpc.ManagedChannelProvider$ProviderNotFoundException: No functional server found. Try adding a dependency on the grpc-netty artifact\n\n猜测google使用netty替代了okhttp，尝试换成grpc-netty的依赖:\n\n```\ndependencies {\n    ...\n    compile 'io.grpc:grpc-netty:1.1.2'\n    compile 'io.grpc:grpc-protobuf-lite:1.1.2'\n    compile 'io.grpc:grpc-stub:1.1.2'\n    compile 'javax.annotation:javax.annotation-api:1.2'\n    ...\n}\n```\n\n这么编译会报错\n\n> com.android.build.api.transform.TransformException: com.android.builder.packaging.DuplicateFileException: Duplicate files copied in APK META-INF/INDEX.LIST\n\n需要加上下面的配置解决\n\n```\nandroid {\n    ...\n    packagingOptions {\n        pickFirst 'META-INF/INDEX.LIST'\n        pickFirst 'META-INF/LICENSE'\n        pickFirst 'META-INF/io.netty.versions.properties'\n    }\n    ...\n}\n```\n\n当然，还需要加上INTERNET权限，要不然运行的时候还是会崩溃。\n\n最终就能看的下面的打印，这样安卓grpc的helloworld就成功了。\n\n> 03-03 00:04:20.000 6137-6137/linjw.com.grpcdemo D/GrpcDemo: hello linjw\n\n# 使用com.google.protobuf.Any\n\nAny可以携带任意类型的数据，用法相当于c语言的void指针。在项目中是很常用的，但是谷歌在javalite的版本不支持Any。\n\n如果在proto文件中使用了Any的话生成java代码就会有报错，例如将helloworld的proto文件改成下面的样子:\n\n```\n// Copyright 2015, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\noption java_multiple_files = true;\noption java_package = \"io.grpc.examples.helloworld\";\noption java_outer_classname = \"HelloWorldProto\";\noption objc_class_prefix = \"HLW\";\n\npackage helloworld;\n\nimport \"google/protobuf/any.proto\";\n\n// The greeting service definition.\nservice Greeter {\n  // Sends a greeting\n  rpc SayHello (google.protobuf.Any) returns (HelloReply) {}\n}\n\n// The request message containing the user's name.\nmessage HelloRequest {\n  string name = 1;\n}\n\n// The response message containing the greetings\nmessage HelloReply {\n  string message = 1;\n}\n```\n\n报错如下\n\n> google/protobuf/any.proto: File not found.\n  helloworld.proto: Import \"google/protobuf/any.proto\" was not found or had errors.\n  helloworld.proto:44:17: \"google.protobuf.Any\" is not defined.\n\n### 使用grpc-jave代替grpc-javalite\n\n但是现在做的这个项目的linux端实现已经用了Any，要改的话需要耗费比较大的精力。幸好尝试了下，发现安卓上也能跑支持Any的grpc-java。\n\n首先我们要使用grpc-protobuf依赖替换grpc-protobuf-lite依赖\n\n```\ndependencies {\n    ...\n    compile 'io.grpc:grpc-netty:1.1.2'\n    compile 'io.grpc:grpc-protobuf:1.1.2'\n    compile 'io.grpc:grpc-stub:1.1.2'\n    compile 'javax.annotation:javax.annotation-api:1.2'\n    ...\n}\n```\n\n接着修改protobuf-gradle-plugin配置使得自动生成java的代码而不是javalite的代码\n\n```\nprotobuf {\n    protoc {\n        artifact = 'com.google.protobuf:protoc:3.0.0'\n    }\n    plugins {\n        grpc {\n            artifact = 'io.grpc:protoc-gen-grpc-java:1.0.0' // CURRENT_GRPC_VERSION\n        }\n    }\n    generateProtoTasks {\n        all().each { task ->\n            task.builtins {\n                java {}\n            }\n            task.plugins {\n                grpc {}\n            }\n        }\n    }\n}\n```\n\n对应的修改helloworld的代码就能运行了\n\n```\n\npublic class MainActivity extends AppCompatActivity {\n    private static final String TAG = \"GrpcDemo\";\n\n    private static final int PROT = 55055;\n    private static final String NAME = \"linjw\";\n    private static final String HOST = \"localhost\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        startServer(PROT);\n        startClient(HOST, PROT, NAME);\n    }\n\n    private void startServer(int port){\n        try {\n            Server server = ServerBuilder.forPort(port)\n                    .addService(new GreeterImpl())\n                    .build()\n                    .start();\n        } catch (IOException e) {\n            e.printStackTrace();\n            Log.d(TAG, e.getMessage());\n        }\n    }\n\n    private void startClient(String host, int port, String name){\n        new GrpcTask(host, port, name).execute();\n    }\n\n    private class GreeterImpl extends GreeterGrpc.GreeterImplBase {\n        public void sayHello(Any request, StreamObserver<HelloReply> responseObserver) {\n            try {\n                responseObserver.onNext(sayHello(request.unpack(HelloRequest.class)));\n                responseObserver.onCompleted();\n            } catch (InvalidProtocolBufferException e) {\n                e.printStackTrace();\n            }\n        }\n\n        private HelloReply sayHello(HelloRequest request) {\n            return HelloReply.newBuilder()\n                    .setMessage(\"hello \"+ request.getName())\n                    .build();\n        }\n    }\n\n    private class GrpcTask extends AsyncTask<Void, Void, String> {\n        private String mHost;\n        private String mName;\n        private int mPort;\n        private ManagedChannel mChannel;\n\n        public GrpcTask(String host, int port, String name) {\n            this.mHost = host;\n            this.mName = name;\n            this.mPort = port;\n        }\n\n        @Override\n        protected void onPreExecute() {\n        }\n\n        @Override\n        protected String doInBackground(Void... nothing) {\n            try {\n                mChannel = ManagedChannelBuilder.forAddress(mHost, mPort)\n                        .usePlaintext(true)\n                        .build();\n                GreeterGrpc.GreeterBlockingStub stub = GreeterGrpc.newBlockingStub(mChannel);\n                HelloRequest message = HelloRequest.newBuilder().setName(mName).build();\n                HelloReply reply = stub.sayHello(Any.pack(message));\n                return reply.getMessage();\n            } catch (Exception e) {\n                StringWriter sw = new StringWriter();\n                PrintWriter pw = new PrintWriter(sw);\n                e.printStackTrace(pw);\n                pw.flush();\n                return \"Failed... : \" + System.lineSeparator() + sw;\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            try {\n                mChannel.shutdown().awaitTermination(1, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            Log.d(TAG, result);\n        }\n    }\n}\n\n```\n\n完整的demo代码可以点[这里](https://github.com/bluesky466/grpc-android-demo)在我的github中查看\n\n# Android方法数不能超过65535的问题\n\n最后使用grpc，方法数会超过65535，可以使用com.android.support:multidex去解决\n","source":"_posts/在android上使用grpc.md","raw":"title: 在android上使用grpc\ndate: 2017-03-03 09:49:37\ntags:\n\t- 技术相关\n\t- Android\n---\n\n最近的一个项目使用到了grpc实现跨平台的远程调用，在安卓端使用的时候遇到了一些坑，这里记录一下。\n\n首先根据grpc android的[官方Demo](https://github.com/grpc/grpc-java/tree/v1.0.0/examples/android)配置grpc依赖，测试它的hello world工程。\n\n# 编译谷歌官方的helloworld工程\n\n### 添加rotobuf-gradle-plugin插件\n首先添加rotobuf-gradle-plugin插件，他是用来从proto文件自动生成java代码的:\n\n```\n//Project的build.gradle中添加rotobuf-gradle-plugin插件\nbuildscript {\n    ...\n    dependencies {\n        ...\n        classpath \"com.google.protobuf:protobuf-gradle-plugin:0.8.0\"\n        ...\n    }\n    ...\n}\n```\n\n```\n//App的build.gradle中添加下面配置\napply plugin: 'com.google.protobuf'\n\nprotobuf {\n    protoc {\n        artifact = 'com.google.protobuf:protoc:3.0.0'\n    }\n    plugins {\n        javalite {\n            artifact = \"com.google.protobuf:protoc-gen-javalite:3.0.0\"\n        }\n        grpc {\n            artifact = 'io.grpc:protoc-gen-grpc-java:1.0.0' // CURRENT_GRPC_VERSION\n        }\n    }\n    generateProtoTasks {\n        all().each { task ->\n            task.plugins {\n                javalite {}\n                grpc {\n                    // Options added to --grpc_out\n                    option 'lite'\n                }\n            }\n        }\n    }\n}\n```\n\n### 添加proto文件并自动生成java代码\n\n在src/main/目录下创建一个proto目录，并将官方的[helloworld.proto](https://github.com/grpc/grpc-java/blob/v1.0.0/examples/android/helloworld/app/src/main/proto/helloworld.proto)放到proto目录下\n\n之后只需要rebuild一下就能看到build/generated/source/proto/目录下根据helloworld.proto生成了几个Java类\n\n\n{% img /在android上使用grpc/proto_gen.jpeg %}\n\n### 添加安卓端grpc的依赖\n\n```\n//App的build.gradle中添加下面配置\n dependencies {\n    ...\n    compile 'io.grpc:grpc-okhttp:1.1.2'\n    compile 'io.grpc:grpc-protobuf-lite:1.1.2'\n    compile 'io.grpc:grpc-stub:1.1.2'\n    compile 'javax.annotation:javax.annotation-api:1.2'\n    ...\n}\n```\n\n```\nconfigurations.all {\n        resolutionStrategy.force 'com.google.code.findbugs:jsr305:3.0.1'\n    }\n```\n\n我这个时候报了这个错误\n\n> Warning:Conflict with dependency 'com.google.code.findbugs:jsr305'. Resolved versions for app (3.0.0) and test app (2.0.1) differ. See http://g.co/androidstudio/app-test-app-conflict for details.\n\n这是因为com.google.code.findbugs:jsr305的版本不一致导致的\n\n可以在App的build.gradle的android标签中配置一下解决\n\n```\nandroid {\n    ...\n    configurations.all {\n        resolutionStrategy.force 'com.google.code.findbugs:jsr305:3.0.1'\n    }\n    ...\n}\n```\n\n### 编写demo代码\n\n```\npublic class MainActivity extends AppCompatActivity {\n    private static final String TAG = \"GrpcDemo\";\n\n    private static final int PROT = 55055;\n    private static final String NAME = \"linjw\";\n    private static final String HOST = \"localhost\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        startServer(PROT);\n        startClient(HOST, PROT, NAME);\n    }\n\n    private void startServer(int port){\n        try {\n            Server server = ServerBuilder.forPort(port)\n                    .addService(new GreeterImpl())\n                    .build()\n                    .start();\n        } catch (IOException e) {\n            e.printStackTrace();\n            Log.d(TAG, e.getMessage());\n        }\n    }\n\n    private void startClient(String host, int port, String name){\n        new GrpcTask(host, port, name).execute();\n    }\n\n    private class GreeterImpl extends GreeterGrpc.GreeterImplBase {\n        public void sayHello(HelloRequest request, StreamObserver<HelloReply> responseObserver) {\n            responseObserver.onNext(sayHello(request));\n            responseObserver.onCompleted();\n        }\n\n        private HelloReply sayHello(HelloRequest request) {\n            return HelloReply.newBuilder()\n                    .setMessage(\"hello \"+ request.getName())\n                    .build();\n        }\n    }\n\n    private class GrpcTask extends AsyncTask<Void, Void, String> {\n        private String mHost;\n        private String mName;\n        private int mPort;\n        private ManagedChannel mChannel;\n\n        public GrpcTask(String host, int port, String name) {\n            this.mHost = host;\n            this.mName = name;\n            this.mPort = port;\n        }\n\n        @Override\n        protected void onPreExecute() {\n        }\n\n        @Override\n        protected String doInBackground(Void... nothing) {\n            try {\n                mChannel = ManagedChannelBuilder.forAddress(mHost, mPort)\n                        .usePlaintext(true)\n                        .build();\n                GreeterGrpc.GreeterBlockingStub stub = GreeterGrpc.newBlockingStub(mChannel);\n                HelloRequest message = HelloRequest.newBuilder().setName(mName).build();\n                HelloReply reply = stub.sayHello(message);\n                return reply.getMessage();\n            } catch (Exception e) {\n                StringWriter sw = new StringWriter();\n                PrintWriter pw = new PrintWriter(sw);\n                e.printStackTrace(pw);\n                pw.flush();\n                return \"Failed... : \" + System.lineSeparator() + sw;\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            try {\n                mChannel.shutdown().awaitTermination(1, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            Log.d(TAG, result);\n        }\n    }\n}\n\n```\n\n这段代码运行会崩溃:\n\n> Caused by: io.grpc.ManagedChannelProvider$ProviderNotFoundException: No functional server found. Try adding a dependency on the grpc-netty artifact\n\n猜测google使用netty替代了okhttp，尝试换成grpc-netty的依赖:\n\n```\ndependencies {\n    ...\n    compile 'io.grpc:grpc-netty:1.1.2'\n    compile 'io.grpc:grpc-protobuf-lite:1.1.2'\n    compile 'io.grpc:grpc-stub:1.1.2'\n    compile 'javax.annotation:javax.annotation-api:1.2'\n    ...\n}\n```\n\n这么编译会报错\n\n> com.android.build.api.transform.TransformException: com.android.builder.packaging.DuplicateFileException: Duplicate files copied in APK META-INF/INDEX.LIST\n\n需要加上下面的配置解决\n\n```\nandroid {\n    ...\n    packagingOptions {\n        pickFirst 'META-INF/INDEX.LIST'\n        pickFirst 'META-INF/LICENSE'\n        pickFirst 'META-INF/io.netty.versions.properties'\n    }\n    ...\n}\n```\n\n当然，还需要加上INTERNET权限，要不然运行的时候还是会崩溃。\n\n最终就能看的下面的打印，这样安卓grpc的helloworld就成功了。\n\n> 03-03 00:04:20.000 6137-6137/linjw.com.grpcdemo D/GrpcDemo: hello linjw\n\n# 使用com.google.protobuf.Any\n\nAny可以携带任意类型的数据，用法相当于c语言的void指针。在项目中是很常用的，但是谷歌在javalite的版本不支持Any。\n\n如果在proto文件中使用了Any的话生成java代码就会有报错，例如将helloworld的proto文件改成下面的样子:\n\n```\n// Copyright 2015, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\noption java_multiple_files = true;\noption java_package = \"io.grpc.examples.helloworld\";\noption java_outer_classname = \"HelloWorldProto\";\noption objc_class_prefix = \"HLW\";\n\npackage helloworld;\n\nimport \"google/protobuf/any.proto\";\n\n// The greeting service definition.\nservice Greeter {\n  // Sends a greeting\n  rpc SayHello (google.protobuf.Any) returns (HelloReply) {}\n}\n\n// The request message containing the user's name.\nmessage HelloRequest {\n  string name = 1;\n}\n\n// The response message containing the greetings\nmessage HelloReply {\n  string message = 1;\n}\n```\n\n报错如下\n\n> google/protobuf/any.proto: File not found.\n  helloworld.proto: Import \"google/protobuf/any.proto\" was not found or had errors.\n  helloworld.proto:44:17: \"google.protobuf.Any\" is not defined.\n\n### 使用grpc-jave代替grpc-javalite\n\n但是现在做的这个项目的linux端实现已经用了Any，要改的话需要耗费比较大的精力。幸好尝试了下，发现安卓上也能跑支持Any的grpc-java。\n\n首先我们要使用grpc-protobuf依赖替换grpc-protobuf-lite依赖\n\n```\ndependencies {\n    ...\n    compile 'io.grpc:grpc-netty:1.1.2'\n    compile 'io.grpc:grpc-protobuf:1.1.2'\n    compile 'io.grpc:grpc-stub:1.1.2'\n    compile 'javax.annotation:javax.annotation-api:1.2'\n    ...\n}\n```\n\n接着修改protobuf-gradle-plugin配置使得自动生成java的代码而不是javalite的代码\n\n```\nprotobuf {\n    protoc {\n        artifact = 'com.google.protobuf:protoc:3.0.0'\n    }\n    plugins {\n        grpc {\n            artifact = 'io.grpc:protoc-gen-grpc-java:1.0.0' // CURRENT_GRPC_VERSION\n        }\n    }\n    generateProtoTasks {\n        all().each { task ->\n            task.builtins {\n                java {}\n            }\n            task.plugins {\n                grpc {}\n            }\n        }\n    }\n}\n```\n\n对应的修改helloworld的代码就能运行了\n\n```\n\npublic class MainActivity extends AppCompatActivity {\n    private static final String TAG = \"GrpcDemo\";\n\n    private static final int PROT = 55055;\n    private static final String NAME = \"linjw\";\n    private static final String HOST = \"localhost\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        startServer(PROT);\n        startClient(HOST, PROT, NAME);\n    }\n\n    private void startServer(int port){\n        try {\n            Server server = ServerBuilder.forPort(port)\n                    .addService(new GreeterImpl())\n                    .build()\n                    .start();\n        } catch (IOException e) {\n            e.printStackTrace();\n            Log.d(TAG, e.getMessage());\n        }\n    }\n\n    private void startClient(String host, int port, String name){\n        new GrpcTask(host, port, name).execute();\n    }\n\n    private class GreeterImpl extends GreeterGrpc.GreeterImplBase {\n        public void sayHello(Any request, StreamObserver<HelloReply> responseObserver) {\n            try {\n                responseObserver.onNext(sayHello(request.unpack(HelloRequest.class)));\n                responseObserver.onCompleted();\n            } catch (InvalidProtocolBufferException e) {\n                e.printStackTrace();\n            }\n        }\n\n        private HelloReply sayHello(HelloRequest request) {\n            return HelloReply.newBuilder()\n                    .setMessage(\"hello \"+ request.getName())\n                    .build();\n        }\n    }\n\n    private class GrpcTask extends AsyncTask<Void, Void, String> {\n        private String mHost;\n        private String mName;\n        private int mPort;\n        private ManagedChannel mChannel;\n\n        public GrpcTask(String host, int port, String name) {\n            this.mHost = host;\n            this.mName = name;\n            this.mPort = port;\n        }\n\n        @Override\n        protected void onPreExecute() {\n        }\n\n        @Override\n        protected String doInBackground(Void... nothing) {\n            try {\n                mChannel = ManagedChannelBuilder.forAddress(mHost, mPort)\n                        .usePlaintext(true)\n                        .build();\n                GreeterGrpc.GreeterBlockingStub stub = GreeterGrpc.newBlockingStub(mChannel);\n                HelloRequest message = HelloRequest.newBuilder().setName(mName).build();\n                HelloReply reply = stub.sayHello(Any.pack(message));\n                return reply.getMessage();\n            } catch (Exception e) {\n                StringWriter sw = new StringWriter();\n                PrintWriter pw = new PrintWriter(sw);\n                e.printStackTrace(pw);\n                pw.flush();\n                return \"Failed... : \" + System.lineSeparator() + sw;\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            try {\n                mChannel.shutdown().awaitTermination(1, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            Log.d(TAG, result);\n        }\n    }\n}\n\n```\n\n完整的demo代码可以点[这里](https://github.com/bluesky466/grpc-android-demo)在我的github中查看\n\n# Android方法数不能超过65535的问题\n\n最后使用grpc，方法数会超过65535，可以使用com.android.support:multidex去解决\n","slug":"在android上使用grpc","published":1,"updated":"2017-05-12T23:19:13.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2ro85cp000o4kr4a1xu6vo2"},{"title":"使用hexo搭建个人博客","date":"2016-01-19T13:10:24.000Z","_content":"\n## 一、安装hexo\n\n**1.安装Node.js**\nhexo是一款基于Node.js的静态博客框架，所以要使用它必须先安装Node.js。网上很多教程讲的都是如何编译源码安装Node.js。但我认为应该用最简单的方式取获取和使用软件或者框架，不是每个初学者都需要从一个软件的源代码编译开始学习。当然，在日后想要更深入理解它的时候，挖出它的源代码进行分析也是一种十分有效的途径。\n下面是ubuntu下使用apt-get安装Node.js的方法（源自博客[如何在Ubuntu上安装最新版本的Node.js ](http://blog.csdn.net/chszs/article/details/37521463)）\n1. apt-get update\n2. apt-get install -y python-software-properties software-properties-common\n3. add-apt-repository ppa:chris-lea/node.js\n4. apt-get update\n5. apt-get install nodejs\n\n**2.安装hexo**\n之后安装hexo就更简单了，只需要这一行代码\n\n    npm install hexo -g\n\n**3.更新hexo**\n\n    npm update hexo -g \n    \n<br>\n\n## 二、创建和配置hexo项目\n\n**1.初始化hexo项目**\n\n    hexo init [folder]\n\n如果指定 _folder_，便会在目前的资料夹建立一个名为 _folder_ 的新资料夹，否则会在当前文件夹初始化。\n执行完这条命令，会出现如下提示:\n\n> INFO  You are almost done! Don't forget to run 'npm install' before you start blogging with Hexo!\n\n所以记得执行npm install\n\n\n**2.创建新的文章**\n\n    hexo new \"文章标题\"\n\n执行完创建命令后会生成以下文件:\n\n> source/_posts/文章标题.md\n\n之后只需要在这个markdown文件里面编写自己的博客文章就可以了\n\n**3.添加主题**\n\n有很多人为hexo编写了很多漂亮的主题，可以自己去[主题列表](https://github.com/hexojs/hexo/wiki/Themes)选择\n安装的方法也很简单，这些主题都是托管在github上的，只要把它们克隆到项目文件夹的themes目录下面就可以了。当然还需要去__config.yml修改配置，选择使用哪个主题：\n\n    theme: 主题名\n\n**4.启动服务器**\n\n编写完文章之后只需要运行下面命令就可以在浏览器地址栏输入 http://0.0.0.0:4000 查看自己的博客了\n\n    hexo server\n\n<br>\n\n## 三、配置博客信息\n\n可以在项目根目录下的_config.yml文件配置博客的标题，作者，语言等相关信息\n\n<br>\n\n## 四、部署到Github\n\ngithub提供了一个名叫Github Pages的服务，我们可以免费的用它来搭建自己的博客。\n做法很简单，首先在github建立与你用户名对应的仓库，仓库名必须为 “你的github用户名.github.io” \n\n接着执行以下命令在本机安装hexo-deployer-git\n\n    npm install hexo-deployer-git --save\n\n然后在_config.yml文件，找到下面的内容\n\n    # Deployment\n    ## Docs: http://hexo.io/docs/deployment.html\n    deploy:\n      type:\n\n将它们修改为\n\n    # Deployment\n    ## Docs: http://hexo.io/docs/deployment.html\n    deploy:\n      type: git\n      repository: git@github.com:你的github用户名/你的github用户名.github.io\n      branch: master\n\n最后执行以下三条命令即可：\n\n    hexo clean\n    hexo generate\n    hexo deploy\n\n（当然你必须为你的电脑添加github ssh key才能正常执行hexo deploy命令上传代码）\n\n<br>\n\n## 五、绑定域名\n\n按照github pages的文档，是在github项目根目录下创建CNAME文件。但因为每次使用hexo更新博客再次上传，都会清除掉之前创建的CNAME文件。所以我们把CNAME放在source目录下（想上传的文件都放在该目录下）\n\n完整步骤如下:\n\n1. 在source目录下添加一个CNAM文件，没有后缀名，里面内容为你的域名(如我的是:blog.islinjw.cn)。\n\n2. ping username.github.io记录下IP地址\n\n3. 购买域名，配置域名解析username.github.io的ip地址\n","source":"_posts/使用hexo搭建个人博客.md","raw":"title: 使用hexo搭建个人博客\ndate: 2016-01-19 21:10:24\ntags: \n    - 技术相关\n    - hexo\n---\n\n## 一、安装hexo\n\n**1.安装Node.js**\nhexo是一款基于Node.js的静态博客框架，所以要使用它必须先安装Node.js。网上很多教程讲的都是如何编译源码安装Node.js。但我认为应该用最简单的方式取获取和使用软件或者框架，不是每个初学者都需要从一个软件的源代码编译开始学习。当然，在日后想要更深入理解它的时候，挖出它的源代码进行分析也是一种十分有效的途径。\n下面是ubuntu下使用apt-get安装Node.js的方法（源自博客[如何在Ubuntu上安装最新版本的Node.js ](http://blog.csdn.net/chszs/article/details/37521463)）\n1. apt-get update\n2. apt-get install -y python-software-properties software-properties-common\n3. add-apt-repository ppa:chris-lea/node.js\n4. apt-get update\n5. apt-get install nodejs\n\n**2.安装hexo**\n之后安装hexo就更简单了，只需要这一行代码\n\n    npm install hexo -g\n\n**3.更新hexo**\n\n    npm update hexo -g \n    \n<br>\n\n## 二、创建和配置hexo项目\n\n**1.初始化hexo项目**\n\n    hexo init [folder]\n\n如果指定 _folder_，便会在目前的资料夹建立一个名为 _folder_ 的新资料夹，否则会在当前文件夹初始化。\n执行完这条命令，会出现如下提示:\n\n> INFO  You are almost done! Don't forget to run 'npm install' before you start blogging with Hexo!\n\n所以记得执行npm install\n\n\n**2.创建新的文章**\n\n    hexo new \"文章标题\"\n\n执行完创建命令后会生成以下文件:\n\n> source/_posts/文章标题.md\n\n之后只需要在这个markdown文件里面编写自己的博客文章就可以了\n\n**3.添加主题**\n\n有很多人为hexo编写了很多漂亮的主题，可以自己去[主题列表](https://github.com/hexojs/hexo/wiki/Themes)选择\n安装的方法也很简单，这些主题都是托管在github上的，只要把它们克隆到项目文件夹的themes目录下面就可以了。当然还需要去__config.yml修改配置，选择使用哪个主题：\n\n    theme: 主题名\n\n**4.启动服务器**\n\n编写完文章之后只需要运行下面命令就可以在浏览器地址栏输入 http://0.0.0.0:4000 查看自己的博客了\n\n    hexo server\n\n<br>\n\n## 三、配置博客信息\n\n可以在项目根目录下的_config.yml文件配置博客的标题，作者，语言等相关信息\n\n<br>\n\n## 四、部署到Github\n\ngithub提供了一个名叫Github Pages的服务，我们可以免费的用它来搭建自己的博客。\n做法很简单，首先在github建立与你用户名对应的仓库，仓库名必须为 “你的github用户名.github.io” \n\n接着执行以下命令在本机安装hexo-deployer-git\n\n    npm install hexo-deployer-git --save\n\n然后在_config.yml文件，找到下面的内容\n\n    # Deployment\n    ## Docs: http://hexo.io/docs/deployment.html\n    deploy:\n      type:\n\n将它们修改为\n\n    # Deployment\n    ## Docs: http://hexo.io/docs/deployment.html\n    deploy:\n      type: git\n      repository: git@github.com:你的github用户名/你的github用户名.github.io\n      branch: master\n\n最后执行以下三条命令即可：\n\n    hexo clean\n    hexo generate\n    hexo deploy\n\n（当然你必须为你的电脑添加github ssh key才能正常执行hexo deploy命令上传代码）\n\n<br>\n\n## 五、绑定域名\n\n按照github pages的文档，是在github项目根目录下创建CNAME文件。但因为每次使用hexo更新博客再次上传，都会清除掉之前创建的CNAME文件。所以我们把CNAME放在source目录下（想上传的文件都放在该目录下）\n\n完整步骤如下:\n\n1. 在source目录下添加一个CNAM文件，没有后缀名，里面内容为你的域名(如我的是:blog.islinjw.cn)。\n\n2. ping username.github.io记录下IP地址\n\n3. 购买域名，配置域名解析username.github.io的ip地址\n","slug":"使用hexo搭建个人博客","published":1,"updated":"2017-05-12T23:19:13.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2ro85cw000s4kr4zy63j0lk"},{"title":"lua面向对象编程","date":"2016-11-15T16:43:45.000Z","_content":"\nlua也支持面向对象编程的,嗯对,就是用table和元表。lua可以在某种程度上实现面向对象的封装、继承和多态三大基本特性。\n\n## 封装\n\nlua实现封装的最简单方法就是将属性和方法放到table之中。首先我们声明一个类table,用来定义一些该类的类方法，其中的new方法就类似其他面向对象语言的new关键字,用来创建一个新的实例出来。同时为了模块化，将它放在一个单独的Position.lua文件中:\n\n```lua\nlocal Position = {}\n\nfunction Position.new(x,y)\n\tlocal instance = {x=x, y=y}\n\treturn instance\nend\n\nfunction Position.getLength(instance)\n\treturn (instance.x^2+instance.y^2)^0.5\nend\n\nreturn Position\n```\n\n这样就可以这样使用它:\n```lua\nlocal Position = require(\"Position\")\nlocal pos1 = Position.new(1,1)\nprint(Position.getLength(pos1))\n```\n\n输出如下:\n>1.4142135623731\n\n看看这个方法的定义:\n\n```lua\nfunction Position.getLength(instance)\n\treturn (instance.x^2+instance.y^2)^0.5\nend\n```\n\n它其实是一种语法糖,上面的写法和下面的写法是一样的\n\n```lua\nPosition.getLength = function(instance)\n\treturn (instance.x^2+instance.y^2)^0.5\nend\n```\n\n但是这样的写法是不是感觉很奇怪,和一般的面向对象的写法和用法都不一样？我们可以把Position.lua改成下面的这个样子:\n\n```lua\nlocal Position = {}\n\nfunction Position.new(x,y)\n\tlocal instance = {x=x, y=y}\n\tsetmetatable(instance, {__index=Position})\n\treturn instance\nend\n\nfunction Position.getLength(instance)\n\treturn (instance.x^2+instance.y^2)^0.5\nend\n\nreturn Position\n```\n\n于是用法就有点接近我们熟悉的面向对象语法了\n\n```lua\nlocal Position = require(\"Position\")\n\nlocal pos1 = Position.new(1,1)\nprint(pos1.getLength(pos1))\n\nlocal pos2 = Position.new(3,4)\nprint(pos2.getLength(pos2))\n```\n\n输出如下:\n\n>1.4142135623731\n>5\n\n但是每次调用类方法都需要把实例显示的当作参数传入,这样既麻烦又容易出错。有没有办法让lua解释器自动传入类实例呢？答案当然是有的,这就要看另一种语法糖了:\n\n```lua\nlocal Position = require(\"Position\")\n\nlocal pos1 = Position.new(1,1)\nprint(pos1:getLength())\n\nlocal pos2 = Position.new(3,4)\nprint(pos2:getLength())\n```\n\n对的，下面的两种写法是等价的:\n\n```lua\npos1.getLength(pos1)\npos1:getLength()\n```\n\n类似的,在Position.lua中也能这么写：\n\n```lua\nlocal Position = {}\n\nfunction Position.new(x,y)\n\tlocal instance = {x=x, y=y}\n\tsetmetatable(instance, {__index=Position})\n\treturn instance\nend\n\nfunction Position:getLength()\n\treturn (self.x^2+self.y^2)^0.5\nend\n\nreturn Position\n```\n\n下面两种写法也是等价的:\n```lua\nfunction Position.getLength(self)\n\treturn (self.x^2+self.y^2)^0.5\nend\n\nfunction Position:getLength()\n\treturn (self.x^2+self.y^2)^0.5\nend\n```\n\n这里的self就相当于c++的this\n\n我们还可以把new方法抽象出来,作为公共方法,而不用为每个类都写一个new方法:\n\n```lua\n-- function.lua\n\nfunction class(className)\n\tlocal cls = {}\n\tcls.__cname = className\n\tcls.new = function(...)\n\t\tlocal instance = {}\n\t\tsetmetatable(instance, {__index=cls})\n\t\tif cls.ctor then cls:ctor(...) end\n\t\treturn instance\n\tend\n\treturn cls\nend\n```\n\n这个new方法将类名保存了下来,方便运行时获取类的类型,同时如果这个类有定义构造函数(ctor)的话,它还会自动的调用类的构造函数。\n\n这个时候类的定义就可以变成下面这个样子了:\n\n```lua\n-- Position.lua\n\nlocal Position = class(\"Position\")\n\nfunction Position:ctor(x,y)\n\tself.x = x\n\tself.y = y\nend\n\nfunction Position:getLength()\n\treturn (self.x^2+self.y^2)^0.5\nend\n\nreturn Position\n```\n\n已经和一般的面向对象语言很接近了。当然,这个class方法我们必须在程序的一开始就加载进来作为全局方法使用。我们来看看main.lua是怎么使用它们的吧:\n\n```lua\nrequire(\"function\")\n\nlocal Position = require(\"Position\")\nprint(Position.__cname)\n\nlocal pos1 = Position.new(1,1)\nprint(pos1:getLength())\n\nlocal pos2 = Position.new(3,4)\nprint(pos2:getLength())\n```\n\n输出如下:\n>Position\n>1.4142135623731\n>5\n\n\n\n## 继承与多态\n\nlua的继承机制在上一篇博客《lua元表》中已经有提到了一些,原理就是使用元表机制,将子类元表的\\__index字段设置为父类。所以我们可以这样拓展我们的new方法:\n\n```lua\n-- function.lua\n\nfunction class(className, super)\n\tlocal cls = {}\n\n\tif super then \n\t\tcls.super = super\n\t\tsetmetatable(cls, {__index=super})\n\tend\n\t\n\tcls.__cname = className\n\n\tcls.new = function(...)\n\t\tlocal instance = {}\n\t\tsetmetatable(instance, {__index=cls})\n\t\tif cls.ctor then cls:ctor(...) end\n\t\treturn instance\n\tend\n\t\n\treturn cls\nend\n```\n这里我们将父类保存到子类的元表的\\__index字段中,同时为类添加了super字段用于保存父类\n\n于是基于new方法,我们可以定义Position的子类Position3D:\n\n```lua\n-- Position3D.lua\n\nlocal Position3D = class(\"Position3D\", require(\"Position\"))\n\nfunction Position3D:ctor(x,y,z)\n\tself.super:ctor(x, y)\n\tself.z = z\nend\n\nfunction Position3D:getLength()\n\treturn (self.x^2+self.y^2+self.z^2)^0.5\nend\n\nreturn Position3D\n```\n\n子类Position3D重写了Position的ctor方法和getLength方法。如果需要用父类的被重写的方法,就要用super字段显示调用,就如ctor方法中做的一样。\n\n来看看main.lua吧：\n\n```lua\nrequire(\"function\")\n\nlocal Position3D = require(\"Position3D\")\nprint(Position3D.__cname)\n\nlocal pos1 = Position3D.new(1,1,1)\nprint(pos1:getLength())\n\nlocal pos2 = Position3D.new(3,4,5)\nprint(pos2:getLength())\n```\n\n输出如下:\n>Position3D\n>1.7320508075689\n>7.0710678118655\n\n\n## 多继承\n\nlua同样可以实现多继承。由于一个多继承的子类有多个父类,所以我们不能简单的把父类设为元表的\\__index属性。但是我们可以将该类的父类保存在一个table里面,然后用一个函数去搜索父类的方法。这时,只有将这个函数赋值个于元表的\\__index就好了。\n\n于是我们可以将class函数拓展成下面的样子\n\n```lua\nfunction class(className, ...)\n\tlocal cls = {__cname = className}\n\n    local supers = {...}\n\tfor i,super in ipairs(supers) do\n        cls.__supers = cls.__supers or {}\n        table.insert(cls.__supers, super)\n\n        if cls.super==nil then\n            cls.super=super\n        end\n\tend\n\n    if cls.__supers==nil or  #cls.__supers==1 then\n        setmetatable(cls, {__index=cls.super})\n\telse\n\t\tlocal index = function(t,k)\n\t\t\tfor i,v in ipairs(cls.__supers) do\n\t\t\t\tif v[k] then return v[k] end\n\t\t\tend\n\t\tend\n        setmetatable(cls, {__index=index})\n\tend\t\n\n\tcls.new = function(...)\n\t    local instance = {}\n\t\tsetmetatable(instance, {__index=cls})\n\t\tif cls.ctor then cls:ctor(...) end\n\t\treturn instance\n\tend\n\n\treturn cls\nend\n```\n\n之后我们就能这样去使用多继承机制了:\n\n```lua\n--ClassA.lua\n\nlocal ClassA = class(\"ClassA\")\n\nfunction ClassA:ctor()\nend\n\nfunction ClassA:methodA()\n\tprint(\"ClassA:methodA\")\nend\n\nreturn ClassA\n```\n\n```lua\n--ClassB.lua\n\nlocal ClassB = class(\"ClassB\")\n\nfunction ClassB:ctor()\nend\n\nfunction ClassB:methodB()\n\tprint(\"ClassB:methodB\")\nend\n\nreturn ClassB\n```\n\n```lua\n--ClassC.lua\n\nlocal ClassC = class(\"ClassC\", require(\"ClassA\"), require(\"ClassB\"))\n\nfunction ClassC:ctor()\nend\n\nreturn ClassC\n```\n\n```lua\n--main.lua\n\nrequire(\"function\")\n\nlocal c = require(\"ClassC\").new()\nc:methodA()\nc:methodB()\n```\n\n执行结果如下:\n\n>ClassA:methodA\n>ClassB:methodB\n","source":"_posts/lua面向对象编程.md","raw":"title: lua面向对象编程\ndate: 2016-11-16 00:43:45\ntags:\n\t- 技术相关\n\t- lua\n---\n\nlua也支持面向对象编程的,嗯对,就是用table和元表。lua可以在某种程度上实现面向对象的封装、继承和多态三大基本特性。\n\n## 封装\n\nlua实现封装的最简单方法就是将属性和方法放到table之中。首先我们声明一个类table,用来定义一些该类的类方法，其中的new方法就类似其他面向对象语言的new关键字,用来创建一个新的实例出来。同时为了模块化，将它放在一个单独的Position.lua文件中:\n\n```lua\nlocal Position = {}\n\nfunction Position.new(x,y)\n\tlocal instance = {x=x, y=y}\n\treturn instance\nend\n\nfunction Position.getLength(instance)\n\treturn (instance.x^2+instance.y^2)^0.5\nend\n\nreturn Position\n```\n\n这样就可以这样使用它:\n```lua\nlocal Position = require(\"Position\")\nlocal pos1 = Position.new(1,1)\nprint(Position.getLength(pos1))\n```\n\n输出如下:\n>1.4142135623731\n\n看看这个方法的定义:\n\n```lua\nfunction Position.getLength(instance)\n\treturn (instance.x^2+instance.y^2)^0.5\nend\n```\n\n它其实是一种语法糖,上面的写法和下面的写法是一样的\n\n```lua\nPosition.getLength = function(instance)\n\treturn (instance.x^2+instance.y^2)^0.5\nend\n```\n\n但是这样的写法是不是感觉很奇怪,和一般的面向对象的写法和用法都不一样？我们可以把Position.lua改成下面的这个样子:\n\n```lua\nlocal Position = {}\n\nfunction Position.new(x,y)\n\tlocal instance = {x=x, y=y}\n\tsetmetatable(instance, {__index=Position})\n\treturn instance\nend\n\nfunction Position.getLength(instance)\n\treturn (instance.x^2+instance.y^2)^0.5\nend\n\nreturn Position\n```\n\n于是用法就有点接近我们熟悉的面向对象语法了\n\n```lua\nlocal Position = require(\"Position\")\n\nlocal pos1 = Position.new(1,1)\nprint(pos1.getLength(pos1))\n\nlocal pos2 = Position.new(3,4)\nprint(pos2.getLength(pos2))\n```\n\n输出如下:\n\n>1.4142135623731\n>5\n\n但是每次调用类方法都需要把实例显示的当作参数传入,这样既麻烦又容易出错。有没有办法让lua解释器自动传入类实例呢？答案当然是有的,这就要看另一种语法糖了:\n\n```lua\nlocal Position = require(\"Position\")\n\nlocal pos1 = Position.new(1,1)\nprint(pos1:getLength())\n\nlocal pos2 = Position.new(3,4)\nprint(pos2:getLength())\n```\n\n对的，下面的两种写法是等价的:\n\n```lua\npos1.getLength(pos1)\npos1:getLength()\n```\n\n类似的,在Position.lua中也能这么写：\n\n```lua\nlocal Position = {}\n\nfunction Position.new(x,y)\n\tlocal instance = {x=x, y=y}\n\tsetmetatable(instance, {__index=Position})\n\treturn instance\nend\n\nfunction Position:getLength()\n\treturn (self.x^2+self.y^2)^0.5\nend\n\nreturn Position\n```\n\n下面两种写法也是等价的:\n```lua\nfunction Position.getLength(self)\n\treturn (self.x^2+self.y^2)^0.5\nend\n\nfunction Position:getLength()\n\treturn (self.x^2+self.y^2)^0.5\nend\n```\n\n这里的self就相当于c++的this\n\n我们还可以把new方法抽象出来,作为公共方法,而不用为每个类都写一个new方法:\n\n```lua\n-- function.lua\n\nfunction class(className)\n\tlocal cls = {}\n\tcls.__cname = className\n\tcls.new = function(...)\n\t\tlocal instance = {}\n\t\tsetmetatable(instance, {__index=cls})\n\t\tif cls.ctor then cls:ctor(...) end\n\t\treturn instance\n\tend\n\treturn cls\nend\n```\n\n这个new方法将类名保存了下来,方便运行时获取类的类型,同时如果这个类有定义构造函数(ctor)的话,它还会自动的调用类的构造函数。\n\n这个时候类的定义就可以变成下面这个样子了:\n\n```lua\n-- Position.lua\n\nlocal Position = class(\"Position\")\n\nfunction Position:ctor(x,y)\n\tself.x = x\n\tself.y = y\nend\n\nfunction Position:getLength()\n\treturn (self.x^2+self.y^2)^0.5\nend\n\nreturn Position\n```\n\n已经和一般的面向对象语言很接近了。当然,这个class方法我们必须在程序的一开始就加载进来作为全局方法使用。我们来看看main.lua是怎么使用它们的吧:\n\n```lua\nrequire(\"function\")\n\nlocal Position = require(\"Position\")\nprint(Position.__cname)\n\nlocal pos1 = Position.new(1,1)\nprint(pos1:getLength())\n\nlocal pos2 = Position.new(3,4)\nprint(pos2:getLength())\n```\n\n输出如下:\n>Position\n>1.4142135623731\n>5\n\n\n\n## 继承与多态\n\nlua的继承机制在上一篇博客《lua元表》中已经有提到了一些,原理就是使用元表机制,将子类元表的\\__index字段设置为父类。所以我们可以这样拓展我们的new方法:\n\n```lua\n-- function.lua\n\nfunction class(className, super)\n\tlocal cls = {}\n\n\tif super then \n\t\tcls.super = super\n\t\tsetmetatable(cls, {__index=super})\n\tend\n\t\n\tcls.__cname = className\n\n\tcls.new = function(...)\n\t\tlocal instance = {}\n\t\tsetmetatable(instance, {__index=cls})\n\t\tif cls.ctor then cls:ctor(...) end\n\t\treturn instance\n\tend\n\t\n\treturn cls\nend\n```\n这里我们将父类保存到子类的元表的\\__index字段中,同时为类添加了super字段用于保存父类\n\n于是基于new方法,我们可以定义Position的子类Position3D:\n\n```lua\n-- Position3D.lua\n\nlocal Position3D = class(\"Position3D\", require(\"Position\"))\n\nfunction Position3D:ctor(x,y,z)\n\tself.super:ctor(x, y)\n\tself.z = z\nend\n\nfunction Position3D:getLength()\n\treturn (self.x^2+self.y^2+self.z^2)^0.5\nend\n\nreturn Position3D\n```\n\n子类Position3D重写了Position的ctor方法和getLength方法。如果需要用父类的被重写的方法,就要用super字段显示调用,就如ctor方法中做的一样。\n\n来看看main.lua吧：\n\n```lua\nrequire(\"function\")\n\nlocal Position3D = require(\"Position3D\")\nprint(Position3D.__cname)\n\nlocal pos1 = Position3D.new(1,1,1)\nprint(pos1:getLength())\n\nlocal pos2 = Position3D.new(3,4,5)\nprint(pos2:getLength())\n```\n\n输出如下:\n>Position3D\n>1.7320508075689\n>7.0710678118655\n\n\n## 多继承\n\nlua同样可以实现多继承。由于一个多继承的子类有多个父类,所以我们不能简单的把父类设为元表的\\__index属性。但是我们可以将该类的父类保存在一个table里面,然后用一个函数去搜索父类的方法。这时,只有将这个函数赋值个于元表的\\__index就好了。\n\n于是我们可以将class函数拓展成下面的样子\n\n```lua\nfunction class(className, ...)\n\tlocal cls = {__cname = className}\n\n    local supers = {...}\n\tfor i,super in ipairs(supers) do\n        cls.__supers = cls.__supers or {}\n        table.insert(cls.__supers, super)\n\n        if cls.super==nil then\n            cls.super=super\n        end\n\tend\n\n    if cls.__supers==nil or  #cls.__supers==1 then\n        setmetatable(cls, {__index=cls.super})\n\telse\n\t\tlocal index = function(t,k)\n\t\t\tfor i,v in ipairs(cls.__supers) do\n\t\t\t\tif v[k] then return v[k] end\n\t\t\tend\n\t\tend\n        setmetatable(cls, {__index=index})\n\tend\t\n\n\tcls.new = function(...)\n\t    local instance = {}\n\t\tsetmetatable(instance, {__index=cls})\n\t\tif cls.ctor then cls:ctor(...) end\n\t\treturn instance\n\tend\n\n\treturn cls\nend\n```\n\n之后我们就能这样去使用多继承机制了:\n\n```lua\n--ClassA.lua\n\nlocal ClassA = class(\"ClassA\")\n\nfunction ClassA:ctor()\nend\n\nfunction ClassA:methodA()\n\tprint(\"ClassA:methodA\")\nend\n\nreturn ClassA\n```\n\n```lua\n--ClassB.lua\n\nlocal ClassB = class(\"ClassB\")\n\nfunction ClassB:ctor()\nend\n\nfunction ClassB:methodB()\n\tprint(\"ClassB:methodB\")\nend\n\nreturn ClassB\n```\n\n```lua\n--ClassC.lua\n\nlocal ClassC = class(\"ClassC\", require(\"ClassA\"), require(\"ClassB\"))\n\nfunction ClassC:ctor()\nend\n\nreturn ClassC\n```\n\n```lua\n--main.lua\n\nrequire(\"function\")\n\nlocal c = require(\"ClassC\").new()\nc:methodA()\nc:methodB()\n```\n\n执行结果如下:\n\n>ClassA:methodA\n>ClassB:methodB\n","slug":"lua面向对象编程","published":1,"updated":"2017-05-12T23:19:13.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2ro85d2000w4kr4oju6s145"},{"title":"lua泛型for的原理","date":"2016-10-23T15:10:47.000Z","_content":"学习lua的时候,一直觉得泛型for是个很有用的东西,也觉得它很神奇,但因为它是语法层面就支持的东西,所以就没有去深入思考其中的原理。直到最近看《Lua程序设计》才知道它底层的工作原理原来那么巧妙。\n\n## 泛型for原理\n\n泛型for的用法如下:\n```lua\nlocal person = {name=\"Jim\", age=18}\nfor k,v in pairs(person) do\n\tprint(k,v)\nend \n```\n\n输出结果如下:\n>name    Jim\n>age     18\n\n它究竟是怎么做到通过循环,把table中的key和value通通打印出来的呢？\n\n其实泛型for语句:\n\n```lua\nfor var_1, ..., var_n in <explist> do <block> end\n```\n\n等价以下的代码:\n\n```lua\ndo \n    local _f,_s,_var = <explist>\n    while true do\n        local var_1, ..., var_n = _f(_s, _var)\n        _var = var_1\n        if _var==nil then break end\n        <block>\n    end\nend\n```\n\n## pairs函数原理\n\n这里要先介绍一个基本函数next。如果k是table t的一个key,在调用next(t,k)的时候,会返回t的下一个key和对应的值,如果key为nil,则返回t的第一组key和value,如果没有下一组key和value则返回nil。\n\n其实pairs的定义很简单:\n\n```lua\nfunction pairs(t)\n    return next, t, nil\nend\n```\n\n它只是简单的返回了next函数和原来的table,所以泛型for又能这么写:\n\n```lua\nlocal person = {name=\"Jim\", age=18}\nfor k,v in next, person do\n    print(k,v)\nend \n```\n等价于:\n\n```lua\nlocal person = {name=\"Jim\", age=18}\ndo\n\tlocal _f,_s,_var = next, person\n\twhile true do\n\t\tk,v = _f(_s, _var)\n\t\t_var = k\n\t\tif _var==nil then break end\n\t\tprint(k,v)\n\tend\nend\n```\n\n## ipairs函数原理\n\nipairs函数比pairs函数要复杂一点。如果按照pair的做法,会出现以下情况:\n\n```lua\nlocal test1 = {\"one\", \"two\", three=3}\n\nfor k,v in next, test1 do\n\tprint(k,v)\nend\n\nprint(\"================\")\n\nfor i,v in ipairs(test1) do\n\tprint(i,v)\nend\n```\n\n输出如下:\n\n>1       one\n>2       two\n>three   3\n>\\================\n>1       one\n>2       two\n\n还会出现下面的这种情况:\n\n```lua\nlocal test1 = {\"one\", nil, \"three\"}\n\nfor k,v in next, test1 do\n\tprint(k,v)\nend\n\nprint(\"================\")\n\nfor i,v in ipairs(test1) do\n\tprint(i,v)\nend\n```\n\n输出:\n>1       one\n>3       three\n>\\================\n>1       one\n\n我们在使用ipairs的时候是想以数组的方式遍历table,但pairs会把table中的所有键值对都遍历一遍。使用ipairs的时候会从下标为1开始逐一遍历table,直到遇到value等于nil的时候停止,它的工作原理如下:\n\n```lua\nfunction iter(t, index)\n\tindex = index + 1\n\tlocal var = t[index]\n\tif var then\n\t\treturn index, var\n\tend\nend\n\nfunction ipairs(t)\n\treturn iter,t,0\nend\n```\n\n或者简化成下面的形式:\n\n```lua\nlocal test1 = {\"one\", \"two\", \"three\"}\n\nfunction iter(t, index)\n\tindex = index + 1\n\tlocal var = t[index]\n\tif var then\n\t\treturn index, var\n\tend\nend\n\nfor i,v in iter,test1,0 do\n\tprint(i,v)\nend\n```","source":"_posts/lua泛型for的原理.md","raw":"title: lua泛型for的原理\ndate: 2016-10-23 23:10:47\ntags:\n\t- 技术相关\n\t- lua\n---\n学习lua的时候,一直觉得泛型for是个很有用的东西,也觉得它很神奇,但因为它是语法层面就支持的东西,所以就没有去深入思考其中的原理。直到最近看《Lua程序设计》才知道它底层的工作原理原来那么巧妙。\n\n## 泛型for原理\n\n泛型for的用法如下:\n```lua\nlocal person = {name=\"Jim\", age=18}\nfor k,v in pairs(person) do\n\tprint(k,v)\nend \n```\n\n输出结果如下:\n>name    Jim\n>age     18\n\n它究竟是怎么做到通过循环,把table中的key和value通通打印出来的呢？\n\n其实泛型for语句:\n\n```lua\nfor var_1, ..., var_n in <explist> do <block> end\n```\n\n等价以下的代码:\n\n```lua\ndo \n    local _f,_s,_var = <explist>\n    while true do\n        local var_1, ..., var_n = _f(_s, _var)\n        _var = var_1\n        if _var==nil then break end\n        <block>\n    end\nend\n```\n\n## pairs函数原理\n\n这里要先介绍一个基本函数next。如果k是table t的一个key,在调用next(t,k)的时候,会返回t的下一个key和对应的值,如果key为nil,则返回t的第一组key和value,如果没有下一组key和value则返回nil。\n\n其实pairs的定义很简单:\n\n```lua\nfunction pairs(t)\n    return next, t, nil\nend\n```\n\n它只是简单的返回了next函数和原来的table,所以泛型for又能这么写:\n\n```lua\nlocal person = {name=\"Jim\", age=18}\nfor k,v in next, person do\n    print(k,v)\nend \n```\n等价于:\n\n```lua\nlocal person = {name=\"Jim\", age=18}\ndo\n\tlocal _f,_s,_var = next, person\n\twhile true do\n\t\tk,v = _f(_s, _var)\n\t\t_var = k\n\t\tif _var==nil then break end\n\t\tprint(k,v)\n\tend\nend\n```\n\n## ipairs函数原理\n\nipairs函数比pairs函数要复杂一点。如果按照pair的做法,会出现以下情况:\n\n```lua\nlocal test1 = {\"one\", \"two\", three=3}\n\nfor k,v in next, test1 do\n\tprint(k,v)\nend\n\nprint(\"================\")\n\nfor i,v in ipairs(test1) do\n\tprint(i,v)\nend\n```\n\n输出如下:\n\n>1       one\n>2       two\n>three   3\n>\\================\n>1       one\n>2       two\n\n还会出现下面的这种情况:\n\n```lua\nlocal test1 = {\"one\", nil, \"three\"}\n\nfor k,v in next, test1 do\n\tprint(k,v)\nend\n\nprint(\"================\")\n\nfor i,v in ipairs(test1) do\n\tprint(i,v)\nend\n```\n\n输出:\n>1       one\n>3       three\n>\\================\n>1       one\n\n我们在使用ipairs的时候是想以数组的方式遍历table,但pairs会把table中的所有键值对都遍历一遍。使用ipairs的时候会从下标为1开始逐一遍历table,直到遇到value等于nil的时候停止,它的工作原理如下:\n\n```lua\nfunction iter(t, index)\n\tindex = index + 1\n\tlocal var = t[index]\n\tif var then\n\t\treturn index, var\n\tend\nend\n\nfunction ipairs(t)\n\treturn iter,t,0\nend\n```\n\n或者简化成下面的形式:\n\n```lua\nlocal test1 = {\"one\", \"two\", \"three\"}\n\nfunction iter(t, index)\n\tindex = index + 1\n\tlocal var = t[index]\n\tif var then\n\t\treturn index, var\n\tend\nend\n\nfor i,v in iter,test1,0 do\n\tprint(i,v)\nend\n```","slug":"lua泛型for的原理","published":1,"updated":"2017-05-12T23:19:13.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2ro85d700104kr4gud5v9s7"},{"title":"lua元表","date":"2016-10-28T14:45:37.000Z","_content":"\n## 元表是什么？\n\n在lua中,每个值都有一套预定义的操作集合。例如数字可以相加、比较、字符串可以连接,lua将这些操作的定义放在了元表中去描述。lua中的每个值都有一个元表。table和userdata可以有各自独立的元表,而其他类型则共享其类型所属的统一元表。(书上是这么说的，但是我用getmetatable方法只能获取到字符串的元表)lua在创建table的时候不会为它创建元表,所以,table没有加的操作,我们就可以通过给table设置我们自己写的元表,为table定义一套自定义的加的操作。\n\n\n## 如何获取元表?\n\nlua中通过getmetatable获取值得元表:\n\n```lua\nprint(\"str 1 : \"..tostring( getmetatable(\"str1\")) )\nprint(\"str 2 : \"..tostring( getmetatable(\"str1\")) )\nprint(\"nil : \"..tostring( getmetatable(nil)) )\nprint(\"number : \"..tostring( getmetatable(1)) )\nprint(\"function : \"..tostring( getmetatable(function()end)) )\nprint(\"table : \"..tostring( getmetatable({})) )\n```\n\n>str 1 : table: 009D9798\n>str 2 : table: 009D9798\n>nil : nilw\n>number : nil\n>function : nil\n>table : nil\n\n可以看到不同的字符串用的是同一个元表,而除了字符串之外其他的值的元表都是nil。这里就是我看到和书上不一样的地方，书上说每个值都有一个元表。不过这只是一个小疑点，并不影响我们对元表的理解。\n\n我们看看string的原表到底是个什么东西:\n\n```lua\nfunction dump(t)\n\tif t==nil then\n\t\tprint(t)\n\telse\n\t\tprint(\"{\")\n\t\tfor k,v in pairs(t) do\n\t\t\tprint(\"\\t\"..tostring(k)..\" = \"..tostring(v))\n\t\tend\n\t\tprint(\"}\")\n\tend\nend\ndump(getmetatable(\"str1\"))\n```\n\n输出如下:\n>{\n>        \\__index = table: 00AF9270\n>}\n\n字符串的元表里面只有一个元素:\\__index,它也是一个table,我们继续跟踪下看看它到底是什么:\n```lua\nfunction dump(t)\n\tif t==nil then\n\t\tprint(t)\n\telse\n\t\tprint(\"{\")\n\t\tfor k,v in pairs(t) do\n\t\t\tprint(\"\\t\"..tostring(k)..\" = \"..tostring(v))\n\t\tend\n\t\tprint(\"}\")\n\tend\nend\ndump(getmetatable(\"str1\").__index)\n```\n\n输出如下:\n>{\n>        sub = function: 00ABABF8\n>        upper = function: 00ABACB8\n>        len = function: 00AB9D00\n>        gfind = function: 00AB9CA0\n>        rep = function: 00ABAD58\n>        find = function: 00AB9E20\n>        match = function: 00ABA9F8\n>        char = function: 00AB9C40\n>        dump = function: 00AB9F20\n>        gmatch = function: 00AB9CA0\n>        reverse = function: 00ABAC38\n>        byte = function: 00AB9CC0\n>        format = function: 00AB9C80\n>        gsub = function: 00AB9CE0\n>        lower = function: 00AB9D40\n>}\n\n\\__index这个table定义了字符串的一些基本操作,如获取长度,查找子串等。它们的其实就定义在string这个table里,也就是说所有的字符串的元表的\\__index都是string:\n\n```lua\nfunction dump(t)\n\tif t==nil then\n\t\tprint(t)\n\telse\n\t\tprint(\"{\")\n\t\tfor k,v in pairs(t) do\n\t\t\tprint(\"\\t\"..tostring(k)..\" = \"..tostring(v))\n\t\tend\n\t\tprint(\"}\")\n\tend\nend\n\nprint(getmetatable(\"str\").__index)\nprint(string)\n```\n>table: 00C89270\n>table: 00C89270\n\n\n## 如何设置元表?\n\n在lua中,我们可以用setmetatable(table, metatable)这个方法去设置table的元表:\n\n```lua\nlocal t = {}\nprint(getmetatable(t))\nsetmetatable(t,{})\nprint(getmetatable(t))\n```\n\n输出如下:\n\n>nil\n>table: 0x7feaf1407190\n\n这样就成功为t设置了一个元表,这个元表是一个空的table。\n\n## 元表的作用\n\n那设置元表又有什么用呢？还记得元表的作用是什么吗？对定义对值得操作,例如下面的代码,我们为table设置了一个tostring的操作:\n```lua\nlocal t = {x=1,y=2}\nprint(tostring(t))\n\nlocal mt = {}\nmt.__tostring = function(t)return \"(\"..t.x..\",\"..t.y..\")\" end\nsetmetatable(t,mt)\nprint(tostring(t))\n```\n\n>table: 00B49678\n>(1,2)\n\n类似的在元表中我们可以定义下面的这些方法:\n\n|方法|作用|\n|--|--|\n|\\__add|加法|\n|\\__sub|减法|\n|\\__mul|乘法|\n|\\__div|除法|\n|\\__unm|相反数|\n|\\__mod|取模|\n|\\__pow|乘幂|\n|\\__concat|连接操作|\n|\\__eq|等于|\n|\\__lt|小于|\n|\\__le|小于等于|\n|\\__tostring|转化为字符串|\n|\\__index|读取不存在的字段|\n|\\__newindex|设置不存在的字段|\n\n注意lua会把a~=b转化为not(a==b),将a>b转化为b<a,将a>=b转化为b<=a,所以元表中并没有表示这几种操作的字段\n\n## 元表与类机制\n\n如果我们每创建一个table都要这样手动的为它创建一个元表,其实是很麻烦的一件事情,所以我们可以用下面的方法去简化操作:\n\n```lua\nlocal MyTable = {__tostring=function(t)return t.x..\",\"..t.y end}\n\nfunction MyTable.new(t)\n\tif t==nil then\n\t\tt = {}\n\tend\n\tsetmetatable(t, MyTable)\n\treturn t\nend\n\nprint(MyTable.new{x=1,y=2})\n```\n\n输出如下:\n\n>1,2\n\n\n看，这是不是有点像类？还记得\\__index吗？它用来定义访问table中没有的字段的时候的操作:\n\n```lua\nlocal mt = {}\nmt.__index = function(t,k)return \"no key [\"..k..\"] in table\" end\n\nlocal t = {x=1,y=2}\nsetmetatable(t,mt)\nprint(t.x)\nprint(t.y)\nprint(t.z)\n```\n\n输出如下:\n\n>1\n>2\n>no key [z] in table\n\n特殊的,如果\\__index是一个table的时候,在访问没有的字段的时候lua解释器就会到元表的\\__index中去找:\n\n```lua\nlocal t = {}\nprint(t.x)\n\nlocal index = {x=123}\nsetmetatable(t,{__index=index})\nprint(t.x)\n\nt.x = 321\nprint(t.x)\nprint(getmetatable(t).__index.x)\n```\n\n它的输出是这样的:\n>nil\n>123\n>321\n>123\n\n当在table中找不到字段时,解释器会去元表的\\__index字段中去找,如果\\__index中可以找到的话就用\\__index中的字段。如果table中有该字段的话,解释器就不会再去查询元表。嗯，听起来是不是有点像继承和重写?事实上lua的继承机制也是利用元表的这种特性实现的。\n","source":"_posts/lua元表.md","raw":"title: lua元表\ndate: 2016-10-28 22:45:37\ntags:\n\t- 技术相关\n\t- lua\n---\n\n## 元表是什么？\n\n在lua中,每个值都有一套预定义的操作集合。例如数字可以相加、比较、字符串可以连接,lua将这些操作的定义放在了元表中去描述。lua中的每个值都有一个元表。table和userdata可以有各自独立的元表,而其他类型则共享其类型所属的统一元表。(书上是这么说的，但是我用getmetatable方法只能获取到字符串的元表)lua在创建table的时候不会为它创建元表,所以,table没有加的操作,我们就可以通过给table设置我们自己写的元表,为table定义一套自定义的加的操作。\n\n\n## 如何获取元表?\n\nlua中通过getmetatable获取值得元表:\n\n```lua\nprint(\"str 1 : \"..tostring( getmetatable(\"str1\")) )\nprint(\"str 2 : \"..tostring( getmetatable(\"str1\")) )\nprint(\"nil : \"..tostring( getmetatable(nil)) )\nprint(\"number : \"..tostring( getmetatable(1)) )\nprint(\"function : \"..tostring( getmetatable(function()end)) )\nprint(\"table : \"..tostring( getmetatable({})) )\n```\n\n>str 1 : table: 009D9798\n>str 2 : table: 009D9798\n>nil : nilw\n>number : nil\n>function : nil\n>table : nil\n\n可以看到不同的字符串用的是同一个元表,而除了字符串之外其他的值的元表都是nil。这里就是我看到和书上不一样的地方，书上说每个值都有一个元表。不过这只是一个小疑点，并不影响我们对元表的理解。\n\n我们看看string的原表到底是个什么东西:\n\n```lua\nfunction dump(t)\n\tif t==nil then\n\t\tprint(t)\n\telse\n\t\tprint(\"{\")\n\t\tfor k,v in pairs(t) do\n\t\t\tprint(\"\\t\"..tostring(k)..\" = \"..tostring(v))\n\t\tend\n\t\tprint(\"}\")\n\tend\nend\ndump(getmetatable(\"str1\"))\n```\n\n输出如下:\n>{\n>        \\__index = table: 00AF9270\n>}\n\n字符串的元表里面只有一个元素:\\__index,它也是一个table,我们继续跟踪下看看它到底是什么:\n```lua\nfunction dump(t)\n\tif t==nil then\n\t\tprint(t)\n\telse\n\t\tprint(\"{\")\n\t\tfor k,v in pairs(t) do\n\t\t\tprint(\"\\t\"..tostring(k)..\" = \"..tostring(v))\n\t\tend\n\t\tprint(\"}\")\n\tend\nend\ndump(getmetatable(\"str1\").__index)\n```\n\n输出如下:\n>{\n>        sub = function: 00ABABF8\n>        upper = function: 00ABACB8\n>        len = function: 00AB9D00\n>        gfind = function: 00AB9CA0\n>        rep = function: 00ABAD58\n>        find = function: 00AB9E20\n>        match = function: 00ABA9F8\n>        char = function: 00AB9C40\n>        dump = function: 00AB9F20\n>        gmatch = function: 00AB9CA0\n>        reverse = function: 00ABAC38\n>        byte = function: 00AB9CC0\n>        format = function: 00AB9C80\n>        gsub = function: 00AB9CE0\n>        lower = function: 00AB9D40\n>}\n\n\\__index这个table定义了字符串的一些基本操作,如获取长度,查找子串等。它们的其实就定义在string这个table里,也就是说所有的字符串的元表的\\__index都是string:\n\n```lua\nfunction dump(t)\n\tif t==nil then\n\t\tprint(t)\n\telse\n\t\tprint(\"{\")\n\t\tfor k,v in pairs(t) do\n\t\t\tprint(\"\\t\"..tostring(k)..\" = \"..tostring(v))\n\t\tend\n\t\tprint(\"}\")\n\tend\nend\n\nprint(getmetatable(\"str\").__index)\nprint(string)\n```\n>table: 00C89270\n>table: 00C89270\n\n\n## 如何设置元表?\n\n在lua中,我们可以用setmetatable(table, metatable)这个方法去设置table的元表:\n\n```lua\nlocal t = {}\nprint(getmetatable(t))\nsetmetatable(t,{})\nprint(getmetatable(t))\n```\n\n输出如下:\n\n>nil\n>table: 0x7feaf1407190\n\n这样就成功为t设置了一个元表,这个元表是一个空的table。\n\n## 元表的作用\n\n那设置元表又有什么用呢？还记得元表的作用是什么吗？对定义对值得操作,例如下面的代码,我们为table设置了一个tostring的操作:\n```lua\nlocal t = {x=1,y=2}\nprint(tostring(t))\n\nlocal mt = {}\nmt.__tostring = function(t)return \"(\"..t.x..\",\"..t.y..\")\" end\nsetmetatable(t,mt)\nprint(tostring(t))\n```\n\n>table: 00B49678\n>(1,2)\n\n类似的在元表中我们可以定义下面的这些方法:\n\n|方法|作用|\n|--|--|\n|\\__add|加法|\n|\\__sub|减法|\n|\\__mul|乘法|\n|\\__div|除法|\n|\\__unm|相反数|\n|\\__mod|取模|\n|\\__pow|乘幂|\n|\\__concat|连接操作|\n|\\__eq|等于|\n|\\__lt|小于|\n|\\__le|小于等于|\n|\\__tostring|转化为字符串|\n|\\__index|读取不存在的字段|\n|\\__newindex|设置不存在的字段|\n\n注意lua会把a~=b转化为not(a==b),将a>b转化为b<a,将a>=b转化为b<=a,所以元表中并没有表示这几种操作的字段\n\n## 元表与类机制\n\n如果我们每创建一个table都要这样手动的为它创建一个元表,其实是很麻烦的一件事情,所以我们可以用下面的方法去简化操作:\n\n```lua\nlocal MyTable = {__tostring=function(t)return t.x..\",\"..t.y end}\n\nfunction MyTable.new(t)\n\tif t==nil then\n\t\tt = {}\n\tend\n\tsetmetatable(t, MyTable)\n\treturn t\nend\n\nprint(MyTable.new{x=1,y=2})\n```\n\n输出如下:\n\n>1,2\n\n\n看，这是不是有点像类？还记得\\__index吗？它用来定义访问table中没有的字段的时候的操作:\n\n```lua\nlocal mt = {}\nmt.__index = function(t,k)return \"no key [\"..k..\"] in table\" end\n\nlocal t = {x=1,y=2}\nsetmetatable(t,mt)\nprint(t.x)\nprint(t.y)\nprint(t.z)\n```\n\n输出如下:\n\n>1\n>2\n>no key [z] in table\n\n特殊的,如果\\__index是一个table的时候,在访问没有的字段的时候lua解释器就会到元表的\\__index中去找:\n\n```lua\nlocal t = {}\nprint(t.x)\n\nlocal index = {x=123}\nsetmetatable(t,{__index=index})\nprint(t.x)\n\nt.x = 321\nprint(t.x)\nprint(getmetatable(t).__index.x)\n```\n\n它的输出是这样的:\n>nil\n>123\n>321\n>123\n\n当在table中找不到字段时,解释器会去元表的\\__index字段中去找,如果\\__index中可以找到的话就用\\__index中的字段。如果table中有该字段的话,解释器就不会再去查询元表。嗯，听起来是不是有点像继承和重写?事实上lua的继承机制也是利用元表的这种特性实现的。\n","slug":"lua元表","published":1,"updated":"2017-05-12T23:19:13.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2ro85db00134kr41rhubkhe"},{"title":"automake学习笔记 - 模块化编译","date":"2017-03-21T05:36:36.000Z","_content":"\n一般来说一个工程会由许多不同的模块组成。源码放在一个地方，示例代码放到另一个地方，第三方库又放到其他地方。这种时候又应该怎么去使用automake呢？\n\n这篇文章就讨论了一下如何使用automake去进行模块化编译\n\n我们还是用easylog来做例子，下面是我们修改后的easylog工程的根目录下的文件:\n\n> configure.ac  examples  Makefile.am  src\n\n## src目录\n\nsrc目录放的就是库的源代码,我们使用src中的源代码编译出一个库来给其他的程序使用easylog的功能  \n\nsrc目录中有下面几个文件log\\_interface.h，easy\\_log.h，easy\\_log.cpp，cout\\_log\\_interface.h，cout\\_log\\_interface.cpp，Makefile.am。实际上就是除了main.cpp，其他文件都放到了这里来。因为我们提供给别的是一个库而不是一个可执行程序，所以main.cpp可以不需要编译到目标文件中\n\n.h和.cpp的内容和上一篇[文章](http://blog.islinjw.cn/2017/03/17/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-helloworld/)的内容是一样的。这里的重点其实是Makefile.am。让我们先来看看它的内容:\n\n```\nlib_LTLIBRARIES = libeasylog.la                                                             \nlibeasylog_la_SOURCES = cout_log_interface.cpp \\                                            \n                     easy_log.cpp\n```\n\n其实它的内容很简单，就是指定了要编译的库的名字和库的源码。但是有一个问题，我们这里需要编译的是但为什么这里的目标文件是libeasylog.la呢?\n\nLibtool是一种属于GNU构建系统的GNU程序设计工具,它将静态库和动态库抽象成了一种统一的叫做libtool库的概念。libtool库使用la作为后缀。它可以用来构建静态库也能用来构建动态库，而最终编译出来的到底是哪一种，在最后执行configure命令的时候才能确定。同时它编译的时候产生的文件就不再是.o文件而是.lo文件。  \n\n这里lib\\_LTLIBRARIES的lib前缀表示的就是目标文件是一个动态库而不是可执行文件(bin前缀表示目标文件是可执行文件,noinst\\_LTLIBRARIES表示目标文件是静态库)。而LTLIBRARIES的LT指的就是Libtool。还有一点是一般编译库文件的话我们会在文件名钱加上lib前缀，所以我们的目标文件是libeasylog.la。\n\n而下面的libeasylog\\_la\\_SOURCES就是指定编译libeasylog.la使用的源代码\n\n\n这里顺便说一点,如果这里需要链接其他的库的话需要用 \\_LIBADD 去指定。如需要链接libpthread这个库的话就需要这样写:\n\n```\nlibeasylog_la_LIBADD = -lpthread\n```\n\n\n\n## examples目录\n\nexamples目录里面放了这个库的example代码。因为我们的库是要提供给其他人使用的，所以一般除了文档之外，还会有一些例子去帮助使用者了解应该如何去使用我们的库。这个目录中的example.cpp其实就是上一篇[文章](http://blog.islinjw.cn/2017/03/17/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-helloworld/)中的main.cpp：\n\n```\n#include \"easy_log.h\"\n#include \"cout_log_interface.h\"\n\n\nint main()\n{\n    EasyLog log(std::make_shared<COutLogInterface>());\n    log.Debug(\"test\", \"testlog\");\n\n    return 0;\n}\n```\n\n这个目录下也有一个Makefile.am，它是用来配置example程序的编译选项的:\n\n```\nAM_CPPFLAGS = -I$(top_srcdir)/src\n\nbin_PROGRAMS = example\nexample_SOURCES = example.cpp\n\nexample_LDADD = -L$(top_builddir)/src \\\n\t\t\t\t-leasylog\n```\n\nAM\\_CPPFLAGS的值在c/c++预处理的时候会当做参数传给预处理器例如我们将源码目录传给预处理器，这样预处理器才能找到easy\\_log.h和cout\\_log\\_interface.h\n\n这里的top\\_srcdir变量会在configure是被定义，它的值是工程目录的位置(也就是configure所在目录的位置)，后面的top\\_builddir也是类似的，不过它的值是编译目录的位置(也就是执行make命令是所在的目录)\n\n这里编译出来的example就是我们的demo程序\n\n\n## 根目录\n\n根目录下也有个Makefile.am,这个文件的内容很简单:\n\n```\nSUBDIRS = src examples\n```\n\n就是将src和examples指定为子目录于是在make编译的时候,编译器就会进入到这两个目录中继续编译。它们在这里的先后顺序决定了编译的先后顺序。因为examples中的example程序是依赖于easylog库的,所以要然src先编译\n\n如果不在这里指定子目录的话,在编译目录执行make命令就不会自动编译子目录中为源码,需要自己进到子目录中手动执行make命令。如果工程中的某些部分是可选编译的时候可以这么做。\n\n最后就是configure.ac文件了:\n\n```\n#                                               -*- Autoconf -*-\n# Process this file with autoconf to produce a configure script.\n\nAC_PREREQ([2.69])\nAC_INIT([easylog], [0.0.2], [466474482@qq.com])\nAM_INIT_AUTOMAKE([-Wall -Werror foreign])\nAC_CONFIG_SRCDIR([src/log_interface.h])\nAC_CONFIG_HEADERS([config.h])\n\nAM_PROG_AR\nLT_INIT\n\n# Checks for programs.\nAC_PROG_CXX\nAC_PROG_CC\nAX_CXX_COMPILE_STDCXX_11\n\n# Checks for libraries.\n\n# Checks for header files.\n\n# Checks for typedefs, structures, and compiler characteristics.\n\n# Checks for library functions.\n\nAC_CONFIG_FILES([Makefile\n                 examples/Makefile\n                 src/Makefile])\n\nAC_OUTPUT\n```\n\n它和上一篇[文章](http://blog.islinjw.cn/2017/03/17/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-helloworld/)只有一点点小的不同:\n\n一是由于将log\\_interface.h放到src中了，所以AC\\_CONFIG\\_SRCDIR需要改一下\n\n```\nAC_CONFIG_SRCDIR([src/log_interface.h])\n```\n\n二是examples和src中的Makefile.am也需要在configure.ac中指定:\n```\nAC_CONFIG_FILES([Makefile\n                 examples/Makefile\n                 src/Makefile])\n```\n\nAC\\_CONFIG\\_FILES指定了一些需要从Makefile.in中生成的Makefile。这里如果不指定的话configure就不会为其生成Makefile\n\n\n三是多了AM\\_PROG\\_AR和LT\\_INIT。如果不定义这两个宏的话,执行autoreconf --install命令得到了下面的错误日志:\n\n```\nsrc/Makefile.am:1: error: Libtool library used but 'LIBTOOL' is undefined\nsrc/Makefile.am:1:   The usual way to define 'LIBTOOL' is to add 'LT_INIT'\nsrc/Makefile.am:1:   to 'configure.ac' and run 'aclocal' and 'autoconf' again.\nsrc/Makefile.am:1:   If 'LT_INIT' is in 'configure.ac', make sure\nsrc/Makefile.am:1:   its definition is in aclocal's search path.\nautomake: warnings are treated as errors\n/usr/share/automake-1.15/am/ltlibrary.am: warning: 'libeasylog.la': linking libtool libraries using a non-POSIX\n/usr/share/automake-1.15/am/ltlibrary.am: archiver requires 'AM_PROG_AR' in 'configure.ac'\nsrc/Makefile.am:1:   while processing Libtool library 'libeasylog.la'\nautoreconf: automake failed with exit status: 1\n```\n\n注意AM\\_PROG\\_AR 要放在 LT\\_INIT 之前,要不然 autoreconf --install 的时候会报warn\n\n如果已经加上了 LT\\_INIT 但还是会报错的话就是系统中没有安装libtool了,必须先安装一下:\n\n```\nsudo apt-get install libtool\n```\n\n## 编译工程\n\n1. 在工程根目录创建子build目录用于编译\n\n2. 进入build目录\n\n3. 执行../configure\n\n4. 执行make\n\n之后进入build/examples运行example就可以看到下面输出:\n\n> [test] testlog\n\n## 静态库和动态库的区别\n\n我们之前在src/Makefile.am中生成的是动态库lib\\_LTLIBRARIES,所以如果将build/src目录删掉,build/examples/example就会因为找不到库而报错:\n\n> /home/linjw/workspace/automake-demo/build/examples/.libs/lt-example: error while loading shared libraries: libeasylog.so.0: cannot open shared object file: No such file or directory\n\n但如果将Makefile.am改成生成静态库则不会报错，因为静态库将库的代码也编译到可执行程序之中了。\n\n```\nnoinst_LTLIBRARIES = libeasylog.la                                               \nlibeasylog_la_SOURCES = cout_log_interface.cpp \\                                    \n                     easy_log.cpp\n```\n\n这里的noinst代表的其实是no install的意思\n\n## Demo项目\n\n可以在[这里](https://github.com/bluesky466/automake-demo/tree/v0.0.2)查看完整的项目代码\n","source":"_posts/automake学习笔记-模块化编译.md","raw":"title: automake学习笔记 - 模块化编译\ndate: 2017-03-21 13:36:36\ntags:\n\t- 技术相关\n\t- 编译相关\n---\n\n一般来说一个工程会由许多不同的模块组成。源码放在一个地方，示例代码放到另一个地方，第三方库又放到其他地方。这种时候又应该怎么去使用automake呢？\n\n这篇文章就讨论了一下如何使用automake去进行模块化编译\n\n我们还是用easylog来做例子，下面是我们修改后的easylog工程的根目录下的文件:\n\n> configure.ac  examples  Makefile.am  src\n\n## src目录\n\nsrc目录放的就是库的源代码,我们使用src中的源代码编译出一个库来给其他的程序使用easylog的功能  \n\nsrc目录中有下面几个文件log\\_interface.h，easy\\_log.h，easy\\_log.cpp，cout\\_log\\_interface.h，cout\\_log\\_interface.cpp，Makefile.am。实际上就是除了main.cpp，其他文件都放到了这里来。因为我们提供给别的是一个库而不是一个可执行程序，所以main.cpp可以不需要编译到目标文件中\n\n.h和.cpp的内容和上一篇[文章](http://blog.islinjw.cn/2017/03/17/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-helloworld/)的内容是一样的。这里的重点其实是Makefile.am。让我们先来看看它的内容:\n\n```\nlib_LTLIBRARIES = libeasylog.la                                                             \nlibeasylog_la_SOURCES = cout_log_interface.cpp \\                                            \n                     easy_log.cpp\n```\n\n其实它的内容很简单，就是指定了要编译的库的名字和库的源码。但是有一个问题，我们这里需要编译的是但为什么这里的目标文件是libeasylog.la呢?\n\nLibtool是一种属于GNU构建系统的GNU程序设计工具,它将静态库和动态库抽象成了一种统一的叫做libtool库的概念。libtool库使用la作为后缀。它可以用来构建静态库也能用来构建动态库，而最终编译出来的到底是哪一种，在最后执行configure命令的时候才能确定。同时它编译的时候产生的文件就不再是.o文件而是.lo文件。  \n\n这里lib\\_LTLIBRARIES的lib前缀表示的就是目标文件是一个动态库而不是可执行文件(bin前缀表示目标文件是可执行文件,noinst\\_LTLIBRARIES表示目标文件是静态库)。而LTLIBRARIES的LT指的就是Libtool。还有一点是一般编译库文件的话我们会在文件名钱加上lib前缀，所以我们的目标文件是libeasylog.la。\n\n而下面的libeasylog\\_la\\_SOURCES就是指定编译libeasylog.la使用的源代码\n\n\n这里顺便说一点,如果这里需要链接其他的库的话需要用 \\_LIBADD 去指定。如需要链接libpthread这个库的话就需要这样写:\n\n```\nlibeasylog_la_LIBADD = -lpthread\n```\n\n\n\n## examples目录\n\nexamples目录里面放了这个库的example代码。因为我们的库是要提供给其他人使用的，所以一般除了文档之外，还会有一些例子去帮助使用者了解应该如何去使用我们的库。这个目录中的example.cpp其实就是上一篇[文章](http://blog.islinjw.cn/2017/03/17/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-helloworld/)中的main.cpp：\n\n```\n#include \"easy_log.h\"\n#include \"cout_log_interface.h\"\n\n\nint main()\n{\n    EasyLog log(std::make_shared<COutLogInterface>());\n    log.Debug(\"test\", \"testlog\");\n\n    return 0;\n}\n```\n\n这个目录下也有一个Makefile.am，它是用来配置example程序的编译选项的:\n\n```\nAM_CPPFLAGS = -I$(top_srcdir)/src\n\nbin_PROGRAMS = example\nexample_SOURCES = example.cpp\n\nexample_LDADD = -L$(top_builddir)/src \\\n\t\t\t\t-leasylog\n```\n\nAM\\_CPPFLAGS的值在c/c++预处理的时候会当做参数传给预处理器例如我们将源码目录传给预处理器，这样预处理器才能找到easy\\_log.h和cout\\_log\\_interface.h\n\n这里的top\\_srcdir变量会在configure是被定义，它的值是工程目录的位置(也就是configure所在目录的位置)，后面的top\\_builddir也是类似的，不过它的值是编译目录的位置(也就是执行make命令是所在的目录)\n\n这里编译出来的example就是我们的demo程序\n\n\n## 根目录\n\n根目录下也有个Makefile.am,这个文件的内容很简单:\n\n```\nSUBDIRS = src examples\n```\n\n就是将src和examples指定为子目录于是在make编译的时候,编译器就会进入到这两个目录中继续编译。它们在这里的先后顺序决定了编译的先后顺序。因为examples中的example程序是依赖于easylog库的,所以要然src先编译\n\n如果不在这里指定子目录的话,在编译目录执行make命令就不会自动编译子目录中为源码,需要自己进到子目录中手动执行make命令。如果工程中的某些部分是可选编译的时候可以这么做。\n\n最后就是configure.ac文件了:\n\n```\n#                                               -*- Autoconf -*-\n# Process this file with autoconf to produce a configure script.\n\nAC_PREREQ([2.69])\nAC_INIT([easylog], [0.0.2], [466474482@qq.com])\nAM_INIT_AUTOMAKE([-Wall -Werror foreign])\nAC_CONFIG_SRCDIR([src/log_interface.h])\nAC_CONFIG_HEADERS([config.h])\n\nAM_PROG_AR\nLT_INIT\n\n# Checks for programs.\nAC_PROG_CXX\nAC_PROG_CC\nAX_CXX_COMPILE_STDCXX_11\n\n# Checks for libraries.\n\n# Checks for header files.\n\n# Checks for typedefs, structures, and compiler characteristics.\n\n# Checks for library functions.\n\nAC_CONFIG_FILES([Makefile\n                 examples/Makefile\n                 src/Makefile])\n\nAC_OUTPUT\n```\n\n它和上一篇[文章](http://blog.islinjw.cn/2017/03/17/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-helloworld/)只有一点点小的不同:\n\n一是由于将log\\_interface.h放到src中了，所以AC\\_CONFIG\\_SRCDIR需要改一下\n\n```\nAC_CONFIG_SRCDIR([src/log_interface.h])\n```\n\n二是examples和src中的Makefile.am也需要在configure.ac中指定:\n```\nAC_CONFIG_FILES([Makefile\n                 examples/Makefile\n                 src/Makefile])\n```\n\nAC\\_CONFIG\\_FILES指定了一些需要从Makefile.in中生成的Makefile。这里如果不指定的话configure就不会为其生成Makefile\n\n\n三是多了AM\\_PROG\\_AR和LT\\_INIT。如果不定义这两个宏的话,执行autoreconf --install命令得到了下面的错误日志:\n\n```\nsrc/Makefile.am:1: error: Libtool library used but 'LIBTOOL' is undefined\nsrc/Makefile.am:1:   The usual way to define 'LIBTOOL' is to add 'LT_INIT'\nsrc/Makefile.am:1:   to 'configure.ac' and run 'aclocal' and 'autoconf' again.\nsrc/Makefile.am:1:   If 'LT_INIT' is in 'configure.ac', make sure\nsrc/Makefile.am:1:   its definition is in aclocal's search path.\nautomake: warnings are treated as errors\n/usr/share/automake-1.15/am/ltlibrary.am: warning: 'libeasylog.la': linking libtool libraries using a non-POSIX\n/usr/share/automake-1.15/am/ltlibrary.am: archiver requires 'AM_PROG_AR' in 'configure.ac'\nsrc/Makefile.am:1:   while processing Libtool library 'libeasylog.la'\nautoreconf: automake failed with exit status: 1\n```\n\n注意AM\\_PROG\\_AR 要放在 LT\\_INIT 之前,要不然 autoreconf --install 的时候会报warn\n\n如果已经加上了 LT\\_INIT 但还是会报错的话就是系统中没有安装libtool了,必须先安装一下:\n\n```\nsudo apt-get install libtool\n```\n\n## 编译工程\n\n1. 在工程根目录创建子build目录用于编译\n\n2. 进入build目录\n\n3. 执行../configure\n\n4. 执行make\n\n之后进入build/examples运行example就可以看到下面输出:\n\n> [test] testlog\n\n## 静态库和动态库的区别\n\n我们之前在src/Makefile.am中生成的是动态库lib\\_LTLIBRARIES,所以如果将build/src目录删掉,build/examples/example就会因为找不到库而报错:\n\n> /home/linjw/workspace/automake-demo/build/examples/.libs/lt-example: error while loading shared libraries: libeasylog.so.0: cannot open shared object file: No such file or directory\n\n但如果将Makefile.am改成生成静态库则不会报错，因为静态库将库的代码也编译到可执行程序之中了。\n\n```\nnoinst_LTLIBRARIES = libeasylog.la                                               \nlibeasylog_la_SOURCES = cout_log_interface.cpp \\                                    \n                     easy_log.cpp\n```\n\n这里的noinst代表的其实是no install的意思\n\n## Demo项目\n\n可以在[这里](https://github.com/bluesky466/automake-demo/tree/v0.0.2)查看完整的项目代码\n","slug":"automake学习笔记-模块化编译","published":1,"updated":"2017-05-12T23:19:13.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2ro85df00164kr427xk4nna"},{"title":"automake学习笔记 - 安装与发布","date":"2017-03-26T07:06:56.000Z","_content":"\n辛辛苦苦写出来的代码当然是需要发布出来给自己或者别人去使用的。这篇文章就谈一谈发布相关的东西吧。\n\n## 安装\n\n软件在编译完后就需要进行安装。configure生成的Makefile支持install。使用make install 命令就可以将编译出来的软件安装到系统中。\n\n如果没有做配置，默认会安装到/usr/local中,当然如果需要的话也可以使用configure的--prefix参数指定安装的路径,如在build中执行下面的命令就可以将build目录指定为安装目录:\n\n> ../configure --prefix=\\`pwd\\`\n\n之后再执行下面的安装命令,工程在编译完后就会安装到build目录下。安装完毕之后可以看到build里面多了bin和lib两个目录\n\n> make install\n\nbin目录下是编译出来的可执行文件example,而lib目录下就是编译出来的依赖库:\n\n```\n-rw-r--r-- 1 linjw linjw 263K 3月  22 13:44 libeasylog.a\n-rwxr-xr-x 1 linjw linjw  985 3月  22 13:44 libeasylog.la\nlrwxrwxrwx 1 linjw linjw   19 3月  22 13:44 libeasylog.so -> libeasylog.so.0.0.0\nlrwxrwxrwx 1 linjw linjw   19 3月  22 13:44 libeasylog.so.0 -> libeasylog.so.0.0.0\n-rwxr-xr-x 1 linjw linjw 143K 3月  22 13:44 libeasylog.so.0.0.0\n```\n\n\n编译出来的libeasylog.so.0.0.0就可以直接拿出去给其他人使用了\n\n## 卸载\n\n卸载的话很简单，只需要执行下面的命令就行了\n\n> make uninstall\n\n当然你也可以选择手动去将安装的文件一个个删除,但是这样既麻烦又容易漏删或者错删\n\n## libtool 库版本号系统\n\n我们可以看到编译出来的so库是带版本号的，默认0.0.0,当然我们也能直接忽略版本号(某些可动态加载的的插件模块可能不需要版本号):\n\n```\nlib_LTLIBRARIES = libeasylog.la\n\nlibeasylog_la_SOURCES = cout_log_interface.cpp \\\n\t\t\t\t\t easy_log.cpp \n\nlibeasylog_la_LDFLAGS = -avoid-version\n```\n\n这样生成安装的so库就不会带版本号了:\n\n```\n-rw-r--r-- 1 linjw linjw 263K 3月  26 11:27 libeasylog.a\n-rwxr-xr-x 1 linjw linjw  975 3月  26 11:27 libeasylog.la\n-rwxr-xr-x 1 linjw linjw 143K 3月  26 11:27 libeasylog.so\n```\n\n当然，绝大部分的库都是需要带上版本号的。每个系统的库版本机制都不一样,libtool通过一种抽象的版本机制最终在创建库的时候才映射到具体的系统版本机制上。这是为了方便在交叉编译的时候可以用一种机制去管理不同平台上的各种版本机制。\n\nlibtool 库版本号系统有下面三个部分:\n\n- current\n\n接口的修改次数\n\n- revision\n\n上次修改后源码的修改次数(注意这里指的是只改动了实现,没有修改接口,如果改了接口的话应该要改current号，并且把revision置零)\n\n- age\n\n当前版本可以向前兼容的版本数\n\n[官方文档](http://www.gnu.org/software/libtool/manual/libtool.html#Updating-version-info)是这么描述这三个部分的更新规则的:\n\n> Here are a set of rules to help you update your library version information:\n1.    Start with version information of ‘0:0:0’ for each libtool library.\n2.    Update the version information only immediately before a public release of your software. More frequent updates are unnecessary, and only guarantee that the current interface number gets larger faster.\n3.    If the library source code has changed at all since the last update, then increment revision (‘c:r:a’ becomes ‘c:r+1:a’).\n4.    If any interfaces have been added, removed, or changed since the last update, increment current, and set revision to 0.\n5.    If any interfaces have been added since the last public release, then increment age.\n6.    If any interfaces have been removed or changed since the last public release, then set age to 0. \n\n翻译过来就是\n\n1. 库版本号应该开始于0.0.0\n2. 只有在正式发布库的时候才更新版本号以避免版本号增长过快\n3. 当实现代码改变的时候revision加1\n4. 当接口改变(无论是添加，删除还是修改接口声明)的时候current加1,同时revision重置为0\n5. 如果库只是增加了接口,则age加1\n6. 如果库删除或者修改了接口声明,则age重置为0\n\n这三个值可以用-version-info指定\n\n> -version-info current[:revision[:age]] \n\nrevision 和 age都可以省略,例如你这样设置:\n\n```\nlib_LTLIBRARIES = libeasylog.la\n\nlibeasylog_la_SOURCES = cout_log_interface.cpp \\\n\t\t\t\t\t easy_log.cpp \n\nlibeasylog_la_LDFLAGS = -version-info 3:12:1\n```\n\n表明接口被修改了三次,第三次修改接口之后又修改了12次源码,接口可以向前兼容1个版本\n\nmake install 后可以看到lib目录下生成的库长这样:\n\n```\n-rw-r--r-- 1 linjw linjw 263K 3月  26 12:11 libeasylog.a\n-rwxr-xr-x 1 linjw linjw  987 3月  26 12:11 libeasylog.la\nlrwxrwxrwx 1 linjw linjw   20 3月  26 12:11 libeasylog.so -> libeasylog.so.2.1.12\nlrwxrwxrwx 1 linjw linjw   20 3月  26 12:11 libeasylog.so.2 -> libeasylog.so.2.1.12\n-rwxr-xr-x 1 linjw linjw 143K 3月  26 12:11 libeasylog.so.2.1.12\n```\n\n为啥是libeasylog.so.2.1.12而不是libeasylog.so.3.12.1呢？\n\n原来这几个数字是这样计算的:\n\n库名.so.current-age.age.revision\n\n这样会引发一个问题:\n\n> 假设你的库有两个【3：0：1】【4：0：2】。 再假设在你编译程序的机器上安装了最新的【4：0：2】， 且你在程序中使用了该版本中新加的接口。当你程序编译好后， 你ldd发现你的程序依赖libraryname.so.2， 同时你将程序安装在了只安装了【3：0：1】的机器上， 你会发现你的程序能搜索到动态库， 却在运行的时候发现未定义的符号， 因为【3：0：1】中没有新添加的接口。 故你需要在运行机器上保证安装了同一主版本号最新的library， 以保证你的程序能正确运行。\n\n从 [libtool动态库版本系统之个人理解 ](http://blog.csdn.net/zlyong0018/article/details/16846325) 这篇博客引用\n\n## 手动指定版本号\n\n我之前了解到的so的命名规范其实和libtool的版本号系统的so库命名规范不一样:\n\n> 库名.so.主版本号.次版本号.发布版本号\n\n[官方文档](http://www.gnu.org/software/libtool/manual/libtool.html#Release-numbers)也有提到这一点:\n\n\n> Often, people want to encode the name of the package release into the shared library so that it is obvious to the user what package their programs are linked against. This convention is used especially on GNU/Linux:\n> \n> trick$ ls /usr/lib/libbfd*\n> /usr/lib/libbfd.a           /usr/lib/libbfd.so.2.7.0.2\n> /usr/lib/libbfd.so\n> trick$\n> \n> On ‘trick’, /usr/lib/libbfd.so is a symbolic link to libbfd.so.2.7.0.2, which was distributed as a part of ‘binutils-2.7.0.2’.\n> \n> Unfortunately, this convention conflicts directly with libtool’s idea of library interface versions, because the library interface rarely changes at the same time that the release number does, and the library suffix is never the same across all platforms.\n> \n> So, to accommodate both views, you can use the -release flag to set release information for libraries for which you do not want to use -version-info. For the libbfd example, the next release that uses libtool should be built with ‘-release 2.9.0’, which will produce the following files on GNU/Linux:\n> \n> trick$ ls /usr/lib/libbfd*\n> /usr/lib/libbfd-2.9.0.so     /usr/lib/libbfd.a\n> /usr/lib/libbfd.so\n> trick$\n> \n> In this case, /usr/lib/libbfd.so is a symbolic link to libbfd-2.9.0.so. This makes it obvious that the user is dealing with ‘binutils-2.9.0’, without compromising libtool’s idea of interface versions.\n> \n> Note that this option causes a modification of the library name, so do not use it unless you want to break binary compatibility with any past library releases. In general, you should only use -release for package-internal libraries or for ones whose interfaces change very frequently. \n\n可以使用-release去手动指定版本号,虽然官方不推荐用这种方式:\n\n```\nlib_LTLIBRARIES = libeasylog.la\n\nlibeasylog_la_SOURCES = cout_log_interface.cpp \\\n\t\t\t\t\t easy_log.cpp \n\nlibeasylog_la_LDFLAGS = -release 0.0.3\n```\n\n安装之后lib目录如下:\n\n```\n-rwxr-xr-x 1 linjw linjw 143K 3月  26 14:48 libeasylog-0.0.3.so\n-rw-r--r-- 1 linjw linjw 263K 3月  26 14:48 libeasylog.a\n-rwxr-xr-x 1 linjw linjw  993 3月  26 14:48 libeasylog.la\nlrwxrwxrwx 1 linjw linjw   19 3月  26 14:48 libeasylog.so -> libeasylog-0.0.3.so\n```\n\n可以在[这里](https://github.com/bluesky466/automake-demo/tree/v0.0.3)查看完整的项目代码\n","source":"_posts/automake学习笔记-安装与发布.md","raw":"title: automake学习笔记 - 安装与发布\ndate: 2017-03-26 15:06:56\ntags:\n\t- 技术相关\n\t- 编译相关\n---\n\n辛辛苦苦写出来的代码当然是需要发布出来给自己或者别人去使用的。这篇文章就谈一谈发布相关的东西吧。\n\n## 安装\n\n软件在编译完后就需要进行安装。configure生成的Makefile支持install。使用make install 命令就可以将编译出来的软件安装到系统中。\n\n如果没有做配置，默认会安装到/usr/local中,当然如果需要的话也可以使用configure的--prefix参数指定安装的路径,如在build中执行下面的命令就可以将build目录指定为安装目录:\n\n> ../configure --prefix=\\`pwd\\`\n\n之后再执行下面的安装命令,工程在编译完后就会安装到build目录下。安装完毕之后可以看到build里面多了bin和lib两个目录\n\n> make install\n\nbin目录下是编译出来的可执行文件example,而lib目录下就是编译出来的依赖库:\n\n```\n-rw-r--r-- 1 linjw linjw 263K 3月  22 13:44 libeasylog.a\n-rwxr-xr-x 1 linjw linjw  985 3月  22 13:44 libeasylog.la\nlrwxrwxrwx 1 linjw linjw   19 3月  22 13:44 libeasylog.so -> libeasylog.so.0.0.0\nlrwxrwxrwx 1 linjw linjw   19 3月  22 13:44 libeasylog.so.0 -> libeasylog.so.0.0.0\n-rwxr-xr-x 1 linjw linjw 143K 3月  22 13:44 libeasylog.so.0.0.0\n```\n\n\n编译出来的libeasylog.so.0.0.0就可以直接拿出去给其他人使用了\n\n## 卸载\n\n卸载的话很简单，只需要执行下面的命令就行了\n\n> make uninstall\n\n当然你也可以选择手动去将安装的文件一个个删除,但是这样既麻烦又容易漏删或者错删\n\n## libtool 库版本号系统\n\n我们可以看到编译出来的so库是带版本号的，默认0.0.0,当然我们也能直接忽略版本号(某些可动态加载的的插件模块可能不需要版本号):\n\n```\nlib_LTLIBRARIES = libeasylog.la\n\nlibeasylog_la_SOURCES = cout_log_interface.cpp \\\n\t\t\t\t\t easy_log.cpp \n\nlibeasylog_la_LDFLAGS = -avoid-version\n```\n\n这样生成安装的so库就不会带版本号了:\n\n```\n-rw-r--r-- 1 linjw linjw 263K 3月  26 11:27 libeasylog.a\n-rwxr-xr-x 1 linjw linjw  975 3月  26 11:27 libeasylog.la\n-rwxr-xr-x 1 linjw linjw 143K 3月  26 11:27 libeasylog.so\n```\n\n当然，绝大部分的库都是需要带上版本号的。每个系统的库版本机制都不一样,libtool通过一种抽象的版本机制最终在创建库的时候才映射到具体的系统版本机制上。这是为了方便在交叉编译的时候可以用一种机制去管理不同平台上的各种版本机制。\n\nlibtool 库版本号系统有下面三个部分:\n\n- current\n\n接口的修改次数\n\n- revision\n\n上次修改后源码的修改次数(注意这里指的是只改动了实现,没有修改接口,如果改了接口的话应该要改current号，并且把revision置零)\n\n- age\n\n当前版本可以向前兼容的版本数\n\n[官方文档](http://www.gnu.org/software/libtool/manual/libtool.html#Updating-version-info)是这么描述这三个部分的更新规则的:\n\n> Here are a set of rules to help you update your library version information:\n1.    Start with version information of ‘0:0:0’ for each libtool library.\n2.    Update the version information only immediately before a public release of your software. More frequent updates are unnecessary, and only guarantee that the current interface number gets larger faster.\n3.    If the library source code has changed at all since the last update, then increment revision (‘c:r:a’ becomes ‘c:r+1:a’).\n4.    If any interfaces have been added, removed, or changed since the last update, increment current, and set revision to 0.\n5.    If any interfaces have been added since the last public release, then increment age.\n6.    If any interfaces have been removed or changed since the last public release, then set age to 0. \n\n翻译过来就是\n\n1. 库版本号应该开始于0.0.0\n2. 只有在正式发布库的时候才更新版本号以避免版本号增长过快\n3. 当实现代码改变的时候revision加1\n4. 当接口改变(无论是添加，删除还是修改接口声明)的时候current加1,同时revision重置为0\n5. 如果库只是增加了接口,则age加1\n6. 如果库删除或者修改了接口声明,则age重置为0\n\n这三个值可以用-version-info指定\n\n> -version-info current[:revision[:age]] \n\nrevision 和 age都可以省略,例如你这样设置:\n\n```\nlib_LTLIBRARIES = libeasylog.la\n\nlibeasylog_la_SOURCES = cout_log_interface.cpp \\\n\t\t\t\t\t easy_log.cpp \n\nlibeasylog_la_LDFLAGS = -version-info 3:12:1\n```\n\n表明接口被修改了三次,第三次修改接口之后又修改了12次源码,接口可以向前兼容1个版本\n\nmake install 后可以看到lib目录下生成的库长这样:\n\n```\n-rw-r--r-- 1 linjw linjw 263K 3月  26 12:11 libeasylog.a\n-rwxr-xr-x 1 linjw linjw  987 3月  26 12:11 libeasylog.la\nlrwxrwxrwx 1 linjw linjw   20 3月  26 12:11 libeasylog.so -> libeasylog.so.2.1.12\nlrwxrwxrwx 1 linjw linjw   20 3月  26 12:11 libeasylog.so.2 -> libeasylog.so.2.1.12\n-rwxr-xr-x 1 linjw linjw 143K 3月  26 12:11 libeasylog.so.2.1.12\n```\n\n为啥是libeasylog.so.2.1.12而不是libeasylog.so.3.12.1呢？\n\n原来这几个数字是这样计算的:\n\n库名.so.current-age.age.revision\n\n这样会引发一个问题:\n\n> 假设你的库有两个【3：0：1】【4：0：2】。 再假设在你编译程序的机器上安装了最新的【4：0：2】， 且你在程序中使用了该版本中新加的接口。当你程序编译好后， 你ldd发现你的程序依赖libraryname.so.2， 同时你将程序安装在了只安装了【3：0：1】的机器上， 你会发现你的程序能搜索到动态库， 却在运行的时候发现未定义的符号， 因为【3：0：1】中没有新添加的接口。 故你需要在运行机器上保证安装了同一主版本号最新的library， 以保证你的程序能正确运行。\n\n从 [libtool动态库版本系统之个人理解 ](http://blog.csdn.net/zlyong0018/article/details/16846325) 这篇博客引用\n\n## 手动指定版本号\n\n我之前了解到的so的命名规范其实和libtool的版本号系统的so库命名规范不一样:\n\n> 库名.so.主版本号.次版本号.发布版本号\n\n[官方文档](http://www.gnu.org/software/libtool/manual/libtool.html#Release-numbers)也有提到这一点:\n\n\n> Often, people want to encode the name of the package release into the shared library so that it is obvious to the user what package their programs are linked against. This convention is used especially on GNU/Linux:\n> \n> trick$ ls /usr/lib/libbfd*\n> /usr/lib/libbfd.a           /usr/lib/libbfd.so.2.7.0.2\n> /usr/lib/libbfd.so\n> trick$\n> \n> On ‘trick’, /usr/lib/libbfd.so is a symbolic link to libbfd.so.2.7.0.2, which was distributed as a part of ‘binutils-2.7.0.2’.\n> \n> Unfortunately, this convention conflicts directly with libtool’s idea of library interface versions, because the library interface rarely changes at the same time that the release number does, and the library suffix is never the same across all platforms.\n> \n> So, to accommodate both views, you can use the -release flag to set release information for libraries for which you do not want to use -version-info. For the libbfd example, the next release that uses libtool should be built with ‘-release 2.9.0’, which will produce the following files on GNU/Linux:\n> \n> trick$ ls /usr/lib/libbfd*\n> /usr/lib/libbfd-2.9.0.so     /usr/lib/libbfd.a\n> /usr/lib/libbfd.so\n> trick$\n> \n> In this case, /usr/lib/libbfd.so is a symbolic link to libbfd-2.9.0.so. This makes it obvious that the user is dealing with ‘binutils-2.9.0’, without compromising libtool’s idea of interface versions.\n> \n> Note that this option causes a modification of the library name, so do not use it unless you want to break binary compatibility with any past library releases. In general, you should only use -release for package-internal libraries or for ones whose interfaces change very frequently. \n\n可以使用-release去手动指定版本号,虽然官方不推荐用这种方式:\n\n```\nlib_LTLIBRARIES = libeasylog.la\n\nlibeasylog_la_SOURCES = cout_log_interface.cpp \\\n\t\t\t\t\t easy_log.cpp \n\nlibeasylog_la_LDFLAGS = -release 0.0.3\n```\n\n安装之后lib目录如下:\n\n```\n-rwxr-xr-x 1 linjw linjw 143K 3月  26 14:48 libeasylog-0.0.3.so\n-rw-r--r-- 1 linjw linjw 263K 3月  26 14:48 libeasylog.a\n-rwxr-xr-x 1 linjw linjw  993 3月  26 14:48 libeasylog.la\nlrwxrwxrwx 1 linjw linjw   19 3月  26 14:48 libeasylog.so -> libeasylog-0.0.3.so\n```\n\n可以在[这里](https://github.com/bluesky466/automake-demo/tree/v0.0.3)查看完整的项目代码\n","slug":"automake学习笔记-安装与发布","published":1,"updated":"2017-05-12T23:19:13.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2ro85di001a4kr4lleq9moh"},{"title":"automake学习笔记 - 交叉编译","date":"2017-04-02T03:05:27.000Z","_content":"\n## 什么是交叉编译\n\n很多时候我们因为各种原因需要在一个平台上编译其他平台的程序。如在linux或者windows上编译可以在安卓使用的so库、apk等。在linux上编译windows的dll或者exe等。\n\n这种在某个系统平台下可以产生另一个系统平台的可执行文件的技术就叫做交叉编译。\n\n## 使用automake进行交叉编译\n\nautomake就提供了交叉编译的功能，但是它的[官方文档](https://www.gnu.org/software/automake/manual/html_node/Cross_002dCompilation.html)十分的简单:\n\n> 2.2.8 Cross-Compilation\n>\n> To cross-compile is to build on one platform a binary that will run on another platform. When speaking of cross-compilation, it is important to distinguish between the build platform on which the compilation is performed, and the host platform on which the resulting executable is expected to run. The following configure options are used to specify each of them:\n>\n> --build=build\nThe system on which the package is built.\n>\n> --host=host\nThe system where built programs and libraries will run.\n>\n> When the --host is used, configure will search for the cross-compiling suite for this platform. Cross-compilation tools commonly have their target architecture as prefix of their name. For instance my cross-compiler for MinGW32 has its binaries called i586-mingw32msvc-gcc, i586-mingw32msvc-ld, i586-mingw32msvc-as, etc.\n>\n> Here is how we could build amhello-1.0 for i586-mingw32msvc on a GNU/Linux PC.\n>\n> ~/amhello-1.0 % ./configure --build i686-pc-linux-gnu --host i586-mingw32msvc\nchecking for a BSD-compatible install... /usr/bin/install -c\nchecking whether build environment is sane... yes\nchecking for gawk... gawk\nchecking whether make sets $(MAKE)... yes\nchecking for i586-mingw32msvc-strip... i586-mingw32msvc-strip\nchecking for i586-mingw32msvc-gcc... i586-mingw32msvc-gcc\nchecking for C compiler default output file name... a.exe\nchecking whether the C compiler works... yes\nchecking whether we are cross compiling... yes\nchecking for suffix of executables... .exe\nchecking for suffix of object files... o\nchecking whether we are using the GNU C compiler... yes\nchecking whether i586-mingw32msvc-gcc accepts -g... yes\nchecking for i586-mingw32msvc-gcc option to accept ANSI C...\n…\n~/amhello-1.0 % make\n…\n~/amhello-1.0 % cd src; file hello.exe\nhello.exe: MS Windows PE 32-bit Intel 80386 console executable not relocatable\nThe --host and --build options are usually all we need for cross-compiling. The only exception is if the package being built is itself a cross-compiler: we need a third option to specify its target architecture.\n>\n> --target=target\nWhen building compiler tools: the system for which the tools will create output.\n>\n> For instance when installing GCC, the GNU Compiler Collection, we can use --target=target to specify that we want to build GCC as a cross-compiler for target. Mixing --build and --target, we can actually cross-compile a cross-compiler; such a three-way cross-compilation is known as a Canadian cross.\n>\n> See Specifying the System Type in The Autoconf Manual, for more information about these configure options.\n\n简单的来说就是通过在执行configure的时候通过传入下面三个参数进行配置,然后和普通的编译一样使用make命令就能编译出指定平台的程序\n\n- --build\n\n编译工程的平台\n\n- --host\n\n编译出来的程序或者库需要运行的平台\n\n- --target\n\n当构建编译器时,指定该编译器编译的程序的运行平台\n\n但是看例子，我们指定平台却并不是简单的指定windows、android这么简单。\n\n> ~/amhello-1.0 % ./configure --build i686-pc-linux-gnu --host i586-mingw32msvc\n\n这里的 i686-pc-linux-gnu和 i586-mingw32msvc-gcc其实指的是一系列的编译工具。交叉编译工具的命名其实是有一定的格式的。 例如，用来编译windows程序的MinGW32的交叉编译器的二进制文件叫做i586-mingw32msvc-gcc，i586-mingw32msvc-ld，i586-mingw32msvc-as等。\n\n> MinGW是Minimalist GNU for Windows的意思，又称mingw32，是将GCC编译器和GNU Binutils移植到Win32平台下的产物，包括一系列头文件（Win32API）、库和可执行文件。-- [维基百科](https://zh.wikipedia.org/wiki/MinGW)\n\n其实就是我们指定了编译工具的前缀，然后automake就会更加这个前缀，找到对应的编译器去编译我们的程序。\n\n## 在linux上编译windows上的程序\n\n有人可能会问，为什么需要在linux上编译这么蛋疼而不直接在windows上编译呢？\n\n就按我遇到的情况来说吧。我们部门的自动构建服务器就是liunx的，我们的项目都需要通过它来编译、检查和发布，我们也习惯于子啊linux上编程，最重要的是我们的项目就是跨平台的，不管是windows、linux还是android上都需要可以运行，所以没有必要为每个平台搭建一套编译环境。直接在linux上编译所有平台的软件是最好的选择。\n\n为了在linux上交叉编译windows的程序，我们先要搭建一下交叉编译的环境:\n\n1. 安装交叉编译工具\n\n```\nsudo apt-get install mingw-w64\n```\n\n2. 更新配置，使用 posix thread\n\n```\nsudo update-alternatives --config i686-w64-mingw32-g++\nsudo update-alternatives --config i686-w64-mingw32-gcc\nsudo update-alternatives --config x86_64-w64-mingw32-g++\nsudo update-alternatives --config x86_64-w64-mingw32-gcc\n```\n\n上面的选项中，选择 posix 版本。\n\n> 可移植操作系统接口（英语：Portable Operating System Interface of UNIX，缩写为POSIX），是IEEE为要在各种UNIX操作系统上运行软件，而定义API的一系列互相关联的标准的总称，其正式称呼为IEEE Std 1003，而国际标准名称为ISO/IEC 9945。此标准源于一个大约开始于1985年的项目。POSIX这个名称是由理查德·斯托曼应IEEE的要求而提议的一个易于记忆的名称。它基本上是Portable Operating System Interface（可移植操作系统接口）的缩写，而X则表明其对Unix API的传承。\nLinux基本上逐步实现了POSIX兼容，但并没有参加正式的POSIX认证。[1]\n微软的Windows NT声称部分实现了POSIX标准。[2]\n当前的POSIX主要分为四个部分[3]：Base Definitions、System Interfaces、Shell and Utilities和Rationale。 -- [维基百科](https://zh.wikipedia.org/wiki/POSIX)\n\n按道理这个时候就可以在build目录执行下面的命令去编译了\n\n```\n../configure --prefix=`pwd` --host i686-w64-mingw32\n```\n\n但是执行了configure之后却会报下面的错误:\n\n> libtool: warning: undefined symbols not allowed in i686-w64-mingw32 shared libraries; building static only\n\n本来我们的工程是需要编译动态库的，但是如果报了这个错误，就会编出静态库来，最终install之后在bin目录下面只有一个 __example.exe__ ，而没有dll。解决方法是在src/Makefile.am中加上\n\n> libeasylog_la_LDFLAGS = -no-undefined\n\n这样编译安装之后就能在bin目录下看到 __example.exe__ 和 __libeasylog-0.dll__ 了\n\n这个时候将这两个东西拷贝到windows平台上去，记得它们需要在同级目录这样 __example.exe__ 才能找到 __libeasylog-0.dll__。然后在控制台中运行 __example.exe__ 就会报下面的错误,其实就是还有几个dll没有找到：\n\n> 无法启动此程序,因为计算机中丢失libstdc++-6.dll。尝试重新安装该程序以解决此问题。  \n>\n> 无法启动此程序,因为计算机中丢失libgcc_s_sjlj-1.dll。尝试重新安装该程序以解决此问题。\n\n我们到下面的目录把缺的dll也拷贝到example的同级目录\n\n> /usr/lib/gcc/i686-w64-mingw32/5.3-posix/\n\n再次运行发现有报了下面的错误:\n\n> 无法启动此程序,因为计算机中丢失libwinpthread-1.dll。尝试重新安装该程序以解决此问题。\n\n这个dll可以到下面的目录拷贝，同样放到example的同级目录，之后再运行example:\n\n> [test] testlog\n\n看已经成功运行了。\n\n## 在linux上编译安卓上的程序\n\n搭建安卓的交叉编译环境就是生成 standalone toochain\n\n首先下载NDK，解压，假设NDK的根目录为NDK_ROOT，然后执行\n\n```\nsudo $NDK_ROOT/build/tools/make-standalone-toolchain.sh \\\n     --platform=android-19 \\\n     --install-dir=$HOME/Android/standalone-toolchains/android-toolchain-arm \\\n     --toolchain=arm-linux-androideabi-4.9 \\\n     --stl=gnustl\n```\n\n最后配置环境变量\n\n```\nexport NDK_ROOT=$HOME/Android/android-ndk-r13b\nexport TOOLCHAIN_HOME=$HOME/Android/standalone-toolchains/android-toolchain-arm\nexport TOOLCHAIN_SYSROOT=$TOOLCHAIN_HOME/sysroot\nexport PATH=$PATH:$TOOLCHAIN_HOME/bin\n```\n\n环境搭建好之后在build目录中执行\n\n```\n../configure --prefix=`pwd` --host arm-linux-androideabi\n```\n\n之后就能使用make install命令编译并安装了。\n\n在某些机器上编译时会报找不到shared_ptr的错误,解决方法是在src/Makefile.am和examples/Makefile.am的CPPFLAGS宏加上-std=c++11:\n\n```\n#src/Makefile.am\nlib_LTLIBRARIES = libeasylog.la\n\nlibeasylog_la_SOURCES = cout_log_interface.cpp \\\n\t\t\t\t\t\teasy_log.cpp\n\nlibeasylog_la_CPPFLAGS = -std=c++11\n\nlibeasylog_la_LDFLAGS = -no-undefined\n```\n\n```\n#examples/Makefile.am\nAM_CPPFLAGS = -I$(top_srcdir)/src \\\n              -std=c++11\n\nbin_PROGRAMS = example\nexample_SOURCES = example.cpp\n\nexample_LDADD = -L$(top_builddir)/src \\\n\t\t\t\t-leasylog\n\n```\n\n编译安装完成后再bin目录可以见到 __example__ ,在lib目录可以看到 __libeasylog.so__。\n\n虽然看起来和linux程序一样，但是直接运行example的话会报错:\n\n> zsh: 可执行文件格式错误: ./example\n\n因为它的运行环境是安卓，在本机(Ubuntu)上不能运行\n\n如果你有一台root了的安卓机器的话，可以使用adb将example给push到/system/bin，将libeasylog.so给push到/system/lib。这样就能在adb shell中使用example命令得到下面的输出了:\n\n> [test] testlog\n\n当然，做应用的一般都不会直接编译出可执行程序来给安卓使用。更多的是编译出so来给apk通过jni调用c/c++的方法。但是编译的过程和这里是一样的，关于jni的使用我之后会另写一篇文章来讨论。\n\n## Demo项目\n\n可以在[这里](https://github.com/bluesky466/automake-demo/tree/v0.0.4)查看完整的项目代码\n","source":"_posts/automake学习笔记-交叉编译.md","raw":"title: automake学习笔记 - 交叉编译\ndate: 2017-04-02 11:05:27\ntags:\n\t- 技术相关\n\t- 编译相关\n---\n\n## 什么是交叉编译\n\n很多时候我们因为各种原因需要在一个平台上编译其他平台的程序。如在linux或者windows上编译可以在安卓使用的so库、apk等。在linux上编译windows的dll或者exe等。\n\n这种在某个系统平台下可以产生另一个系统平台的可执行文件的技术就叫做交叉编译。\n\n## 使用automake进行交叉编译\n\nautomake就提供了交叉编译的功能，但是它的[官方文档](https://www.gnu.org/software/automake/manual/html_node/Cross_002dCompilation.html)十分的简单:\n\n> 2.2.8 Cross-Compilation\n>\n> To cross-compile is to build on one platform a binary that will run on another platform. When speaking of cross-compilation, it is important to distinguish between the build platform on which the compilation is performed, and the host platform on which the resulting executable is expected to run. The following configure options are used to specify each of them:\n>\n> --build=build\nThe system on which the package is built.\n>\n> --host=host\nThe system where built programs and libraries will run.\n>\n> When the --host is used, configure will search for the cross-compiling suite for this platform. Cross-compilation tools commonly have their target architecture as prefix of their name. For instance my cross-compiler for MinGW32 has its binaries called i586-mingw32msvc-gcc, i586-mingw32msvc-ld, i586-mingw32msvc-as, etc.\n>\n> Here is how we could build amhello-1.0 for i586-mingw32msvc on a GNU/Linux PC.\n>\n> ~/amhello-1.0 % ./configure --build i686-pc-linux-gnu --host i586-mingw32msvc\nchecking for a BSD-compatible install... /usr/bin/install -c\nchecking whether build environment is sane... yes\nchecking for gawk... gawk\nchecking whether make sets $(MAKE)... yes\nchecking for i586-mingw32msvc-strip... i586-mingw32msvc-strip\nchecking for i586-mingw32msvc-gcc... i586-mingw32msvc-gcc\nchecking for C compiler default output file name... a.exe\nchecking whether the C compiler works... yes\nchecking whether we are cross compiling... yes\nchecking for suffix of executables... .exe\nchecking for suffix of object files... o\nchecking whether we are using the GNU C compiler... yes\nchecking whether i586-mingw32msvc-gcc accepts -g... yes\nchecking for i586-mingw32msvc-gcc option to accept ANSI C...\n…\n~/amhello-1.0 % make\n…\n~/amhello-1.0 % cd src; file hello.exe\nhello.exe: MS Windows PE 32-bit Intel 80386 console executable not relocatable\nThe --host and --build options are usually all we need for cross-compiling. The only exception is if the package being built is itself a cross-compiler: we need a third option to specify its target architecture.\n>\n> --target=target\nWhen building compiler tools: the system for which the tools will create output.\n>\n> For instance when installing GCC, the GNU Compiler Collection, we can use --target=target to specify that we want to build GCC as a cross-compiler for target. Mixing --build and --target, we can actually cross-compile a cross-compiler; such a three-way cross-compilation is known as a Canadian cross.\n>\n> See Specifying the System Type in The Autoconf Manual, for more information about these configure options.\n\n简单的来说就是通过在执行configure的时候通过传入下面三个参数进行配置,然后和普通的编译一样使用make命令就能编译出指定平台的程序\n\n- --build\n\n编译工程的平台\n\n- --host\n\n编译出来的程序或者库需要运行的平台\n\n- --target\n\n当构建编译器时,指定该编译器编译的程序的运行平台\n\n但是看例子，我们指定平台却并不是简单的指定windows、android这么简单。\n\n> ~/amhello-1.0 % ./configure --build i686-pc-linux-gnu --host i586-mingw32msvc\n\n这里的 i686-pc-linux-gnu和 i586-mingw32msvc-gcc其实指的是一系列的编译工具。交叉编译工具的命名其实是有一定的格式的。 例如，用来编译windows程序的MinGW32的交叉编译器的二进制文件叫做i586-mingw32msvc-gcc，i586-mingw32msvc-ld，i586-mingw32msvc-as等。\n\n> MinGW是Minimalist GNU for Windows的意思，又称mingw32，是将GCC编译器和GNU Binutils移植到Win32平台下的产物，包括一系列头文件（Win32API）、库和可执行文件。-- [维基百科](https://zh.wikipedia.org/wiki/MinGW)\n\n其实就是我们指定了编译工具的前缀，然后automake就会更加这个前缀，找到对应的编译器去编译我们的程序。\n\n## 在linux上编译windows上的程序\n\n有人可能会问，为什么需要在linux上编译这么蛋疼而不直接在windows上编译呢？\n\n就按我遇到的情况来说吧。我们部门的自动构建服务器就是liunx的，我们的项目都需要通过它来编译、检查和发布，我们也习惯于子啊linux上编程，最重要的是我们的项目就是跨平台的，不管是windows、linux还是android上都需要可以运行，所以没有必要为每个平台搭建一套编译环境。直接在linux上编译所有平台的软件是最好的选择。\n\n为了在linux上交叉编译windows的程序，我们先要搭建一下交叉编译的环境:\n\n1. 安装交叉编译工具\n\n```\nsudo apt-get install mingw-w64\n```\n\n2. 更新配置，使用 posix thread\n\n```\nsudo update-alternatives --config i686-w64-mingw32-g++\nsudo update-alternatives --config i686-w64-mingw32-gcc\nsudo update-alternatives --config x86_64-w64-mingw32-g++\nsudo update-alternatives --config x86_64-w64-mingw32-gcc\n```\n\n上面的选项中，选择 posix 版本。\n\n> 可移植操作系统接口（英语：Portable Operating System Interface of UNIX，缩写为POSIX），是IEEE为要在各种UNIX操作系统上运行软件，而定义API的一系列互相关联的标准的总称，其正式称呼为IEEE Std 1003，而国际标准名称为ISO/IEC 9945。此标准源于一个大约开始于1985年的项目。POSIX这个名称是由理查德·斯托曼应IEEE的要求而提议的一个易于记忆的名称。它基本上是Portable Operating System Interface（可移植操作系统接口）的缩写，而X则表明其对Unix API的传承。\nLinux基本上逐步实现了POSIX兼容，但并没有参加正式的POSIX认证。[1]\n微软的Windows NT声称部分实现了POSIX标准。[2]\n当前的POSIX主要分为四个部分[3]：Base Definitions、System Interfaces、Shell and Utilities和Rationale。 -- [维基百科](https://zh.wikipedia.org/wiki/POSIX)\n\n按道理这个时候就可以在build目录执行下面的命令去编译了\n\n```\n../configure --prefix=`pwd` --host i686-w64-mingw32\n```\n\n但是执行了configure之后却会报下面的错误:\n\n> libtool: warning: undefined symbols not allowed in i686-w64-mingw32 shared libraries; building static only\n\n本来我们的工程是需要编译动态库的，但是如果报了这个错误，就会编出静态库来，最终install之后在bin目录下面只有一个 __example.exe__ ，而没有dll。解决方法是在src/Makefile.am中加上\n\n> libeasylog_la_LDFLAGS = -no-undefined\n\n这样编译安装之后就能在bin目录下看到 __example.exe__ 和 __libeasylog-0.dll__ 了\n\n这个时候将这两个东西拷贝到windows平台上去，记得它们需要在同级目录这样 __example.exe__ 才能找到 __libeasylog-0.dll__。然后在控制台中运行 __example.exe__ 就会报下面的错误,其实就是还有几个dll没有找到：\n\n> 无法启动此程序,因为计算机中丢失libstdc++-6.dll。尝试重新安装该程序以解决此问题。  \n>\n> 无法启动此程序,因为计算机中丢失libgcc_s_sjlj-1.dll。尝试重新安装该程序以解决此问题。\n\n我们到下面的目录把缺的dll也拷贝到example的同级目录\n\n> /usr/lib/gcc/i686-w64-mingw32/5.3-posix/\n\n再次运行发现有报了下面的错误:\n\n> 无法启动此程序,因为计算机中丢失libwinpthread-1.dll。尝试重新安装该程序以解决此问题。\n\n这个dll可以到下面的目录拷贝，同样放到example的同级目录，之后再运行example:\n\n> [test] testlog\n\n看已经成功运行了。\n\n## 在linux上编译安卓上的程序\n\n搭建安卓的交叉编译环境就是生成 standalone toochain\n\n首先下载NDK，解压，假设NDK的根目录为NDK_ROOT，然后执行\n\n```\nsudo $NDK_ROOT/build/tools/make-standalone-toolchain.sh \\\n     --platform=android-19 \\\n     --install-dir=$HOME/Android/standalone-toolchains/android-toolchain-arm \\\n     --toolchain=arm-linux-androideabi-4.9 \\\n     --stl=gnustl\n```\n\n最后配置环境变量\n\n```\nexport NDK_ROOT=$HOME/Android/android-ndk-r13b\nexport TOOLCHAIN_HOME=$HOME/Android/standalone-toolchains/android-toolchain-arm\nexport TOOLCHAIN_SYSROOT=$TOOLCHAIN_HOME/sysroot\nexport PATH=$PATH:$TOOLCHAIN_HOME/bin\n```\n\n环境搭建好之后在build目录中执行\n\n```\n../configure --prefix=`pwd` --host arm-linux-androideabi\n```\n\n之后就能使用make install命令编译并安装了。\n\n在某些机器上编译时会报找不到shared_ptr的错误,解决方法是在src/Makefile.am和examples/Makefile.am的CPPFLAGS宏加上-std=c++11:\n\n```\n#src/Makefile.am\nlib_LTLIBRARIES = libeasylog.la\n\nlibeasylog_la_SOURCES = cout_log_interface.cpp \\\n\t\t\t\t\t\teasy_log.cpp\n\nlibeasylog_la_CPPFLAGS = -std=c++11\n\nlibeasylog_la_LDFLAGS = -no-undefined\n```\n\n```\n#examples/Makefile.am\nAM_CPPFLAGS = -I$(top_srcdir)/src \\\n              -std=c++11\n\nbin_PROGRAMS = example\nexample_SOURCES = example.cpp\n\nexample_LDADD = -L$(top_builddir)/src \\\n\t\t\t\t-leasylog\n\n```\n\n编译安装完成后再bin目录可以见到 __example__ ,在lib目录可以看到 __libeasylog.so__。\n\n虽然看起来和linux程序一样，但是直接运行example的话会报错:\n\n> zsh: 可执行文件格式错误: ./example\n\n因为它的运行环境是安卓，在本机(Ubuntu)上不能运行\n\n如果你有一台root了的安卓机器的话，可以使用adb将example给push到/system/bin，将libeasylog.so给push到/system/lib。这样就能在adb shell中使用example命令得到下面的输出了:\n\n> [test] testlog\n\n当然，做应用的一般都不会直接编译出可执行程序来给安卓使用。更多的是编译出so来给apk通过jni调用c/c++的方法。但是编译的过程和这里是一样的，关于jni的使用我之后会另写一篇文章来讨论。\n\n## Demo项目\n\n可以在[这里](https://github.com/bluesky466/automake-demo/tree/v0.0.4)查看完整的项目代码\n","slug":"automake学习笔记-交叉编译","published":1,"updated":"2017-05-12T23:19:13.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2ro85dk001d4kr4uvwdq8db"},{"title":"automake学习笔记 - helloworld","date":"2017-03-16T17:11:40.000Z","_content":"\n虽然之前已经用过一段时间的automake,但是总觉得对它的理解不过充分,只是知其然而不知其所以然。于是下定决心好好啃[文档](http://www.gnu.org/software/automake/manual/automake.html),并将学的的东西记录下来。\n\n这篇文章用一个简单的log工具的编译先对automake做一个hello world级别的介绍。\n\n## 代码\n我们的demo有6个文件cout\\_log\\_interface.h, cout\\_log\\_interface.cpp, log\\_interface.h, easy\\_log.h, easy\\_log.cpp, main.cpp\n\n简单介绍下代码吧,首先有个简单的Log类:\n\n```\nclass EasyLog {\npublic:\n    EasyLog(std::shared_ptr<LogInterface> interface);\n\n    void Info(const std::string& tag, const std::string& log);\n\n    void Debug(const std::string& tag, const std::string& log);\n\n    void Warn(const std::string& tag, const std::string& log);\n\n    void Error(const std::string& tag, const std::string& log);\n\nprivate:\n    std::string GetLog(const std::string& tag, const std::string& log) const;\n\n    std::shared_ptr<LogInterface> interface_;\n};\n```\n\n它的实现十分简单，就是将所有的操作代理给LogInterface:\n\n```\nEasyLog::EasyLog(shared_ptr<LogInterface> interface)\n    : interface_(interface)\n{\n}\n\nvoid EasyLog::Info(const string& tag, const string& log)\n{\n    interface_->DoLog(kInfo, tag, GetLog(tag, log));\n}\n\nvoid EasyLog::Debug(const string& tag, const string& log)\n{\n    interface_->DoLog(kDebug, tag, GetLog(tag, log));\n}\n\nvoid EasyLog::Warn(const string& tag, const string& log)\n{\n    interface_->DoLog(kWarn, tag, GetLog(tag, log));\n}\n\nvoid EasyLog::Error(const string& tag, const string& log)\n{\n    interface_->DoLog(kError, tag, GetLog(tag, log));\n}\n\nstd::string EasyLog::GetLog(const string& tag, const string& log) const\n{\n    return \"[\" + tag + \"]\" + \" \" + log;\n}\n```\n\nLogInterface是一个纯虚类，然后LogLevel是一个枚举体:\n\n```\nenum LogLevel {\n    kInfo,\n    kDebug,\n    kWarn,\n    kError\n};\n\nclass LogInterface {\npublic:\n    virtual void DoLog(LogLevel level, const std::string& tag, const std::string& log) = 0;\n};\n```\n\n我们再写一个使用标准输出打印log的LogInterface:\n\n```\nclass COutLogInterface : public LogInterface {\npublic:\n    virtual void DoLog(LogLevel level, const std::string& tag, const std::string& log);\n};\n```\n\n它的实现就是使用cout打印log:\n\n```\nvoid COutLogInterface::DoLog(LogLevel level, const string& tag, const string& log) {\n    cout<<log<<endl;\n}\n```\n\n当然需要有个main函数:\n\n```\nint main()\n{\n    EasyLog log(std::make_shared<COutLogInterface>());\n    log.Debug(\"test\", \"testlog\");\n    return 0;\n}\n```\n\n## Makefile.am\n\nautomake使用Makefile.am配置工程的源码,它的内容如下:\n\n```\nbin_PROGRAMS = easylog\neasylog_SOURCES = cout_log_interface.cpp \\\n                  easy_log.cpp \\\n                  main.cpp\n```\n\nbin\\_PROGRAMS 指定了要编译生成的目标程序的名字,在这里我们最终编译出来的目标程序的文件名是easylog\n\n之后的 easylog\\_SOURCES 指定了需要参与编译的源代码。\n\n如果需要同时编译多个目标程序的话可以用下面的方式分别指定各个目标程序的源代码\n\n```\nbin_PROGRAMS = program_a program_b\nprogram_a_SOURCES = code_a.cpp\nprogram_b_SOURCES = code_b.cpp \n```\n\n## configure.ac\n\n指定了源代码还不够，因为automake不仅仅可以用来生成编译c/c++的makefile，还可以用来编译生成其他许许多多语言的makefile，所以还需要指定编译器和依赖文件等。automake使用configure.ac配置这些东西,本例子的configure.ac是这么写的:\n\n```\nAC_INIT([easylog], [0.0.1], [466474482@qq.com])\nAM_INIT_AUTOMAKE([-Wall -Werror foreign])\nAC_CONFIG_HEADERS([config.h])\n\nAC_PROG_CXX\nAX_CXX_COMPILE_STDCXX_11\n\nAC_CONFIG_FILES([Makefile])\n\nAC_OUTPUT\n```\n\n简单分析一下configure.ac的内容:\n\n- AC\\_INIT \n\n指定了工程的名字、版本号、和bug的报告邮箱\n\n- AM\\_INIT\\_AUTOMAKE\n\n指定了一些选项,-Wall和-Werror指定编译的时候将所有的warning当做error来报错, foreign告诉automake这里不用遵循GNU标准。GNU软件包应该包括一些附加文件去描述如修改项，作者等信息。在这里我们不需要automake去检查这些附加文件的存在。\n\n- AC\\_CONFIG\\_HEADERS \n\n我们在AC\\_INIT中配置了版本号等信息,c/c++中一般需要用宏来定义它们,这里就指定了生成的配置宏的头文件名。配置了这里,automake就会自动帮我们生成config.h头文件,里面定义了一些VERSION之类的宏\n\n- AC\\_PROG\\_CXX\n\n该宏用于检查系统中是否有g++编译器\n\n- AX\\_CXX\\_COMPILE\\_STDCXX\\_11 \n\n检查系统的c++11编译支持\n\n- AC\\_CONFIG\\_FILES \n\n指定了需要configure生成的Makefile,autoreconf的时候会通过Makefile.am生成Makefile.in。而configure的时候会通过Makefile.in生成Makefile。因为Makefile.am和configure.ac在同级目录,所以直接写Makefile就好了。在后面我会介绍当Makefile.am和configure.ac不在同级目录的时候需要怎么配置\n\n- AC\\_OUTPUT\n\n这是一个结束标志,实际上它是一个脚本命令用来创建AC\\_CONFIG\\_HEADERS和AC\\_CONFIG\\_FILES所配置的文件\n\n## 生成Makefile\n\n首先要安装autoconf\n\n> sudo apt-get install autoconf\n\n然后使用下面的命令生成configure\n\n> autoreconf --install\n\n除了configure之外，它还会生成一些其他的文件，当然现在我们不需要去管这些文件\n\n之后就能使用configure脚本去生成Makefile和config.h等\n\n> ./configure\n\n\n## 编译工程\n\nMakefile都已经生成了，现在就可以使用make命令编译工程啦  \n\n编译成功之后就能在当前目录看到easylog程序。我们可以运行它:\n\n> ./easylog\n\n得到下面输出:\n\n> [test] testlog\n\n## 在build目录中编译项目\n\n现在我们编译生成的.o文件和目标程序都混在源代码中间,看起来很不舒服。我们可以创建一个build目录。然后进入build目录执行下面命令\n\n> ../configure\n\n这样就在build目录下生成Makefile了,于是现在我们在build中使用make命令编辑工程就会发现编译产生的.o文件和目标文件都在build中而不会污染源代码了。\n\n## 使用autoscan生成configure.ac                                                  \n                                                                                 \n如果直接手写configure.ac的话是比较困难的,很容易漏掉一些依赖项没有检查。所以就出现了autoscan这个工具,它可以帮我们检查工程中的依赖项生成configure.ac的模板,然后我们只需要在它生成的模板上略加改动就可以了。\n                                                                                 \n我们在工程目录下使用autoscan命令,会得到下面的两个文件:                           \n                                                                                 \n1. autoscan.log                                                                  \n                                                                                 \n2. configure.scan                                                                \n                                                                                 \nautoscan.log是一个日志文件,通过它我们可以知道一些配置为什么会被需要              \n                                                                                 \n而configure.scan就是生成出来的configure.ac的模板了,在easylog工程目录使用autoscan,生成的configure.scan内容如下\n                                                                                 \n```                                                                              \n#                                               -*- Autoconf -*-                 \n# Process this file with autoconf to produce a configure script.                 \n                                                                                 \nAC_PREREQ([2.69])                                                                \nAC_INIT([FULL-PACKAGE-NAME], [VERSION], [BUG-REPORT-ADDRESS])                    \nAC_CONFIG_SRCDIR([log_interface.h])                                              \nAC_CONFIG_HEADERS([config.h])                                                    \n                                                                                 \n# Checks for programs.                                                           \nAC_PROG_CXX                                                                      \nAC_PROG_CC                                                                       \n                                                                                 \n# Checks for libraries.                                                          \n                                                                                 \n# Checks for header files.                                                       \n                                                                                 \n# Checks for typedefs, structures, and compiler characteristics.                 \n                                                                                 \n# Checks for library functions.                                                  \n                                                                                 \nAC_CONFIG_FILES([Makefile])                                                      \nAC_OUTPUT                                                                        \n```                                                                              \n                                                                                 \n看是不是和我们之前手写的很像?我们只有在上面进行一些小的修改就能得到最终我们需要的configure.ac了\n\n这里有两个宏我们是没有见过的\n\n- AC\\_PREREQ\n\n用于检查autoconf的最低版本\n\n- AC\\_CONFIG\\_SRCDIR\n\n用一个项目中一定存在的文件去确定源码目录的有效性,这是一个安全检查宏。configure有一个--srcdir的参数可以指定源码目录,这个宏就可以检查出源码目录是否不小心配置错了\n\n## Demo项目\n\n可以在[这里](https://github.com/bluesky466/automake-demo/tree/v0.0.1)查看完整的项目代码\n","source":"_posts/automake学习笔记-helloworld.md","raw":"title: automake学习笔记 - helloworld\ndate: 2017-03-17 01:11:40\ntags:\n\t- 技术相关\n\t- 编译相关\n---\n\n虽然之前已经用过一段时间的automake,但是总觉得对它的理解不过充分,只是知其然而不知其所以然。于是下定决心好好啃[文档](http://www.gnu.org/software/automake/manual/automake.html),并将学的的东西记录下来。\n\n这篇文章用一个简单的log工具的编译先对automake做一个hello world级别的介绍。\n\n## 代码\n我们的demo有6个文件cout\\_log\\_interface.h, cout\\_log\\_interface.cpp, log\\_interface.h, easy\\_log.h, easy\\_log.cpp, main.cpp\n\n简单介绍下代码吧,首先有个简单的Log类:\n\n```\nclass EasyLog {\npublic:\n    EasyLog(std::shared_ptr<LogInterface> interface);\n\n    void Info(const std::string& tag, const std::string& log);\n\n    void Debug(const std::string& tag, const std::string& log);\n\n    void Warn(const std::string& tag, const std::string& log);\n\n    void Error(const std::string& tag, const std::string& log);\n\nprivate:\n    std::string GetLog(const std::string& tag, const std::string& log) const;\n\n    std::shared_ptr<LogInterface> interface_;\n};\n```\n\n它的实现十分简单，就是将所有的操作代理给LogInterface:\n\n```\nEasyLog::EasyLog(shared_ptr<LogInterface> interface)\n    : interface_(interface)\n{\n}\n\nvoid EasyLog::Info(const string& tag, const string& log)\n{\n    interface_->DoLog(kInfo, tag, GetLog(tag, log));\n}\n\nvoid EasyLog::Debug(const string& tag, const string& log)\n{\n    interface_->DoLog(kDebug, tag, GetLog(tag, log));\n}\n\nvoid EasyLog::Warn(const string& tag, const string& log)\n{\n    interface_->DoLog(kWarn, tag, GetLog(tag, log));\n}\n\nvoid EasyLog::Error(const string& tag, const string& log)\n{\n    interface_->DoLog(kError, tag, GetLog(tag, log));\n}\n\nstd::string EasyLog::GetLog(const string& tag, const string& log) const\n{\n    return \"[\" + tag + \"]\" + \" \" + log;\n}\n```\n\nLogInterface是一个纯虚类，然后LogLevel是一个枚举体:\n\n```\nenum LogLevel {\n    kInfo,\n    kDebug,\n    kWarn,\n    kError\n};\n\nclass LogInterface {\npublic:\n    virtual void DoLog(LogLevel level, const std::string& tag, const std::string& log) = 0;\n};\n```\n\n我们再写一个使用标准输出打印log的LogInterface:\n\n```\nclass COutLogInterface : public LogInterface {\npublic:\n    virtual void DoLog(LogLevel level, const std::string& tag, const std::string& log);\n};\n```\n\n它的实现就是使用cout打印log:\n\n```\nvoid COutLogInterface::DoLog(LogLevel level, const string& tag, const string& log) {\n    cout<<log<<endl;\n}\n```\n\n当然需要有个main函数:\n\n```\nint main()\n{\n    EasyLog log(std::make_shared<COutLogInterface>());\n    log.Debug(\"test\", \"testlog\");\n    return 0;\n}\n```\n\n## Makefile.am\n\nautomake使用Makefile.am配置工程的源码,它的内容如下:\n\n```\nbin_PROGRAMS = easylog\neasylog_SOURCES = cout_log_interface.cpp \\\n                  easy_log.cpp \\\n                  main.cpp\n```\n\nbin\\_PROGRAMS 指定了要编译生成的目标程序的名字,在这里我们最终编译出来的目标程序的文件名是easylog\n\n之后的 easylog\\_SOURCES 指定了需要参与编译的源代码。\n\n如果需要同时编译多个目标程序的话可以用下面的方式分别指定各个目标程序的源代码\n\n```\nbin_PROGRAMS = program_a program_b\nprogram_a_SOURCES = code_a.cpp\nprogram_b_SOURCES = code_b.cpp \n```\n\n## configure.ac\n\n指定了源代码还不够，因为automake不仅仅可以用来生成编译c/c++的makefile，还可以用来编译生成其他许许多多语言的makefile，所以还需要指定编译器和依赖文件等。automake使用configure.ac配置这些东西,本例子的configure.ac是这么写的:\n\n```\nAC_INIT([easylog], [0.0.1], [466474482@qq.com])\nAM_INIT_AUTOMAKE([-Wall -Werror foreign])\nAC_CONFIG_HEADERS([config.h])\n\nAC_PROG_CXX\nAX_CXX_COMPILE_STDCXX_11\n\nAC_CONFIG_FILES([Makefile])\n\nAC_OUTPUT\n```\n\n简单分析一下configure.ac的内容:\n\n- AC\\_INIT \n\n指定了工程的名字、版本号、和bug的报告邮箱\n\n- AM\\_INIT\\_AUTOMAKE\n\n指定了一些选项,-Wall和-Werror指定编译的时候将所有的warning当做error来报错, foreign告诉automake这里不用遵循GNU标准。GNU软件包应该包括一些附加文件去描述如修改项，作者等信息。在这里我们不需要automake去检查这些附加文件的存在。\n\n- AC\\_CONFIG\\_HEADERS \n\n我们在AC\\_INIT中配置了版本号等信息,c/c++中一般需要用宏来定义它们,这里就指定了生成的配置宏的头文件名。配置了这里,automake就会自动帮我们生成config.h头文件,里面定义了一些VERSION之类的宏\n\n- AC\\_PROG\\_CXX\n\n该宏用于检查系统中是否有g++编译器\n\n- AX\\_CXX\\_COMPILE\\_STDCXX\\_11 \n\n检查系统的c++11编译支持\n\n- AC\\_CONFIG\\_FILES \n\n指定了需要configure生成的Makefile,autoreconf的时候会通过Makefile.am生成Makefile.in。而configure的时候会通过Makefile.in生成Makefile。因为Makefile.am和configure.ac在同级目录,所以直接写Makefile就好了。在后面我会介绍当Makefile.am和configure.ac不在同级目录的时候需要怎么配置\n\n- AC\\_OUTPUT\n\n这是一个结束标志,实际上它是一个脚本命令用来创建AC\\_CONFIG\\_HEADERS和AC\\_CONFIG\\_FILES所配置的文件\n\n## 生成Makefile\n\n首先要安装autoconf\n\n> sudo apt-get install autoconf\n\n然后使用下面的命令生成configure\n\n> autoreconf --install\n\n除了configure之外，它还会生成一些其他的文件，当然现在我们不需要去管这些文件\n\n之后就能使用configure脚本去生成Makefile和config.h等\n\n> ./configure\n\n\n## 编译工程\n\nMakefile都已经生成了，现在就可以使用make命令编译工程啦  \n\n编译成功之后就能在当前目录看到easylog程序。我们可以运行它:\n\n> ./easylog\n\n得到下面输出:\n\n> [test] testlog\n\n## 在build目录中编译项目\n\n现在我们编译生成的.o文件和目标程序都混在源代码中间,看起来很不舒服。我们可以创建一个build目录。然后进入build目录执行下面命令\n\n> ../configure\n\n这样就在build目录下生成Makefile了,于是现在我们在build中使用make命令编辑工程就会发现编译产生的.o文件和目标文件都在build中而不会污染源代码了。\n\n## 使用autoscan生成configure.ac                                                  \n                                                                                 \n如果直接手写configure.ac的话是比较困难的,很容易漏掉一些依赖项没有检查。所以就出现了autoscan这个工具,它可以帮我们检查工程中的依赖项生成configure.ac的模板,然后我们只需要在它生成的模板上略加改动就可以了。\n                                                                                 \n我们在工程目录下使用autoscan命令,会得到下面的两个文件:                           \n                                                                                 \n1. autoscan.log                                                                  \n                                                                                 \n2. configure.scan                                                                \n                                                                                 \nautoscan.log是一个日志文件,通过它我们可以知道一些配置为什么会被需要              \n                                                                                 \n而configure.scan就是生成出来的configure.ac的模板了,在easylog工程目录使用autoscan,生成的configure.scan内容如下\n                                                                                 \n```                                                                              \n#                                               -*- Autoconf -*-                 \n# Process this file with autoconf to produce a configure script.                 \n                                                                                 \nAC_PREREQ([2.69])                                                                \nAC_INIT([FULL-PACKAGE-NAME], [VERSION], [BUG-REPORT-ADDRESS])                    \nAC_CONFIG_SRCDIR([log_interface.h])                                              \nAC_CONFIG_HEADERS([config.h])                                                    \n                                                                                 \n# Checks for programs.                                                           \nAC_PROG_CXX                                                                      \nAC_PROG_CC                                                                       \n                                                                                 \n# Checks for libraries.                                                          \n                                                                                 \n# Checks for header files.                                                       \n                                                                                 \n# Checks for typedefs, structures, and compiler characteristics.                 \n                                                                                 \n# Checks for library functions.                                                  \n                                                                                 \nAC_CONFIG_FILES([Makefile])                                                      \nAC_OUTPUT                                                                        \n```                                                                              \n                                                                                 \n看是不是和我们之前手写的很像?我们只有在上面进行一些小的修改就能得到最终我们需要的configure.ac了\n\n这里有两个宏我们是没有见过的\n\n- AC\\_PREREQ\n\n用于检查autoconf的最低版本\n\n- AC\\_CONFIG\\_SRCDIR\n\n用一个项目中一定存在的文件去确定源码目录的有效性,这是一个安全检查宏。configure有一个--srcdir的参数可以指定源码目录,这个宏就可以检查出源码目录是否不小心配置错了\n\n## Demo项目\n\n可以在[这里](https://github.com/bluesky466/automake-demo/tree/v0.0.1)查看完整的项目代码\n","slug":"automake学习笔记-helloworld","published":1,"updated":"2017-05-12T23:19:13.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2ro85dm001g4kr49m9k6b37"},{"title":"ToolBar 学习笔记","date":"2016-01-25T06:56:42.000Z","_content":"\n虽然android studio在新建项目的时候就可以创建一个默认带有ToolBar的MainActivity，但是抱着学习学全套的精神，我们就从一个没有Activity的空项目入手，一步一步把ToolBar学透。\n\n## **一、创建基础ToolBar**\n\n创建完一个不带Activity的空项目之后的第一步就是创建自己的Activity了，注意这个Activity必须继承AppCompatActivity（ActionBarActivity已经被废弃了）。\n\n```java\n    public class MainActivity extends AppCompatActivity{\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.main_activity);\n        }\n    }\n```\n\n如果不能import android.support.v7.app.AppCompatActivity;的话就在build.gradle（Module：App）的dependencies里面添加\n\n    compile 'com.android.support:appcompat-v7:23.1.1'\n\n这个R.layout.main_activity也是要自己创建的，我这里创建了一个只有一个TextView的LinearLayout\n\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Hello World\"/>\n    </LinearLayout>\n```\n\n当然，不要忘了在manifests里面注册MainActivity\n```xml\n\t<activity android:name=\".MainActivity\"\n            android:label=\"@string/app_name\"\n            android:theme=\"@style/AppTheme\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\"/>\n                <category android:name=\"android.intent.category.LAUNCHER\"/>\n            </intent-filter>\n\t</activity>\n```\n然后运行程序就能就是下面这个样子：\n{% img /ToolBar-学习笔记/1.jpg %}\n\n## **二、自定义ToolBar样式**\n\n因为用上面的方法创建的ToolBar是Activity自带的，在需要自定义样式的时候不够灵活，所以我们把它去掉，换成我们自己创建的ToolBar。\n\n可以在@style/AppTheme添加如下item：\n\n```xml\n\t<!-- 去掉Activity自带的ToolBar -->\n\t<item name=\"windowNoTitle\">true</item>\n```\n\n这个时候再运行项目，就会发现ToolBar已经不见了。然后我们自己在R.layout.main_activity里面自己声明一个ToolBar:\n\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <android.support.v7.widget.Toolbar\n            android:id=\"@+id/toolbar\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"?attr/actionBarSize\"\n            android:theme=\"@style/ToolBarTheme\"/>\n\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Hello World\"/>\n\n    </LinearLayout>\n```\n\nToolBar的Theme分离出来放在@style/Theme,可以在这里自定义ToolBar的样式:\n```xml\n \t<style name=\"ToolBarTheme\" parent=\"Theme.AppCompat\">\n        <!-- 设置ToolBar底色 -->\n        <item name=\"android:background\">#3F51B5</item>\n        <!-- 设置字体颜色 -->\n        <item name=\"android:textColorPrimary\">#FFFFFF</item>\n    </style>\n```\n\n最后在MainActivity里调用setSupportActionBar，顺便设置调用ToolBar的方法设置一些属性。注意这里的ToolBar是导的android.support.v7.widget.Toolbar的包：\n\n```java\n    public class MainActivity extends AppCompatActivity{\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.main_activity);\n\n            Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n\n            toolbar.setTitle(\"title\"); //setTile方法必须在setSupportActionBar之前调用\n            toolbar.setSubtitle(\"subtitle\");\n            toolbar.setLogo(R.mipmap.ic_launcher);\n\n            setSupportActionBar(toolbar);\n\n            //给Navigate按钮加一个默认的返回箭头\n            //也可以用toolbar.setNavigationIcon()直接给Navigate设置icon\n        \tgetSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        }\n    }\n```\n\n运行起来之后长这个样子:\n{% img /ToolBar-学习笔记/2.jpg %}\n\n## **三、添加菜单按钮**\n\n首先创建一个menu/main.xml:\n\n```xml\n    <menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n        <item\n            android:id=\"@+id/btn_ico\"\n            android:title=\"btn_ico\"\n            android:icon=\"@mipmap/ic_launcher\"\n            app:showAsAction=\"ifRoom\" />\n        <item\n            android:id=\"@+id/btn_search\"\n            android:title=\"btn_search\"\n            app:actionViewClass=\"android.support.v7.widget.SearchView\"\n            app:showAsAction=\"ifRoom\" />\n        <item\n            android:id=\"@+id/btn_1\"\n            android:title=\"btn_1\"\n            app:showAsAction=\"never\" />\n        <item\n            android:id=\"@+id/btn_2\"\n            android:title=\"btn_2\"\n            app:showAsAction=\"never\"/>\n    </menu>\n```\n\n这里的app:showAsAction就是按钮出现的位置，它可以填入以下的值:\n1. always：这个值会使菜单项一直显示在ToolBar上。\n2. ifRoom：如果有足够的空间，这个值会使菜单项显示在ToolBar上。\n3. never：这个值使菜单项永远都不出现在ToolBar上。\n4. withText：这个值使菜单项和它的图标，菜单文本一起显示。 \n\n\n然后在MainActivity覆盖onCreateOptionsMenu方法：\n```java\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.main, menu);\n        return true;\n    }\n```\n\n运行程序之后长这个样子：\n{% img /ToolBar-学习笔记/3.jpg %}\n\n## **四、监听菜单按钮消息**\n\n监听这些菜单按钮的消息有两种方法\n1.覆盖Activity的onOptionsItemSelected方法\n\n```java\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Toast.makeText(this, item.getTitle(), Toast.LENGTH_SHORT).show();\n        return true;\n    }\n```\n\n2.调用ToolBar的setOnMenuItemClickListener方法\n\n```java\n    //setOnMenuItemClickListener方法必须在setSupportActionBar之后调用才有效\n    toolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() {\n        @Override\n        public boolean onMenuItemClick(MenuItem item) {\n            Toast.makeText(MainActivity.this, item.getTitle(), Toast.LENGTH_SHORT).show();\n            return false;\n        }\n    });\n```\n\n这个时候Navigation按钮的消息也是在上面两个回调方法中处理的，当然也能直接调用ToolBar的setNavigationOnClickListener方法设置，这样只有在该listener方法里面才会收到Navigation按钮的消息：\n```java\n    //setNavigationOnClickListener方法必须在setSupportActionBar之后调用才有效\n    toolbar.setNavigationOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            finish();\n        }\n    });\n```\n\n而ToolBar上的搜索按钮可以这样设置它的回调:\n```java\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.main, menu);\n        MenuItem item = menu.findItem(R.id.btn_search);\n        SearchView searcher = (SearchView) item.getActionView();\n        searcher.setOnQueryTextListener(new SearchView.OnQueryTextListener() {\n            @Override\n            public boolean onQueryTextSubmit(String query) {\n                Toast.makeText(MainActivity.this, query, Toast.LENGTH_SHORT).show();\n                return false;\n            }\n\n            @Override\n            public boolean onQueryTextChange(String newText) {\n                return false;\n            }\n        });\n        return true;\n    }\n```\n\n## **五、设置弹出菜单的样式**\n\n弹出菜单的样式默认是和ToolBar的样式一样的:\n{% img /ToolBar-学习笔记/4.jpg %}\n\n但也可以通过下面的方法自定义\n\n1.新建样式PopupTheme\n\n```xml\n\t<style name=\"PopupTheme\" parent=\"Theme.AppCompat\">\n        <item name=\"android:background\">#FFFFFF</item>\n        <item name=\"android:textColorPrimary\">#000000</item>\n    </style>\n```\n\n2.设置ToolBar的PopupTheme,注意这里的前缀是app:\n```xml\n\t<android.support.v7.widget.Toolbar\n        android:id=\"@+id/toolbar\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"?attr/actionBarSize\"\n        android:theme=\"@style/ToolBarTheme\"\n        app:popupTheme=\"@style/PopupTheme\"/>\n```\n\n效果如下：\n{% img /ToolBar-学习笔记/5.jpg %}\n","source":"_posts/ToolBar-学习笔记.md","raw":"title: ToolBar 学习笔记\ndate: 2016-01-25 14:56:42\ntags:\n    - 技术相关\n    - Android\n---\n\n虽然android studio在新建项目的时候就可以创建一个默认带有ToolBar的MainActivity，但是抱着学习学全套的精神，我们就从一个没有Activity的空项目入手，一步一步把ToolBar学透。\n\n## **一、创建基础ToolBar**\n\n创建完一个不带Activity的空项目之后的第一步就是创建自己的Activity了，注意这个Activity必须继承AppCompatActivity（ActionBarActivity已经被废弃了）。\n\n```java\n    public class MainActivity extends AppCompatActivity{\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.main_activity);\n        }\n    }\n```\n\n如果不能import android.support.v7.app.AppCompatActivity;的话就在build.gradle（Module：App）的dependencies里面添加\n\n    compile 'com.android.support:appcompat-v7:23.1.1'\n\n这个R.layout.main_activity也是要自己创建的，我这里创建了一个只有一个TextView的LinearLayout\n\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Hello World\"/>\n    </LinearLayout>\n```\n\n当然，不要忘了在manifests里面注册MainActivity\n```xml\n\t<activity android:name=\".MainActivity\"\n            android:label=\"@string/app_name\"\n            android:theme=\"@style/AppTheme\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\"/>\n                <category android:name=\"android.intent.category.LAUNCHER\"/>\n            </intent-filter>\n\t</activity>\n```\n然后运行程序就能就是下面这个样子：\n{% img /ToolBar-学习笔记/1.jpg %}\n\n## **二、自定义ToolBar样式**\n\n因为用上面的方法创建的ToolBar是Activity自带的，在需要自定义样式的时候不够灵活，所以我们把它去掉，换成我们自己创建的ToolBar。\n\n可以在@style/AppTheme添加如下item：\n\n```xml\n\t<!-- 去掉Activity自带的ToolBar -->\n\t<item name=\"windowNoTitle\">true</item>\n```\n\n这个时候再运行项目，就会发现ToolBar已经不见了。然后我们自己在R.layout.main_activity里面自己声明一个ToolBar:\n\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <android.support.v7.widget.Toolbar\n            android:id=\"@+id/toolbar\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"?attr/actionBarSize\"\n            android:theme=\"@style/ToolBarTheme\"/>\n\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Hello World\"/>\n\n    </LinearLayout>\n```\n\nToolBar的Theme分离出来放在@style/Theme,可以在这里自定义ToolBar的样式:\n```xml\n \t<style name=\"ToolBarTheme\" parent=\"Theme.AppCompat\">\n        <!-- 设置ToolBar底色 -->\n        <item name=\"android:background\">#3F51B5</item>\n        <!-- 设置字体颜色 -->\n        <item name=\"android:textColorPrimary\">#FFFFFF</item>\n    </style>\n```\n\n最后在MainActivity里调用setSupportActionBar，顺便设置调用ToolBar的方法设置一些属性。注意这里的ToolBar是导的android.support.v7.widget.Toolbar的包：\n\n```java\n    public class MainActivity extends AppCompatActivity{\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.main_activity);\n\n            Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n\n            toolbar.setTitle(\"title\"); //setTile方法必须在setSupportActionBar之前调用\n            toolbar.setSubtitle(\"subtitle\");\n            toolbar.setLogo(R.mipmap.ic_launcher);\n\n            setSupportActionBar(toolbar);\n\n            //给Navigate按钮加一个默认的返回箭头\n            //也可以用toolbar.setNavigationIcon()直接给Navigate设置icon\n        \tgetSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        }\n    }\n```\n\n运行起来之后长这个样子:\n{% img /ToolBar-学习笔记/2.jpg %}\n\n## **三、添加菜单按钮**\n\n首先创建一个menu/main.xml:\n\n```xml\n    <menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n        <item\n            android:id=\"@+id/btn_ico\"\n            android:title=\"btn_ico\"\n            android:icon=\"@mipmap/ic_launcher\"\n            app:showAsAction=\"ifRoom\" />\n        <item\n            android:id=\"@+id/btn_search\"\n            android:title=\"btn_search\"\n            app:actionViewClass=\"android.support.v7.widget.SearchView\"\n            app:showAsAction=\"ifRoom\" />\n        <item\n            android:id=\"@+id/btn_1\"\n            android:title=\"btn_1\"\n            app:showAsAction=\"never\" />\n        <item\n            android:id=\"@+id/btn_2\"\n            android:title=\"btn_2\"\n            app:showAsAction=\"never\"/>\n    </menu>\n```\n\n这里的app:showAsAction就是按钮出现的位置，它可以填入以下的值:\n1. always：这个值会使菜单项一直显示在ToolBar上。\n2. ifRoom：如果有足够的空间，这个值会使菜单项显示在ToolBar上。\n3. never：这个值使菜单项永远都不出现在ToolBar上。\n4. withText：这个值使菜单项和它的图标，菜单文本一起显示。 \n\n\n然后在MainActivity覆盖onCreateOptionsMenu方法：\n```java\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.main, menu);\n        return true;\n    }\n```\n\n运行程序之后长这个样子：\n{% img /ToolBar-学习笔记/3.jpg %}\n\n## **四、监听菜单按钮消息**\n\n监听这些菜单按钮的消息有两种方法\n1.覆盖Activity的onOptionsItemSelected方法\n\n```java\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Toast.makeText(this, item.getTitle(), Toast.LENGTH_SHORT).show();\n        return true;\n    }\n```\n\n2.调用ToolBar的setOnMenuItemClickListener方法\n\n```java\n    //setOnMenuItemClickListener方法必须在setSupportActionBar之后调用才有效\n    toolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() {\n        @Override\n        public boolean onMenuItemClick(MenuItem item) {\n            Toast.makeText(MainActivity.this, item.getTitle(), Toast.LENGTH_SHORT).show();\n            return false;\n        }\n    });\n```\n\n这个时候Navigation按钮的消息也是在上面两个回调方法中处理的，当然也能直接调用ToolBar的setNavigationOnClickListener方法设置，这样只有在该listener方法里面才会收到Navigation按钮的消息：\n```java\n    //setNavigationOnClickListener方法必须在setSupportActionBar之后调用才有效\n    toolbar.setNavigationOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            finish();\n        }\n    });\n```\n\n而ToolBar上的搜索按钮可以这样设置它的回调:\n```java\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.main, menu);\n        MenuItem item = menu.findItem(R.id.btn_search);\n        SearchView searcher = (SearchView) item.getActionView();\n        searcher.setOnQueryTextListener(new SearchView.OnQueryTextListener() {\n            @Override\n            public boolean onQueryTextSubmit(String query) {\n                Toast.makeText(MainActivity.this, query, Toast.LENGTH_SHORT).show();\n                return false;\n            }\n\n            @Override\n            public boolean onQueryTextChange(String newText) {\n                return false;\n            }\n        });\n        return true;\n    }\n```\n\n## **五、设置弹出菜单的样式**\n\n弹出菜单的样式默认是和ToolBar的样式一样的:\n{% img /ToolBar-学习笔记/4.jpg %}\n\n但也可以通过下面的方法自定义\n\n1.新建样式PopupTheme\n\n```xml\n\t<style name=\"PopupTheme\" parent=\"Theme.AppCompat\">\n        <item name=\"android:background\">#FFFFFF</item>\n        <item name=\"android:textColorPrimary\">#000000</item>\n    </style>\n```\n\n2.设置ToolBar的PopupTheme,注意这里的前缀是app:\n```xml\n\t<android.support.v7.widget.Toolbar\n        android:id=\"@+id/toolbar\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"?attr/actionBarSize\"\n        android:theme=\"@style/ToolBarTheme\"\n        app:popupTheme=\"@style/PopupTheme\"/>\n```\n\n效果如下：\n{% img /ToolBar-学习笔记/5.jpg %}\n","slug":"ToolBar-学习笔记","published":1,"updated":"2017-05-12T23:19:13.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2ro85dq001j4kr4fgkszs4v"},{"title":"Retrofit 学习笔记","date":"2016-02-22T08:19:56.000Z","_content":"\n工欲善其事必先利其器，使用一些强大方便的器，可以大大的提高开发的效率，我认为 Retrofit 和 RxJava 就是这样的利器。\n\nRetrofit 是一个开源的 java http 请求库，目前已经更新到 2.0.0-beta4，官方的介绍是：\n\n> Type-safe HTTP client for Android and Java by Square, Inc.\n\n我在学习它的过程中遇到了不少问题，于是写了这篇东西把遇到的问题和解决方法都记录一下。\n\n## __android studio 导入 Retrofit__\n\n首先我使用的是 android studio，一开始搜索怎样使用第三方库的时候看到了不少的文章，有介绍导入 jar 包的，有介绍源码库的，但使用方法和我接下来介绍的都显得复杂很多。\n\n比如现在我们要使用 Retrofit ，先登录 [http://search.maven.org/](http://search.maven.org/)，搜索 Retrofit 我们可以看到搜出了不少东西，我们直接用最新的版本 2.0.0-beta4，可以看到它有两个版本，点进去看看：\n\n{% img /Retrofit-学习笔记/1.jpg %}\n\n原来一个是beta3，一个是beta4：\n\n{% img /Retrofit-学习笔记/2.jpg %}\n\n然后我们打开 android studio 项目的 build.gradle(Module: app)， 在它的 dependencies 里面加上  retrofit 的引用:\n\n```\n    dependencies {\n        compile fileTree(dir: 'libs', include: ['*.jar'])\n        testCompile 'junit:junit:4.12'\n        compile 'com.android.support:appcompat-v7:23.1.1'\n        compile 'com.squareup.retrofit2:retrofit:2.0.0-beta4'\n    }\n```\n\n要使用 [http://search.maven.org/](http://search.maven.org/)，搜索到的第三方库只需要在 dependencies 里面加上\n\n> compile 'GroupId:ArtifactId:Version'\n\n对应 retrofit 就是这句：\n\n> compile 'com.squareup.retrofit2:retrofit:2.0.0-beta4'\n\n再点击 android studio 弹出的 Sync Now，android studio 就会帮你自动下载和配置第三方库，而你就能直接使用了。\n\n{% img /Retrofit-学习笔记/3.jpg %}\n\n## __使用 Retrofit 的 Call 类获取 github 用户的信息__\n\n官方文档一开始就展示了一个简单的demo [http://square.github.io/retrofit/](http://square.github.io/retrofit/)\n\n可惜都是代码碎片，你按照它写好代码之后就会发现......报异常了。\n\n{% img /Retrofit-学习笔记/4.jpg %}\n\n{% img /Retrofit-学习笔记/5.jpg %}\n\n我先把讲讲我写的demo，最后再告诉你们官方文档到底哪里出问题了。\n\n首先定义一个 User 类用于保存获取到的用户信息：\n\n```java\n    public class User {\n        private String login;\n        private long id;\n        private String name;\n\n        @Override\n        public String toString() {\n            return \"login:\" + login + \", \"\n                    + \"id:\" + id + \", \"\n                    + \"name:\" + name;\n        }\n\n        public String getLogin() {\n            return login;\n        }\n\n        public void setLogin(String login) {\n            this.login = login;\n        }\n\n        public long getId() {\n            return id;\n        }\n\n        public void setId(long id) {\n            this.id = id;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n    }\n```\n\n接着定义一个接口用于告诉 Retrofit 怎样去获取数据，如下代码就表明使用 get 方法获取 users 路径下的 user 资源，使用的最终使用的时候，传入的 user 参数会替换 users/{user} 的 {user} 字段。\n\n不过我还真不知道它这里到底是怎么实现的，看来 java 基础还真要去补一补才行了。\n\n```java\n     public interface GitHubService {\n            @GET(\"users/{user}\")\n            Call<User> getUserInfoByCall(@Path(\"user\") String user);\n        }\n```\n\n之后就可以创建一个 GitHubService 实例了（我总觉得有点 java 黑魔法的感觉）：\n\n```java\n     GitHubService service = new Retrofit.Builder()\n                    .baseUrl(\"https://api.github.com\")\n                    .addConverterFactory(GsonConverterFactory.create())\n                    .build()\n                    .create(GitHubService.class);\n```\n\n然后调用 service 的 getUserInfoByCall 方法就能获取到一个 Call 对象了。像如下的代码，就能获取到一个用于访问 [https://api.github.com/users/bluesky466](https://api.github.com/users/bluesky466) 的 Call 对象：\n\n```java\n\tfinal Call<User> call = service.getUserInfoByCall(\"bluesky466\");\n```\n\n最后就能用 call 的 execute 方法访问服务器获取用户数据了。因为 execute 是同步的，而安卓不允许在 ui 线程访问网络，所以我们需要用一个子线程去访问。\n\n```java\n    new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        Response<User> response = call.execute();\n                        User user = response.body();\n                        Log.d(\"result\", user.toString());\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }).start();\n```\n\n结果如下：\n\n{% img /Retrofit-学习笔记/6.jpg %}\n\n当然，Retrofit 也提供了异步访问的方法：\n\n```java\n     call.enqueue(new Callback<User>() {\n                @Override\n                public void onResponse(Call<User> call, Response<User> response) {\n                    User user = response.body();\n                \tLog.d(\"result\", user.toString());\n                }\n\n                @Override\n                public void onFailure(Call<User> call, Throwable t) {\n\n                }\n            });\n```\n\nRetrofit 用获取到的数据生成了一个User对象。这是什么黑魔法？\n\n还记得我一开始说的按照官方文档的代码会报异常吗？\n\n官方文档的代码：\n\n```java\n    Retrofit retrofit = new Retrofit.Builder()\n        .baseUrl(\"https://api.github.com\")\n        .build();\n\n    GitHubService service = retrofit.create(GitHubService.class);\n```\n\n我的代码：\n\n```java\n    GitHubService service = new Retrofit.Builder()\n                        .baseUrl(\"https://api.github.com\")\n                        .addConverterFactory(GsonConverterFactory.create())\n                        .build()\n                        .create(GitHubService.class);\n```\n\n差别就在在这里：\n\n```\n\t.addConverterFactory(GsonConverterFactory.create())\n```\n\n我这里指定了一个 Gson 转换工厂，因为 [https://api.github.com](https://api.github.com) 使用josn 格式返回数据，所以我们可以使用 Gson 去解析它，然后生成一个 User 对象。\n\n不过就算你按我这样写代码又会发现找不到 GsonConverterFactory 的包......\n\n{% img /Retrofit-学习笔记/7.jpg %}\n\n原因在于 GsonConverterFactory 使用来转换json的，你也可以指定其他的 Factory 去转换 xml 之类的格式。而这些 Factory 并不包含在 Retrofit 库里面，需要用户自己去导入。\n\n{% img /Retrofit-学习笔记/8.jpg %}\n\n在 dependencies 中加入：\n\n```\n\tcompile 'com.squareup.retrofit2:converter-gson:2.0.0-beta4'\n```\n\n类似的库有下面这些：\n- __Gson__: com.squareup.retrofit2:converter-gson\n- __Jackson__: com.squareup.retrofit2:converter-jackson\n- __Moshi__: com.squareup.retrofit2:converter-moshi\n- __Protobuf__: com.squareup.retrofit2:converter-protobuf\n- __Wire__: com.squareup.retrofit2:converter-wire\n- __Simple__ XML: com.squareup.retrofit2:converter-simplexml\n- __Scalars__ (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars\n\n\n## __使用 Retrofit 配合 RxJava 获取 github 用户的信息__\n\nRxJava 在 GitHub 主页上的自我介绍是 \"a library for composing asynchronous and event-based programs using observable sequences for the Java VM\"（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。\n\n它可以用来替换 AsyncTask 之类的东西。\n\n关于 RxJava 有一篇很好的博客 -- [给 Android 开发者的 RxJava 详解](http://gank.io/post/560e15be2dca930e00da1083)。这里基本上把 RxJava 讲的很透彻了。我这里就不多说，只是讲一讲怎样在 Retrofit 中使用 RxJava。\n\n在 Retrofit 中使用 RxJava 首先需要导入 adapter-rxjava 库，而且因为是在安卓上使用，所以需要导入 RxJava 的 Android 平台的扩展 rxandroid 库：\n\n```\n\tcompile 'com.squareup.retrofit2:adapter-rxjava:2.0.0-beta4\n    compile 'io.reactivex:rxandroid:1.1.0'\n```\n\n添加 GitHubService 接口的 RxJava 获取方法：\n```java\n    public interface GitHubService {\n            @GET(\"users/{user}\")\n            Call<User> getUserInfoByCall(@Path(\"user\") String user);\n\n            @GET(\"users/{user}\")\n            Observable<User> getUserInfoByObservable(@Path(\"user\") String user);\n        }\n```\n\n然后创建 GitHubService 的时候需要指定 RxJava的适配工厂：\n\n```java\n     GitHubService service = new Retrofit.Builder()\n                    .baseUrl(\"https://api.github.com\")\n                    .addConverterFactory(GsonConverterFactory.create())//指定RxJava适配工厂\n                    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())\n                    .build()\n                    .create(GitHubService.class);\n```\n\n然后就是指定 subscribe 去输出结果了：\n\n```java\n    service.getUserInfoByObservable(\"bluesky466\")\n                    .subscribeOn(Schedulers.newThread())\n                    .observeOn(AndroidSchedulers.mainThread())\n                    .subscribe(new Subscriber<User>() {\n                        @Override\n                        public void onNext(User user) {\n                            if (user != null) {\n                                Log.d(\"result\", user.toString());\n                            }\n                        }\n\n                        @Override\n                        public void onCompleted() {\n                        }\n\n                        @Override\n                        public void onError(Throwable e) {\n                        }\n                    });\n```\n\n## __一个小 Demo__\n\n我写了一个 demo 用来展示 Retrofit 的用法，完整源码如下：\n\nMainActivity：\n\n```java\n    public class MainActivity extends AppCompatActivity {\n        private GitHubService mService;\n        private EditText mUserName;\n        private TextView mResult;\n\n        public interface GitHubService {\n            @GET(\"users/{user}\")\n            Call<User> getUserInfoByCall(@Path(\"user\") String user);\n\n            @GET(\"users/{user}\")\n            Observable<User> getUserInfoByObservable(@Path(\"user\") String user);\n        }\n\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.activity_main);\n\n            mUserName = (EditText) findViewById(R.id.username);\n            mResult = (TextView) findViewById(R.id.result);\n\n            Button btnCall = (Button) findViewById(R.id.btnCall);\n            btnCall.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    queryByCall(mUserName.getText().toString());\n                }\n            });\n\n            Button btnObservable = (Button) findViewById(R.id.btnObservable);\n            btnObservable.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    queryByObservable(mUserName.getText().toString());\n                }\n            });\n\n            mService = new Retrofit.Builder()\n                    .baseUrl(\"https://api.github.com\")\n                    .addConverterFactory(GsonConverterFactory.create())\n                    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())\n                    .build()\n                    .create(GitHubService.class);\n        }\n\n        private void queryByCall(final String username) {\n            mService.getUserInfoByCall(username).enqueue(new Callback<User>() {\n                @Override\n                public void onResponse(Call<User> call, Response<User> response) {\n                    if (response.body() != null) {\n                        mResult.setText(\"[ByCall] \" + response.body().toString());\n                    } else {\n                        mResult.setText(\"[ByCall] Not Found\");\n                    }\n                }\n\n                @Override\n                public void onFailure(Call<User> call, Throwable t) {\n                    mResult.setText(\"[ByCall] Not Found\");\n                }\n            });\n        }\n\n        private void queryByObservable(final String username) {\n            mService.getUserInfoByObservable(username)\n                    .subscribeOn(Schedulers.newThread())\n                    .observeOn(AndroidSchedulers.mainThread())\n                    .subscribe(new Subscriber<User>() {\n                        @Override\n                        public void onCompleted() {\n                        }\n\n                        @Override\n                        public void onError(Throwable e) {\n                            mResult.setText(\"[ByObservable] Not Found\");\n                        }\n\n                        @Override\n                        public void onNext(User user) {\n                            if (user != null) {\n                                mResult.setText(\"[ByObservable] \" + user.toString());\n                            }\n                        }\n                    });\n        }\n    }\n```\n\nactivity\\_main.xml:\n\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        xmlns:tools=\"http://schemas.android.com/tools\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <LinearLayout\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:orientation=\"horizontal\">\n\n            <EditText\n                android:id=\"@+id/username\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_weight=\"1\"\n                android:hint=\"user name\" />\n\n            <Button\n                android:id=\"@+id/btnCall\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"Call\" />\n\n            <Button\n                android:id=\"@+id/btnObservable\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"Observable\" />\n        </LinearLayout>\n\n        <TextView\n            android:id=\"@+id/result\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"\" />\n    </LinearLayout>\n```\n\nUser:\n\n```java\n    public class User {\n        private String login;\n        private long id;\n        private String name;\n\n        @Override\n        public String toString() {\n            return \"login:\" + login + \", \"\n                    + \"id:\" + id + \", \"\n                    + \"name:\" + name;\n        }\n\n        public String getLogin() {\n            return login;\n        }\n\n        public void setLogin(String login) {\n            this.login = login;\n        }\n\n        public long getId() {\n            return id;\n        }\n\n        public void setId(long id) {\n            this.id = id;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n    }\n\n```\n\ndependencies:\n\n```\n\tdependencies {\n        compile fileTree(dir: 'libs', include: ['*.jar'])\n        testCompile 'junit:junit:4.12'\n        compile 'com.android.support:appcompat-v7:23.1.1'\n        compile 'com.squareup.retrofit2:retrofit:2.0.0-beta4'\n        compile 'com.squareup.retrofit2:converter-gson:2.0.0-beta4'\n        compile 'com.squareup.retrofit2:adapter-rxjava:2.0.0-beta4'\n        compile 'io.reactivex:rxandroid:1.1.0'\n    }\n```\n","source":"_posts/Retrofit-学习笔记.md","raw":"title: Retrofit 学习笔记\ndate: 2016-02-22 16:19:56\ntags:\n\t- 技术相关\n\t- Android\n---\n\n工欲善其事必先利其器，使用一些强大方便的器，可以大大的提高开发的效率，我认为 Retrofit 和 RxJava 就是这样的利器。\n\nRetrofit 是一个开源的 java http 请求库，目前已经更新到 2.0.0-beta4，官方的介绍是：\n\n> Type-safe HTTP client for Android and Java by Square, Inc.\n\n我在学习它的过程中遇到了不少问题，于是写了这篇东西把遇到的问题和解决方法都记录一下。\n\n## __android studio 导入 Retrofit__\n\n首先我使用的是 android studio，一开始搜索怎样使用第三方库的时候看到了不少的文章，有介绍导入 jar 包的，有介绍源码库的，但使用方法和我接下来介绍的都显得复杂很多。\n\n比如现在我们要使用 Retrofit ，先登录 [http://search.maven.org/](http://search.maven.org/)，搜索 Retrofit 我们可以看到搜出了不少东西，我们直接用最新的版本 2.0.0-beta4，可以看到它有两个版本，点进去看看：\n\n{% img /Retrofit-学习笔记/1.jpg %}\n\n原来一个是beta3，一个是beta4：\n\n{% img /Retrofit-学习笔记/2.jpg %}\n\n然后我们打开 android studio 项目的 build.gradle(Module: app)， 在它的 dependencies 里面加上  retrofit 的引用:\n\n```\n    dependencies {\n        compile fileTree(dir: 'libs', include: ['*.jar'])\n        testCompile 'junit:junit:4.12'\n        compile 'com.android.support:appcompat-v7:23.1.1'\n        compile 'com.squareup.retrofit2:retrofit:2.0.0-beta4'\n    }\n```\n\n要使用 [http://search.maven.org/](http://search.maven.org/)，搜索到的第三方库只需要在 dependencies 里面加上\n\n> compile 'GroupId:ArtifactId:Version'\n\n对应 retrofit 就是这句：\n\n> compile 'com.squareup.retrofit2:retrofit:2.0.0-beta4'\n\n再点击 android studio 弹出的 Sync Now，android studio 就会帮你自动下载和配置第三方库，而你就能直接使用了。\n\n{% img /Retrofit-学习笔记/3.jpg %}\n\n## __使用 Retrofit 的 Call 类获取 github 用户的信息__\n\n官方文档一开始就展示了一个简单的demo [http://square.github.io/retrofit/](http://square.github.io/retrofit/)\n\n可惜都是代码碎片，你按照它写好代码之后就会发现......报异常了。\n\n{% img /Retrofit-学习笔记/4.jpg %}\n\n{% img /Retrofit-学习笔记/5.jpg %}\n\n我先把讲讲我写的demo，最后再告诉你们官方文档到底哪里出问题了。\n\n首先定义一个 User 类用于保存获取到的用户信息：\n\n```java\n    public class User {\n        private String login;\n        private long id;\n        private String name;\n\n        @Override\n        public String toString() {\n            return \"login:\" + login + \", \"\n                    + \"id:\" + id + \", \"\n                    + \"name:\" + name;\n        }\n\n        public String getLogin() {\n            return login;\n        }\n\n        public void setLogin(String login) {\n            this.login = login;\n        }\n\n        public long getId() {\n            return id;\n        }\n\n        public void setId(long id) {\n            this.id = id;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n    }\n```\n\n接着定义一个接口用于告诉 Retrofit 怎样去获取数据，如下代码就表明使用 get 方法获取 users 路径下的 user 资源，使用的最终使用的时候，传入的 user 参数会替换 users/{user} 的 {user} 字段。\n\n不过我还真不知道它这里到底是怎么实现的，看来 java 基础还真要去补一补才行了。\n\n```java\n     public interface GitHubService {\n            @GET(\"users/{user}\")\n            Call<User> getUserInfoByCall(@Path(\"user\") String user);\n        }\n```\n\n之后就可以创建一个 GitHubService 实例了（我总觉得有点 java 黑魔法的感觉）：\n\n```java\n     GitHubService service = new Retrofit.Builder()\n                    .baseUrl(\"https://api.github.com\")\n                    .addConverterFactory(GsonConverterFactory.create())\n                    .build()\n                    .create(GitHubService.class);\n```\n\n然后调用 service 的 getUserInfoByCall 方法就能获取到一个 Call 对象了。像如下的代码，就能获取到一个用于访问 [https://api.github.com/users/bluesky466](https://api.github.com/users/bluesky466) 的 Call 对象：\n\n```java\n\tfinal Call<User> call = service.getUserInfoByCall(\"bluesky466\");\n```\n\n最后就能用 call 的 execute 方法访问服务器获取用户数据了。因为 execute 是同步的，而安卓不允许在 ui 线程访问网络，所以我们需要用一个子线程去访问。\n\n```java\n    new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        Response<User> response = call.execute();\n                        User user = response.body();\n                        Log.d(\"result\", user.toString());\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }).start();\n```\n\n结果如下：\n\n{% img /Retrofit-学习笔记/6.jpg %}\n\n当然，Retrofit 也提供了异步访问的方法：\n\n```java\n     call.enqueue(new Callback<User>() {\n                @Override\n                public void onResponse(Call<User> call, Response<User> response) {\n                    User user = response.body();\n                \tLog.d(\"result\", user.toString());\n                }\n\n                @Override\n                public void onFailure(Call<User> call, Throwable t) {\n\n                }\n            });\n```\n\nRetrofit 用获取到的数据生成了一个User对象。这是什么黑魔法？\n\n还记得我一开始说的按照官方文档的代码会报异常吗？\n\n官方文档的代码：\n\n```java\n    Retrofit retrofit = new Retrofit.Builder()\n        .baseUrl(\"https://api.github.com\")\n        .build();\n\n    GitHubService service = retrofit.create(GitHubService.class);\n```\n\n我的代码：\n\n```java\n    GitHubService service = new Retrofit.Builder()\n                        .baseUrl(\"https://api.github.com\")\n                        .addConverterFactory(GsonConverterFactory.create())\n                        .build()\n                        .create(GitHubService.class);\n```\n\n差别就在在这里：\n\n```\n\t.addConverterFactory(GsonConverterFactory.create())\n```\n\n我这里指定了一个 Gson 转换工厂，因为 [https://api.github.com](https://api.github.com) 使用josn 格式返回数据，所以我们可以使用 Gson 去解析它，然后生成一个 User 对象。\n\n不过就算你按我这样写代码又会发现找不到 GsonConverterFactory 的包......\n\n{% img /Retrofit-学习笔记/7.jpg %}\n\n原因在于 GsonConverterFactory 使用来转换json的，你也可以指定其他的 Factory 去转换 xml 之类的格式。而这些 Factory 并不包含在 Retrofit 库里面，需要用户自己去导入。\n\n{% img /Retrofit-学习笔记/8.jpg %}\n\n在 dependencies 中加入：\n\n```\n\tcompile 'com.squareup.retrofit2:converter-gson:2.0.0-beta4'\n```\n\n类似的库有下面这些：\n- __Gson__: com.squareup.retrofit2:converter-gson\n- __Jackson__: com.squareup.retrofit2:converter-jackson\n- __Moshi__: com.squareup.retrofit2:converter-moshi\n- __Protobuf__: com.squareup.retrofit2:converter-protobuf\n- __Wire__: com.squareup.retrofit2:converter-wire\n- __Simple__ XML: com.squareup.retrofit2:converter-simplexml\n- __Scalars__ (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars\n\n\n## __使用 Retrofit 配合 RxJava 获取 github 用户的信息__\n\nRxJava 在 GitHub 主页上的自我介绍是 \"a library for composing asynchronous and event-based programs using observable sequences for the Java VM\"（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。\n\n它可以用来替换 AsyncTask 之类的东西。\n\n关于 RxJava 有一篇很好的博客 -- [给 Android 开发者的 RxJava 详解](http://gank.io/post/560e15be2dca930e00da1083)。这里基本上把 RxJava 讲的很透彻了。我这里就不多说，只是讲一讲怎样在 Retrofit 中使用 RxJava。\n\n在 Retrofit 中使用 RxJava 首先需要导入 adapter-rxjava 库，而且因为是在安卓上使用，所以需要导入 RxJava 的 Android 平台的扩展 rxandroid 库：\n\n```\n\tcompile 'com.squareup.retrofit2:adapter-rxjava:2.0.0-beta4\n    compile 'io.reactivex:rxandroid:1.1.0'\n```\n\n添加 GitHubService 接口的 RxJava 获取方法：\n```java\n    public interface GitHubService {\n            @GET(\"users/{user}\")\n            Call<User> getUserInfoByCall(@Path(\"user\") String user);\n\n            @GET(\"users/{user}\")\n            Observable<User> getUserInfoByObservable(@Path(\"user\") String user);\n        }\n```\n\n然后创建 GitHubService 的时候需要指定 RxJava的适配工厂：\n\n```java\n     GitHubService service = new Retrofit.Builder()\n                    .baseUrl(\"https://api.github.com\")\n                    .addConverterFactory(GsonConverterFactory.create())//指定RxJava适配工厂\n                    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())\n                    .build()\n                    .create(GitHubService.class);\n```\n\n然后就是指定 subscribe 去输出结果了：\n\n```java\n    service.getUserInfoByObservable(\"bluesky466\")\n                    .subscribeOn(Schedulers.newThread())\n                    .observeOn(AndroidSchedulers.mainThread())\n                    .subscribe(new Subscriber<User>() {\n                        @Override\n                        public void onNext(User user) {\n                            if (user != null) {\n                                Log.d(\"result\", user.toString());\n                            }\n                        }\n\n                        @Override\n                        public void onCompleted() {\n                        }\n\n                        @Override\n                        public void onError(Throwable e) {\n                        }\n                    });\n```\n\n## __一个小 Demo__\n\n我写了一个 demo 用来展示 Retrofit 的用法，完整源码如下：\n\nMainActivity：\n\n```java\n    public class MainActivity extends AppCompatActivity {\n        private GitHubService mService;\n        private EditText mUserName;\n        private TextView mResult;\n\n        public interface GitHubService {\n            @GET(\"users/{user}\")\n            Call<User> getUserInfoByCall(@Path(\"user\") String user);\n\n            @GET(\"users/{user}\")\n            Observable<User> getUserInfoByObservable(@Path(\"user\") String user);\n        }\n\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.activity_main);\n\n            mUserName = (EditText) findViewById(R.id.username);\n            mResult = (TextView) findViewById(R.id.result);\n\n            Button btnCall = (Button) findViewById(R.id.btnCall);\n            btnCall.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    queryByCall(mUserName.getText().toString());\n                }\n            });\n\n            Button btnObservable = (Button) findViewById(R.id.btnObservable);\n            btnObservable.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    queryByObservable(mUserName.getText().toString());\n                }\n            });\n\n            mService = new Retrofit.Builder()\n                    .baseUrl(\"https://api.github.com\")\n                    .addConverterFactory(GsonConverterFactory.create())\n                    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())\n                    .build()\n                    .create(GitHubService.class);\n        }\n\n        private void queryByCall(final String username) {\n            mService.getUserInfoByCall(username).enqueue(new Callback<User>() {\n                @Override\n                public void onResponse(Call<User> call, Response<User> response) {\n                    if (response.body() != null) {\n                        mResult.setText(\"[ByCall] \" + response.body().toString());\n                    } else {\n                        mResult.setText(\"[ByCall] Not Found\");\n                    }\n                }\n\n                @Override\n                public void onFailure(Call<User> call, Throwable t) {\n                    mResult.setText(\"[ByCall] Not Found\");\n                }\n            });\n        }\n\n        private void queryByObservable(final String username) {\n            mService.getUserInfoByObservable(username)\n                    .subscribeOn(Schedulers.newThread())\n                    .observeOn(AndroidSchedulers.mainThread())\n                    .subscribe(new Subscriber<User>() {\n                        @Override\n                        public void onCompleted() {\n                        }\n\n                        @Override\n                        public void onError(Throwable e) {\n                            mResult.setText(\"[ByObservable] Not Found\");\n                        }\n\n                        @Override\n                        public void onNext(User user) {\n                            if (user != null) {\n                                mResult.setText(\"[ByObservable] \" + user.toString());\n                            }\n                        }\n                    });\n        }\n    }\n```\n\nactivity\\_main.xml:\n\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        xmlns:tools=\"http://schemas.android.com/tools\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <LinearLayout\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:orientation=\"horizontal\">\n\n            <EditText\n                android:id=\"@+id/username\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_weight=\"1\"\n                android:hint=\"user name\" />\n\n            <Button\n                android:id=\"@+id/btnCall\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"Call\" />\n\n            <Button\n                android:id=\"@+id/btnObservable\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"Observable\" />\n        </LinearLayout>\n\n        <TextView\n            android:id=\"@+id/result\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"\" />\n    </LinearLayout>\n```\n\nUser:\n\n```java\n    public class User {\n        private String login;\n        private long id;\n        private String name;\n\n        @Override\n        public String toString() {\n            return \"login:\" + login + \", \"\n                    + \"id:\" + id + \", \"\n                    + \"name:\" + name;\n        }\n\n        public String getLogin() {\n            return login;\n        }\n\n        public void setLogin(String login) {\n            this.login = login;\n        }\n\n        public long getId() {\n            return id;\n        }\n\n        public void setId(long id) {\n            this.id = id;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n    }\n\n```\n\ndependencies:\n\n```\n\tdependencies {\n        compile fileTree(dir: 'libs', include: ['*.jar'])\n        testCompile 'junit:junit:4.12'\n        compile 'com.android.support:appcompat-v7:23.1.1'\n        compile 'com.squareup.retrofit2:retrofit:2.0.0-beta4'\n        compile 'com.squareup.retrofit2:converter-gson:2.0.0-beta4'\n        compile 'com.squareup.retrofit2:adapter-rxjava:2.0.0-beta4'\n        compile 'io.reactivex:rxandroid:1.1.0'\n    }\n```\n","slug":"Retrofit-学习笔记","published":1,"updated":"2017-05-12T23:19:13.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2ro85dt001m4kr49oykycpb"},{"title":"Java自定义注解和动态代理","date":"2016-05-27T11:49:05.000Z","_content":"在学习Retrofit的时候就对它奇特的使用方式感到十分的好奇，为什么定义一个接口，使用\"@GET\",\"@Query\"这些奇怪的注解就能创建出能实际访问服务器的实例出来:\n\n```java\npublic interface GitHubService {\n    @GET(\"/users/{user}/repos\")\n    List<Repo> listRepos(@Path(\"user\") String user);\n}\n\nRestAdapter restAdapter = new RestAdapter.Builder()\n    .setEndpoint(\"https://api.github.com\")\n    .build();\nGitHubService service = restAdapter.create(GitHubService.class);\nList<Repo> repos = service.listRepos(\"octocat\");\n```\n\n尤其是对如何创建一个接口的实例感到万分的好奇，这几天回学校写毕设论文刚好有点空，于是就抽了点时间研究了一下。\n\n# 自定义Java注解\n\n说起Java的注解，大家都能很自然的想起\"@Override\",\"@Deprecated\",\"@Documented\"这些很常用的内置注解。但很多新手应该都不知道其实Java也是支持自定义注解的吧？(反正我以前是不知道的)\n\n## 元注解\n元注解的作用就是负责注解其他注解，Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解：\n\n- @Target\n- @Retention\n- @Documented\n- @Inherited\n\n### @Target\n\n@Target说明了自定义注解的修饰类型，也就是说可以用它来声明自定义注解可以用在什么地方，它的取值范围有：\n\n1. ElementType.CONSTRUCTOR : 用于描述构造器\n1. ElementType.FIELD : 用于描述域\n1. ElementType.LOCAL_VARIABLE : 用于描述局部变量\n1. ElementType.METHOD : 用于描述方法\n1. ElementType.PACKAGE : 用于描述包\n1. ElementType.PARAMETER : 用于描述参数\n1. ElementType.TYPE : 用于描述类、接口(包括注解类型) 或enum声明\n\n例如：\n\n```java\n@Target(ElementType.TYPE)\npublic @interface TypeAnnotation {\n}\n\n@Target(ElementType.METHOD)\npublic @interface MethodAnnotation {\n}\n\n@Target(ElementType.PARAMETER)\npublic @interface ParamAnnotation {\n}\n```\n\nTypeAnnotation可以用来修饰描述类、接口(包括注解类型) 或enum声明，MethodAnnotation可以用来修饰方法，ParamAnnotation可以用来修饰参数：\n\n```java\n@TypeAnnotation\npublic interface MyInterface {\n\t@MethodAnnotation\n\tpublic void func(@ParamAnnotation String param);\n}\n```\n\n## @Retention\n\n@Retention 定义了自定义注解的生命长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。\n\n它的取值有下面这些：\n\n1. RetentionPolicy.SOURCE : 在源文件中有效（即源文件保留）\n1. RetentionPolicy.CLASS : 在class文件中有效（即class保留）\n1. RetentionPolicy.RUNTIME : 时有效（即运行时保留）\n\n注解也是可以保存数据的，如value属性就是默认的数据保存属性:\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MethodAnnotation {\n\tString value() default \"default value\";\n}\n\npublic class ClassA{\n\t@MethodAnnotation()\n\tpublic void func1(){}\n    \n\t@MethodAnnotation(\"data\")\n\tpublic void func2(){}\n}\n\n```\n\n比如可以在程序运行的时候（因为声明了@Retention(RetentionPolicy.RUNTIME)）通过反射获取上面的ClassA.func1的注解MethodAnnotation保存的数据（默认值\"default value\"）和ClassA.func2的注解MethodAnnotation保存的数据（\"data\"）\n\n当然如果只能保持一个数据限制就太大了，你可以定义多个数据：\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MethodAnnotation {\n\tpublic enum EnumData{ DATA1, DATA2, DATA3};\n\t\n\tString data1();\n\tint data2() default 0xffff;\n\tEnumData data3() default EnumData.DATA1;\n}\n\npublic class ClassA{\n\t@MethodAnnotation(data1=\"data1\")\n\tpublic void func1(){}\n    \n\t@MethodAnnotation(data1=\"data1\", data2=0, data3=MethodAnnotation.EnumData.DATA1)\n\tpublic void func2(){}\n}\n```\n\n当属性没有用default指定默认值得时候在使用的时候必须由用户设置属性值（如这里的data1）\n\n注解参数的可支持数据类型：\n\n1.所有基本数据类型（int,float,boolean,byte,double,char,long,short)\n2.String类型\n3.Class类型\n4.enum类型\n5.Annotation类型\n6.以上所有类型的数组\n\n\n## @Inherited\n\n@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。\n\n# Java动态代理\n\n我知道可以用反射调用方法甚至创建对象，但我还真的没有想到怎样创建出一个接口的实例。用了各种形容方式之后终于找到了这种技术的专业名称:\"动态代理\"，下面是一个简单的例子：\n\n```java\npublic interface MyInterface{\n\tvoid func();\n}\n\npublic class MyHandler implements InvocationHandler{\n\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.print(\"call : \" + method.getName());\n\t\treturn null;\n\t}\n}\n\n\npublic static void main(String[] args){\n\t\tMyInterface myInterface = (MyInterface)Proxy.newProxyInstance(\n        \t\t MyInterface.class.getClassLoader(), \n\t\t\t     new Class[]{MyInterface.class}, \n\t\t\t     new MyHandler());\n\t\tmyInterface.func();\n}\n```\n\n这个例子的输出为：\n\n> call : func\n\n通过实现InvocationHandler接口，定义自己的handler类，再使用Proxy.newProxyInstance就可以实例化出一个接口的实例。当调用接口的方法的时候，InvocationHandler接口的invoke方法就会被调用，可以在这里编写实际的功能代码。\n\n当然也能将创建实例的代码抽象出来，实现复用：\n\n```java\nprivate static <T>T newProxyInstance(Class<T> c){\n\t\treturn (T)Proxy.newProxyInstance(\n\t\t\t\tc.getClassLoader(),\n\t\t\t\tnew Class<?>[]{c},\n\t\t\t\tnew DataBaseHalder(c));\n\t}\n    \npublic static void main(String[] args){\n    //使用方式\n    MyInterface myInterface = (MyInterface)newProxyInstance(MyInterface.class, new MyHandler());\n\tmyInterface.func();\n}\n```\n\n# 通过反射获取注解保存的数据\n- 通过Class.getAnnotation(XXXAnnotation.class)可以获取到方法的ElementType.METHOD或者类ElementType.TYPE类型的注解\n- 通过 Method.getParameterAnnotations()可以获取到方法各个参数的注解（ElementType.PARAMETER类型）\n\n这部分用代码来解释最直接了：\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface TypeAnnotation {\n\tString value();\n}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MethodAnnotation {\n\tString value();\n}\n\n@Target(ElementType.PARAMETER)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ParamAnnotation {\n\tString value();\n}\n\n@TypeAnnotation(\"interface MyInterface\")\npublic interface MyInterface{\n\t@MethodAnnotation(\"MyInterface.func\")\n\tvoid func(@ParamAnnotation(\"param1\") String a, @ParamAnnotation(\"param2\") int b);\n}\n\npublic class MyHandler implements InvocationHandler{\n\tprivate Class mClass;\n\t\n\tMyHandler(Class c){\n\t\tmClass = c;\n\t\tTypeAnnotation typeAnnotation = (TypeAnnotation) mClass.getAnnotation(TypeAnnotation.class);\n\t\tSystem.out.print(\"TypeAnnotation : \" + typeAnnotation.value() + \"\\n\");\n\t}\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\t\n\t\tMethodAnnotation methodAnnotation = (MethodAnnotation)method.getAnnotation(MethodAnnotation.class);\n\t\tSystem.out.print(\"MethodAnnotation : \" + methodAnnotation.value() + \"\\n\");\n\n\t\tClass[] parameterTypes = method.getParameterTypes();\n\t\tAnnotation[][] parameterAnnotations = method.getParameterAnnotations();\n\t\tfor(int i = 0; i< parameterAnnotations.length ; i++){\n\t\t\tClass type = parameterTypes[i];\n\t\t\tfor(Annotation annotation : parameterAnnotations[i]){\n\t\t\t\tif(annotation instanceof ParamAnnotation){\n\t\t\t\t\tParamAnnotation paramAnnotation = (ParamAnnotation) annotation;\n\t\t\t\t\tSystem.out.print(paramAnnotation.value() + \" - \" + args[i]  + \"[\" + type.getName() + \"]\"+ \"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n}\n\n//调用\npublic static void main(String[] args){\n\t\tMyInterface myInterface = (MyInterface)Proxy.newProxyInstance(\n\t\t\t\tMyInterface.class.getClassLoader(), \n\t\t\t\tnew Class<?>[]{MyInterface.class},\n\t\t\t\tnew MyHandler(MyInterface.class));\n\t\tmyInterface.func(\"data1\",123);\n}\n```\n\n输出如下：\n\n> TypeAnnotation : interface MyInterface\n> MethodAnnotation : MyInterface.func\n> param1 - data1[java.lang.String]\n> param2 - 123[int]\n\n这里最难理解的就是这两行代码：\n\n```java\nClass[] parameterTypes = method.getParameterTypes();\nAnnotation[][] parameterAnnotations = method.getParameterAnnotations();\n```\n\nmethod.getParameterTypes() 可以获取到参数的类型，而method.getParameterAnnotations()则获取到一个二维数组，它保存了所有变量的全部注解。\n\n# 一个简单的应用实例\n\n用过Retrofit的人都知道，这种动态代理技术在框架搭建完成之后，使用起来便十分的便利了，有兴趣的同学可以去看看Retrofit的相关资料。我这里再写一个模拟操作数据库的小例子，展示一下这种框架的便捷性。\n\n首先是接口的定义：\n\n```java\n@DataBase(database=\"SchoolSystem\", username=\"root\", password=\"123456\", ip=\"localhost\")\npublic interface IDataBaseOperation {\n\t@Table(\"Student\")\n\t@Column({\"name\",\"age\",\"sex\"})\n\tList<Map<String,String>> getStudentByName(@Condition(\"name\")String name);\n\t\n\t@Table(\"Student\")\n\t@Column({\"name\",\"age\",\"sex\"})\n\tList<Map<String,String>> getStudentOlder(@Condition(value=\"age\",compare=\">\")int age);\n\n\t@Table(\"Student\")\n\t@Column({\"name\",\"age\",\"sex\"})\n\tList<Map<String,String>> getStudentBySexAndAge(@Condition(\"sex\")String sex, @Condition(\"age\")int age);\n\t\n\t@Table(\"Teacher join Course on Teacher.id=Course.teacher\")\n\t@Column({\"Course.name\"})\n\tList<Map<String,String>> getCourseByTeacher(@Condition(\"Teacher.name\")String teacher);\n}\n```\n\n让我们先跳过实现细节，直接看它的用法：\n\n```java\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tIDataBaseOperation oprBaseOperation = newProxyInstance(IDataBaseOperation.class, new DataBaseHalder(IDataBaseOperation.class));\n\n\t\toprBaseOperation.getStudentByName(\"小红\");\n\t\toprBaseOperation.getStudentOlder(12);\n\t\toprBaseOperation.getStudentBySexAndAge(\"男\", 12);\n\t\toprBaseOperation.getCourseByTeacher(\"李老师\");\n\t}\n\t\n\tprivate static <T>T newProxyInstance(Class<T> c, InvocationHandler handler){\n\t\treturn (T)Proxy.newProxyInstance(\n\t\t\t\tc.getClassLoader(), \n\t\t\t\tnew Class<?>[]{c},\n\t\t\t\thandler);\n\t}\n}\n```\n\n这样我们就能看到这样的输出:\n\n> ===================================\n> \n> connect database : \n> ip : localhost\n> username : root\n> password : 123456\n> database : SchoolSystem\n>\n>===================================\n> select name,age,sex from Student where name = \"小红\";\n> select name,age,sex from Student where age > 12;\n> select name,age,sex from Student where sex = \"男\" and age = 12;\n> select Course.name from Teacher join Course on Teacher.id=Course.teacher where > > > Teacher.name = \"李老师\";\n\n这里没有真的去做数据库操作，只是用打印的方法模拟了一下，但如果真的要实现的话也是不难的。\n\n但从这几处使用代码来看，这个框架的是十分易用的，如果我们想要增加一个查询操作的话，只需要在IDataBaseOperation接口声明多一个方法，然后直接就能在得到实例后使用了。\n\n最后将一些细节代码也贴上来：\n\n```java\n//Column.java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Column {\n\tString[] value();\n}\n```\n\n```java\n//Condition.java\n@Target(ElementType.PARAMETER)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Condition {\n\tpublic String value();\n\tpublic String compare() default \"=\";\n}\n```\n\n```java\n//Table.java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Table {\n\tString value();\n}\n```\n\n```java\n//DataBase.java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface DataBase {\n\tString ip();\n\tString database();\n\tString username();\n\tString password();\n}\n```\n\n```java\n//DataBaseHalder.java\npublic class DataBaseHalder implements InvocationHandler{\n\tprivate Class mInterface;\n\t\n\tpublic DataBaseHalder(Class object){\n\t\tmInterface = object;\n\t\t\n\t\tDataBase db = (DataBase) mInterface.getAnnotation(DataBase.class);\n\n\t\tSystem.out.print(\"===================================\\n\");\n\t\tSystem.out.print(\"connect database : \\n\");\n\t\tSystem.out.print(\"ip : \" + db.ip() + \"\\n\");\n\t\tSystem.out.print(\"username : \" + db.username() + \"\\n\");\n\t\tSystem.out.print(\"password : \" + db.password() + \"\\n\");\n\t\tSystem.out.print(\"database : \" + db.database() + \"\\n\");\n\t\tSystem.out.print(\"===================================\\n\");\n\t\t\n\t}\n\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\t\n\t\tif(method.getName().matches(\"^get.*\")){\n\t\t\tString sql =  \"select \" + getColumns(method) + \" from \" + getTable(method) \n\t\t\t\t\t+ \" where \" + getCondition(method, args) + \";\";\n\t\t\tSystem.out.print(sql + \"\\n\");\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tprivate String getTable(Method method){\n\t\treturn method.getAnnotation(Table.class).value();\n\t}\n\t\n\tprivate String getColumns(Method method){\n\t\tString result = \"\";\n\t\tString conn = \"\";\n\t\tfor (String col : method.getAnnotation(Column.class).value()) {\n\t\t\tresult += conn + col;\n\t\t\tconn = \",\";\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate String getCondition(Method method, Object[] args) {\n\t\tString result = \"\";\n\t\tString andConnect = \"\";\n\t\tClass[] parameterTypes = method.getParameterTypes();\n\n\t\tAnnotation[][] parameterAnnotations = method.getParameterAnnotations();\n\t\tfor(int i = 0; i< parameterAnnotations.length ; i++){\n\t\t\tClass type = parameterTypes[i];\n\t\t\tfor(Annotation annotation : parameterAnnotations[i]){\n\t\t\t\tif(annotation instanceof Condition){\n\t\t\t\t\tresult += andConnect + parseCondition(type, args[i], (Condition) annotation);\n\t\t\t\t\tandConnect = \" and \";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate String parseCondition(Class argType, Object arg, Annotation annotation){\n\t\tCondition condition = (Condition) annotation;\n\t\tString result = condition.value() + \" \" + condition.compare() + \" \";\n\t\tif(argType == String.class){\n\t\t\tresult += \"\\\"\" + arg + \"\\\"\";\n\t\t}else{\n\t\t\tresult += arg;\n\t\t}\n\t\treturn result;\n\t}\n}\n```\n\n# 另外的一个实用的小例子\n\n相信做安卓的同学都遇到过在Activity.onCreate初始化的时候写一大堆的findViewById吧？这种重复性的无趣工作其实也可以用注解来简化：\n\n```java\npublic @interface ViewField {\n    int value();\n\n    public static class Processor{\n        public static void process(Activity activity) throws IllegalAccessException {\n            Field[] fields = activity.getClass().getDeclaredFields();\n            ViewField ann = null;\n            for (Field field : fields) {\n                ann = field.getAnnotation(ViewField.class);\n                if (ann!=null){\n                    field.setAccessible(true);\n                    field.set(activity, activity.findViewById(ann.value()));\n                }\n            }\n        }\n    }\n}\n```\n\n然后我们的Activity就可以这样写来让注解自动初始化View变量了：\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    @ViewField(R.id.text)\n    private TextView mTextView;\n\n    @ViewField(R.id.button)\n    private Button mButton;\n\n    @ViewField(R.id.image)\n    private ImageView mImageView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        try {\n            ViewField.Processor.process(this);\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n\n        mTextView.setText(\"text\");\n        mButton.setText(\"button\");\n        mImageView.setImageResource(R.mipmap.ic_launcher);\n    }\n}\n```\n\n当然有人说用注解，效率会很低。但我觉得这里的额外消耗其实根本不起眼，用这点小损耗换来编码的便利性是很值得的。但如果真的很在意，也能用下面的泛型方法简化findViewById操作：\n\n```java\nprotected <T extends View> T generateFindViewById(int id) {\n\t//return返回view时,加上泛型T\n\treturn (T) findViewById(id);\n}\nmButton = generateFindViewById(R.id.button);\n```\n\n这样能减少强制转换的操作，但编写效率还是不如用注解。\n","source":"_posts/Java自定义注解和动态代理.md","raw":"title: Java自定义注解和动态代理\ndate: 2016-05-27 19:49:05\ntags:\n\t- 技术相关\n\t- java\n---\n在学习Retrofit的时候就对它奇特的使用方式感到十分的好奇，为什么定义一个接口，使用\"@GET\",\"@Query\"这些奇怪的注解就能创建出能实际访问服务器的实例出来:\n\n```java\npublic interface GitHubService {\n    @GET(\"/users/{user}/repos\")\n    List<Repo> listRepos(@Path(\"user\") String user);\n}\n\nRestAdapter restAdapter = new RestAdapter.Builder()\n    .setEndpoint(\"https://api.github.com\")\n    .build();\nGitHubService service = restAdapter.create(GitHubService.class);\nList<Repo> repos = service.listRepos(\"octocat\");\n```\n\n尤其是对如何创建一个接口的实例感到万分的好奇，这几天回学校写毕设论文刚好有点空，于是就抽了点时间研究了一下。\n\n# 自定义Java注解\n\n说起Java的注解，大家都能很自然的想起\"@Override\",\"@Deprecated\",\"@Documented\"这些很常用的内置注解。但很多新手应该都不知道其实Java也是支持自定义注解的吧？(反正我以前是不知道的)\n\n## 元注解\n元注解的作用就是负责注解其他注解，Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解：\n\n- @Target\n- @Retention\n- @Documented\n- @Inherited\n\n### @Target\n\n@Target说明了自定义注解的修饰类型，也就是说可以用它来声明自定义注解可以用在什么地方，它的取值范围有：\n\n1. ElementType.CONSTRUCTOR : 用于描述构造器\n1. ElementType.FIELD : 用于描述域\n1. ElementType.LOCAL_VARIABLE : 用于描述局部变量\n1. ElementType.METHOD : 用于描述方法\n1. ElementType.PACKAGE : 用于描述包\n1. ElementType.PARAMETER : 用于描述参数\n1. ElementType.TYPE : 用于描述类、接口(包括注解类型) 或enum声明\n\n例如：\n\n```java\n@Target(ElementType.TYPE)\npublic @interface TypeAnnotation {\n}\n\n@Target(ElementType.METHOD)\npublic @interface MethodAnnotation {\n}\n\n@Target(ElementType.PARAMETER)\npublic @interface ParamAnnotation {\n}\n```\n\nTypeAnnotation可以用来修饰描述类、接口(包括注解类型) 或enum声明，MethodAnnotation可以用来修饰方法，ParamAnnotation可以用来修饰参数：\n\n```java\n@TypeAnnotation\npublic interface MyInterface {\n\t@MethodAnnotation\n\tpublic void func(@ParamAnnotation String param);\n}\n```\n\n## @Retention\n\n@Retention 定义了自定义注解的生命长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。\n\n它的取值有下面这些：\n\n1. RetentionPolicy.SOURCE : 在源文件中有效（即源文件保留）\n1. RetentionPolicy.CLASS : 在class文件中有效（即class保留）\n1. RetentionPolicy.RUNTIME : 时有效（即运行时保留）\n\n注解也是可以保存数据的，如value属性就是默认的数据保存属性:\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MethodAnnotation {\n\tString value() default \"default value\";\n}\n\npublic class ClassA{\n\t@MethodAnnotation()\n\tpublic void func1(){}\n    \n\t@MethodAnnotation(\"data\")\n\tpublic void func2(){}\n}\n\n```\n\n比如可以在程序运行的时候（因为声明了@Retention(RetentionPolicy.RUNTIME)）通过反射获取上面的ClassA.func1的注解MethodAnnotation保存的数据（默认值\"default value\"）和ClassA.func2的注解MethodAnnotation保存的数据（\"data\"）\n\n当然如果只能保持一个数据限制就太大了，你可以定义多个数据：\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MethodAnnotation {\n\tpublic enum EnumData{ DATA1, DATA2, DATA3};\n\t\n\tString data1();\n\tint data2() default 0xffff;\n\tEnumData data3() default EnumData.DATA1;\n}\n\npublic class ClassA{\n\t@MethodAnnotation(data1=\"data1\")\n\tpublic void func1(){}\n    \n\t@MethodAnnotation(data1=\"data1\", data2=0, data3=MethodAnnotation.EnumData.DATA1)\n\tpublic void func2(){}\n}\n```\n\n当属性没有用default指定默认值得时候在使用的时候必须由用户设置属性值（如这里的data1）\n\n注解参数的可支持数据类型：\n\n1.所有基本数据类型（int,float,boolean,byte,double,char,long,short)\n2.String类型\n3.Class类型\n4.enum类型\n5.Annotation类型\n6.以上所有类型的数组\n\n\n## @Inherited\n\n@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。\n\n# Java动态代理\n\n我知道可以用反射调用方法甚至创建对象，但我还真的没有想到怎样创建出一个接口的实例。用了各种形容方式之后终于找到了这种技术的专业名称:\"动态代理\"，下面是一个简单的例子：\n\n```java\npublic interface MyInterface{\n\tvoid func();\n}\n\npublic class MyHandler implements InvocationHandler{\n\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.print(\"call : \" + method.getName());\n\t\treturn null;\n\t}\n}\n\n\npublic static void main(String[] args){\n\t\tMyInterface myInterface = (MyInterface)Proxy.newProxyInstance(\n        \t\t MyInterface.class.getClassLoader(), \n\t\t\t     new Class[]{MyInterface.class}, \n\t\t\t     new MyHandler());\n\t\tmyInterface.func();\n}\n```\n\n这个例子的输出为：\n\n> call : func\n\n通过实现InvocationHandler接口，定义自己的handler类，再使用Proxy.newProxyInstance就可以实例化出一个接口的实例。当调用接口的方法的时候，InvocationHandler接口的invoke方法就会被调用，可以在这里编写实际的功能代码。\n\n当然也能将创建实例的代码抽象出来，实现复用：\n\n```java\nprivate static <T>T newProxyInstance(Class<T> c){\n\t\treturn (T)Proxy.newProxyInstance(\n\t\t\t\tc.getClassLoader(),\n\t\t\t\tnew Class<?>[]{c},\n\t\t\t\tnew DataBaseHalder(c));\n\t}\n    \npublic static void main(String[] args){\n    //使用方式\n    MyInterface myInterface = (MyInterface)newProxyInstance(MyInterface.class, new MyHandler());\n\tmyInterface.func();\n}\n```\n\n# 通过反射获取注解保存的数据\n- 通过Class.getAnnotation(XXXAnnotation.class)可以获取到方法的ElementType.METHOD或者类ElementType.TYPE类型的注解\n- 通过 Method.getParameterAnnotations()可以获取到方法各个参数的注解（ElementType.PARAMETER类型）\n\n这部分用代码来解释最直接了：\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface TypeAnnotation {\n\tString value();\n}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MethodAnnotation {\n\tString value();\n}\n\n@Target(ElementType.PARAMETER)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ParamAnnotation {\n\tString value();\n}\n\n@TypeAnnotation(\"interface MyInterface\")\npublic interface MyInterface{\n\t@MethodAnnotation(\"MyInterface.func\")\n\tvoid func(@ParamAnnotation(\"param1\") String a, @ParamAnnotation(\"param2\") int b);\n}\n\npublic class MyHandler implements InvocationHandler{\n\tprivate Class mClass;\n\t\n\tMyHandler(Class c){\n\t\tmClass = c;\n\t\tTypeAnnotation typeAnnotation = (TypeAnnotation) mClass.getAnnotation(TypeAnnotation.class);\n\t\tSystem.out.print(\"TypeAnnotation : \" + typeAnnotation.value() + \"\\n\");\n\t}\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\t\n\t\tMethodAnnotation methodAnnotation = (MethodAnnotation)method.getAnnotation(MethodAnnotation.class);\n\t\tSystem.out.print(\"MethodAnnotation : \" + methodAnnotation.value() + \"\\n\");\n\n\t\tClass[] parameterTypes = method.getParameterTypes();\n\t\tAnnotation[][] parameterAnnotations = method.getParameterAnnotations();\n\t\tfor(int i = 0; i< parameterAnnotations.length ; i++){\n\t\t\tClass type = parameterTypes[i];\n\t\t\tfor(Annotation annotation : parameterAnnotations[i]){\n\t\t\t\tif(annotation instanceof ParamAnnotation){\n\t\t\t\t\tParamAnnotation paramAnnotation = (ParamAnnotation) annotation;\n\t\t\t\t\tSystem.out.print(paramAnnotation.value() + \" - \" + args[i]  + \"[\" + type.getName() + \"]\"+ \"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n}\n\n//调用\npublic static void main(String[] args){\n\t\tMyInterface myInterface = (MyInterface)Proxy.newProxyInstance(\n\t\t\t\tMyInterface.class.getClassLoader(), \n\t\t\t\tnew Class<?>[]{MyInterface.class},\n\t\t\t\tnew MyHandler(MyInterface.class));\n\t\tmyInterface.func(\"data1\",123);\n}\n```\n\n输出如下：\n\n> TypeAnnotation : interface MyInterface\n> MethodAnnotation : MyInterface.func\n> param1 - data1[java.lang.String]\n> param2 - 123[int]\n\n这里最难理解的就是这两行代码：\n\n```java\nClass[] parameterTypes = method.getParameterTypes();\nAnnotation[][] parameterAnnotations = method.getParameterAnnotations();\n```\n\nmethod.getParameterTypes() 可以获取到参数的类型，而method.getParameterAnnotations()则获取到一个二维数组，它保存了所有变量的全部注解。\n\n# 一个简单的应用实例\n\n用过Retrofit的人都知道，这种动态代理技术在框架搭建完成之后，使用起来便十分的便利了，有兴趣的同学可以去看看Retrofit的相关资料。我这里再写一个模拟操作数据库的小例子，展示一下这种框架的便捷性。\n\n首先是接口的定义：\n\n```java\n@DataBase(database=\"SchoolSystem\", username=\"root\", password=\"123456\", ip=\"localhost\")\npublic interface IDataBaseOperation {\n\t@Table(\"Student\")\n\t@Column({\"name\",\"age\",\"sex\"})\n\tList<Map<String,String>> getStudentByName(@Condition(\"name\")String name);\n\t\n\t@Table(\"Student\")\n\t@Column({\"name\",\"age\",\"sex\"})\n\tList<Map<String,String>> getStudentOlder(@Condition(value=\"age\",compare=\">\")int age);\n\n\t@Table(\"Student\")\n\t@Column({\"name\",\"age\",\"sex\"})\n\tList<Map<String,String>> getStudentBySexAndAge(@Condition(\"sex\")String sex, @Condition(\"age\")int age);\n\t\n\t@Table(\"Teacher join Course on Teacher.id=Course.teacher\")\n\t@Column({\"Course.name\"})\n\tList<Map<String,String>> getCourseByTeacher(@Condition(\"Teacher.name\")String teacher);\n}\n```\n\n让我们先跳过实现细节，直接看它的用法：\n\n```java\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tIDataBaseOperation oprBaseOperation = newProxyInstance(IDataBaseOperation.class, new DataBaseHalder(IDataBaseOperation.class));\n\n\t\toprBaseOperation.getStudentByName(\"小红\");\n\t\toprBaseOperation.getStudentOlder(12);\n\t\toprBaseOperation.getStudentBySexAndAge(\"男\", 12);\n\t\toprBaseOperation.getCourseByTeacher(\"李老师\");\n\t}\n\t\n\tprivate static <T>T newProxyInstance(Class<T> c, InvocationHandler handler){\n\t\treturn (T)Proxy.newProxyInstance(\n\t\t\t\tc.getClassLoader(), \n\t\t\t\tnew Class<?>[]{c},\n\t\t\t\thandler);\n\t}\n}\n```\n\n这样我们就能看到这样的输出:\n\n> ===================================\n> \n> connect database : \n> ip : localhost\n> username : root\n> password : 123456\n> database : SchoolSystem\n>\n>===================================\n> select name,age,sex from Student where name = \"小红\";\n> select name,age,sex from Student where age > 12;\n> select name,age,sex from Student where sex = \"男\" and age = 12;\n> select Course.name from Teacher join Course on Teacher.id=Course.teacher where > > > Teacher.name = \"李老师\";\n\n这里没有真的去做数据库操作，只是用打印的方法模拟了一下，但如果真的要实现的话也是不难的。\n\n但从这几处使用代码来看，这个框架的是十分易用的，如果我们想要增加一个查询操作的话，只需要在IDataBaseOperation接口声明多一个方法，然后直接就能在得到实例后使用了。\n\n最后将一些细节代码也贴上来：\n\n```java\n//Column.java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Column {\n\tString[] value();\n}\n```\n\n```java\n//Condition.java\n@Target(ElementType.PARAMETER)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Condition {\n\tpublic String value();\n\tpublic String compare() default \"=\";\n}\n```\n\n```java\n//Table.java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Table {\n\tString value();\n}\n```\n\n```java\n//DataBase.java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface DataBase {\n\tString ip();\n\tString database();\n\tString username();\n\tString password();\n}\n```\n\n```java\n//DataBaseHalder.java\npublic class DataBaseHalder implements InvocationHandler{\n\tprivate Class mInterface;\n\t\n\tpublic DataBaseHalder(Class object){\n\t\tmInterface = object;\n\t\t\n\t\tDataBase db = (DataBase) mInterface.getAnnotation(DataBase.class);\n\n\t\tSystem.out.print(\"===================================\\n\");\n\t\tSystem.out.print(\"connect database : \\n\");\n\t\tSystem.out.print(\"ip : \" + db.ip() + \"\\n\");\n\t\tSystem.out.print(\"username : \" + db.username() + \"\\n\");\n\t\tSystem.out.print(\"password : \" + db.password() + \"\\n\");\n\t\tSystem.out.print(\"database : \" + db.database() + \"\\n\");\n\t\tSystem.out.print(\"===================================\\n\");\n\t\t\n\t}\n\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\t\n\t\tif(method.getName().matches(\"^get.*\")){\n\t\t\tString sql =  \"select \" + getColumns(method) + \" from \" + getTable(method) \n\t\t\t\t\t+ \" where \" + getCondition(method, args) + \";\";\n\t\t\tSystem.out.print(sql + \"\\n\");\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tprivate String getTable(Method method){\n\t\treturn method.getAnnotation(Table.class).value();\n\t}\n\t\n\tprivate String getColumns(Method method){\n\t\tString result = \"\";\n\t\tString conn = \"\";\n\t\tfor (String col : method.getAnnotation(Column.class).value()) {\n\t\t\tresult += conn + col;\n\t\t\tconn = \",\";\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate String getCondition(Method method, Object[] args) {\n\t\tString result = \"\";\n\t\tString andConnect = \"\";\n\t\tClass[] parameterTypes = method.getParameterTypes();\n\n\t\tAnnotation[][] parameterAnnotations = method.getParameterAnnotations();\n\t\tfor(int i = 0; i< parameterAnnotations.length ; i++){\n\t\t\tClass type = parameterTypes[i];\n\t\t\tfor(Annotation annotation : parameterAnnotations[i]){\n\t\t\t\tif(annotation instanceof Condition){\n\t\t\t\t\tresult += andConnect + parseCondition(type, args[i], (Condition) annotation);\n\t\t\t\t\tandConnect = \" and \";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate String parseCondition(Class argType, Object arg, Annotation annotation){\n\t\tCondition condition = (Condition) annotation;\n\t\tString result = condition.value() + \" \" + condition.compare() + \" \";\n\t\tif(argType == String.class){\n\t\t\tresult += \"\\\"\" + arg + \"\\\"\";\n\t\t}else{\n\t\t\tresult += arg;\n\t\t}\n\t\treturn result;\n\t}\n}\n```\n\n# 另外的一个实用的小例子\n\n相信做安卓的同学都遇到过在Activity.onCreate初始化的时候写一大堆的findViewById吧？这种重复性的无趣工作其实也可以用注解来简化：\n\n```java\npublic @interface ViewField {\n    int value();\n\n    public static class Processor{\n        public static void process(Activity activity) throws IllegalAccessException {\n            Field[] fields = activity.getClass().getDeclaredFields();\n            ViewField ann = null;\n            for (Field field : fields) {\n                ann = field.getAnnotation(ViewField.class);\n                if (ann!=null){\n                    field.setAccessible(true);\n                    field.set(activity, activity.findViewById(ann.value()));\n                }\n            }\n        }\n    }\n}\n```\n\n然后我们的Activity就可以这样写来让注解自动初始化View变量了：\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    @ViewField(R.id.text)\n    private TextView mTextView;\n\n    @ViewField(R.id.button)\n    private Button mButton;\n\n    @ViewField(R.id.image)\n    private ImageView mImageView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        try {\n            ViewField.Processor.process(this);\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n\n        mTextView.setText(\"text\");\n        mButton.setText(\"button\");\n        mImageView.setImageResource(R.mipmap.ic_launcher);\n    }\n}\n```\n\n当然有人说用注解，效率会很低。但我觉得这里的额外消耗其实根本不起眼，用这点小损耗换来编码的便利性是很值得的。但如果真的很在意，也能用下面的泛型方法简化findViewById操作：\n\n```java\nprotected <T extends View> T generateFindViewById(int id) {\n\t//return返回view时,加上泛型T\n\treturn (T) findViewById(id);\n}\nmButton = generateFindViewById(R.id.button);\n```\n\n这样能减少强制转换的操作，但编写效率还是不如用注解。\n","slug":"Java自定义注解和动态代理","published":1,"updated":"2017-05-12T23:19:13.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2ro85dx001p4kr46nnl3tr3"},{"title":"GTest源码剖析 - 测试代码的注册","date":"2016-02-15T14:07:08.000Z","_content":"单元测试框架，最基本的功能当然就是运行用户所编写的测试用例了。\n\n## __毫无技巧的方法__\n\n一种毫无技巧的方法就是用户手动在 main 函数里面将自己编写的测试代码注册到框架中，就像下面的代码：\n```cpp\n    void test1() {...}\n    void test2() {...}\n    void test3() {...}\n    ...\n\n    int main(){\n        RegisterTestFunc(test1);\n        RegisterTestFunc(test2);\n        RegisterTestFunc(test3);\n        ...\n        return 0;\n    }\n```\n\n这样的代码虽然可以运行，但是将初始化的责任放到的用户那里，这样的代码是不够优秀的。有两种容易出现的情况：一是项目中可能拥有大量的测试代码，用户很有可能会漏掉其中的部分测试代码，忘记把它们注册到测试框架中。二是可能用户去掉了一些测试代码，却又忘了去掉注册的代码。\n\n后者编译器会报错，但前者却没有办法检测（除非对着测试结果一条条的检测，看是否所有测试代码都运行了）。\n\n## __一种有问题的方法__\n\n最好在编写测试代码的时候就能通过一种机制帮用户注册，而不用用户手动去注册。面对这个需求，我脑海里面想到的第一个方法就是利用全局变量和宏定义。\n\n首先定义一个用来管理注册的测试方法的类：\n```cpp\n\ttypedef list<function<void()>> FuncList;\n    class Test{\n    public:\n        Test(const function<void()>& test_func){\n            test_funcs_.push_back(test_func);\n        }\n\n        static void runAllTest(){\n            for (auto func : test_funcs_){\n                func();\n            }\n        }\n\n    private:\n        static FuncList test_funcs_;\n    };\n```\n\n它有一个静态的成员变量 test\\_funcs\\_ ，用来保存测试方法，同时它有一个构造函数用来将传入的测试方法插入 test\\_funcs\\_ 中\n\n接着定义一个宏：\n```cpp\n    #define TEST_FUNC(NAME) \\\n        void NAME(); \\\n        static Test register_##NAME(NAME); \\\n        void NAME()\n```\n它在帮助我们在定义一个测试方法的时候自动注册到 test\\_funcs\\_ 中。原理其实很简单，就是在声明一个函数的同时声明一个 Test 全局变量，将定义的测试方法传入，这个测试函数就会在 Test 的构造函数中被插入 test\\_funcs\\_ 。\n\n所以我们只要这样编写测试代码，就能实现自动注册了：\n```cpp\n\tTEST_FUNC(testSomething){\n        ...\n    }\n```\n\n看起来这个方法不错是吧？可惜这种方法是有问题的！至少在我的 vs2013 上会崩溃！\n\n问题就出在 Test 全局变量和 Test::test\\_funcs\\_ 的初始化顺序上。你无法保证 Test::test\\_funcs\\_ 比全局变量 Test 先初始化。很奇怪是吧？ Test 的静态成员变量居然比 Test 全局变量的初始化时间晚，也就是说在 Test 这个类还没有完全准备好的时候，就已经拿来创建一个全局变量了。书上一直强调的全局变量的初始化顺序不能确定难道也有这种含义？\n\n## __一种可能可行的方法__\n\n既然是因为初始化顺序导致了内存错误，那我们只要使用某种机制让保存测试函数的容器首先初始化就行了。\n\n让我们将 Test 类的定义修改成下面的样子：\n\n```cpp\n    class Test{\n    public:\n        virtual void run() = 0;\n\n        static void runAllTest(){\n            for (auto i : test_list){\n                i->run();\n            }\n        }\n\n    protected:\n        static void addTest(Test* test){\n            test_list.push_back(test);\n        }\n\n    private:\n        static list<Test*> test_list;\n    };\n```\n\n容器里面不再直接放测试函数，改为放 Test 的指针。而 Test 又是一个抽象类，所以事实上放的是 Test 的子类。\n\n再把 TEST_FUNC 宏的定义改成下面的样子：\n\n```cpp\n    #define TEST_FUNC(NAME) \\\n        class NAME : public Test{ \\\n        public: \\\n            virtual void run(); \\\n        private: \\\n            NAME(){ \\\n                addTest(this); \\\n            } \\\n            static NAME* instance_; \\\n        }; \\\n        NAME* NAME::instance_ = new NAME(); \\\n        void NAME::run()\n\n```\n\n现在实际上用户写的测试方法实现的是 Test 的子类的 run 方法。\n\n依然是需要在定义测试方法的时候顺便定义一个全局变量，但我们换了一种方式，定义了一个类静态变量。子类在构造函数中把自己注册到 Test 的测试容器中，而且子类还包含了一个本类指针静态成员变量（有点拗口，但看代码很容易看出来）。在子类的静态成员变量初始化的之前，父类的静态成员变量应该就已经初始化了。就是根据这种机制，达到了我们的目的。\n\n使用方法还是一样：\n\n```cpp\n    TEST_FUNC(testSomething){\n        ...\n    }\n```\n\n为什么说这是“一种可能可行的方法”呢？因为父类的静态成员变量初始化先于子类的静态成员变量初始化这个前提是我自己推论的。可能是我读的书少或者读书不仔细，至今没有在哪里见到有提及父类和子类的静态成员变量的初始化顺序的。所以虽然在我的编译器上它的确能正常的工作，但为了严谨起见，姑且称为“可能”的吧。如果有人有在哪里看到这方面的描述，请务必私信我，让我把“可能”二字去掉或者将标题改成“另一种有问题的方法”\n\n## __GTest 的做法__\n\n讲了这么久我的想法，现状让我们来看看谷歌的大神们是怎么做的吧。\n\n我们从 TEST 宏看起：\n\n```cpp\n    #if !GTEST_DONT_DEFINE_TEST\n    # define TEST(test_case_name, test_name) GTEST_TEST(test_case_name, test_name)\n    #endif\n```\n\n这里这么搞，主要是为了防止 TEST 被系统或者其他框架定义了。如果出现这种情况，只要把GTEST\\_DONT\\_DEFINE\\_TEST 定义为 1，之后编写测试用例的时候直接使用 GTEST\\_TEST 就好了。不得不说，他们考虑的真仔细。让我们继续跟踪，看 GTEST\\_TEST：\n\n```cpp\n    #define GTEST_TEST(test_case_name, test_name)\\\n      GTEST_TEST_(test_case_name, test_name, \\\n                  ::testing::Test, ::testing::internal::GetTestTypeId())\n```\n\nGTEST\\_TEST 宏又用到了另一个宏 GTEST\\_TEST\\_，但我想先说一下 GetTestTypeId，这个东西的用法真的令我眼前一亮，不得不佩服：\n\n```cpp\n    TypeId GetTestTypeId() {\n      return GetTypeId<Test>();\n    }\n\n\t...\n\n\ttemplate <typename T>\n    TypeId GetTypeId() {\n      // The compiler is required to allocate a different\n      // TypeIdHelper<T>::dummy_ variable for each T used to instantiate\n      // the template.  Therefore, the address of dummy_ is guaranteed to\n      // be unique.\n      return &(TypeIdHelper<T>::dummy_);\n    }\n\n\t...\n\n    template <typename T>\n    class TypeIdHelper {\n     public:\n      // dummy_ must not have a const type.  Otherwise an overly eager\n      // compiler (e.g. MSVC 7.1 & 8.0) may try to merge\n      // TypeIdHelper<T>::dummy_ for different Ts as an \"optimization\".\n      static bool dummy_;\n    };\n```\n\n这里直接用一个类的静态成员变量的地址当作 id 号。当时我就懵逼了，明明很简单，怎么就感觉那么玄幻呢？\n\n膜拜完我们再继续看 GTEST\\_TEST\\_：\n```cpp\n    #define GTEST_TEST_(test_case_name, test_name, parent_class, parent_id)\\\n    class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class {\\\n     public:\\\n      GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}\\\n     private:\\\n      virtual void TestBody();\\\n      static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;\\\n      GTEST_DISALLOW_COPY_AND_ASSIGN_(\\\n          GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\\\n    };\\\n    \\\n    ::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)\\\n      ::test_info_ =\\\n        ::testing::internal::MakeAndRegisterTestInfo(\\\n            #test_case_name, #test_name, NULL, NULL, \\\n            (parent_id), \\\n            parent_class::SetUpTestCase, \\\n            parent_class::TearDownTestCase, \\\n            new ::testing::internal::TestFactoryImpl<\\\n                GTEST_TEST_CLASS_NAME_(test_case_name, test_name)>);\\\n    void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()\n```\n\n这个宏的做法和我的最后一个方法的 TEST\\_FUNC 宏差不多，用户写的测试函数实际上是实现了 ::testing::Test 的子类的 TestBody 方法。也是初始化了子类的一个静态成员变量，但GTest这里没有我那么暴力，它初始化的是一个 TestInfo 类型的的静态成员变量，这里面包含了测试的很多信息。其中最重要的是 ::testing::internal::TestFactoryImpl 这个东西：\n\n```cpp\n    template <class TestClass>\n    class TestFactoryImpl : public TestFactoryBase {\n     public:\n      virtual Test* CreateTest() { return new TestClass; }\n    };\n\n    ...\n\n\tclass TestFactoryBase {\n     public:\n      virtual ~TestFactoryBase() {}\n\n      // Creates a test instance to run. The instance is both created and destroyed\n      // within TestInfoImpl::Run()\n      virtual Test* CreateTest() = 0;\n\n     protected:\n      TestFactoryBase() {}\n\n     private:\n      GTEST_DISALLOW_COPY_AND_ASSIGN_(TestFactoryBase);\n    };\n```\n\n它是一个工厂类，用来创建传入的测试类的实例，也就是 GTEST\\_TEST\\_CLASS\\_NAME\\_(test\\_case\\_name, test\\_name)> 这个类，它的 TestBody 就是用户所写的测试代码。可以看看 GTEST\\_TEST\\_CLASS\\_NAME\\_ 的定义：\n\n```cpp\n    #define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n      test_case_name##_##test_name##_Test\n```\n\nok,很简单是吧？就是字符串拼接而已。\n\n好了，让我们继续深入，看看 MakeAndRegisterTestInfo ：\n```cpp\n\t//gtest.cc\n    TestInfo* MakeAndRegisterTestInfo(\n        const char* test_case_name,\n        const char* name,\n        const char* type_param,\n        const char* value_param,\n        TypeId fixture_class_id,\n        SetUpTestCaseFunc set_up_tc,\n        TearDownTestCaseFunc tear_down_tc,\n        TestFactoryBase* factory) {\n      TestInfo* const test_info =\n          new TestInfo(test_case_name, name, type_param, value_param,\n                       fixture_class_id, factory);\n      GetUnitTestImpl()->AddTestInfo(set_up_tc, tear_down_tc, test_info);\n      return test_info;\n    }\n\n\t//gtest-internal-inl.h\n\tinline UnitTestImpl* GetUnitTestImpl() {\n      return UnitTest::GetInstance()->impl();\n    }\n\n    //gtest.h\n    class GTEST_API_ UnitTest {\n     public:\n      static UnitTest* GetInstance();\n      ...\n      internal::UnitTestImpl* impl() { return impl_; }\n      ...\n      internal::UnitTestImpl* impl_;\n      ...\n    };\n\n    //gtest.cc\n    UnitTest* UnitTest::GetInstance() {\n      // When compiled with MSVC 7.1 in optimized mode, destroying the\n      // UnitTest object upon exiting the program messes up the exit code,\n      // causing successful tests to appear failed.  We have to use a\n      // different implementation in this case to bypass the compiler bug.\n      // This implementation makes the compiler happy, at the cost of\n      // leaking the UnitTest object.\n\n      // CodeGear C++Builder insists on a public destructor for the\n      // default implementation.  Use this implementation to keep good OO\n      // design with private destructor.\n\n    #if (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)\n      static UnitTest* const instance = new UnitTest;\n      return instance;\n    #else\n      static UnitTest instance;\n      return &instance;\n    #endif  // (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)\n    }\n\n    //gtest-internal-inl.h\n    class GTEST_API_ UnitTestImpl {\n    \t...\n        void AddTestInfo(Test::SetUpTestCaseFunc set_up_tc,\n                   Test::TearDownTestCaseFunc tear_down_tc,\n                   TestInfo* test_info) {\n        // In order to support thread-safe death tests, we need to\n        // remember the original working directory when the test program\n        // was first invoked.  We cannot do this in RUN_ALL_TESTS(), as\n        // the user may have changed the current directory before calling\n        // RUN_ALL_TESTS().  Therefore we capture the current directory in\n        // AddTestInfo(), which is called to register a TEST or TEST_F\n        // before main() is reached.\n        if (original_working_dir_.IsEmpty()) {\n          original_working_dir_.Set(FilePath::GetCurrentDir());\n          GTEST_CHECK_(!original_working_dir_.IsEmpty())\n              << \"Failed to get the current working directory.\";\n        }\n\n        GetTestCase(test_info->test_case_name(),\n                    test_info->type_param(),\n                    set_up_tc,\n                    tear_down_tc)->AddTestInfo(test_info);\n      }\n      ...\n      //这个方法从test_cases_里面获取TestCase\n      TestCase* GetTestCase(const char* test_case_name,\n                        const char* type_param,\n                        Test::SetUpTestCaseFunc set_up_tc,\n                        Test::TearDownTestCaseFunc tear_down_tc);\n      ...\n      std::vector<TestCase*> test_cases_;\n      ...\n    };\n\n    //gtest.cc\n    void TestCase::AddTestInfo(TestInfo * test_info) {\n      test_info_list_.push_back(test_info);\n      test_indices_.push_back(static_cast<int>(test_indices_.size()));\n    }\n\n    //gtest.h\n    class GTEST_API_ TestCase {\n    \t...\n    \tstd::vector<TestInfo*> test_info_list_;\n        std::vector<int> test_indices_;\n        ...\n    };\n```\n\n代码很多，我简单的描述一下。UnitTest 是一个单例类，它有一个成员变量 internal::UnitTestImpl* impl\\_， impl\\_ 里面又有成员变量 test\\_info\\_list\\_。最终我们写的测试类就放在 test\\_info\\_list\\_ 里。\n\n九曲十八弯，实际 GTest 用一个单例类 UnitTest 保存了注册的测试代码（放在 ::testing::Test 子类的 TestBody 方法里面）。\n\n那他是怎么解决初始化顺序的问题的？注意看 UnitTest::GetInstance() 方法：\n\n```cpp\n\t//gtest.cc\n    UnitTest* UnitTest::GetInstance() {\n      // When compiled with MSVC 7.1 in optimized mode, destroying the\n      // UnitTest object upon exiting the program messes up the exit code,\n      // causing successful tests to appear failed.  We have to use a\n      // different implementation in this case to bypass the compiler bug.\n      // This implementation makes the compiler happy, at the cost of\n      // leaking the UnitTest object.\n\n      // CodeGear C++Builder insists on a public destructor for the\n      // default implementation.  Use this implementation to keep good OO\n      // design with private destructor.\n\n    #if (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)\n      static UnitTest* const instance = new UnitTest;\n      return instance;\n    #else\n      static UnitTest instance;\n      return &instance;\n    #endif  // (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)\n    }\n```\n\n这里使用了局部静态变量，在第一次进入这个方法的时候就会生成一个 UnitTest 实例！不需要靠人品祈祷编译器按照我们设想的顺序创建全局变量！\n\n谷歌大神们不愧是大神，在看 GTest 源码的时候我都不知道被惊艳了多少次，真心学到了不少东西。怪不得别人都说看源码才是最好的提升方式。\n","source":"_posts/GTest源码剖析-测试代码的注册.md","raw":"title: GTest源码剖析 - 测试代码的注册\ndate: 2016-02-15 22:07:08\ntags:\n\t- 技术相关\n\t- 单元测试\n---\n单元测试框架，最基本的功能当然就是运行用户所编写的测试用例了。\n\n## __毫无技巧的方法__\n\n一种毫无技巧的方法就是用户手动在 main 函数里面将自己编写的测试代码注册到框架中，就像下面的代码：\n```cpp\n    void test1() {...}\n    void test2() {...}\n    void test3() {...}\n    ...\n\n    int main(){\n        RegisterTestFunc(test1);\n        RegisterTestFunc(test2);\n        RegisterTestFunc(test3);\n        ...\n        return 0;\n    }\n```\n\n这样的代码虽然可以运行，但是将初始化的责任放到的用户那里，这样的代码是不够优秀的。有两种容易出现的情况：一是项目中可能拥有大量的测试代码，用户很有可能会漏掉其中的部分测试代码，忘记把它们注册到测试框架中。二是可能用户去掉了一些测试代码，却又忘了去掉注册的代码。\n\n后者编译器会报错，但前者却没有办法检测（除非对着测试结果一条条的检测，看是否所有测试代码都运行了）。\n\n## __一种有问题的方法__\n\n最好在编写测试代码的时候就能通过一种机制帮用户注册，而不用用户手动去注册。面对这个需求，我脑海里面想到的第一个方法就是利用全局变量和宏定义。\n\n首先定义一个用来管理注册的测试方法的类：\n```cpp\n\ttypedef list<function<void()>> FuncList;\n    class Test{\n    public:\n        Test(const function<void()>& test_func){\n            test_funcs_.push_back(test_func);\n        }\n\n        static void runAllTest(){\n            for (auto func : test_funcs_){\n                func();\n            }\n        }\n\n    private:\n        static FuncList test_funcs_;\n    };\n```\n\n它有一个静态的成员变量 test\\_funcs\\_ ，用来保存测试方法，同时它有一个构造函数用来将传入的测试方法插入 test\\_funcs\\_ 中\n\n接着定义一个宏：\n```cpp\n    #define TEST_FUNC(NAME) \\\n        void NAME(); \\\n        static Test register_##NAME(NAME); \\\n        void NAME()\n```\n它在帮助我们在定义一个测试方法的时候自动注册到 test\\_funcs\\_ 中。原理其实很简单，就是在声明一个函数的同时声明一个 Test 全局变量，将定义的测试方法传入，这个测试函数就会在 Test 的构造函数中被插入 test\\_funcs\\_ 。\n\n所以我们只要这样编写测试代码，就能实现自动注册了：\n```cpp\n\tTEST_FUNC(testSomething){\n        ...\n    }\n```\n\n看起来这个方法不错是吧？可惜这种方法是有问题的！至少在我的 vs2013 上会崩溃！\n\n问题就出在 Test 全局变量和 Test::test\\_funcs\\_ 的初始化顺序上。你无法保证 Test::test\\_funcs\\_ 比全局变量 Test 先初始化。很奇怪是吧？ Test 的静态成员变量居然比 Test 全局变量的初始化时间晚，也就是说在 Test 这个类还没有完全准备好的时候，就已经拿来创建一个全局变量了。书上一直强调的全局变量的初始化顺序不能确定难道也有这种含义？\n\n## __一种可能可行的方法__\n\n既然是因为初始化顺序导致了内存错误，那我们只要使用某种机制让保存测试函数的容器首先初始化就行了。\n\n让我们将 Test 类的定义修改成下面的样子：\n\n```cpp\n    class Test{\n    public:\n        virtual void run() = 0;\n\n        static void runAllTest(){\n            for (auto i : test_list){\n                i->run();\n            }\n        }\n\n    protected:\n        static void addTest(Test* test){\n            test_list.push_back(test);\n        }\n\n    private:\n        static list<Test*> test_list;\n    };\n```\n\n容器里面不再直接放测试函数，改为放 Test 的指针。而 Test 又是一个抽象类，所以事实上放的是 Test 的子类。\n\n再把 TEST_FUNC 宏的定义改成下面的样子：\n\n```cpp\n    #define TEST_FUNC(NAME) \\\n        class NAME : public Test{ \\\n        public: \\\n            virtual void run(); \\\n        private: \\\n            NAME(){ \\\n                addTest(this); \\\n            } \\\n            static NAME* instance_; \\\n        }; \\\n        NAME* NAME::instance_ = new NAME(); \\\n        void NAME::run()\n\n```\n\n现在实际上用户写的测试方法实现的是 Test 的子类的 run 方法。\n\n依然是需要在定义测试方法的时候顺便定义一个全局变量，但我们换了一种方式，定义了一个类静态变量。子类在构造函数中把自己注册到 Test 的测试容器中，而且子类还包含了一个本类指针静态成员变量（有点拗口，但看代码很容易看出来）。在子类的静态成员变量初始化的之前，父类的静态成员变量应该就已经初始化了。就是根据这种机制，达到了我们的目的。\n\n使用方法还是一样：\n\n```cpp\n    TEST_FUNC(testSomething){\n        ...\n    }\n```\n\n为什么说这是“一种可能可行的方法”呢？因为父类的静态成员变量初始化先于子类的静态成员变量初始化这个前提是我自己推论的。可能是我读的书少或者读书不仔细，至今没有在哪里见到有提及父类和子类的静态成员变量的初始化顺序的。所以虽然在我的编译器上它的确能正常的工作，但为了严谨起见，姑且称为“可能”的吧。如果有人有在哪里看到这方面的描述，请务必私信我，让我把“可能”二字去掉或者将标题改成“另一种有问题的方法”\n\n## __GTest 的做法__\n\n讲了这么久我的想法，现状让我们来看看谷歌的大神们是怎么做的吧。\n\n我们从 TEST 宏看起：\n\n```cpp\n    #if !GTEST_DONT_DEFINE_TEST\n    # define TEST(test_case_name, test_name) GTEST_TEST(test_case_name, test_name)\n    #endif\n```\n\n这里这么搞，主要是为了防止 TEST 被系统或者其他框架定义了。如果出现这种情况，只要把GTEST\\_DONT\\_DEFINE\\_TEST 定义为 1，之后编写测试用例的时候直接使用 GTEST\\_TEST 就好了。不得不说，他们考虑的真仔细。让我们继续跟踪，看 GTEST\\_TEST：\n\n```cpp\n    #define GTEST_TEST(test_case_name, test_name)\\\n      GTEST_TEST_(test_case_name, test_name, \\\n                  ::testing::Test, ::testing::internal::GetTestTypeId())\n```\n\nGTEST\\_TEST 宏又用到了另一个宏 GTEST\\_TEST\\_，但我想先说一下 GetTestTypeId，这个东西的用法真的令我眼前一亮，不得不佩服：\n\n```cpp\n    TypeId GetTestTypeId() {\n      return GetTypeId<Test>();\n    }\n\n\t...\n\n\ttemplate <typename T>\n    TypeId GetTypeId() {\n      // The compiler is required to allocate a different\n      // TypeIdHelper<T>::dummy_ variable for each T used to instantiate\n      // the template.  Therefore, the address of dummy_ is guaranteed to\n      // be unique.\n      return &(TypeIdHelper<T>::dummy_);\n    }\n\n\t...\n\n    template <typename T>\n    class TypeIdHelper {\n     public:\n      // dummy_ must not have a const type.  Otherwise an overly eager\n      // compiler (e.g. MSVC 7.1 & 8.0) may try to merge\n      // TypeIdHelper<T>::dummy_ for different Ts as an \"optimization\".\n      static bool dummy_;\n    };\n```\n\n这里直接用一个类的静态成员变量的地址当作 id 号。当时我就懵逼了，明明很简单，怎么就感觉那么玄幻呢？\n\n膜拜完我们再继续看 GTEST\\_TEST\\_：\n```cpp\n    #define GTEST_TEST_(test_case_name, test_name, parent_class, parent_id)\\\n    class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class {\\\n     public:\\\n      GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}\\\n     private:\\\n      virtual void TestBody();\\\n      static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;\\\n      GTEST_DISALLOW_COPY_AND_ASSIGN_(\\\n          GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\\\n    };\\\n    \\\n    ::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)\\\n      ::test_info_ =\\\n        ::testing::internal::MakeAndRegisterTestInfo(\\\n            #test_case_name, #test_name, NULL, NULL, \\\n            (parent_id), \\\n            parent_class::SetUpTestCase, \\\n            parent_class::TearDownTestCase, \\\n            new ::testing::internal::TestFactoryImpl<\\\n                GTEST_TEST_CLASS_NAME_(test_case_name, test_name)>);\\\n    void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()\n```\n\n这个宏的做法和我的最后一个方法的 TEST\\_FUNC 宏差不多，用户写的测试函数实际上是实现了 ::testing::Test 的子类的 TestBody 方法。也是初始化了子类的一个静态成员变量，但GTest这里没有我那么暴力，它初始化的是一个 TestInfo 类型的的静态成员变量，这里面包含了测试的很多信息。其中最重要的是 ::testing::internal::TestFactoryImpl 这个东西：\n\n```cpp\n    template <class TestClass>\n    class TestFactoryImpl : public TestFactoryBase {\n     public:\n      virtual Test* CreateTest() { return new TestClass; }\n    };\n\n    ...\n\n\tclass TestFactoryBase {\n     public:\n      virtual ~TestFactoryBase() {}\n\n      // Creates a test instance to run. The instance is both created and destroyed\n      // within TestInfoImpl::Run()\n      virtual Test* CreateTest() = 0;\n\n     protected:\n      TestFactoryBase() {}\n\n     private:\n      GTEST_DISALLOW_COPY_AND_ASSIGN_(TestFactoryBase);\n    };\n```\n\n它是一个工厂类，用来创建传入的测试类的实例，也就是 GTEST\\_TEST\\_CLASS\\_NAME\\_(test\\_case\\_name, test\\_name)> 这个类，它的 TestBody 就是用户所写的测试代码。可以看看 GTEST\\_TEST\\_CLASS\\_NAME\\_ 的定义：\n\n```cpp\n    #define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n      test_case_name##_##test_name##_Test\n```\n\nok,很简单是吧？就是字符串拼接而已。\n\n好了，让我们继续深入，看看 MakeAndRegisterTestInfo ：\n```cpp\n\t//gtest.cc\n    TestInfo* MakeAndRegisterTestInfo(\n        const char* test_case_name,\n        const char* name,\n        const char* type_param,\n        const char* value_param,\n        TypeId fixture_class_id,\n        SetUpTestCaseFunc set_up_tc,\n        TearDownTestCaseFunc tear_down_tc,\n        TestFactoryBase* factory) {\n      TestInfo* const test_info =\n          new TestInfo(test_case_name, name, type_param, value_param,\n                       fixture_class_id, factory);\n      GetUnitTestImpl()->AddTestInfo(set_up_tc, tear_down_tc, test_info);\n      return test_info;\n    }\n\n\t//gtest-internal-inl.h\n\tinline UnitTestImpl* GetUnitTestImpl() {\n      return UnitTest::GetInstance()->impl();\n    }\n\n    //gtest.h\n    class GTEST_API_ UnitTest {\n     public:\n      static UnitTest* GetInstance();\n      ...\n      internal::UnitTestImpl* impl() { return impl_; }\n      ...\n      internal::UnitTestImpl* impl_;\n      ...\n    };\n\n    //gtest.cc\n    UnitTest* UnitTest::GetInstance() {\n      // When compiled with MSVC 7.1 in optimized mode, destroying the\n      // UnitTest object upon exiting the program messes up the exit code,\n      // causing successful tests to appear failed.  We have to use a\n      // different implementation in this case to bypass the compiler bug.\n      // This implementation makes the compiler happy, at the cost of\n      // leaking the UnitTest object.\n\n      // CodeGear C++Builder insists on a public destructor for the\n      // default implementation.  Use this implementation to keep good OO\n      // design with private destructor.\n\n    #if (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)\n      static UnitTest* const instance = new UnitTest;\n      return instance;\n    #else\n      static UnitTest instance;\n      return &instance;\n    #endif  // (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)\n    }\n\n    //gtest-internal-inl.h\n    class GTEST_API_ UnitTestImpl {\n    \t...\n        void AddTestInfo(Test::SetUpTestCaseFunc set_up_tc,\n                   Test::TearDownTestCaseFunc tear_down_tc,\n                   TestInfo* test_info) {\n        // In order to support thread-safe death tests, we need to\n        // remember the original working directory when the test program\n        // was first invoked.  We cannot do this in RUN_ALL_TESTS(), as\n        // the user may have changed the current directory before calling\n        // RUN_ALL_TESTS().  Therefore we capture the current directory in\n        // AddTestInfo(), which is called to register a TEST or TEST_F\n        // before main() is reached.\n        if (original_working_dir_.IsEmpty()) {\n          original_working_dir_.Set(FilePath::GetCurrentDir());\n          GTEST_CHECK_(!original_working_dir_.IsEmpty())\n              << \"Failed to get the current working directory.\";\n        }\n\n        GetTestCase(test_info->test_case_name(),\n                    test_info->type_param(),\n                    set_up_tc,\n                    tear_down_tc)->AddTestInfo(test_info);\n      }\n      ...\n      //这个方法从test_cases_里面获取TestCase\n      TestCase* GetTestCase(const char* test_case_name,\n                        const char* type_param,\n                        Test::SetUpTestCaseFunc set_up_tc,\n                        Test::TearDownTestCaseFunc tear_down_tc);\n      ...\n      std::vector<TestCase*> test_cases_;\n      ...\n    };\n\n    //gtest.cc\n    void TestCase::AddTestInfo(TestInfo * test_info) {\n      test_info_list_.push_back(test_info);\n      test_indices_.push_back(static_cast<int>(test_indices_.size()));\n    }\n\n    //gtest.h\n    class GTEST_API_ TestCase {\n    \t...\n    \tstd::vector<TestInfo*> test_info_list_;\n        std::vector<int> test_indices_;\n        ...\n    };\n```\n\n代码很多，我简单的描述一下。UnitTest 是一个单例类，它有一个成员变量 internal::UnitTestImpl* impl\\_， impl\\_ 里面又有成员变量 test\\_info\\_list\\_。最终我们写的测试类就放在 test\\_info\\_list\\_ 里。\n\n九曲十八弯，实际 GTest 用一个单例类 UnitTest 保存了注册的测试代码（放在 ::testing::Test 子类的 TestBody 方法里面）。\n\n那他是怎么解决初始化顺序的问题的？注意看 UnitTest::GetInstance() 方法：\n\n```cpp\n\t//gtest.cc\n    UnitTest* UnitTest::GetInstance() {\n      // When compiled with MSVC 7.1 in optimized mode, destroying the\n      // UnitTest object upon exiting the program messes up the exit code,\n      // causing successful tests to appear failed.  We have to use a\n      // different implementation in this case to bypass the compiler bug.\n      // This implementation makes the compiler happy, at the cost of\n      // leaking the UnitTest object.\n\n      // CodeGear C++Builder insists on a public destructor for the\n      // default implementation.  Use this implementation to keep good OO\n      // design with private destructor.\n\n    #if (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)\n      static UnitTest* const instance = new UnitTest;\n      return instance;\n    #else\n      static UnitTest instance;\n      return &instance;\n    #endif  // (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)\n    }\n```\n\n这里使用了局部静态变量，在第一次进入这个方法的时候就会生成一个 UnitTest 实例！不需要靠人品祈祷编译器按照我们设想的顺序创建全局变量！\n\n谷歌大神们不愧是大神，在看 GTest 源码的时候我都不知道被惊艳了多少次，真心学到了不少东西。怪不得别人都说看源码才是最好的提升方式。\n","slug":"GTest源码剖析-测试代码的注册","published":1,"updated":"2017-05-12T23:19:13.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2ro85e0001t4kr4wjygcn1i"},{"title":"GTest实例解析","date":"2016-02-08T09:01:49.000Z","_content":"gtest是google的一套开源的c++单元测试框架，可以方便程序员对自己的代码进行单元测试。学习这套框架，除了墙外的官方文档之外，我强力推荐[玩转Google开源C\\+\\+单元测试框架Google Test系列](http://www.cnblogs.com/coderzh/archive/2009/04/06/1426755.html)。\n\n这系列的博客已经将gtest讲的十分详细了，所以我这篇博客就不再详细介绍gtest的基本使用方法了，而是通过一个简单的例子，介绍一下如何在实际的项目中使用它。同时也会通过分析gtest的源代码，使得大家能够更好的理解gtest的工作原理\n\n## __需要测试的类__\n\n首先我实现了一个简单的类TwoDimensionalMark，它的功能相当于bool二维数组，可以将二维下标标记为true或者false。只不过它内部使用位运算，一个字节可以记录八个标记数据，可以大量节省内存。它的声明如下：\n\n```cpp\n    class TwoDimensionalMark{\n        public:\n            TwoDimensionalMark(int row, int col, bool flag = false);\n            TwoDimensionalMark(const TwoDimensionalMark& cpy)；\n            ~TwoDimensionalMark();\n            const TwoDimensionalMark& operator =(const TwoDimensionalMark& cpy)；\n\n            //将所有的位置标记为true或者false\n            void clean(bool mark);\n\n            //设置(x,y)下标为true或者false\n            void set(int x, int y, bool mark);\n\n            //获取(x,y)下标的数据\n            bool check(int x, int y)const;\n\n            int getRow();\n            int getCol();\n\n            ...\n    };\n```\n\n## __完整的测试代码__\n我先把完整的测试代码放在这里，可以先简单浏览一遍。\n```cpp\n    #include \"TwoDimensionalMark.h\"\n    #include \"gtest/gtest.h\"\n    #include <cstdlib>\n    #include <vector>\n\n    using namespace std;\n\n    struct MarkSize{\n        MarkSize(int r, int c): row(r),col(c){}\n        int row, col;\n    };\n    class TestWithMarkSize : public testing::TestWithParam<MarkSize>{\n    public:\n        struct Coord{\n            int x, y;\n        };\n\n        vector<vector<bool> > CreateContrast(int row, int col, bool flag){\n            vector<vector<bool> > contrast(row);\n            for (int i = 0; i < row; i++){\n                contrast[i] = vector<bool>(col, flag);\n            }\n            return contrast;\n        }\n\n        vector<Coord> CreateRandCoords(int row, int col){\n            int yRange = row * 3;\n            int xRange = col * 3;\n            int numRandCoord = row * col / 2;\n\n            vector<Coord> coords;\n            for (int i = 0; i < numRandCoord; i++){\n                int x = (rand() % xRange) - col;\n                int y = (rand() % yRange) - row;\n                coords.push_back({ x, y });\n            }\n\n            return coords;\n        }\n\n        void SetFlag(TwoDimensionalMark* mark,  vector<vector<bool> >* contrast,  \n                    const MarkSize& size, const vector<Coord>& coords, bool flag){\n            for (auto c : coords){\n                mark->set(c.x, c.y, flag);\n                //随机位置有可能在row，col之外，要防止溢出\n                if (c.x >= 0 && c.x < size.col && c.y >= 0 && c.y < size.row){\n                    (*contrast)[c.y][c.x] = flag;\n                }\n            }\n        }\n    };\n\n    //行数多于列数的情况\n    INSTANTIATE_TEST_CASE_P(RowLTCol, TestWithMarkSize,\ttesting::Values(MarkSize(200, 100), MarkSize(50, 30)));\n    //行数少于列数的情况\n    INSTANTIATE_TEST_CASE_P(ColLTRow, TestWithMarkSize,\ttesting::Values(MarkSize(10, 100), MarkSize(3, 10)));\n    //行数等于列数的情况\n    INSTANTIATE_TEST_CASE_P(RowEQCol, TestWithMarkSize,\ttesting::Values(MarkSize(100, 100), MarkSize(3, 3)));\n\n\n    TEST_P(TestWithMarkSize,testWithTrueClean){\n        MarkSize size = GetParam();\n\n        //初始化TwoDimensionalMark和用来做对比的contrast,将他们全部用true填充\n        TwoDimensionalMark mark(size.row, size.col);\n        mark.clean(true);\n        vector<vector<bool> > contrast = CreateContrast(size.row, size.col, true);\n\n        //验证mark和contrast里面都是true\n        for (int i = 0; i < size.row; i++){\n            for (int j = 0; j < size.col; j++){\n                ASSERT_TRUE(mark.check(j, i));\n                ASSERT_TRUE(contrast[i][j]);\n            }\n        }\n\n        //随机将一些坐标位置,这个函数生成的随机位置有可能在row，col之外\n        vector<Coord> coords = CreateRandCoords(size.row, size.col);\n\n        //将mark和contrast的之前随机生成的位置设为false\n        SetFlag(&mark, &contrast, size, coords, false);\n\n        //检测随机生成的位置上的值有没有设置正确\n        //mark若位置超出范围则返回false,而contrast则需要防止溢出\n        for (auto c : coords){\n            ASSERT_FALSE(mark.check(c.x,c.y));\n            if (c.x >= 0 && c.x < size.col && c.y >= 0 && c.y < size.row){\n                ASSERT_FALSE(contrast[c.y][c.x]);\n            }\n        }\n\n        //对比contrast和mark，两者应该相等\n        for (int y = 0; y < size.row; y++)\n            for (int x = 0; x < size.col; x++){\n                ASSERT_EQ(contrast[y][x], mark.check(x, y));\n            }\n    }\n\n    TEST_P(TestWithMarkSize, testWithFalseClean){\n        MarkSize size = GetParam();\n\n        //初始化TwoDimensionalMark和用来做对比的contrast,将他们全部用false填充\n        TwoDimensionalMark mark(size.row, size.col);\n        mark.clean(false);\n        vector<vector<bool> > contrast = CreateContrast(size.row, size.col, false);\n\n        //验证mark和contrast里面都是false\n        for (int i = 0; i < size.row; i++){\n            for (int j = 0; j < size.col; j++){\n                ASSERT_FALSE(mark.check(j, i));\n                ASSERT_FALSE(contrast[i][j]);\n            }\n        }\n\n        //随机将一些坐标位置,这个函数生成的随机位置有可能在row，col之外\n        vector<Coord> coords = CreateRandCoords(size.row, size.col);\n\n        //将mark和contrast的之前随机生成的位置设为true\n        SetFlag(&mark, &contrast, size, coords, true);\n\n        //检测随机生成的位置上的值有没有设置正确\n        //mark若位置超出范围则返回false,而contrast则需要防止溢出\n        for (auto c : coords){\n            if (c.x >= 0 && c.x < size.col && c.y >= 0 && c.y < size.row){\n                ASSERT_TRUE(contrast[c.y][c.x]);\n                ASSERT_TRUE(mark.check(c.x, c.y));\n            }\n            else{\n                ASSERT_FALSE(mark.check(c.x, c.y));\n            }\n        }\n    }\n\n    int main(int argc, char* argv[])\n    {\n        testing::InitGoogleTest(&argc, argv);\n        int result =  RUN_ALL_TESTS();\n        getchar();\n        return result;\n    }\n```\n\n## __传入多个参数__\n\n为了覆盖各种大小的情况（行和列数量相等，行多于列，行少于列），需要定义多个不同行列数的TwoDimensionalMark。但如果每个测试用例都手动硬编码的话将会有许多的重复代码，这个时候就可以使用参数化的方法去将行列数作为参数传入各个测试用例中，详细的介绍看[这里](http://www.cnblogs.com/coderzh/archive/2009/04/08/1431297.html)。\n\n这篇博客只写到了一个参数的处理。但我们这里需要传入行数和列数两个参数应该怎么办？\n其实很方法也很简单，首先定义一个结构体MarkSize用于保存行数和列数\n\n```cpp\n    struct MarkSize{\n        MarkSize(int r, int c): row(r),col(c){}\n        int row, col;\n    }\n```\n\n用它作为TestWithParam的模板参数，再声明一个类继承于它。\n\n```cpp\n    class TestWithMarkSize : public testing::TestWithParam<MarkSize>{\n    }\n```\n\n然后传入参数，这里我定义了三组参数，每组两个。分别对应行数比较多，列数比较多，行数列数一样多三种情况：\n\n```cpp\n    //行数多于列数的情况\n    INSTANTIATE_TEST_CASE_P(RowLTCol, TestWithMarkSize,\ttesting::Values(MarkSize(200, 100), MarkSize(50, 30)));\n    //行数少于列数的情况\n    INSTANTIATE_TEST_CASE_P(ColLTRow, TestWithMarkSize,\ttesting::Values(MarkSize(10, 100), MarkSize(3, 10)));\n    //行数等于列数的情况\n    INSTANTIATE_TEST_CASE_P(RowEQCol, TestWithMarkSize,\ttesting::Values(MarkSize(100, 100), MarkSize(3, 3)));\n```\n\n这样一来，只要是 test_case_name 为 TestWithMarkSize 的测试用例都可以使用GetParam方法获取传入的参数了：\n\n```cpp\n    TEST_P(TestWithMarkSize,testWithTrueClean){\n        MarkSize size = GetParam();\n        ...\n    }\n\n    TEST_P(TestWithMarkSize, testWithFalseClean){\n\t\tMarkSize size = GetParam();\n\t\t...\n\t}\n```\n\n\n## __TEST\\_P源码解析__\n\nTEST\\_P 宏的定义如下\n\n```cpp\n    # define TEST_P(test_case_name, test_name) \\\n      class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n          : public test_case_name { \\\n      ...\n      }; \\\n      ...\n      void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()\n```\n\nGTEST_TEST_CLASS_NAME_又是个什么东西？其实它的功能十分简单，就是将类名拼接出来而已，它的定义如下：\n\n```cpp\n    #define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n      test_case_name##_##test_name##_Test\n```\n\n\n所以我们使用 TEST_P(TestWithMarkSize,testWithTrueClean){...} 实际上就是定义了一个 TestWithMarkSize 的子类 TestWithMarkSize_testWithTrueClean_Test。\n\n而花括号里面实际上就是void TestWithMarkSize_testWithTrueClean_Test::TestBody()的实现。\n\n也就是说，实际上我们的测试用例都是TestWithMarkSize的子类。所以我们可以将一些公共的方法和数据结构定义在TestWithMarkSize内，只要将他们声明为protected或者public，就能在TEST_P(TestWithMarkSize,testWithTrueClean){...} 和 TEST_P(TestWithMarkSize,testWithFalseClean){...} 内使用。\n\n这样既可以提炼重复代码，又能将它们的作用范围限定在测试用例中，防止提炼出来的函数或者定义的数据结构放在全局影响实际的功能代码。\n\n如我这里定义的 Coord 结构体和CreateContrast、CreateRandCoords 和 SetFlag 方法。\n\n而GetParam()的定义如下：\n\n```cpp\n    static const ParamType* parameter_;\n\n    const ParamType& GetParam() const {\n        GTEST_CHECK_(parameter_ != NULL)\n            << \"GetParam() can only be called inside a value-parameterized test \"\n            << \"-- did you intend to write TEST_P instead of TEST_F?\";\n        return *parameter_;\n    }\n```\n\n既然 const T* WithParamInterface<T>::parameter_ 是有一个类静态成员变量，那就不难理解为什么所有继承于 TestWithMarkSize 的测试用例都能拿到同样的参数了。\n\n## __测试用例分析__\n\n要知道 TwoDimensionalMark 实际上的功能是和bool二维数组基本一样的，所以我们就很自然的想到使用一个对比用的bool二维数组作为参照，去测试 TwoDimensionalMark 的功能究竟有没有bug。\n\nTEST_P(TestWithMarkSize,testWithTrueClean) 的测试分下面三个步骤：\n\n1.根据传入的数组大小，创建了一个 TwoDimensionalMark 和用两重 vector 实现的 bool 二维数组。\n\n2.将它们全部用true填充，然后验证每一个下标的数据是否均为 true，如此去测试TwoDimensionalMark::clean(true) 的功能\n\n3.随机生成一些坐标，将 TwoDimensionalMark 和 bool 二维数组对应这些坐标的数据都设为 false 。然后检测设置的位置的数据是否都为false，还有对比两者每个下标的数据是否相等。以测试 set 和 check 方法是否正确。同时因为这些下标有些是超出范围之外的，也能测试 TwoDimensionalMark 对超出范围的操作是否正确\n\n代码如下：\n\n```cpp\n    TEST_P(TestWithMarkSize,testWithTrueClean){\n        MarkSize size = GetParam();\n\n        //初始化TwoDimensionalMark和用来做对比的contrast,将他们全部用true填充\n        TwoDimensionalMark mark(size.row, size.col);\n        mark.clean(true);\n        vector<vector<bool> > contrast = CreateContrast(size.row, size.col, true);\n\n        //验证mark和contrast里面都是true\n        for (int i = 0; i < size.row; i++){\n            for (int j = 0; j < size.col; j++){\n                ASSERT_TRUE(mark.check(j, i));\n                ASSERT_TRUE(contrast[i][j]);\n            }\n        }\n\n        //随机将一些坐标位置,这个函数生成的随机位置有可能在row，col之外\n        vector<Coord> coords = CreateRandCoords(size.row, size.col);\n\n        //将mark和contrast的之前随机生成的位置设为false\n        SetFlag(&mark, &contrast, size, coords, false);\n\n        //检测随机生成的位置上的值有没有设置正确\n        //mark若位置超出范围则返回false,而contrast则需要防止溢出\n        for (auto c : coords){\n            ASSERT_FALSE(mark.check(c.x,c.y));\n            if (c.x >= 0 && c.x < size.col && c.y >= 0 && c.y < size.row){\n                ASSERT_FALSE(contrast[c.y][c.x]);\n            }\n        }\n\n        //对比contrast和mark，两者应该相等\n        for (int y = 0; y < size.row; y++)\n            for (int x = 0; x < size.col; x++){\n                ASSERT_EQ(contrast[y][x], mark.check(x, y));\n            }\n    }\n```\n\nTEST_P(TestWithMarkSize, testWithFalseClean) 和上面的差不多，只不过换成一开始用 false 填充，之后设置随机下标的数据为 true，读者可以自己查看代码，这里就不详细分析了。\n\n## __测试结果__\n\n运行测试代码得到下面的结果：\n{% img /GTest实例解析/1.jpg %}\n\n全部测试均通过！\n\n完整代码:[https://github.com/bluesky466/GTestDemo](https://github.com/bluesky466/GTestDemo)\n（为了方便，我直接将实现写在了头文件里，好孩子不要学~）\n","source":"_posts/GTest实例解析.md","raw":"title: GTest实例解析\ndate: 2016-02-08 17:01:49\ntags:\n\t- 技术相关\n\t- 单元测试\n---\ngtest是google的一套开源的c++单元测试框架，可以方便程序员对自己的代码进行单元测试。学习这套框架，除了墙外的官方文档之外，我强力推荐[玩转Google开源C\\+\\+单元测试框架Google Test系列](http://www.cnblogs.com/coderzh/archive/2009/04/06/1426755.html)。\n\n这系列的博客已经将gtest讲的十分详细了，所以我这篇博客就不再详细介绍gtest的基本使用方法了，而是通过一个简单的例子，介绍一下如何在实际的项目中使用它。同时也会通过分析gtest的源代码，使得大家能够更好的理解gtest的工作原理\n\n## __需要测试的类__\n\n首先我实现了一个简单的类TwoDimensionalMark，它的功能相当于bool二维数组，可以将二维下标标记为true或者false。只不过它内部使用位运算，一个字节可以记录八个标记数据，可以大量节省内存。它的声明如下：\n\n```cpp\n    class TwoDimensionalMark{\n        public:\n            TwoDimensionalMark(int row, int col, bool flag = false);\n            TwoDimensionalMark(const TwoDimensionalMark& cpy)；\n            ~TwoDimensionalMark();\n            const TwoDimensionalMark& operator =(const TwoDimensionalMark& cpy)；\n\n            //将所有的位置标记为true或者false\n            void clean(bool mark);\n\n            //设置(x,y)下标为true或者false\n            void set(int x, int y, bool mark);\n\n            //获取(x,y)下标的数据\n            bool check(int x, int y)const;\n\n            int getRow();\n            int getCol();\n\n            ...\n    };\n```\n\n## __完整的测试代码__\n我先把完整的测试代码放在这里，可以先简单浏览一遍。\n```cpp\n    #include \"TwoDimensionalMark.h\"\n    #include \"gtest/gtest.h\"\n    #include <cstdlib>\n    #include <vector>\n\n    using namespace std;\n\n    struct MarkSize{\n        MarkSize(int r, int c): row(r),col(c){}\n        int row, col;\n    };\n    class TestWithMarkSize : public testing::TestWithParam<MarkSize>{\n    public:\n        struct Coord{\n            int x, y;\n        };\n\n        vector<vector<bool> > CreateContrast(int row, int col, bool flag){\n            vector<vector<bool> > contrast(row);\n            for (int i = 0; i < row; i++){\n                contrast[i] = vector<bool>(col, flag);\n            }\n            return contrast;\n        }\n\n        vector<Coord> CreateRandCoords(int row, int col){\n            int yRange = row * 3;\n            int xRange = col * 3;\n            int numRandCoord = row * col / 2;\n\n            vector<Coord> coords;\n            for (int i = 0; i < numRandCoord; i++){\n                int x = (rand() % xRange) - col;\n                int y = (rand() % yRange) - row;\n                coords.push_back({ x, y });\n            }\n\n            return coords;\n        }\n\n        void SetFlag(TwoDimensionalMark* mark,  vector<vector<bool> >* contrast,  \n                    const MarkSize& size, const vector<Coord>& coords, bool flag){\n            for (auto c : coords){\n                mark->set(c.x, c.y, flag);\n                //随机位置有可能在row，col之外，要防止溢出\n                if (c.x >= 0 && c.x < size.col && c.y >= 0 && c.y < size.row){\n                    (*contrast)[c.y][c.x] = flag;\n                }\n            }\n        }\n    };\n\n    //行数多于列数的情况\n    INSTANTIATE_TEST_CASE_P(RowLTCol, TestWithMarkSize,\ttesting::Values(MarkSize(200, 100), MarkSize(50, 30)));\n    //行数少于列数的情况\n    INSTANTIATE_TEST_CASE_P(ColLTRow, TestWithMarkSize,\ttesting::Values(MarkSize(10, 100), MarkSize(3, 10)));\n    //行数等于列数的情况\n    INSTANTIATE_TEST_CASE_P(RowEQCol, TestWithMarkSize,\ttesting::Values(MarkSize(100, 100), MarkSize(3, 3)));\n\n\n    TEST_P(TestWithMarkSize,testWithTrueClean){\n        MarkSize size = GetParam();\n\n        //初始化TwoDimensionalMark和用来做对比的contrast,将他们全部用true填充\n        TwoDimensionalMark mark(size.row, size.col);\n        mark.clean(true);\n        vector<vector<bool> > contrast = CreateContrast(size.row, size.col, true);\n\n        //验证mark和contrast里面都是true\n        for (int i = 0; i < size.row; i++){\n            for (int j = 0; j < size.col; j++){\n                ASSERT_TRUE(mark.check(j, i));\n                ASSERT_TRUE(contrast[i][j]);\n            }\n        }\n\n        //随机将一些坐标位置,这个函数生成的随机位置有可能在row，col之外\n        vector<Coord> coords = CreateRandCoords(size.row, size.col);\n\n        //将mark和contrast的之前随机生成的位置设为false\n        SetFlag(&mark, &contrast, size, coords, false);\n\n        //检测随机生成的位置上的值有没有设置正确\n        //mark若位置超出范围则返回false,而contrast则需要防止溢出\n        for (auto c : coords){\n            ASSERT_FALSE(mark.check(c.x,c.y));\n            if (c.x >= 0 && c.x < size.col && c.y >= 0 && c.y < size.row){\n                ASSERT_FALSE(contrast[c.y][c.x]);\n            }\n        }\n\n        //对比contrast和mark，两者应该相等\n        for (int y = 0; y < size.row; y++)\n            for (int x = 0; x < size.col; x++){\n                ASSERT_EQ(contrast[y][x], mark.check(x, y));\n            }\n    }\n\n    TEST_P(TestWithMarkSize, testWithFalseClean){\n        MarkSize size = GetParam();\n\n        //初始化TwoDimensionalMark和用来做对比的contrast,将他们全部用false填充\n        TwoDimensionalMark mark(size.row, size.col);\n        mark.clean(false);\n        vector<vector<bool> > contrast = CreateContrast(size.row, size.col, false);\n\n        //验证mark和contrast里面都是false\n        for (int i = 0; i < size.row; i++){\n            for (int j = 0; j < size.col; j++){\n                ASSERT_FALSE(mark.check(j, i));\n                ASSERT_FALSE(contrast[i][j]);\n            }\n        }\n\n        //随机将一些坐标位置,这个函数生成的随机位置有可能在row，col之外\n        vector<Coord> coords = CreateRandCoords(size.row, size.col);\n\n        //将mark和contrast的之前随机生成的位置设为true\n        SetFlag(&mark, &contrast, size, coords, true);\n\n        //检测随机生成的位置上的值有没有设置正确\n        //mark若位置超出范围则返回false,而contrast则需要防止溢出\n        for (auto c : coords){\n            if (c.x >= 0 && c.x < size.col && c.y >= 0 && c.y < size.row){\n                ASSERT_TRUE(contrast[c.y][c.x]);\n                ASSERT_TRUE(mark.check(c.x, c.y));\n            }\n            else{\n                ASSERT_FALSE(mark.check(c.x, c.y));\n            }\n        }\n    }\n\n    int main(int argc, char* argv[])\n    {\n        testing::InitGoogleTest(&argc, argv);\n        int result =  RUN_ALL_TESTS();\n        getchar();\n        return result;\n    }\n```\n\n## __传入多个参数__\n\n为了覆盖各种大小的情况（行和列数量相等，行多于列，行少于列），需要定义多个不同行列数的TwoDimensionalMark。但如果每个测试用例都手动硬编码的话将会有许多的重复代码，这个时候就可以使用参数化的方法去将行列数作为参数传入各个测试用例中，详细的介绍看[这里](http://www.cnblogs.com/coderzh/archive/2009/04/08/1431297.html)。\n\n这篇博客只写到了一个参数的处理。但我们这里需要传入行数和列数两个参数应该怎么办？\n其实很方法也很简单，首先定义一个结构体MarkSize用于保存行数和列数\n\n```cpp\n    struct MarkSize{\n        MarkSize(int r, int c): row(r),col(c){}\n        int row, col;\n    }\n```\n\n用它作为TestWithParam的模板参数，再声明一个类继承于它。\n\n```cpp\n    class TestWithMarkSize : public testing::TestWithParam<MarkSize>{\n    }\n```\n\n然后传入参数，这里我定义了三组参数，每组两个。分别对应行数比较多，列数比较多，行数列数一样多三种情况：\n\n```cpp\n    //行数多于列数的情况\n    INSTANTIATE_TEST_CASE_P(RowLTCol, TestWithMarkSize,\ttesting::Values(MarkSize(200, 100), MarkSize(50, 30)));\n    //行数少于列数的情况\n    INSTANTIATE_TEST_CASE_P(ColLTRow, TestWithMarkSize,\ttesting::Values(MarkSize(10, 100), MarkSize(3, 10)));\n    //行数等于列数的情况\n    INSTANTIATE_TEST_CASE_P(RowEQCol, TestWithMarkSize,\ttesting::Values(MarkSize(100, 100), MarkSize(3, 3)));\n```\n\n这样一来，只要是 test_case_name 为 TestWithMarkSize 的测试用例都可以使用GetParam方法获取传入的参数了：\n\n```cpp\n    TEST_P(TestWithMarkSize,testWithTrueClean){\n        MarkSize size = GetParam();\n        ...\n    }\n\n    TEST_P(TestWithMarkSize, testWithFalseClean){\n\t\tMarkSize size = GetParam();\n\t\t...\n\t}\n```\n\n\n## __TEST\\_P源码解析__\n\nTEST\\_P 宏的定义如下\n\n```cpp\n    # define TEST_P(test_case_name, test_name) \\\n      class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n          : public test_case_name { \\\n      ...\n      }; \\\n      ...\n      void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()\n```\n\nGTEST_TEST_CLASS_NAME_又是个什么东西？其实它的功能十分简单，就是将类名拼接出来而已，它的定义如下：\n\n```cpp\n    #define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n      test_case_name##_##test_name##_Test\n```\n\n\n所以我们使用 TEST_P(TestWithMarkSize,testWithTrueClean){...} 实际上就是定义了一个 TestWithMarkSize 的子类 TestWithMarkSize_testWithTrueClean_Test。\n\n而花括号里面实际上就是void TestWithMarkSize_testWithTrueClean_Test::TestBody()的实现。\n\n也就是说，实际上我们的测试用例都是TestWithMarkSize的子类。所以我们可以将一些公共的方法和数据结构定义在TestWithMarkSize内，只要将他们声明为protected或者public，就能在TEST_P(TestWithMarkSize,testWithTrueClean){...} 和 TEST_P(TestWithMarkSize,testWithFalseClean){...} 内使用。\n\n这样既可以提炼重复代码，又能将它们的作用范围限定在测试用例中，防止提炼出来的函数或者定义的数据结构放在全局影响实际的功能代码。\n\n如我这里定义的 Coord 结构体和CreateContrast、CreateRandCoords 和 SetFlag 方法。\n\n而GetParam()的定义如下：\n\n```cpp\n    static const ParamType* parameter_;\n\n    const ParamType& GetParam() const {\n        GTEST_CHECK_(parameter_ != NULL)\n            << \"GetParam() can only be called inside a value-parameterized test \"\n            << \"-- did you intend to write TEST_P instead of TEST_F?\";\n        return *parameter_;\n    }\n```\n\n既然 const T* WithParamInterface<T>::parameter_ 是有一个类静态成员变量，那就不难理解为什么所有继承于 TestWithMarkSize 的测试用例都能拿到同样的参数了。\n\n## __测试用例分析__\n\n要知道 TwoDimensionalMark 实际上的功能是和bool二维数组基本一样的，所以我们就很自然的想到使用一个对比用的bool二维数组作为参照，去测试 TwoDimensionalMark 的功能究竟有没有bug。\n\nTEST_P(TestWithMarkSize,testWithTrueClean) 的测试分下面三个步骤：\n\n1.根据传入的数组大小，创建了一个 TwoDimensionalMark 和用两重 vector 实现的 bool 二维数组。\n\n2.将它们全部用true填充，然后验证每一个下标的数据是否均为 true，如此去测试TwoDimensionalMark::clean(true) 的功能\n\n3.随机生成一些坐标，将 TwoDimensionalMark 和 bool 二维数组对应这些坐标的数据都设为 false 。然后检测设置的位置的数据是否都为false，还有对比两者每个下标的数据是否相等。以测试 set 和 check 方法是否正确。同时因为这些下标有些是超出范围之外的，也能测试 TwoDimensionalMark 对超出范围的操作是否正确\n\n代码如下：\n\n```cpp\n    TEST_P(TestWithMarkSize,testWithTrueClean){\n        MarkSize size = GetParam();\n\n        //初始化TwoDimensionalMark和用来做对比的contrast,将他们全部用true填充\n        TwoDimensionalMark mark(size.row, size.col);\n        mark.clean(true);\n        vector<vector<bool> > contrast = CreateContrast(size.row, size.col, true);\n\n        //验证mark和contrast里面都是true\n        for (int i = 0; i < size.row; i++){\n            for (int j = 0; j < size.col; j++){\n                ASSERT_TRUE(mark.check(j, i));\n                ASSERT_TRUE(contrast[i][j]);\n            }\n        }\n\n        //随机将一些坐标位置,这个函数生成的随机位置有可能在row，col之外\n        vector<Coord> coords = CreateRandCoords(size.row, size.col);\n\n        //将mark和contrast的之前随机生成的位置设为false\n        SetFlag(&mark, &contrast, size, coords, false);\n\n        //检测随机生成的位置上的值有没有设置正确\n        //mark若位置超出范围则返回false,而contrast则需要防止溢出\n        for (auto c : coords){\n            ASSERT_FALSE(mark.check(c.x,c.y));\n            if (c.x >= 0 && c.x < size.col && c.y >= 0 && c.y < size.row){\n                ASSERT_FALSE(contrast[c.y][c.x]);\n            }\n        }\n\n        //对比contrast和mark，两者应该相等\n        for (int y = 0; y < size.row; y++)\n            for (int x = 0; x < size.col; x++){\n                ASSERT_EQ(contrast[y][x], mark.check(x, y));\n            }\n    }\n```\n\nTEST_P(TestWithMarkSize, testWithFalseClean) 和上面的差不多，只不过换成一开始用 false 填充，之后设置随机下标的数据为 true，读者可以自己查看代码，这里就不详细分析了。\n\n## __测试结果__\n\n运行测试代码得到下面的结果：\n{% img /GTest实例解析/1.jpg %}\n\n全部测试均通过！\n\n完整代码:[https://github.com/bluesky466/GTestDemo](https://github.com/bluesky466/GTestDemo)\n（为了方便，我直接将实现写在了头文件里，好孩子不要学~）\n","slug":"GTest实例解析","published":1,"updated":"2017-05-12T23:19:13.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2ro85e3001x4kr44k2vozmb"},{"title":"DrawerLayout 学习笔记","date":"2016-01-27T09:44:24.000Z","_content":"\nDrawerLayout的使用十分简单，使用android.support.v4.widget.DrawerLayout标签即可，DrawerLayout的第一个子标签就是正文，其他布局都是抽屉布局（默认隐藏在屏幕外）。可以使用android:layout_gravity属性指定是隐藏在屏幕的左边或者右边。\n\n## **一、使用DrawerLayout布局**\n\n把activity_main.xml修改成下面的样子，这里声明了一个LinearLayout作为正文布局（DrawerLayout的第一个子标签），和其他两个LinearLayout布局作为抽屉布局（将android:layout_gravity设置为left或者right）：\n\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <android.support.v4.widget.DrawerLayout\n            android:id=\"@+id/drawer_layout\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\">\n\n            <!-- 正文布局 -->\n            <LinearLayout\n                android:id=\"@+id/content\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:gravity=\"center_horizontal\"\n                android:orientation=\"horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"content\" />\n\n            </LinearLayout>\n\n            <!-- 从左边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_left\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"left\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"left\" />\n            </LinearLayout>\n\n            <!-- 从右边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_right\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"right\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"right\" />\n            </LinearLayout>\n        </android.support.v4.widget.DrawerLayout>\n    </LinearLayout>\n```\n\n运行之后就长这个样子，可以用手指从左边或者右边把抽屉布局拖出来：\n{% img /DrawerLayout-学习笔记/1.jpg %}\n\n{% img /DrawerLayout-学习笔记/3.jpg %}\n\n{% img /DrawerLayout-学习笔记/2.jpg %}\n\n当然也能在代码里面调用openDrawer来显示：\n```java \n    //打开左边的抽屉布局\n    drawerLayout.openDrawer(Gravity.LEFT);\n    //打开右边的抽屉布局\n    drawerLayout.openDrawer(Gravity.RIGHT);\n```\n  \n  \n## **二、使用ActionBarDrawerToggle**\nandroid提供了一个ActionBarDrawerToggle来简化DrawerLayout的操作，用法十分简单。\n1.自定义一个ToolBar（可以查看我之前的一篇博文）\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <android.support.v7.widget.Toolbar\n            android:id=\"@+id/toolbar\"\n            android:background=\"#3F51B5\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"?attr/actionBarSize\" />\n\n        <android.support.v4.widget.DrawerLayout\n            android:id=\"@+id/drawer_layout\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\">\n\n            <!-- 正文布局 -->\n            <LinearLayout\n                android:id=\"@+id/content\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:gravity=\"center_horizontal\"\n                android:orientation=\"horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"content\" />\n\n            </LinearLayout>\n\n            <!-- 从左边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_left\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"left\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"left\" />\n            </LinearLayout>\n\n            <!-- 从右边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_right\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"right\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"right\" />\n            </LinearLayout>\n        </android.support.v4.widget.DrawerLayout>\n    </LinearLayout>\n```\n\n2.在acvitity代码中创建ActionBarDrawerToggle并重写下面的方法就可以了\n- 在onPostCreate方法中调用ActionBarDrawerToggle.syncState()，如果不调用该方法，则ActionBarDrawerToggle不会显示 （onPostCreate在Activity完全加载成功之后调用，这个时候所有界面资源都已经创建和初始化完成）\n- 在onOptionsItemSelected方法中调用ActionBarDrawerToggle.onOptionsItemSelected()。（原本我以为这里是用来实现按下按钮打开和关闭抽屉布局的，但经测试，就算不调用也能正常运行。）\n```java\n    public class MainActivity extends AppCompatActivity {\n        ActionBarDrawerToggle mToggle;\n\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n\n            setContentView(R.layout.activity_main);\n\n            Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n            setSupportActionBar(toolbar);\n\n            DrawerLayout drawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);\n            mToggle = new ActionBarDrawerToggle(this, drawerLayout,toolbar,R.string.drawer_open, R.string.drawer_close);\n\n            drawerLayout.setDrawerListener(mToggle);\n        }\n\n        @Override\n        protected void onPostCreate(Bundle savedInstanceState) {\n        \t//onPostCreate在Activity完全加载成功之后调用\n            //这个时候所有界面资源都已经创建和初始化完成\n            super.onPostCreate(savedInstanceState);\n\n            //如果不调用该方法，则ActionBarDrawerToggle不会显示\n            mToggle.syncState();\n        }\n\n        @Override\n        public boolean onOptionsItemSelected(MenuItem item) {\n        \t//原本我以为这里是用来实现按下按钮打开和关闭抽屉布局的\n            //但经测试，就算不调用也能正常运行。\n            return mToggle.onOptionsItemSelected(item) || super.onOptionsItemSelected(item);\n        }\n    }\n```\n\n运行可以得到下面这效果，可以使用控制按钮来打开和关闭左边的抽屉布局，那个控制按钮还实现了一种特别酷炫的动画：\n{% img /DrawerLayout-学习笔记/4.jpg %}\n\n{% img /DrawerLayout-学习笔记/5.jpg %}\n\n{% img /DrawerLayout-学习笔记/6.jpg %}\n  \n  \n## **三、将抽屉布局的层级填到toolbar之上**\n知乎的安卓app也使用了DrawerLayout，但它的抽屉布局显示的时候是位于toolbar之上的。我们只要把toolbar标签放到内容布局（DrawerLayout的第一个子标签）里面就能实现这样的效果了。\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <android.support.v4.widget.DrawerLayout\n            android:id=\"@+id/drawer_layout\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\">\n\n            <!-- 正文布局 -->\n            <LinearLayout\n                android:id=\"@+id/content\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:gravity=\"center_horizontal\"\n                android:orientation=\"horizontal\">\n\n                <!-- 把toolbar放到这里，使抽屉布局层级比toolbar高 -->\n                <android.support.v7.widget.Toolbar\n                    android:id=\"@+id/toolbar\"\n                    android:background=\"#3F51B5\"\n                    android:layout_width=\"match_parent\"\n                    android:layout_height=\"?attr/actionBarSize\" />\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"content\" />\n\n            </LinearLayout>\n\n            <!-- 从左边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_left\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"left\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"left\" />\n            </LinearLayout>\n\n            <!-- 从右边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_right\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"right\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"right\" />\n            </LinearLayout>\n        </android.support.v4.widget.DrawerLayout>\n    </LinearLayout>\n```\n\n运行效果如下：\n\n{% img /DrawerLayout-学习笔记/7.jpg %}\n","source":"_posts/DrawerLayout-学习笔记.md","raw":"title: DrawerLayout 学习笔记\ndate: 2016-01-27 17:44:24\ntags:\n\t- 技术相关\n\t- Android\n---\n\nDrawerLayout的使用十分简单，使用android.support.v4.widget.DrawerLayout标签即可，DrawerLayout的第一个子标签就是正文，其他布局都是抽屉布局（默认隐藏在屏幕外）。可以使用android:layout_gravity属性指定是隐藏在屏幕的左边或者右边。\n\n## **一、使用DrawerLayout布局**\n\n把activity_main.xml修改成下面的样子，这里声明了一个LinearLayout作为正文布局（DrawerLayout的第一个子标签），和其他两个LinearLayout布局作为抽屉布局（将android:layout_gravity设置为left或者right）：\n\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <android.support.v4.widget.DrawerLayout\n            android:id=\"@+id/drawer_layout\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\">\n\n            <!-- 正文布局 -->\n            <LinearLayout\n                android:id=\"@+id/content\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:gravity=\"center_horizontal\"\n                android:orientation=\"horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"content\" />\n\n            </LinearLayout>\n\n            <!-- 从左边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_left\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"left\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"left\" />\n            </LinearLayout>\n\n            <!-- 从右边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_right\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"right\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"right\" />\n            </LinearLayout>\n        </android.support.v4.widget.DrawerLayout>\n    </LinearLayout>\n```\n\n运行之后就长这个样子，可以用手指从左边或者右边把抽屉布局拖出来：\n{% img /DrawerLayout-学习笔记/1.jpg %}\n\n{% img /DrawerLayout-学习笔记/3.jpg %}\n\n{% img /DrawerLayout-学习笔记/2.jpg %}\n\n当然也能在代码里面调用openDrawer来显示：\n```java \n    //打开左边的抽屉布局\n    drawerLayout.openDrawer(Gravity.LEFT);\n    //打开右边的抽屉布局\n    drawerLayout.openDrawer(Gravity.RIGHT);\n```\n  \n  \n## **二、使用ActionBarDrawerToggle**\nandroid提供了一个ActionBarDrawerToggle来简化DrawerLayout的操作，用法十分简单。\n1.自定义一个ToolBar（可以查看我之前的一篇博文）\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <android.support.v7.widget.Toolbar\n            android:id=\"@+id/toolbar\"\n            android:background=\"#3F51B5\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"?attr/actionBarSize\" />\n\n        <android.support.v4.widget.DrawerLayout\n            android:id=\"@+id/drawer_layout\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\">\n\n            <!-- 正文布局 -->\n            <LinearLayout\n                android:id=\"@+id/content\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:gravity=\"center_horizontal\"\n                android:orientation=\"horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"content\" />\n\n            </LinearLayout>\n\n            <!-- 从左边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_left\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"left\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"left\" />\n            </LinearLayout>\n\n            <!-- 从右边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_right\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"right\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"right\" />\n            </LinearLayout>\n        </android.support.v4.widget.DrawerLayout>\n    </LinearLayout>\n```\n\n2.在acvitity代码中创建ActionBarDrawerToggle并重写下面的方法就可以了\n- 在onPostCreate方法中调用ActionBarDrawerToggle.syncState()，如果不调用该方法，则ActionBarDrawerToggle不会显示 （onPostCreate在Activity完全加载成功之后调用，这个时候所有界面资源都已经创建和初始化完成）\n- 在onOptionsItemSelected方法中调用ActionBarDrawerToggle.onOptionsItemSelected()。（原本我以为这里是用来实现按下按钮打开和关闭抽屉布局的，但经测试，就算不调用也能正常运行。）\n```java\n    public class MainActivity extends AppCompatActivity {\n        ActionBarDrawerToggle mToggle;\n\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n\n            setContentView(R.layout.activity_main);\n\n            Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n            setSupportActionBar(toolbar);\n\n            DrawerLayout drawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);\n            mToggle = new ActionBarDrawerToggle(this, drawerLayout,toolbar,R.string.drawer_open, R.string.drawer_close);\n\n            drawerLayout.setDrawerListener(mToggle);\n        }\n\n        @Override\n        protected void onPostCreate(Bundle savedInstanceState) {\n        \t//onPostCreate在Activity完全加载成功之后调用\n            //这个时候所有界面资源都已经创建和初始化完成\n            super.onPostCreate(savedInstanceState);\n\n            //如果不调用该方法，则ActionBarDrawerToggle不会显示\n            mToggle.syncState();\n        }\n\n        @Override\n        public boolean onOptionsItemSelected(MenuItem item) {\n        \t//原本我以为这里是用来实现按下按钮打开和关闭抽屉布局的\n            //但经测试，就算不调用也能正常运行。\n            return mToggle.onOptionsItemSelected(item) || super.onOptionsItemSelected(item);\n        }\n    }\n```\n\n运行可以得到下面这效果，可以使用控制按钮来打开和关闭左边的抽屉布局，那个控制按钮还实现了一种特别酷炫的动画：\n{% img /DrawerLayout-学习笔记/4.jpg %}\n\n{% img /DrawerLayout-学习笔记/5.jpg %}\n\n{% img /DrawerLayout-学习笔记/6.jpg %}\n  \n  \n## **三、将抽屉布局的层级填到toolbar之上**\n知乎的安卓app也使用了DrawerLayout，但它的抽屉布局显示的时候是位于toolbar之上的。我们只要把toolbar标签放到内容布局（DrawerLayout的第一个子标签）里面就能实现这样的效果了。\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <android.support.v4.widget.DrawerLayout\n            android:id=\"@+id/drawer_layout\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\">\n\n            <!-- 正文布局 -->\n            <LinearLayout\n                android:id=\"@+id/content\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:gravity=\"center_horizontal\"\n                android:orientation=\"horizontal\">\n\n                <!-- 把toolbar放到这里，使抽屉布局层级比toolbar高 -->\n                <android.support.v7.widget.Toolbar\n                    android:id=\"@+id/toolbar\"\n                    android:background=\"#3F51B5\"\n                    android:layout_width=\"match_parent\"\n                    android:layout_height=\"?attr/actionBarSize\" />\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"content\" />\n\n            </LinearLayout>\n\n            <!-- 从左边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_left\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"left\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"left\" />\n            </LinearLayout>\n\n            <!-- 从右边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_right\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"right\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"right\" />\n            </LinearLayout>\n        </android.support.v4.widget.DrawerLayout>\n    </LinearLayout>\n```\n\n运行效果如下：\n\n{% img /DrawerLayout-学习笔记/7.jpg %}\n","slug":"DrawerLayout-学习笔记","published":1,"updated":"2017-05-12T23:19:13.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2ro85e900204kr4rsip87a4"},{"title":"Dagger2学习笔记(一)","date":"2017-05-12T22:53:27.000Z","_content":"\n依赖注入是一种十分好的技巧，它能解偶高层次模块和低层次模块，使得高层模块不用将底层模块硬编码到内部。\n所有依赖的底层模块都由外部注入，实际是一种面向接口编程。高层模块不依赖底层模块的实现细节，可以方便的做到替换底层模块。\n这种技术在编写跨平台程序的时候可以很容易的替换调依赖系统的底层模块，并且在做单元测试的时候也可以很容易的使用stub对象注入宿主类中从而方便宿主类的测试代码的编写。\n\n# 使用Dagger2实现依赖注入\n\n如果不使用DI框架，我们也可以在构造方法里传入依赖类或着用setter方法来将依赖类注入宿主类。但是这样的话就会需要我们在业务逻辑中处理依赖类的生成和注入，其实这些依赖的注入代码和业务都没有什么关系，仅仅是一些初始化的操作而已，如果可以将这些与业务逻辑无关的代码都独立出去，这样的话我们的代码逻辑就会更加的简洁和清晰。Dagger2就是一个十分强大的DI框架，它可以帮助我们轻松的在业务逻辑之外实现依赖注入。\n\n下面我将用一个小Demo来介绍一下Dagger2的用法。这个小Demo的功能是通过github帐号搜索用户头像和用户名，同时列出该用户的follower\n\n## Dagger2的引入\n\nDagger2没有使用反射，它是通过编译时生成代码来实现依赖注入的。所以需要引入apt:\n\n```\n//build.gradle(project)\n...\nbuildscript {\n\trepositories {\n\t\tjcenter()\n\t}\n\n\tdependencies {\n\t\tclasspath 'com.android.tools.build:gradle:2.3.0'\n\t\tclasspath 'com.neenbedankt.gradle.plugins:android-apt:1.8'\n\t}\n}\n...\n```\n\n```\n//build.gradle(app)\napply plugin: 'com.android.application'\napply plugin: 'com.neenbedankt.android-apt'\n...\n```\n\n之后再引入javax.annotation和dagger2:\n```\n//build.gradle(app)\n...\ndependencies {\n\t...\n\tcompile 'com.google.dagger:dagger:2.4'\n\tapt 'com.google.dagger:dagger-compiler:2.4'\n\tcompile 'org.glassfish:javax.annotation:10.0-b28'\n\t...\n}\n```\n\n## Dagger2的两个重要组件\n\nDagger2有两个十分重要的组件：Module和Component。\n\n- Module\n\n\tModule是依赖的提供者，Dagger2框架通过Module的Provides方法获取被依赖类的实例。\n\n- Component\n\n\tComponent是一个注入接口，Dagger2框架通过Component将依赖注入到高层类中。\n\n\t用一个形象的比喻来说明就是Module是装有被依赖类的针筒，Component是针头。Dagger2通过选择针筒和针头的不同组合可以将不同的被依赖实例注入到高层模块中。\n\n## 实现搜索页面\n\n### @Inject注解\n\n我们的搜索页面很简单，只有一个输入框和一个搜索安按钮。我们使用MVP模式去实现它,因为它不需要model层，所以只有View和Presenter:\n\n```\npublic interface SearchView {\n\t...\n}\n```\n\n```\npublic class SearchPresenter{\n\t...\n\t@Inject\n\tSearchView mSearchView;\n\n    @Inject\n    Context mContext;\n\n\t@Inject\n    public SearchPresenter() {\n        Log.d(TAG, \"SearchPresenter()\");\n    }\n\t...\n}\n```\n\n```\npublic class SearchActivity extends Activity implements SearchView {\n\t...\n\t@Inject\n\tSearchPresenter mSearchPresenter;\n\t...\n}\n```\n\n我们通过@Inject注解告诉Dagger2哪些成员变量是需要被注入的，这里需要注意的是被@Inject标注的成员变量不可以是private的，因为Dagger2没有用到反射，而是通过生成代码去完成注入的，所以一旦你将成员变量声明成private的，那Dagger2就不能访问到它，从而无法无法完成注入了。@Inject还有另外一个作用就是告诉Dagger2用哪个构造函数去创建实例，如这里Dagger2就会用SearchPresenter()去创建SearchPresenter的实例，这个构造函数的作用在接下来就会被讲到。\n\n### Module\n\n然后再让我们来看看SearchPresenterModule:\n\n```\n@Module\npublic class SearchPresenterModule {\n    private SearchActivity mSearchActivity;\n\n    public SearchPresenterModule(SearchActivity view) {\n        mSearchActivity = view;\n    }\n\n    @Provides\n    SearchView provideSearchView() {\n        return mSearchActivity;\n    }\n\n    @Provides\n    Context provideContext() {\n        return mSearchActivity;\n    }\n}\n```\n\n注入SearchPresenter所需要的SearchView和Context就是从这里提供的\n\nModule类首先需要使用@Module注解标注，让Dagger2知道这是一个Module，然后内部的使用@Provides注解标注的方法就是用来获取被依赖类的实例的方法,例如provideSearchView就可以用来提供SearchView\n\n### Component\n\n接着看看Component:\n\n```\n@Component(modules = {SearchPresenterModule.class})\npublic interface SearchComponent {\n    void inject(SearchActivity activity);\n\n    void inject(SearchPresenter presenter);\n}\n```\n\nComponent是一个被@Component注解标注的接口，Dagger2会自动生成实现这个接口的类，去完成注入的功能。我们需要用modules去告诉Component从哪个Module中获取被依赖类的实例。这里Dagger2就会自动生成实现了SearchComponent接口的DaggerSearchComponent类，它有两个方法，分别用来向SearchActivity和SearchPresenter注入依赖。\n\n向SearchPresenter注入的SearchView和Context都是SearchPresenterModule提供的这个很容易理解，但是向SearchActivity注入的SearchPresenter又是从哪里来的呢?还记得我们用@Inject标注了SearchPresenter的一个构造函数了吗？Dagger2会使用我们标注的构造函数创建出一个SearchPresenter来给SearchActivity注入使用。\n\n### 调用注入方法实现注入\n\n在SearchActivity的onCreate方法中将依赖注入到SearchActivity和SearchPresenter中:\n\n\n```\nSearchComponent component = DaggerSearchComponent.builder()\n                .searchPresenterModule(new SearchPresenterModule(this))\n                .build();\n\ncomponent.inject(this);\ncomponent.inject(mSearchPresenter);\n```\n\n它实际是通过查找SearchActivity和SearchPresenter中带有@Inject注解的成员变量知道哪个变量需要被注入，然后通过SearchPresenterModule的provide方法和SearchPresenter被标注的构造方法获取到被依赖类的实例去实现注入的。\n\n这里有一点需要注意的是调用顺序，inject(SearchActivity activity)要在inject(SearchPresenter presenter)前面调用，因为需要先将SearchActivity.this的mSearchPresenter注入，才能向mSearchPresenter中再注入SearchActivity\n\n### 指定构造函数\n\n我们在前面讲到过@Inject可以指定构造函数，其实它还有另一重意义，就是存在多个构造函数的时候选择其中一种。\n\n我们现在添加另外一种SearchPresenter构造函数,然后中添加打印:\n\n```\npublic class SearchPresenter{\n\t...\n\t@Inject\n\tSearchView mSearchView;\n\n    @Inject\n    Context mContext;\n\n\t@Inject\n    public SearchPresenter() {\n        Log.d(TAG, \"SearchPresenter()\");\n    }\n\n\tpublic SearchPresenter(Context context) {\n\t    Log.d(TAG, \"SearchPresenter(Context context)\");\n\t\tmContext = context;\n\t}\n\t...\n}\n```\n\n让我们看看运行的时候到底调的是哪个构造函数吧:\n\n> D/SearchPresenter(27333): SearchPresenter()\n\n如果我们把SearchPresenter类修改一下呢?\n\n```\npublic class SearchPresenter{\n\t...\n\t@Inject\n\tSearchView mSearchView;\n\n    // @Inject 注释掉\n    Context mContext;\n\n\t// @Inject 注释掉\n    public SearchPresenter() {\n        Log.d(TAG, \"SearchPresenter()\");\n    }\n\n\t@Inject // 添加@Inject\n\tpublic SearchPresenter(Context context) {\n\t    Log.d(TAG, \"SearchPresenter(Context context)\");\n\t\tmContext = context;\n\t}\n\t...\n}\n```\n\n现在可以看到打印:\n\n> D/SearchPresenter(27693): SearchPresenter(Context context)\n\n从打印来看，@Inject的确是可以选择构造函数的。但还有个细节不知道大家有没有注意到,我们去掉了mContext的@Inject,改由构造函数传入。这个传入构造函数的Context又是怎么来的呢？\n\n答案在SearchPresenterModule里:\n\n```\n@Module\npublic class SearchPresenterModule {\n    private SearchActivity mSearchActivity;\n\n    public SearchPresenterModule(SearchActivity view) {\n        mSearchActivity = view;\n    }\n\n    @Provides\n    SearchView provideSearchView() {\n        return mSearchActivity;\n    }\n\n\t// 是它,是它,就是它\n    @Provides\n    Context provideContext() {\n        return mSearchActivity;\n    }\n}\n```\n\n没错SearchPresenterModule.provideContext()这个方法还能创建Context出来给SearchPresenter的构造函数使用！\n","source":"_posts/Dagger2学习笔记-一.md","raw":"title: Dagger2学习笔记(一)\ndate: 2017-05-13 06:53:27\ntags:\n\t- 技术相关\n\t- Android\n---\n\n依赖注入是一种十分好的技巧，它能解偶高层次模块和低层次模块，使得高层模块不用将底层模块硬编码到内部。\n所有依赖的底层模块都由外部注入，实际是一种面向接口编程。高层模块不依赖底层模块的实现细节，可以方便的做到替换底层模块。\n这种技术在编写跨平台程序的时候可以很容易的替换调依赖系统的底层模块，并且在做单元测试的时候也可以很容易的使用stub对象注入宿主类中从而方便宿主类的测试代码的编写。\n\n# 使用Dagger2实现依赖注入\n\n如果不使用DI框架，我们也可以在构造方法里传入依赖类或着用setter方法来将依赖类注入宿主类。但是这样的话就会需要我们在业务逻辑中处理依赖类的生成和注入，其实这些依赖的注入代码和业务都没有什么关系，仅仅是一些初始化的操作而已，如果可以将这些与业务逻辑无关的代码都独立出去，这样的话我们的代码逻辑就会更加的简洁和清晰。Dagger2就是一个十分强大的DI框架，它可以帮助我们轻松的在业务逻辑之外实现依赖注入。\n\n下面我将用一个小Demo来介绍一下Dagger2的用法。这个小Demo的功能是通过github帐号搜索用户头像和用户名，同时列出该用户的follower\n\n## Dagger2的引入\n\nDagger2没有使用反射，它是通过编译时生成代码来实现依赖注入的。所以需要引入apt:\n\n```\n//build.gradle(project)\n...\nbuildscript {\n\trepositories {\n\t\tjcenter()\n\t}\n\n\tdependencies {\n\t\tclasspath 'com.android.tools.build:gradle:2.3.0'\n\t\tclasspath 'com.neenbedankt.gradle.plugins:android-apt:1.8'\n\t}\n}\n...\n```\n\n```\n//build.gradle(app)\napply plugin: 'com.android.application'\napply plugin: 'com.neenbedankt.android-apt'\n...\n```\n\n之后再引入javax.annotation和dagger2:\n```\n//build.gradle(app)\n...\ndependencies {\n\t...\n\tcompile 'com.google.dagger:dagger:2.4'\n\tapt 'com.google.dagger:dagger-compiler:2.4'\n\tcompile 'org.glassfish:javax.annotation:10.0-b28'\n\t...\n}\n```\n\n## Dagger2的两个重要组件\n\nDagger2有两个十分重要的组件：Module和Component。\n\n- Module\n\n\tModule是依赖的提供者，Dagger2框架通过Module的Provides方法获取被依赖类的实例。\n\n- Component\n\n\tComponent是一个注入接口，Dagger2框架通过Component将依赖注入到高层类中。\n\n\t用一个形象的比喻来说明就是Module是装有被依赖类的针筒，Component是针头。Dagger2通过选择针筒和针头的不同组合可以将不同的被依赖实例注入到高层模块中。\n\n## 实现搜索页面\n\n### @Inject注解\n\n我们的搜索页面很简单，只有一个输入框和一个搜索安按钮。我们使用MVP模式去实现它,因为它不需要model层，所以只有View和Presenter:\n\n```\npublic interface SearchView {\n\t...\n}\n```\n\n```\npublic class SearchPresenter{\n\t...\n\t@Inject\n\tSearchView mSearchView;\n\n    @Inject\n    Context mContext;\n\n\t@Inject\n    public SearchPresenter() {\n        Log.d(TAG, \"SearchPresenter()\");\n    }\n\t...\n}\n```\n\n```\npublic class SearchActivity extends Activity implements SearchView {\n\t...\n\t@Inject\n\tSearchPresenter mSearchPresenter;\n\t...\n}\n```\n\n我们通过@Inject注解告诉Dagger2哪些成员变量是需要被注入的，这里需要注意的是被@Inject标注的成员变量不可以是private的，因为Dagger2没有用到反射，而是通过生成代码去完成注入的，所以一旦你将成员变量声明成private的，那Dagger2就不能访问到它，从而无法无法完成注入了。@Inject还有另外一个作用就是告诉Dagger2用哪个构造函数去创建实例，如这里Dagger2就会用SearchPresenter()去创建SearchPresenter的实例，这个构造函数的作用在接下来就会被讲到。\n\n### Module\n\n然后再让我们来看看SearchPresenterModule:\n\n```\n@Module\npublic class SearchPresenterModule {\n    private SearchActivity mSearchActivity;\n\n    public SearchPresenterModule(SearchActivity view) {\n        mSearchActivity = view;\n    }\n\n    @Provides\n    SearchView provideSearchView() {\n        return mSearchActivity;\n    }\n\n    @Provides\n    Context provideContext() {\n        return mSearchActivity;\n    }\n}\n```\n\n注入SearchPresenter所需要的SearchView和Context就是从这里提供的\n\nModule类首先需要使用@Module注解标注，让Dagger2知道这是一个Module，然后内部的使用@Provides注解标注的方法就是用来获取被依赖类的实例的方法,例如provideSearchView就可以用来提供SearchView\n\n### Component\n\n接着看看Component:\n\n```\n@Component(modules = {SearchPresenterModule.class})\npublic interface SearchComponent {\n    void inject(SearchActivity activity);\n\n    void inject(SearchPresenter presenter);\n}\n```\n\nComponent是一个被@Component注解标注的接口，Dagger2会自动生成实现这个接口的类，去完成注入的功能。我们需要用modules去告诉Component从哪个Module中获取被依赖类的实例。这里Dagger2就会自动生成实现了SearchComponent接口的DaggerSearchComponent类，它有两个方法，分别用来向SearchActivity和SearchPresenter注入依赖。\n\n向SearchPresenter注入的SearchView和Context都是SearchPresenterModule提供的这个很容易理解，但是向SearchActivity注入的SearchPresenter又是从哪里来的呢?还记得我们用@Inject标注了SearchPresenter的一个构造函数了吗？Dagger2会使用我们标注的构造函数创建出一个SearchPresenter来给SearchActivity注入使用。\n\n### 调用注入方法实现注入\n\n在SearchActivity的onCreate方法中将依赖注入到SearchActivity和SearchPresenter中:\n\n\n```\nSearchComponent component = DaggerSearchComponent.builder()\n                .searchPresenterModule(new SearchPresenterModule(this))\n                .build();\n\ncomponent.inject(this);\ncomponent.inject(mSearchPresenter);\n```\n\n它实际是通过查找SearchActivity和SearchPresenter中带有@Inject注解的成员变量知道哪个变量需要被注入，然后通过SearchPresenterModule的provide方法和SearchPresenter被标注的构造方法获取到被依赖类的实例去实现注入的。\n\n这里有一点需要注意的是调用顺序，inject(SearchActivity activity)要在inject(SearchPresenter presenter)前面调用，因为需要先将SearchActivity.this的mSearchPresenter注入，才能向mSearchPresenter中再注入SearchActivity\n\n### 指定构造函数\n\n我们在前面讲到过@Inject可以指定构造函数，其实它还有另一重意义，就是存在多个构造函数的时候选择其中一种。\n\n我们现在添加另外一种SearchPresenter构造函数,然后中添加打印:\n\n```\npublic class SearchPresenter{\n\t...\n\t@Inject\n\tSearchView mSearchView;\n\n    @Inject\n    Context mContext;\n\n\t@Inject\n    public SearchPresenter() {\n        Log.d(TAG, \"SearchPresenter()\");\n    }\n\n\tpublic SearchPresenter(Context context) {\n\t    Log.d(TAG, \"SearchPresenter(Context context)\");\n\t\tmContext = context;\n\t}\n\t...\n}\n```\n\n让我们看看运行的时候到底调的是哪个构造函数吧:\n\n> D/SearchPresenter(27333): SearchPresenter()\n\n如果我们把SearchPresenter类修改一下呢?\n\n```\npublic class SearchPresenter{\n\t...\n\t@Inject\n\tSearchView mSearchView;\n\n    // @Inject 注释掉\n    Context mContext;\n\n\t// @Inject 注释掉\n    public SearchPresenter() {\n        Log.d(TAG, \"SearchPresenter()\");\n    }\n\n\t@Inject // 添加@Inject\n\tpublic SearchPresenter(Context context) {\n\t    Log.d(TAG, \"SearchPresenter(Context context)\");\n\t\tmContext = context;\n\t}\n\t...\n}\n```\n\n现在可以看到打印:\n\n> D/SearchPresenter(27693): SearchPresenter(Context context)\n\n从打印来看，@Inject的确是可以选择构造函数的。但还有个细节不知道大家有没有注意到,我们去掉了mContext的@Inject,改由构造函数传入。这个传入构造函数的Context又是怎么来的呢？\n\n答案在SearchPresenterModule里:\n\n```\n@Module\npublic class SearchPresenterModule {\n    private SearchActivity mSearchActivity;\n\n    public SearchPresenterModule(SearchActivity view) {\n        mSearchActivity = view;\n    }\n\n    @Provides\n    SearchView provideSearchView() {\n        return mSearchActivity;\n    }\n\n\t// 是它,是它,就是它\n    @Provides\n    Context provideContext() {\n        return mSearchActivity;\n    }\n}\n```\n\n没错SearchPresenterModule.provideContext()这个方法还能创建Context出来给SearchPresenter的构造函数使用！\n","slug":"Dagger2学习笔记-一","published":1,"updated":"2017-05-16T14:45:20.762Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2ro85ec00234kr4koykx3tr"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj2ro85bx00034kr46uuj46cg","tag_id":"cj2ro85c200044kr4hf935rjk","_id":"cj2ro85c500064kr4srsv3ef2"},{"post_id":"cj2ro85bx00034kr46uuj46cg","tag_id":"cj2ro85c500054kr4h3w897fn","_id":"cj2ro85c500074kr46ra0i3e7"},{"post_id":"cj2ro85c700084kr43h1ef662","tag_id":"cj2ro85c800094kr46ge704rd","_id":"cj2ro85c9000a4kr42s0h9g5f"},{"post_id":"cj2ro85ca000b4kr40kjtx1c4","tag_id":"cj2ro85c800094kr46ge704rd","_id":"cj2ro85cb000c4kr411d3y2pg"},{"post_id":"cj2ro85cc000d4kr4021vli6f","tag_id":"cj2ro85c800094kr46ge704rd","_id":"cj2ro85ce000e4kr48nfpov00"},{"post_id":"cj2ro85cf000f4kr49itwlm48","tag_id":"cj2ro85c800094kr46ge704rd","_id":"cj2ro85cg000g4kr426oxunp1"},{"post_id":"cj2ro85ci000h4kr4ii1l51im","tag_id":"cj2ro85c200044kr4hf935rjk","_id":"cj2ro85ck000j4kr4quevvr76"},{"post_id":"cj2ro85ci000h4kr4ii1l51im","tag_id":"cj2ro85ck000i4kr45lu0ve8l","_id":"cj2ro85cl000k4kr4dtrfwte9"},{"post_id":"cj2ro85cm000l4kr4j7ftelgu","tag_id":"cj2ro85c200044kr4hf935rjk","_id":"cj2ro85co000m4kr494260ddt"},{"post_id":"cj2ro85cm000l4kr4j7ftelgu","tag_id":"cj2ro85ck000i4kr45lu0ve8l","_id":"cj2ro85co000n4kr41q9k2g03"},{"post_id":"cj2ro85cp000o4kr4a1xu6vo2","tag_id":"cj2ro85c200044kr4hf935rjk","_id":"cj2ro85cs000q4kr46u7wbiyy"},{"post_id":"cj2ro85cp000o4kr4a1xu6vo2","tag_id":"cj2ro85cr000p4kr4mnfzgjh0","_id":"cj2ro85ct000r4kr43334ex65"},{"post_id":"cj2ro85cw000s4kr4zy63j0lk","tag_id":"cj2ro85c200044kr4hf935rjk","_id":"cj2ro85d0000u4kr4aflgjjbc"},{"post_id":"cj2ro85cw000s4kr4zy63j0lk","tag_id":"cj2ro85cz000t4kr48m2tyoxr","_id":"cj2ro85d0000v4kr4kui12pno"},{"post_id":"cj2ro85d2000w4kr4oju6s145","tag_id":"cj2ro85c200044kr4hf935rjk","_id":"cj2ro85d3000y4kr4l2ua3gjh"},{"post_id":"cj2ro85d2000w4kr4oju6s145","tag_id":"cj2ro85d3000x4kr4szi99axn","_id":"cj2ro85d4000z4kr4kdyuyedz"},{"post_id":"cj2ro85d700104kr4gud5v9s7","tag_id":"cj2ro85c200044kr4hf935rjk","_id":"cj2ro85d800114kr4xhw7ja0u"},{"post_id":"cj2ro85d700104kr4gud5v9s7","tag_id":"cj2ro85d3000x4kr4szi99axn","_id":"cj2ro85d900124kr4g8ajq1w1"},{"post_id":"cj2ro85db00134kr41rhubkhe","tag_id":"cj2ro85c200044kr4hf935rjk","_id":"cj2ro85dd00144kr4yencz65v"},{"post_id":"cj2ro85db00134kr41rhubkhe","tag_id":"cj2ro85d3000x4kr4szi99axn","_id":"cj2ro85de00154kr442cweh2g"},{"post_id":"cj2ro85df00164kr427xk4nna","tag_id":"cj2ro85c200044kr4hf935rjk","_id":"cj2ro85dg00184kr4izteek4i"},{"post_id":"cj2ro85df00164kr427xk4nna","tag_id":"cj2ro85dg00174kr46au2m5zm","_id":"cj2ro85dh00194kr4jkjqo1h8"},{"post_id":"cj2ro85di001a4kr4lleq9moh","tag_id":"cj2ro85c200044kr4hf935rjk","_id":"cj2ro85dj001b4kr4y4ir3p80"},{"post_id":"cj2ro85di001a4kr4lleq9moh","tag_id":"cj2ro85dg00174kr46au2m5zm","_id":"cj2ro85dj001c4kr4fwrs7msc"},{"post_id":"cj2ro85dk001d4kr4uvwdq8db","tag_id":"cj2ro85c200044kr4hf935rjk","_id":"cj2ro85dl001e4kr44gla546w"},{"post_id":"cj2ro85dk001d4kr4uvwdq8db","tag_id":"cj2ro85dg00174kr46au2m5zm","_id":"cj2ro85dl001f4kr4gpmfm7op"},{"post_id":"cj2ro85dm001g4kr49m9k6b37","tag_id":"cj2ro85c200044kr4hf935rjk","_id":"cj2ro85do001h4kr48aafmek0"},{"post_id":"cj2ro85dm001g4kr49m9k6b37","tag_id":"cj2ro85dg00174kr46au2m5zm","_id":"cj2ro85do001i4kr4o1rhh163"},{"post_id":"cj2ro85dq001j4kr4fgkszs4v","tag_id":"cj2ro85c200044kr4hf935rjk","_id":"cj2ro85dr001k4kr4me3djtfi"},{"post_id":"cj2ro85dq001j4kr4fgkszs4v","tag_id":"cj2ro85cr000p4kr4mnfzgjh0","_id":"cj2ro85dr001l4kr49653xqvg"},{"post_id":"cj2ro85dt001m4kr49oykycpb","tag_id":"cj2ro85c200044kr4hf935rjk","_id":"cj2ro85dv001n4kr401o6deh2"},{"post_id":"cj2ro85dt001m4kr49oykycpb","tag_id":"cj2ro85cr000p4kr4mnfzgjh0","_id":"cj2ro85dv001o4kr405yfwudw"},{"post_id":"cj2ro85dx001p4kr46nnl3tr3","tag_id":"cj2ro85c200044kr4hf935rjk","_id":"cj2ro85dy001r4kr4ebz56tke"},{"post_id":"cj2ro85dx001p4kr46nnl3tr3","tag_id":"cj2ro85dy001q4kr48eqmi5s1","_id":"cj2ro85dy001s4kr482y2k3h6"},{"post_id":"cj2ro85e0001t4kr4wjygcn1i","tag_id":"cj2ro85c200044kr4hf935rjk","_id":"cj2ro85e2001v4kr4d3b9wudi"},{"post_id":"cj2ro85e0001t4kr4wjygcn1i","tag_id":"cj2ro85e1001u4kr4o0oa9m77","_id":"cj2ro85e2001w4kr4a7oi7gc7"},{"post_id":"cj2ro85e3001x4kr44k2vozmb","tag_id":"cj2ro85c200044kr4hf935rjk","_id":"cj2ro85e6001y4kr4c2i61ejm"},{"post_id":"cj2ro85e3001x4kr44k2vozmb","tag_id":"cj2ro85e1001u4kr4o0oa9m77","_id":"cj2ro85e6001z4kr40hjj1e0p"},{"post_id":"cj2ro85e900204kr4rsip87a4","tag_id":"cj2ro85c200044kr4hf935rjk","_id":"cj2ro85eb00214kr4yvoh3n6e"},{"post_id":"cj2ro85e900204kr4rsip87a4","tag_id":"cj2ro85cr000p4kr4mnfzgjh0","_id":"cj2ro85eb00224kr43zk93eo4"},{"post_id":"cj2ro85ec00234kr4koykx3tr","tag_id":"cj2ro85c200044kr4hf935rjk","_id":"cj2ro85ee00244kr4uhzxilsz"},{"post_id":"cj2ro85ec00234kr4koykx3tr","tag_id":"cj2ro85cr000p4kr4mnfzgjh0","_id":"cj2ro85ee00254kr4esi86u0l"}],"Tag":[{"name":"技术相关","_id":"cj2ro85c200044kr4hf935rjk"},{"name":"设计模式","_id":"cj2ro85c500054kr4h3w897fn"},{"name":"读书笔记","_id":"cj2ro85c800094kr46ge704rd"},{"name":"Http协议","_id":"cj2ro85ck000i4kr45lu0ve8l"},{"name":"Android","_id":"cj2ro85cr000p4kr4mnfzgjh0"},{"name":"hexo","_id":"cj2ro85cz000t4kr48m2tyoxr"},{"name":"lua","_id":"cj2ro85d3000x4kr4szi99axn"},{"name":"编译相关","_id":"cj2ro85dg00174kr46au2m5zm"},{"name":"java","_id":"cj2ro85dy001q4kr48eqmi5s1"},{"name":"单元测试","_id":"cj2ro85e1001u4kr4o0oa9m77"}]}}