[{"title":"安卓存储权限原理","url":"/2023/03/12/安卓存储权限原理/","content":"上篇[博客](https://blog.islinjw.cn/2023/02/23/FileProvider%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/)介绍了FileProvider是如何跨应用访问文件的。这篇博客我们来讲讲安卓是如何控制文件的访问权限的。\n\n\n# 内部储存\n\n由于安卓基于Linux,所以最简单的文件访问权限控制方法就是使用Linux的文件权限机制.例如应用的私有目录就是这么实现的。\n\n安卓系统为每个安卓的应用都分配了一个用户和用户组,我们可以通过ps命令查看运行中的应用对应的用户:\n\n```\nUSER           PID  PPID     VSZ    RSS WCHAN            ADDR S NAME\n...\nu0_a66        2685  1085 3914640  70688 SyS_epoll_wait      0 S me.linw.demo\n...\n```\n\n这里的u0\\_a66指的是应用的user name,它表示该应用是user 0(这里指的是安卓多用户模式下的主用户,和前面讲的Linux用户不是同一个概念)下面的应用id是66.由于通应用程序的user id都是从10000开始,所以这个应用的user id是10066.可以从/data/system/packages.list文件中确认:\n\n```\nme.linw.demo 10066 1 /data/user/0/me.linw.demo default:targetSdkVersion=30 3003\n```\n\n应用的私有目录为`/data/data/${包名}/`,可以看到安卓系统给应用创建了一个权限为700的目录,文件的owner和group都只属于这个应用,这样就保证了每个应用的私有目录只有自己可以访问:\n\n```\n# ls -l /data/data/ | grep me.linw.demo\ndrwx------ 5 u0_a66 u0_a66 4096 2023-03-07 19:32 me.linw.demo\n```\n\n## SharedUserId\n\n当然也可以在AndroidManifest.xml里面配置android:sharedUserId让他们是用同一个User:\n\n```\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"me.linw.demo2\"\n    android:sharedUserId=\"test.same.user\">\n```\n\n```\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"me.linw.demo\"\n    android:sharedUserId=\"test.same.user\">\n```\n\n这样的话两个应用的user就是一样的,就能相互访问私有目录了:\n\n```\ndrwx------ 4 u0_a66 u0_a66 4096 2023-03-10 17:07 me.linw.demo2\ndrwx------ 5 u0_a66 u0_a66 4096 2023-03-10 16:53 me.linw.demo\n```\n\n# 外部存储\n\n外部存储的文件系统几经变更。从早期的FUSE到Android 8改为性能更优的SDCardFS,再到Android 11上为了更细的管理文件权限又换回FUSE。各个安卓版本的实现细节也稍有差异,过于老旧的版本也没有学习的必要,这里只拿比较有代表性的Android 8和Android 11进行源码分析。\n\n## Android 11以前\n\n安卓11以前的外部存储权限控制做的比较粗糙。应用申请了WREAD\\_EXTERNAL\\_STORAGE、WRITE\\_EXTERNAL\\_STORAGE就可以对外部存储进行读写。\n\n这个外部存储一般指的是`/storage/emulated/`目录,它为每个用户分配了一个子目录。例如`0`子目录就是user 0(主用户)的外部存储目录.\n\n这里我们用一个shellExec在进程里面执行命令协助我们理解外部存储的管理原理:\n\n```java\npublic void shellExec(String shell) throws IOException {\n    InputStream is = Runtime.getRuntime().exec(shell).getInputStream();\n    BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n    StringBuilder sb = new StringBuilder();\n    char[] buff = new char[1024];\n    int ch;\n    while ((ch = reader.read(buff)) != -1) {\n        sb.append(buff, 0, ch);\n    }\n    reader.close();\n    Log.d(\"ExecShell\", shell);\n    Log.d(\"ExecShell\", sb.toString());\n}\n```\n\n\n申请READ\\_EXTERNAL\\_STORAGE权限之后执行`ls -l /storage/emulated/0/`就可以看到熟悉的外部存储目录结构:\n\n```shell\nshellExec(\"ls -l /storage/emulated/0/\");\n\n\n03-11 17:02:26.861  3411  3411 D ExecShell: ls -l /storage/emulated/0/\n03-11 17:02:26.861  3411  3411 D ExecShell: total 40\n03-11 17:02:26.861  3411  3411 D ExecShell: drwxr-x--- 2 root everybody 4096 2022-04-24 20:25 Alarms\n03-11 17:02:26.861  3411  3411 D ExecShell: drwxr-x--- 3 root everybody 4096 2023-03-08 14:13 Android\n03-11 17:02:26.861  3411  3411 D ExecShell: drwxr-x--- 2 root everybody 4096 2022-04-24 20:25 DCIM\n03-11 17:02:26.861  3411  3411 D ExecShell: drwxr-x--- 2 root everybody 4096 2023-03-07 19:49 Download\n03-11 17:02:26.861  3411  3411 D ExecShell: drwxr-x--- 2 root everybody 4096 2022-04-24 20:25 Movies\n03-11 17:02:26.861  3411  3411 D ExecShell: drwxr-x--- 2 root everybody 4096 2022-04-24 20:25 Music\n03-11 17:02:26.861  3411  3411 D ExecShell: drwxr-x--- 2 root everybody 4096 2022-04-24 20:25 Notifications\n03-11 17:02:26.861  3411  3411 D ExecShell: drwxr-x--- 2 root everybody 4096 2023-03-07 19:46 Pictures\n03-11 17:02:26.861  3411  3411 D ExecShell: drwxr-x--- 2 root everybody 4096 2022-04-24 20:25 Podcasts\n03-11 17:02:26.861  3411  3411 D ExecShell: drwxr-x--- 2 root everybody 4096 2022-04-24 20:25 Ringtones\n```\n\n这里可以看到虽然这些目录的user是root,但是所属的group是everybody,即所有人对这些目录都有`r-x`的权限可读可进入文件夹。\n\n而如果申请了WRITE\\_EXTERNAL\\_STORAGE权限之后再执行`ls -l /storage/emulated/0/`就会看见group的权限变成了`rwx`可读可写可进入文件夹。\n\n```\n03-11 17:10:44.146  3646  3646 D ExecShell: ls -l /storage/emulated/0/\n03-11 17:10:44.146  3646  3646 D ExecShell: total 40\n03-11 17:10:44.146  3646  3646 D ExecShell: drwxrwx--- 2 root everybody 4096 2022-04-24 20:25 Alarms\n03-11 17:10:44.146  3646  3646 D ExecShell: drwxrwx--- 3 root everybody 4096 2023-03-08 14:13 Android\n...\n```\n\n也就是说不同的权限下应用看到/storage/emulated/0/的文件权限是不一样的,这一点又是怎么做的的呢?\n\n### /mnt/runtime目录\n\n\n这里先介绍/mnt/runtime下的三个目录:\n\n```shell\nmount | grep /mnt/runtime\n/data/media on /mnt/runtime/default/emulated type sdcardfs (rw,nosuid,nodev,noexec,noatime,fsuid=1023,fsgid=1023,gid=1015,multiuser,mask=6,derive_gid)\n/data/media on /mnt/runtime/read/emulated type sdcardfs (rw,nosuid,nodev,noexec,noatime,fsuid=1023,fsgid=1023,gid=9997,multiuser,mask=23,derive_gid)\n/data/media on /mnt/runtime/write/emulated type sdcardfs (rw,nosuid,nodev,noexec,noatime,fsuid=1023,fsgid=1023,gid=9997,multiuser,mask=7,derive_gid)\n```\n\n可以看到`/mnt/runtime/default/emulated`、`/mnt/runtime/read/emulated`、`/mnt/runtime/write/emulated`都挂载了`/data/media`。只不过他们的gid、和mask不尽相同。\n\n\n#### group\n\n其实这三个目录都是通过bind mount机制挂载的`/data/media`目录,gid指的是挂载之后修改文件系统下文件的group:\n\n```shell\n# ls -l /data/media\ntotal 8\ndrwxrwx--- 12 media_rw media_rw 4096 2023-03-11 16:51 0\ndrwxrwxr-x  2 media_rw media_rw 4096 1970-01-01 08:00 obb\n\n# ls -l /mnt/runtime/default/emulated\ntotal 8\ndrwxrwx--x 12 root sdcard_rw 4096 2023-03-11 16:51 0\ndrwxrwx--x  2 root sdcard_rw 4096 1970-01-01 08:00 obb\n\n# ls -l /mnt/runtime/read/emulated\ntotal 8\ndrwxr-x--- 12 root everybody 4096 2023-03-11 16:51 0\ndrwxr-x---  2 root everybody 4096 1970-01-01 08:00 obb\n\n# ls -l /mnt/runtime/write/emulated\ntotal 8\ndrwxrwx--- 12 root everybody 4096 2023-03-11 16:51 0\ndrwxrwx---  2 root everybody 4096 1970-01-01 08:00 obb\n```\n\n可以看到原本`/data/media`下的文件group是media\\_rw(id=1023),但挂载之后`/mnt/runtime/default/emulated`的group是sdcard\\_rw(id=1015),`/mnt/runtime/read/emulated`、`/mnt/runtime/write/emulated`的group是everybody(id=9997)。\n\n这些group的id可以在android\\_filesystem\\_config.h看到:\n\n```c++\n// http://androidxref.com/8.0.0_r4/xref/system/core/include/private/android_filesystem_config.h\n\n...\n#define AID_SDCARD_RW 1015       /* external storage write access */\n...\n#define AID_MEDIA_RW 1023        /* internal media storage write access */\n...\n#define AID_EVERYBODY 9997 /* shared between all apps in the same profile */\n...\n```\n\n#### mask\n\n而mask则是用来重新定义文件的rwx权限的,挂载后文件的权限通过`0775 & ~mask`计算得到(注意这里的0775指定是8进制的775,即十进制的509),所以\n\n`/mnt/runtime/default/emulated`的权限为`0775 & ~6`:\n\n```\n0775 =  111111101 = 111111101\n~6   = ~000000110 = 111111001 \n------------------------------\n                    111111001 = rwxrwx--x\n```\n\n`/mnt/runtime/read/emulated`的权限为`0775 & ~23`:\n\n```\n0775 =  111111101 = 111111101\n~23  = ~000010111 = 111101000\n------------------------------\n                    111101000 = rwxr-x---\n```\n\n`/mnt/runtime/default/emulated`的权限为`0775 & ~7`:\n\n```\n0775 =  111111101 = 111111101\n~7   = ~000000111 = 111111000\n------------------------------\n                    111111000 = rwxrwx---\n```\n\n综上所述:\n\n- 在`/mnt/runtime/default/emulated` : 普通应用由于不在media\\_rw组,只有进入子目录的权限,并不能读写。\n- 在`/mnt/runtime/read/emulated` : 普通应用属于everybody组,有r-x权限\n- 在`/mnt/runtime/default/emulated` : 普通应用属于everybody组,有rwx权限\n\n### 外部存储读写权限原理\n\n实际上外部存储路径`/storage/emulated`是通过挂载前面所说的三个目录去实现不同的访问权限的。\n\n在Zygote进程fork应用进程的时候会通过Linux的bind mount机制为应用在私有挂载空间挂载`/storage`目录:\n\n```java\n// https://cs.android.com/android/platform/superproject/+/android-8.0.0_r1:frameworks/base/core/jni/com_android_internal_os_Zygote.cpp\n\n// Create a private mount namespace and bind mount appropriate emulated\n// storage for the given user.\nstatic bool MountEmulatedStorage(uid_t uid, jint mount_mode,\n        bool force_mount_namespace) {\n    // See storage config details at http://source.android.com/tech/storage/\n\n    String8 storageSource;\n    if (mount_mode == MOUNT_EXTERNAL_DEFAULT) {\n        storageSource = \"/mnt/runtime/default\";\n    } else if (mount_mode == MOUNT_EXTERNAL_READ) {\n        storageSource = \"/mnt/runtime/read\";\n    } else if (mount_mode == MOUNT_EXTERNAL_WRITE) {\n        storageSource = \"/mnt/runtime/write\";\n    } else if (!force_mount_namespace) {\n        // Sane default of no storage visible\n        return true;\n    }\n\n    // Create a second private mount namespace for our process\n    if (unshare(CLONE_NEWNS) == -1) {\n        ALOGW(\"Failed to unshare(): %s\", strerror(errno));\n        return false;\n    }\n\n    ...\n\n    if (TEMP_FAILURE_RETRY(mount(storageSource.string(), \"/storage\",\n            NULL, MS_BIND | MS_REC | MS_SLAVE, NULL)) == -1) {\n        ALOGW(\"Failed to mount %s to /storage: %s\", storageSource.string(), strerror(errno));\n        return false;\n    }\n\n    ...\n}\n```\n\n系统根据应用的外部存储权限传入不同的mount\\_mode:\n\n- 没有权限挂载`/mnt/runtime/default`\n- 有READ\\_EXTERNAL\\_STORAGE权限挂载`/mnt/runtime/read`\n- 有WRITE\\_EXTERNAL\\_STORAGE权限挂载`/mnt/runtime/write`\n\n由于使用了unshare所以挂载的`/storage`实际是在应用的私有挂载空间,即每个应用挂载的`/storage`是仅自己可见其他应用不可见的。\n\n而这里使用了MS\\_REC参数,所以会递归挂载子目录,即:`/mnt/runtime/default`挂载到`/storage`的同时`/mnt/runtime/default/emulated`也会挂载到`/storage/emulated`\n\n### 间接挂载\n\n不过通过`mount`命令可以看到`/storage/emulated`实际上也是挂载了`/data/media`,而不是前面说的三个目录:\n\n```\n03-11 17:13:36.495  3778  3778 D ExecShell: mount\n...\n03-11 17:13:36.495  3778  3778 D ExecShell: /data/media on /storage/emulated type sdcardfs (rw,nosuid,nodev,noexec,noatime,fsuid=1023,fsgid=1023,gid=9997,multiuser,mask=7,derive_gid)\n...\n```\n\n这是由于bind mount的特性,并不能看到间接挂载的过程。例如我们可以将`/mnt/runtime/default/emulated`通过bind mount挂载到`/data/test/`,然后用`mount`命令可以看到`/data/test`也是挂载了`/data/media`:\n\n```shell\n# mount --bind /mnt/runtime/default/emulated  /data/test\n# mount | grep /data/test\n/data/media on /data/test type sdcardfs (rw,nosuid,nodev,noexec,noatime,fsuid=1023,fsgid=1023,gid=1015,multiuser,mask=6,derive_gid)\n```\n\n### 运行时权限\n\nAndroid 6之后导入了运行时权限,READ\\_EXTERNAL\\_STORAGE和WRITE\\_EXTERNAL\\_STORAGE需要在运行时申请.\n\n所以应用在第一次启动的时候还没有外部存储的权限,挂载的是`/mnt/runtime/default`.\n\n当运行时权限申请成功之后就会触发StorageManagerInternalImpl.onExternalStoragePolicyChanged然后去给这个应用重新挂载`/storage/emulated`:\n\n\n```java\n// https://cs.android.com/android/platform/superproject/+/android-8.0.0_r1:frameworks/base/services/core/java/com/android/server/StorageManagerService.java\nprivate final class StorageManagerInternalImpl extends StorageManagerInternal {\n    ...\n    @Override\n    public void onExternalStoragePolicyChanged(int uid, String packageName) {\n        final int mountMode = getExternalStorageMountMode(uid, packageName);\n        remountUidExternalStorage(uid, mountMode);\n    }\n    ...\n}\n\nprivate void remountUidExternalStorage(int uid, int mode) {\n    waitForReady();\n\n    String modeName = \"none\";\n    switch (mode) {\n        case Zygote.MOUNT_EXTERNAL_DEFAULT: {\n            modeName = \"default\";\n        } break;\n\n        case Zygote.MOUNT_EXTERNAL_READ: {\n            modeName = \"read\";\n        } break;\n\n        case Zygote.MOUNT_EXTERNAL_WRITE: {\n            modeName = \"write\";\n        } break;\n    }\n\n    try {\n        mConnector.execute(\"volume\", \"remount_uid\", uid, modeName);\n    } catch (NativeDaemonConnectorException e) {\n        Slog.w(TAG, \"Failed to remount UID \" + uid + \" as \" + modeName + \": \" + e);\n    }\n}\n```\n\n最终会调用到VolumeManager::remountUid从proc查找应用进程对应的私有挂载空间,重新根据权限挂载`/storage`:\n\n```c++\n// https://cs.android.com/android/platform/superproject/+/android-8.0.0_r1:system/vold/VolumeManager.cpp\n\nint VolumeManager::remountUid(uid_t uid, const std::string& mode) {\n    ...\n\n    if (!(dir = opendir(\"/proc\"))) {\n        PLOG(ERROR) << \"Failed to opendir\";\n        return -1;\n    }\n\n    ...\n\n    // 遍历/proc的子目录\n    while ((de = readdir(dir))) {\n        pidFd = -1;\n        nsFd = -1;\n\n        pidFd = openat(dirfd(dir), de->d_name, O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n        if (pidFd < 0) {\n            goto next;\n        }\n        if (fstat(pidFd, &sb) != 0) {\n            PLOG(WARNING) << \"Failed to stat \" << de->d_name;\n            goto next;\n        }\n\n        // 对比uid,查找uid对应的进程目录\n        if (sb.st_uid != uid) {\n            goto next;\n        }\n\n        ...\n\n        // 读取私有挂载空间的id\n        nsFd = openat(pidFd, \"ns/mnt\", O_RDONLY); // not O_CLOEXEC\n        if (nsFd < 0) {\n            PLOG(WARNING) << \"Failed to open namespace for \" << de->d_name;\n            goto next;\n        }\n\n        // 开启子进程实现并发\n        if (!(child = fork())) {\n            // 进入应用进程的私有挂载空间\n            if (setns(nsFd, CLONE_NEWNS) != 0) {\n                PLOG(ERROR) << \"Failed to setns for \" << de->d_name;\n                _exit(1);\n            }\n\n            // 解除/storage挂载\n            unmount_tree(\"/storage\");\n\n            // 根据权限挂载对应目录\n            std::string storageSource;\n            if (mode == \"default\") {\n                storageSource = \"/mnt/runtime/default\";\n            } else if (mode == \"read\") {\n                storageSource = \"/mnt/runtime/read\";\n            } else if (mode == \"write\") {\n                storageSource = \"/mnt/runtime/write\";\n            } else {\n                // Sane default of no storage visible\n                _exit(0);\n            }\n\n            //重新挂载/storage\n            if (TEMP_FAILURE_RETRY(mount(storageSource.c_str(), \"/storage\",\n                    NULL, MS_BIND | MS_REC, NULL)) == -1) {\n                PLOG(ERROR) << \"Failed to mount \" << storageSource << \" for \"\n                        << de->d_name;\n                _exit(1);\n            }\n            ...\n\n            _exit(0);\n        }\n\n        if (child == -1) {\n            PLOG(ERROR) << \"Failed to fork\";\n            goto next;\n        } else {\n            TEMP_FAILURE_RETRY(waitpid(child, nullptr, 0));\n        }\n\nnext:\n        close(nsFd);\n        close(pidFd);\n    }\n    closedir(dir);\n    return 0;\n}\n```\n\n### 缺点\n\n这种权限管理的方式比较粗犷,一旦获取了读写的权限就能对外部存储的任意目录进行读写,例如应用的外部存储路径`/storage/emulated/0/Android/data/${包名}/`:\n\n```\nshellExec(\"ls -l /storage/emulated/0/Android/data\");\n\n03-12 18:48:12.809  2934  2934 D ExecShell: ls -l /storage/emulated/0/Android/data\n03-12 18:48:12.809  2934  2934 D ExecShell: total 4\n03-12 18:48:12.809  2934  2934 D ExecShell: drwxrwx--- 3 u0_a15 everybody 4096 2023-03-12 18:47 com.android.launcher3\n```\n\n获取到读取权限之后就能对其他应用的外部存储路径进行读写了。因此一些敏感的信息一般不会写入到下面方法获取出来的路径:\n\n```java\npublic File getExternalFilesDir(String type)\npublic File[] getExternalFilesDirs(String type) \npublic File getExternalCacheDir() \npublic File[] getExternalCacheDirs() \npublic File[] getExternalMediaDirs()\n```\n\n## Android 11以后\n\n安卓11为了更好的管控外部存储的权限,废弃了READ\\_EXTERNAL\\_STORAGE和WRITE\\_EXTERNAL\\_STORAGE,使用[分区存储(Scoped Storage)](https://source.android.google.cn/docs/core/storage/scoped?hl=zh-cn)的去管理外部存储:\n\n\n```\n使用分区存储的应用可具有以下访问权限级别（实际访问权限因实现而异）。\n\n- 对自己的文件拥有读取和写入访问权限（没有权限限制）\n- 对其他应用的媒体文件拥有读取访问权限（需要具备 READ_EXTERNAL_STORAGE 权限）\n- 只有在用户直接同意的情况下，才允许对其他应用的媒体文件拥有写入访问权限（系统图库以及符合“所有文件访问权限”获取条件的应用除外）\n- 对其他应用的外部应用数据目录没有读取或写入访问权限\n```\n\n应用端具体的适配方法在网上有很多文章有提及,无非是通过MediaStore或者SAF去访问外部存储,我这边就不做介绍了。这篇博客主要介绍系统端是如何实现外部存储的权限管理的。\n\n### FUSE\n\n为了实现分区存储,前面的bind mount机制是无法做到这么细致的管理的。所以在Android 11谷歌又废弃了Android 8导入的[SDCardFS](https://source.android.google.cn/docs/core/storage/sdcardfs-deprecate?hl=zh-cn),回归[FUSE](https://www.kernel.org/doc/html/latest/filesystems/fuse.html)机制。\n\n\nFUSE是由Linux Kernel提供的一种文件系统。它的框架图如下:\n\n{% img /安卓存储权限原理/1.png %}\n\nLinux为了支持多种文件系统(如EXT4, NTFS, FAT等)抽象了一个虚拟文件系统层(VFS),FUSE就是其中的一种.\n\n从上面的框架图可以看到,在用户空间会有一个FUSE daemon进程监听对FUSE文件系统的操作,然后对其进行转发给到其他的文件系统。\n\n由于是在FUSE是kernel提供的机制,所以无论应用是通过java还是native方法去操作的文件,安卓都可以在FUSE daemon对文件的操作请求进行权限鉴别和拦截。\n\n\n### FUSE daemon\n\n例如使用FileOutputStream在外部存储创建文件的时候会回调到FuseDaemon的pf\\_create:\n\n```c++\n// https://cs.android.com/android/platform/superproject/+/android-mainline-11.0.0_r1:packages/providers/MediaProvider/jni/FuseDaemon.cpp\nstatic void pf_create(fuse_req_t req,\n                      fuse_ino_t parent,\n                      const char* name,\n                      mode_t mode,\n                      struct fuse_file_info* fi) {\n      ...\n      if (!is_app_accessible_path(fuse->mp, parent_path, req->ctx.uid)) {\n          fuse_reply_err(req, ENOENT);\n          return;\n      }\n  \n      TRACE_NODE(parent_node, req);\n  \n      const string child_path = parent_path + \"/\" + name;\n  \n      int mp_return_code = fuse->mp->InsertFile(child_path.c_str(), req->ctx.uid);\n      if (mp_return_code) {\n          fuse_reply_err(req, mp_return_code);\n          return;\n      }\n\n      ...\n      // Let MediaProvider know we've created a new file\n      fuse->mp->OnFileCreated(child_path);\n      ...\n}\n```\n\n从代码上我们看到首先它会调用is\\_app\\_accessible\\_path去判断应用的访问权限:\n\n```c++\nconst std::regex PATTERN_OWNED_PATH(\n    \"^/storage/[^/]+/(?:[0-9]+/)?Android/(?:data|obb|sandbox)/([^/]+)(/?.*)?\",\n    std::regex_constants::icase);\n\nstatic bool is_app_accessible_path(MediaProviderWrapper* mp, const string& path, uid_t uid) {\n  // 系统权限的应用会被允许访问, FuseDaemon进程自己也允许访问\n  if (uid < AID_APP_START || uid == MY_UID) {\n      return true;\n  }\n\n  //应用不能直接访问/storage/emulated,只能访问它的子目录,例如/storage/emulated/0\n  if (path == \"/storage/emulated\") {\n      return false;\n  }\n\n  std::smatch match;\n  if (std::regex_match(path, match, PATTERN_OWNED_PATH)) {\n      const std::string& pkg = match[1];\n      ...\n      if (!mp->IsUidForPackage(pkg, uid)) {\n          // /storage/emulated/0/Andrdoi/data/${包名} 这样的目录不允许其他应用访问\n          PLOG(WARNING) << \"Invalid other package file access from \" << pkg << \"(: \" << path;\n          return false;\n      }\n  }\n  return true;\n}\n```\n\n然后会调用fuse->mp->InsertFile去通过jni回调到java层的MediaProvider.insertFileIfNecessaryForFuse去插入文件:\n\n```c++\n// https://cs.android.com/android/platform/superproject/+/android-mainline-11.0.0_r1:packages/providers/MediaProvider/jni/MediaProviderWrapper.cpp\nint MediaProviderWrapper::InsertFile(const string& path, uid_t uid) {\n    ...\n    return insertFileInternal(env, media_provider_object_, mid_insert_file_, path, uid);\n}\n\nint insertFileInternal(JNIEnv* env, jobject media_provider_object, jmethodID mid_insert_file,\n                       const string& path, uid_t uid) {\n    ScopedLocalRef<jstring> j_path(env, env->NewStringUTF(path.c_str()));\n    int res = env->CallIntMethod(media_provider_object, mid_insert_file, j_path.get(), uid);\n    ...\n}\n\nMediaProviderWrapper::MediaProviderWrapper(JNIEnv* env, jobject media_provider) {\n    ...\n    media_provider_class_ = env->FindClass(\"com/android/providers/media/MediaProvider\");\n    ...\n    mid_insert_file_ = CacheMethod(env, \"insertFileIfNecessary\", \"(Ljava/lang/String;I)I\",\n                               /*is_static*/ false);\n    ...\n}\n\njmethodID MediaProviderWrapper::CacheMethod(JNIEnv* env, const char method_name[],\n                                            const char signature[], bool is_static) {\n    jmethodID mid;\n    string actual_method_name(method_name);\n    actual_method_name.append(\"ForFuse\");\n    if (is_static) {\n        mid = env->GetStaticMethodID(media_provider_class_, actual_method_name.c_str(), signature);\n    } else {\n        mid = env->GetMethodID(media_provider_class_, actual_method_name.c_str(), signature);\n    }\n    ...\n}\n```\n\n### 目录隔离\n\ninsertFileIfNecessaryForFuse会通过文件的后缀解析出mimeType(例如.jpg就是图片类型,.mp4就是视频类型),然后创建contentUri调用insertFileForFuse:\n\n```java\n// https://cs.android.com/android/platform/superproject/+/android-mainline-11.0.0_r1:packages/providers/MediaProvider/src/com/android/providers/media/MediaProvider.java\npublic int insertFileIfNecessaryForFuse(@NonNull String path, int uid) {\n    ...\n    final String mimeType = MimeUtils.resolveMimeType(new File(path));\n    ...\n    final Uri contentUri = getContentUriForFile(path, mimeType);\n    final Uri item = insertFileForFuse(path, contentUri, mimeType, /*useData*/ false);\n    if (item == null) {\n        return OsConstants.EPERM;\n    }\n  ...\n}\n\nprivate Uri insertFileForFuse(@NonNull String path, @NonNull Uri uri, @NonNull String mimeType,\n            boolean useData) {\n    ContentValues values = new ContentValues();\n    values.put(FileColumns.OWNER_PACKAGE_NAME, getCallingPackageOrSelf());\n    values.put(MediaColumns.MIME_TYPE, mimeType);\n    values.put(FileColumns.IS_PENDING, 1);\n\n    if (useData) {\n        values.put(FileColumns.DATA, path);\n    } else {\n        values.put(FileColumns.VOLUME_NAME, extractVolumeName(path));\n        values.put(FileColumns.RELATIVE_PATH, extractRelativePath(path));\n        values.put(FileColumns.DISPLAY_NAME, extractDisplayName(path));\n    }\n    return insert(uri, values, Bundle.EMPTY);\n}\n```\ninsert里面会对文件类型和存放的路径做校验,也就是说外部存储公共目录下只能存放特定类型的文件,例如Movies下只能放视频文件、Music下只能放音频文件、Pictures下只能放图片文件等。你不能将png的图片放到`/storage/emulated/0/Movies`下:\n\n```shell\n03-14 19:48:04.683  1774  2181 E MediaProvider: java.lang.IllegalArgumentException: MIME type image/png cannot be inserted into content://media\n/external_primary/video/media; expected MIME type under video/*\n```\n\n这个校验是在insert里面调用ensureFileColumns方法去检查的:\n\n```java\n// https://cs.android.com/android/platform/superproject/+/android-mainline-11.0.0_r1:packages/providers/MediaProvider/src/com/android/providers/media/MediaProvider.java\nprivate void ensureFileColumns(int match, @NonNull Uri uri, @NonNull Bundle extras,\n        @NonNull ContentValues values, boolean makeUnique, @Nullable String currentPath)\n        throws VolumeArgumentException, VolumeNotFoundException {\n  ...\n  else if (defaultMediaType != actualMediaType) {\n      final String[] split = defaultMimeType.split(\"/\");\n      throw new IllegalArgumentException(\n              \"MIME type \" + mimeType + \" cannot be inserted into \" + uri\n                      + \"; expected MIME type under \" + split[0] + \"/*\");\n  }\n  ...\n}\n```\n\n而像`/storage/emulated/0/Android/media/${包名}`这样的外部媒体私有路径也会被拦截下来:\n\n```\n03-14 20:11:49.541  1774  2038 E MediaProvider: java.lang.IllegalArgumentException: Primary directory Android not allowed for content://media/external_primary/file; allowed directories are [Download, Documents]\n```\n\n它同样是在ensureFileColumns里面拦截的:\n\n```java\n// https://cs.android.com/android/platform/superproject/+/android-mainline-11.0.0_r1:packages/providers/MediaProvider/src/com/android/providers/media/MediaProvider.java\nprivate void ensureFileColumns(int match, @NonNull Uri uri, @NonNull Bundle extras,\n        @NonNull ContentValues values, boolean makeUnique, @Nullable String currentPath)\n        throws VolumeArgumentException, VolumeNotFoundException {\n    ...\n    // Consider allowing external media directory of calling package\n    if (!validPath) {\n        final String pathOwnerPackage = extractPathOwnerPackageName(res.getAbsolutePath());\n        if (pathOwnerPackage != null) {\n            validPath = isExternalMediaDirectory(res.getAbsolutePath()) &&\n                  isCallingIdentitySharedPackageName(pathOwnerPackage);\n        }\n    }\n    ...\n    if (!validPath) {\n        throw new IllegalArgumentException(\n              \"Primary directory \" + primary + \" not allowed for \" + uri\n                      + \"; allowed directories are \" + allowedPrimary);\n    }\n    ...\n}\n\nprivate boolean isExternalMediaDirectory(@NonNull String path) {\n    final String relativePath = extractRelativePath(path);\n    if (relativePath != null) {\n        return relativePath.startsWith(\"Android/media\");\n    }\n    return false;\n}\n```\n\n```java\n// https://cs.android.com/android/platform/superproject/+/android-mainline-11.0.0_r1:packages/providers/MediaProvider/src/com/android/providers/media/util/FileUtils.java\npublic static final Pattern PATTERN_OWNED_PATH = Pattern.compile(\n        \"(?i)^/storage/[^/]+/(?:[0-9]+/)?\"\n        + PROP_CROSS_USER_ROOT_PATTERN\n        + \"Android/(?:data|media|obb)/([^/]+)(/?.*)?\");\n\npublic static @Nullable String extractPathOwnerPackageName(@Nullable String path) {\n    if (path == null) return null;\n    final Matcher m = PATTERN_OWNED_PATH.matcher(path);\n    if (m.matches()) {\n        return m.group(1);\n    }\n    return null;\n}\n```\n\n从上面的错误日志可以看出来Download, Documents是公共目录。实际上这两个目录不会检查文件类型,可以存放所有类型的文件。\n\n\n### 媒体数据库\n\n另外我们看到insertFileForFuse里面会创建ContentValues去调用insert,这里的代码其实和应用层使用[MediaStore](https://developer.android.com/reference/android/provider/MediaStore)去访问外部存储基本一致了。\n\ninsert的意思实际上是插入到MediaProvider数据库,所以我们可以从MediaProvider数据库通过文件类型查找文件(例如音乐播放器可以通过MediaProvider查找到手机上的所有音频文件):\n\n```java\n// https://cs.android.com/android/platform/superproject/+/android-mainline-11.0.0_r1:packages/providers/MediaProvider/src/com/android/providers/media/MediaProvider.java\npublic @Nullable Uri insert(@NonNull Uri uri, @Nullable ContentValues values,\n        @Nullable Bundle extras) {\n    ...\n    return insertInternal(uri, values, extras);\n    ...\n}\n\nprivate @Nullable Uri insertInternal(@NonNull Uri uri, @Nullable ContentValues initialValues,\n            @Nullable Bundle extras) throws FallbackException {\n    ...\n    final SQLiteQueryBuilder qb = getQueryBuilder(TYPE_INSERT, match, uri, extras, null);\n    ...\n    switch (match) {\n        case IMAGES_MEDIA: {\n            ..\n            newUri = insertFile(qb, helper, match, uri, extras, initialValues,\n                    FileColumns.MEDIA_TYPE_IMAGE);\n            break;\n        }\n\n        case IMAGES_THUMBNAILS: {\n            ...\n\n            rowId = qb.insert(helper, initialValues);\n            if (rowId > 0) {\n                newUri = ContentUris.withAppendedId(Images.Thumbnails.\n                        getContentUri(originalVolumeName), rowId);\n            }\n            break;\n        }\n\n        case VIDEO_THUMBNAILS: {\n            ...\n\n            rowId = qb.insert(helper, initialValues);\n            if (rowId > 0) {\n                newUri = ContentUris.withAppendedId(Video.Thumbnails.\n                        getContentUri(originalVolumeName), rowId);\n            }\n            break;\n        }\n\n        case AUDIO_MEDIA: {\n            ...\n            newUri = insertFile(qb, helper, match, uri, extras, initialValues,\n                    FileColumns.MEDIA_TYPE_AUDIO);\n            break;\n        }\n        ...\n    }\n    ...\n}\n\nprivate Uri insertFile(@NonNull SQLiteQueryBuilder qb, @NonNull DatabaseHelper helper,\n        int match, @NonNull Uri uri, @NonNull Bundle extras, @NonNull ContentValues values,\n        int mediaType) throws VolumeArgumentException, VolumeNotFoundException {\n    ...\n    rowId = insertAllowingUpsert(qb, helper, values, path);\n    ...\n}\n\n\nprivate long insertAllowingUpsert(@NonNull SQLiteQueryBuilder qb,\n        @NonNull DatabaseHelper helper, @NonNull ContentValues values, String path)\n        throws SQLiteConstraintException {\n    return helper.runWithTransaction((db) -> {\n        ...\n        return qb.insert(helper, values);\n        ...\n    }\n}\n```\n\n\n### 文件隔离\n\n虽然前面讲到Download, Document是公共目录,谁都可以往里面写入文件。但是正常情况下普通应用只能读取自己写入的问题,没有权限读取其他应用写入的文件:\n\n```\n1774  2181 E MediaProvider: Permission to access file: //storage/emulated/0/Download/OtherAppFile.txt is denied\n```\n这是因为打开文件的时候会触发到FuseDaemon的pf\\_open:\n\n```c++\nstatic void pf_open(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info* fi) {\n  ...\n  std::unique_ptr<FileOpenResult> result = fuse->mp->OnFileOpen(\n            build_path, io_path, ctx->uid, ctx->pid, node->GetTransformsReason(), for_write,\n            !for_write /* redact */, true /* log_transforms_metrics */);\n  ...\n}\n```\n\n最终去到MediaProvider.onFileOpenForFuse在里面调用checkAccess检查访问权限:\n\n```java\npublic FileOpenResult onFileOpenForFuse(String path, String ioPath, int uid, int tid,\n        int transformsReason, boolean forWrite, boolean redact, boolean logTransformsMetrics) {\n  ...\n  try {\n    ...\n    checkAccess(fileUri, Bundle.EMPTY, file, forWrite);\n    ...\n  } catch (IllegalStateException | SecurityException e) {\n      Log.e(TAG, \"Permission to access file: \" + path + \" is denied\");\n      return new FileOpenResult(OsConstants.EACCES /* status */, originalUid,\n              mediaCapabilitiesUid, new long[0]);\n  } \n  ...\n}\n```\n\ncheckAccess最终最一堆的权限检查,如果没有符合的就抛出SecurityException异常:\n\n```java\nprivate void checkAccess(@NonNull Uri uri, @NonNull Bundle extras, @NonNull File file,\n        boolean isWrite) throws FileNotFoundException {\n    enforceCallingPermission(uri, extras, isWrite);\n    ...\n}\n\nprivate void enforceCallingPermission(@NonNull Uri uri, @NonNull Bundle extras,\n        boolean forWrite) {\n    ...\n    enforceCallingPermissionInternal(uri, extras, forWrite);\n    ...\n}\n\nprivate void enforceCallingPermissionInternal(@NonNull Uri uri, @NonNull Bundle extras,\n            boolean forWrite) {\n    ...\n    if (checkCallingPermissionGlobal(uri, forWrite)) {\n        // Access allowed, yay!\n        return;\n    }\n    ...\n    throw new SecurityException(getCallingPackageOrSelf() + \" has no access to \" + uri);\n}\n\n```\n其中checkCallingPermissionGlobal会检测android.permission.MANAGE\\_EXTERNAL\\_STORAGE权限,也就是文件管理器可以读取外部存储的所有公有文件的原理(例如`Android/data/${包名}`下的文件在前面的判断里面会跳出所以还是不能访问):\n\n```java\nprivate boolean checkCallingPermissionGlobal(Uri uri, boolean forWrite) {\n    ...\n    // Apps that have permission to manage external storage can work with all files\n    if (isCallingPackageManager()) {\n        return true;\n    }\n    ...\n}\n```\n\n开启文件管理器权限需要:\n\n1. 在AndroidManifest.xml声明android.permission.MANAGE\\_EXTERNAL\\_STORAGE权限\n2. 使用Settings.ACTION\\_MANAGE\\_ALL\\_FILES\\_ACCESS\\_PERMISSION启动设置页面让用户手动打开该应用的文件管理权限:\n\n```java\nIntent intent = new Intent(Settings.ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION);\nstartActivity(intent);\n```\n\n","tags":["技术相关","Android"]},{"title":"FileProvider的一些事","url":"/2023/02/23/FileProvider的一些事/","content":"\n高版本的android对文件权限的管控抓的很严格,理论上两个应用之间的文件传递现在都应该是用FileProvider去实现,这篇博客来一起了解下它的实现原理。\n\n首先我们要明确一点,FileProvider就是一个ContentProvider,所以需要在AndroidManifest.xml里面对它进行声明:\n\n```\n<provider\n    android:name=\"androidx.core.content.FileProvider\"\n    android:authorities=\"me.linjw.demo.fileprovider.provider\"\n    android:exported=\"false\"\n    android:grantUriPermissions=\"true\">\n    <meta-data\n        android:name=\"android.support.FILE_PROVIDER_PATHS\"\n        android:resource=\"@xml/file_path\" />\n</provider>\n```\n\n和普通的ContentProvider不一样的是他多了一个android.support.FILE\\_PROVIDER\\_PATHS的meta-data指定了一个xml资源:\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<paths xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <root-path name=\"root\" path=\"\" />\n    <files-path name=\"files\" path=\"images/\" />\n    <cache-path name=\"cache\" path=\"\" />\n    <external-path name=\"external\" path=\"\" />\n    <external-files-path  name=\"external-files\" path=\"\" />\n    <external-cache-path name=\"external-cache\" path=\"\" />\n    <external-media-path name=\"external-media\" path=\"\" />\n</paths>\n```\n\n# 文件URI\n\n这个xml的作用在于为文件生成URI,root-path、files-path、cache-path这些标签代表父路径:\n\n- root-path : File(\"/\")\n- files-path : Context.getFilesDir()\n- cache-path : context.getCacheDir()\n- external-path : Environment.getExternalStorageDirectory()\n- external-files-path : ContextCompat.getExternalFilesDirs(context, null)[0]\n- external-cache-path :  ContextCompat.getExternalCacheDirs(context)[0]\n- external-media-path :  context.getExternalMediaDirs()[0]\n\npath属性代表子路径,name代表为\"父路径/子路径\"起的名字,\n\n```\n<files-path name=\"files\" path=\"images/\" />\n```\n\n例如上面配置代表的就是我们为 new File(context.getFilesDir(), \"images/\") 这个路径起了个名字叫做files\n\n```\nval filesDir = File(context.getFilesDir(), \"images/\")\nval uri = FileProvider.getUriForFile(this, \"me.linjw.demo.fileprovider.provider\", File(filesDir, \"test.jpg\"))\n// uri就是把filesDir的路径转换\"files\",然后加上content://me.linjw.demo.fileprovider.provider\n// 即 \"content://me.linjw.demo.fileprovider.provider/files/test.jpg\"\n```\n\n从FileProvider的源码里面就能看到这部分的转换逻辑:\n\n```\nprivate static final String TAG_ROOT_PATH = \"root-path\";\nprivate static final String TAG_FILES_PATH = \"files-path\";\nprivate static final String TAG_CACHE_PATH = \"cache-path\";\nprivate static final String TAG_EXTERNAL = \"external-path\";\nprivate static final String TAG_EXTERNAL_FILES = \"external-files-path\";\nprivate static final String TAG_EXTERNAL_CACHE = \"external-cache-path\";\nprivate static final String TAG_EXTERNAL_MEDIA = \"external-media-path\";\n\n...\n\nint type;\nwhile ((type = in.next()) != END_DOCUMENT) {\n    if (type == START_TAG) {\n        final String tag = in.getName();\n\n        final String name = in.getAttributeValue(null, ATTR_NAME);\n        String path = in.getAttributeValue(null, ATTR_PATH);\n\n        File target = null;\n        if (TAG_ROOT_PATH.equals(tag)) {\n            target = DEVICE_ROOT;\n        } else if (TAG_FILES_PATH.equals(tag)) {\n            target = context.getFilesDir();\n        } else if (TAG_CACHE_PATH.equals(tag)) {\n            target = context.getCacheDir();\n        } else if (TAG_EXTERNAL.equals(tag)) {\n            target = Environment.getExternalStorageDirectory();\n        } else if (TAG_EXTERNAL_FILES.equals(tag)) {\n            File[] externalFilesDirs = ContextCompat.getExternalFilesDirs(context, null);\n            if (externalFilesDirs.length > 0) {\n                target = externalFilesDirs[0];\n            }\n        } else if (TAG_EXTERNAL_CACHE.equals(tag)) {\n            File[] externalCacheDirs = ContextCompat.getExternalCacheDirs(context);\n            if (externalCacheDirs.length > 0) {\n                target = externalCacheDirs[0];\n            }\n        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP\n                && TAG_EXTERNAL_MEDIA.equals(tag)) {\n            File[] externalMediaDirs = context.getExternalMediaDirs();\n            if (externalMediaDirs.length > 0) {\n                target = externalMediaDirs[0];\n            }\n        }\n\n        if (target != null) {\n            strat.addRoot(name, buildPath(target, path));\n        }\n    }\n}\n\n...\n\nprivate static File buildPath(File base, String... segments) {\n    File cur = base;\n    for (String segment : segments) {\n        if (segment != null) {\n            cur = new File(cur, segment);\n        }\n    }\n    return cur;\n}\n```\n\n查询的时候就只需要从strat里面找到文件路径最匹配的name即可。\n\n# 打开文件\n\n有了这个uri之后我们就能通过Intent将它传给其他应用,并配置Intent.FLAG\\_GRANT\\_READ\\_URI\\_PERMISSION或者Intent.FLAG\\_GRANT\\_WRITE\\_URI\\_PERMISSION为其他应用设置读写权限:\n\n```\nval uri = FileProvider.getUriForFile(this, \"me.linjw.demo.fileprovider.provider\", file)\nval intent = Intent()\nintent.data = uri\nintent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)\nintent.setClassName(\"me.linjw.demo.fileprovider.recv\", \"me.linjw.demo.fileprovider.recv.MainActivity\")\nstartActivity(intent)\n```\n\n其他应用拿到这个uri就可以通过ContentResolver.openInputStream打开文件流:\n\n```\nval inputStream = intent.data?.let { contentResolver.openInputStream(it) }\n```\n\n或者有时候我们希望通过String传递uri的时候可以提前使用Context.grantUriPermission为指定的包名申请权限,然后接收端Uri.parse去解析出Uri来操作文件:\n\n\n```\n// 发送端\nval uri = FileProvider.getUriForFile(this, \"me.linjw.demo.fileprovider.provider\", file)\ngrantUriPermission(\"me.linjw.demo.fileprovider.recv\", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION)\n\nval intent = Intent()\nintent.putExtra(\"uri\", uri.toString())\nintent.setClassName(\"me.linjw.demo.fileprovider.recv\", \"me.linjw.demo.fileprovider.recv.MainActivity\")\nstartActivity(intent)\n\n// 接收端\nval uri = Uri.parse(intent.getStringExtra(\"uri\"))\nval inputStream = contentResolver.openInputStream(uri)\n```\n\nUri操作文件的原理实际上就是通过请求我们之前声明的me.linjw.demo.fileprovider.provider这个ContentProvider,让它给我们去打开文件:\n\n```\n// FileProvider.java\npublic ParcelFileDescriptor openFile(@NonNull Uri uri, @NonNull String mode)\n        throws FileNotFoundException {\n    // ContentProvider has already checked granted permissions\n    final File file = mStrategy.getFileForUri(uri);\n    final int fileMode = modeToMode(mode);\n    return ParcelFileDescriptor.open(file, fileMode);\n}\n```\n\n也就是说文件权限的校验实际上只发生在打开的阶段.其他应用虽然没有权限打开我们的文件,但是我们可以在ContentProvider里面帮它打开然后返回文件描述符,给其他应用去读写。\n\n{% plantuml %}\nAPP1 -> APP2 : 文件uri\nAPP2 -> APP1 : ContentProvider.openFile\nAPP1 -> APP2 : ParcelFileDescriptor\nAPP2 -> File : 使用ParcelFileDescriptor打开APP1的文件进行读写\n{% endplantuml %}\n\n# 系统应用使用FileProvider的坑\n\n项目中有个系统应用需要向其他应用传的文件,于是把FileProvider加上,然后发现其他应用还是没有权限。从日志里面看是说这个FileProvider并没有从UID 1000里暴露出来:\n\n```\n02-13 06:52:28.921  4292  4292 E AndroidRuntime: Caused by: java.lang.SecurityException: Permission Denial: opening provider androidx.core.content.FileProvider from ProcessRecord{806d30d 4292:me.linjw.demo.fileprovider.recv/u0a53} (pid=4292, uid=10053) that is not exported from UID 1000\n```\n\n由于这个UID 1000太显眼，所以尝试将系统签名去掉发现权限就正常了,实锤是系统签名的原因。\n\n查看出现异常的时候的日志,发现了下面的打印: \n\n```\n02-13 06:52:28.486   863  1393 W UriGrantsManagerService: For security reasons, the system cannot issue a Uri permission grant to content://me.linjw.demo.fileprovider.provider/root/data/user/0/me.linjw.demo.fileprovider/files/test.txt [user 0]; use startActivityAsCaller() instead\n```\n\n在代码里面搜索关键字,发现系统应用需要在源码里面配置FileProvider的authorities:\n\n```\n// https://cs.android.com/android/platform/superproject/+/android-13.0.0_r29:frameworks/base/services/core/java/com/android/server/uri/UriGrantsManagerService.java\n\n// Bail early if system is trying to hand out permissions directly; it\n// must always grant permissions on behalf of someone explicit.\nfinal int callingAppId = UserHandle.getAppId(callingUid);\nif ((callingAppId == SYSTEM_UID) || (callingAppId == ROOT_UID)) {\n    if (\"com.android.settings.files\".equals(grantUri.uri.getAuthority())\n            || \"com.android.settings.module_licenses\".equals(grantUri.uri.getAuthority())) {\n        // Exempted authority for\n        // 1. cropping user photos and sharing a generated license html\n        //    file in Settings app\n        // 2. sharing a generated license html file in TvSettings app\n        // 3. Sharing module license files from Settings app\n    } else {\n        Slog.w(TAG, \"For security reasons, the system cannot issue a Uri permission\"\n                + \" grant to \" + grantUri + \"; use startActivityAsCaller() instead\");\n        return -1;\n    }\n}\n```\n\n# 直接传递ParcelFileDescriptor\n\n从原理上看FileProvider实际就是打开文件的ParcelFileDescriptor传给其他应用使用,那我们能不能直接打开文件然后将ParcelFileDescriptor直接通过Intent传给其他应用呢?\n\n```\nval intent = Intent()\nintent.putExtra(\"fd\" , ParcelFileDescriptor.open(file, MODE_READ_ONLY))\nintent.setClassName(\"me.linjw.demo.fileprovider.recv\", \"me.linjw.demo.fileprovider.recv.MainActivity\")\nstartActivity(intent)\n```\n\n答案是不行:\n\n```\n02-15 20:27:24.200 16968 16968 E AndroidRuntime: Process: me.linjw.demo.fileprovider, PID: 16968\n02-15 20:27:24.200 16968 16968 E AndroidRuntime: java.lang.RuntimeException: Not allowed to write file descriptors here                        \n02-15 20:27:24.200 16968 16968 E AndroidRuntime:        at android.os.Parcel.nativeWriteFileDescriptor(Native Method)\n02-15 20:27:24.200 16968 16968 E AndroidRuntime:        at android.os.Parcel.writeFileDescriptor(Parcel.java:922)\n02-15 20:27:24.200 16968 16968 E AndroidRuntime:        at android.os.ParcelFileDescriptor.writeToParcel(ParcelFileDescriptor.java:1110)\n02-15 20:27:24.200 16968 16968 E AndroidRuntime:        at android.os.Parcel.writeParcelable(Parcel.java:1953)\n02-15 20:27:24.200 16968 16968 E AndroidRuntime:        at android.os.Parcel.writeValue(Parcel.java:1859)\n02-15 20:27:24.200 16968 16968 E AndroidRuntime:        at android.os.Parcel.writeArrayMapInternal(Parcel.java:1024)\n02-15 20:27:24.200 16968 16968 E AndroidRuntime:        at android.os.BaseBundle.writeToParcelInner(BaseBundle.java:1620)\n02-15 20:27:24.200 16968 16968 E AndroidRuntime:        at android.os.Bundle.writeToParcel(Bundle.java:1304)\n02-15 20:27:24.200 16968 16968 E AndroidRuntime:        at android.os.Parcel.writeBundle(Parcel.java:1093)\n02-15 20:27:24.200 16968 16968 E AndroidRuntime:        at android.content.Intent.writeToParcel(Intent.java:11123)\n02-15 20:27:24.200 16968 16968 E AndroidRuntime:        at android.app.IActivityTaskManager$Stub$Proxy.startActivity(IActivityTaskManager.java:\n2298)\n```\n\n原因在于Instrumentation的execStartActivity启动Activity前会调用Intent.prepareToLeaveProcess最终调用到Bundle.setAllowFds(false)不允许传递ParcelFileDescriptor:\n\n```\n// https://cs.android.com/android/platform/superproject/+/android-13.0.0_r29:frameworks/base/core/java/android/app/Instrumentation.java\npublic ActivityResult execStartActivity(\n        Context who, IBinder contextThread, IBinder token, Activity target,\n        Intent intent, int requestCode, Bundle options) {\n    ...\n    intent.prepareToLeaveProcess(who);\n    ...\n}\n\n\n// https://cs.android.com/android/platform/superproject/+/android-13.0.0_r29:frameworks/base/core/java/android/content/Intent.java\npublic void prepareToLeaveProcess(Context context) {\n    final boolean leavingPackage;\n    if (mComponent != null) {\n        leavingPackage = !Objects.equals(mComponent.getPackageName(), context.getPackageName());\n    } else if (mPackage != null) {\n        leavingPackage = !Objects.equals(mPackage, context.getPackageName());\n    } else {\n        leavingPackage = true;\n    }\n    prepareToLeaveProcess(leavingPackage);\n}\n\n/**\n * Prepare this {@link Intent} to leave an app process.\n *\n * @hide\n */\npublic void prepareToLeaveProcess(boolean leavingPackage) {\n    setAllowFds(false);\n    ...\n}\n\npublic void setAllowFds(boolean allowFds) {\n    if (mExtras != null) {\n        mExtras.setAllowFds(allowFds);\n    }\n}\n```\n\n一开始我想通过反射去强行调用setAllowFds(true),但是发现这个方法被限制了,需要系统权限才能调用:\n\n```\nAccessing hidden method Landroid/os/Bundle;->setAllowFds(Z)Z (max-target-o, reflection, denied)\n```\n\n只能另谋出路,由于ParcelFileDescriptor实现了Parcelable,所以我们可以通过传递Binder的方式迂回的去传递:\n\n```\n// aidl\ninterface IFileDescriptorsProvider {\n    ParcelFileDescriptor get();\n}\n\n// 发送端\nval fileProvider = object : IFileDescriptorsProvider.Stub() {\n    override fun get(): ParcelFileDescriptor {\n        return ParcelFileDescriptor.open(file, MODE_READ_ONLY)\n    }\n}\nval intent = Intent()\nval bundle = Bundle().apply { putBinder(\"fileProvider\", fileProvider) }\nintent.putExtras(bundle)\nintent.setClassName(\"me.linjw.demo.fileprovider.recv\", \"me.linjw.demo.fileprovider.recv.MainActivity\")\nstartActivity(intent)\n\n// 接收端\nval text = intent.extras?.getBinder(\"fileProvider\")?.let { it ->\n    val fd = IFileDescriptorsProvider.Stub.asInterface(it).get()\n    AssetFileDescriptor(fd, 0, -1)\n        .createInputStream()\n        .use { it.bufferedReader().readLine() }\n}\n```\n","tags":["技术相关","Android"]},{"title":"记一个线程阻塞问题的分析过程","url":"/2022/12/29/记一个线程阻塞问题的分析过程/","content":"\n最近遇到了一个线程阻塞的问题,分析的过程比较有代表性,这里做个总结分享下。\n\n\n测试报的问题是: 概率性出现开机的前几分钟我们的服务不可用。\n\n\n查看日志发现开机之后的几分钟之内[mqtt库](https://github.com/eclipse/paho.mqtt.java)不断在断开、重连broker。MqttCallback.disconnected一直在被调用,而且还能看到发布消息也失败了:\n\n```\n12-28 18:27:18.948   812   884 E LinJwDemoMqtt: publish failed : 等待来自服务器的响应时超时 (32000)\n12-28 18:27:18.948   812   884 E LinJwDemoMqtt: \tat d.c.a.a.a.l(Unknown Source:9)\n12-28 18:27:18.948   812   884 E LinJwDemoMqtt: \tat g.b.a.a.a.l.b.a(:4)\n12-28 18:27:18.948   812   884 E LinJwDemoMqtt: \tat g.b.a.a.a.k$b.run(:8)\n12-28 18:27:18.948   812   884 E LinJwDemoMqtt: \tat java.util.TimerThread.mainLoop(Timer.java:562)\n12-28 18:27:18.948   812   884 E LinJwDemoMqtt: \tat java.util.TimerThread.run(Timer.java:512)\n```\n\n过了几分钟之后就恢复了,能够和mqtt broker正常通讯。\n\n正常情况下断开连接应该是网络问题,但是发生如果是网络问题应该是一直连不上,而不会连接上又断开连接。除非刚开机的时候系统网络模块异常抽风,从日志上看网络是正常的,而且在broker的日志里面看到的是client主动断开的连接:\n\n```\n2022-12-28T18:27:19: Client LinJwDemoMqtt_1672223154916 closed its connection.\n```\n\n# Long monitor contention \n\n这样看来问题还是出在客户端,仔细翻看**首次出现异常**和**恢复正常**的那段时间的日志,在恢复正常的时候发现了这样的打印: \n\n```\nLong monitor contention with owner MQTT Call: LinJwDemoMqtt_1672223154916 (1252) at void java.lang.Thread.sleep(java.lang.Object, long, int)(Thread.java:-2) waiters=0 in java.util.List d.d.e.c.k.b.f.f(java.lang.String, java.lang.String) for 270.749s\n```\n\n这行日志的意思是tid为1252的LinJwDemoMqtt_1672223154916线程长期持有了对象的monitor,导致d.d.e.c.k.b.f.f这个方法等待了270.749秒才获取到线程锁。\n\n这里的monitor指的就是synchronized关键字的底层实现。正常情况对一段代码进行加锁应该是一个短时间的行为,一旦某个线程长时间持有对象锁就容易导致其他线程卡死。monitor会去监控等待锁的时长,如果超过某个阈值(正常是100ms,调试模式下是1s)就会输出上面的Long monitor contention打印提醒我们:\n\n```\n// https://cs.android.com/android/platform/superproject/+/android-9.0.0_r60:art/runtime/monitor.cc\nstatic constexpr uint64_t kDebugThresholdFudgeFactor = kIsDebugBuild ? 10 : 1;\nstatic constexpr uint64_t kLongWaitMs = 100 * kDebugThresholdFudgeFactor;\n\n...\n} else if (wait_ms > kLongWaitMs && owners_method != nullptr) {\nuint32_t pc;\nArtMethod* m = self->GetCurrentMethod(&pc);\n// TODO: We should maybe check that original_owner is still a live thread.\nLOG(WARNING) << \"Long \"\n    << PrettyContentionInfo(original_owner_name,\n                            original_owner_tid,\n                            owners_method,\n                            owners_dex_pc,\n                            num_waiters)\n    << \" in \" << ArtMethod::PrettyMethod(m) << \" for \"\n    << PrettyDuration(MsToNs(wait_ms));\n}\n...\n```\n\n例如下面的代码sleep1会卡住sleep2:\n\n```\nprivate void testLongMonitor() {\n    new Thread(\"TestLongMonitor1\") {\n        @Override\n        public void run() {\n            super.run();\n            sleep1();\n        }\n    }.start();\n\n    new Thread(\"TestLongMonitor2\") {\n        @Override\n        public void run() {\n            super.run();\n            sleep2();\n        }\n    }.start();\n}\n\nprivate synchronized void sleep1() {\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n\nprivate synchronized void sleep2() {\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n在进入sleep2的时候就能看到下面的打印:\n\n```\nLong monitor contention with owner TestLongMonitor1 (3457) at void me.linjw.demo.MainActivity.sleep1()(MainActivity.java:41) waiters=0 in void me.linjw.demo.MainActivity.sleep2() for 1s\n```\n\n所以当我们看到这个打印的时候就应该去检查下是否在上锁的代码块里面做了耗时操作。\n\n# kill -3 命令\n\n再来看看这个日志:\n\n```\nLong monitor contention with owner MQTT Call: LinJwDemoMqtt_1672223154916 (1252) at void java.lang.Thread.sleep(java.lang.Object, long, int)(Thread.java:-2) waiters=0 in java.util.List d.d.e.c.k.b.f.f(java.lang.String, java.lang.String) for 270.749s\n```\n\n让我比较难以理解的是LinJwDemoMqtt_1672223154916这个线程是卡在了java.lang.Thread.sleep这里。难道说我们的代码里面会有一个sleep 270秒的操作?搜索完整个代码都没有找到sleep的调用,于是只能压测复现然后使用\"kill -3 {pid}\"命令强制打印出进程的堆栈,然后在/data/anr/目录下找到它:\n\n```\n\"MQTT Call: LinJwDemoMqtt_1672223154916\" prio=5 tid=21 Sleeping\n  | group=\"main\" sCount=1 dsCount=0 flags=1 obj=0x132c06f0 self=0x7d42a40800\n  | sysTid=1561 nice=0 cgrp=default sched=0/0 handle=0x7d329144f0\n  | state=S schedstat=( 2172565480 1496095545 17833 ) utm=151 stm=64 core=5 HZ=100\n  | stack=0x7d32811000-0x7d32813000 stackSize=1041KB\n  | held mutexes=\n  at java.lang.Thread.sleep(Native method)\n  - sleeping on <0x07054ef1> (a java.lang.Object)\n  at java.lang.Thread.sleep(Thread.java:373)\n  - locked <0x07054ef1> (a java.lang.Object)\n  at java.lang.Thread.sleep(Thread.java:314)\n  at android.net.LocalSocketImpl$SocketOutputStream.flush(LocalSocketImpl.java:185)\n  at d.d.e.b.c.b.a(:2)\n  at d.d.e.c.k.b.f.g(:-1)\n  at d.d.e.c.k.b.f.f(:-1)\n  - locked <0x0ab63ad6> (a d.d.e.c.k.b.f)\n  at d.d.e.c.k.b.e.a(:-1)\n  at d.d.e.c.k.a.a(:2)\n  at d.d.e.c.j.d$a.a(:3)\n  at d.d.e.c.h.e$a.a(:30)\n  at g.b.a.a.a.l.c.d(:12)\n  at g.b.a.a.a.l.c.run(:-1)\n  at java.lang.Thread.run(Thread.java:764)\n```\n\n发现是卡在了LocalSocket里面,我们的确会使用localsocket做通讯。翻看LocalSocketImpl的源码会找到这样一个丑陋的实现:\n\n```\n// https://cs.android.com/android/platform/superproject/+/android-9.0.0_r60:frameworks/base/core/java/android/net/LocalSocketImpl.java\npublic void flush() throws IOException {\n    FileDescriptor myFd = fd;\n    if (myFd == null) throw new IOException(\"socket closed\");\n\n    // Loop until the output buffer is empty.\n    Int32Ref pending = new Int32Ref(0);\n    while (true) {\n        try {\n            // See linux/net/unix/af_unix.c\n            Os.ioctlInt(myFd, OsConstants.TIOCOUTQ, pending);\n        } catch (ErrnoException e) {\n            throw e.rethrowAsIOException();\n        }\n\n        if (pending.value <= 0) {\n            // The output buffer is empty.\n            break;\n        }\n\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException ie) {\n            break;\n        }\n    }\n}\n```\n\n有个while true里面去sleep了10ms。但是这里和我们看到的270多秒相差甚远,就算Thread.sleep再怎么有误差也差不了这么多。\n\n由于是开机的时候出现的,考虑可能是时间同步的锅,可能在sleep前后系统时间改变了。但是翻看日志发现时间是连续的没有出现跳变。\n\n# schedstat\n\n我连续抓了几次堆栈,发现schedstat值是在增加的:\n\n```\n// 第一次抓取\n\"MQTT Call: LinJwDemoMqtt_1672223154916\" prio=5 tid=21 Sleeping\n  | group=\"main\" sCount=1 dsCount=0 flags=1 obj=0x132c06f0 self=0x7d42a40800\n  | sysTid=1561 nice=0 cgrp=default sched=0/0 handle=0x7d329144f0\n  | state=S schedstat=( 1808090884 1440374635 15039 ) utm=129 stm=50 core=4 HZ=100\n\n// 第二次抓取\n\"MQTT Call: LinJwDemoMqtt_1672223154916\" prio=5 tid=21 Sleeping\n  | group=\"main\" sCount=1 dsCount=0 flags=1 obj=0x132c06f0 self=0x7d42a40800\n  | sysTid=1561 nice=0 cgrp=default sched=0/0 handle=0x7d329144f0\n  | state=S schedstat=( 2391421933 1559350961 20051 ) utm=165 stm=73 core=3 HZ=100\n\n\n// 第三次抓取\n\"MQTT Call: LinJwDemoMqtt_1672223154916\" prio=5 tid=21 Sleeping\n  | group=\"main\" sCount=1 dsCount=0 flags=1 obj=0x132c06f0 self=0x7d42a40800\n  | sysTid=1561 nice=0 cgrp=default sched=0/0 handle=0x7d329144f0\n  | state=S schedstat=( 3049001564 1709661634 25792 ) utm=210 stm=94 core=1 HZ=100\n```\n\n这个schedstat其实是Linux里面的东西,从[文档](https://docs.kernel.org/scheduler/sched-stats.html?highlight=schedstat)来看这三个值分别是:\n\n1. 在cpu上花费的时间（纳秒）\n2. 等待运行队列所花费的时间（纳秒）\n3. 此cpu上运行的时间片数\n\n我们也可以用cat命令直接读取到:\n\n> cat /proc/{pic}/task/{tid}/schedstat\n\n从schedstat来看线程占用的cpu时间片是一直在增加的,所以这个线程并不是一直sleep的。只能说读取owners\\_method的时候刚好抓到sleep这个方法了。\n\n由于我们写入的数据是一个很短的字符串,于是结合LocalSocketImpl的源码可以猜测是Os.ioctlInt写入之后pending.value一直大于0。也许是localsocket接收端有问题,又有可能是系统本身在开机的时候某些状态有问题。\n\n由于复现了几次,时间都是270、280秒,感觉系统本身的问题概率不大。于是写了个简单的测试接收端,发现只要接收端一直不去read数据,发送端flush里的while循环就一直出不来。\n\n由于我们提供的客户端sdk里面使用okhttp封装了一层localsocket,okhttp的复用连接池里面socket的生存时间是5分钟,在生存时间到了之后就会自动回收socket,触发发送端的flush退出while循环。所以复现的几次都是卡了270、280多秒接近5分钟。从恢复时间点附近也找到了这样的日志作为佐证:\n\n12-28 18:30:59.832  1852  2770 W System  : A resource failed to call response.body().close(). \n\n# 线程锁定位\n\n从上面我们只能看到其中的一个线程被localsocket堵住了,但是为什么mqtt会不断断开呢,我们从堆栈里面看到这个线程锁了一个0x0ab63ad6对象,在堆栈里搜索它,可以看到后面新启动的mqtt线程都在\"waiting to lock <0x0ab63ad6> (a d.d.e.c.k.b.f) held by thread 21\":\n\n```\n\"MQTT Call: LinJwDemoMqtt_1672223188697\" prio=5 tid=41 Blocked\n  | group=\"main\" sCount=1 dsCount=0 flags=1 obj=0x13780ef8 self=0x7d42a3fc00\n  | sysTid=4307 nice=0 cgrp=default sched=0/0 handle=0x7d30f194f0\n  | state=S schedstat=( 9329835 2060251 4 ) utm=0 stm=0 core=2 HZ=100\n  | stack=0x7d30e16000-0x7d30e18000 stackSize=1041KB\n  | held mutexes=\n  at d.d.e.c.k.b.f.f(:-1)\n  - waiting to lock <0x0ab63ad6> (a d.d.e.c.k.b.f) held by thread 21\n  at d.d.e.c.k.b.e.a(:-1)\n  at d.d.e.c.k.a.a(:2)\n  at d.d.e.c.a.a(:3)\n  at d.d.e.c.j.d.a(:24)\n  at d.d.e.c.j.b.a(:1)\n  at d.d.e.c.h.e$a.a(:11)\n  at g.b.a.a.a.l.c.d(:12)\n  at g.b.a.a.a.l.c.run(:-1)\n  at java.lang.Thread.run(Thread.java:764)\n\n\"MQTT Call: LinJwDemoMqtt_1672223201187\" prio=5 tid=42 Blocked\n  | group=\"main\" sCount=1 dsCount=0 flags=1 obj=0x131c10b8 self=0x7d44472000\n  | sysTid=4730 nice=0 cgrp=default sched=0/0 handle=0x7d30e134f0\n  | state=S schedstat=( 23179915 15908085 274 ) utm=1 stm=0 core=3 HZ=100\n  | stack=0x7d30d10000-0x7d30d12000 stackSize=1041KB\n  | held mutexes=\n  at d.d.e.c.k.b.f.f(:-1)\n  - waiting to lock <0x0ab63ad6> (a d.d.e.c.k.b.f) held by thread 21\n  at d.d.e.c.k.b.e.a(:-1)\n  at d.d.e.c.k.a.a(:2)\n  at d.d.e.c.a.a(:3)\n  at d.d.e.c.j.d.a(:24)\n  at d.d.e.c.j.b.a(:1)\n  at d.d.e.c.h.e$a.a(:11)\n  at g.b.a.a.a.l.c.d(:12)\n  at g.b.a.a.a.l.c.run(:-1)\n  at java.lang.Thread.run(Thread.java:764)\n\n\"MQTT Call: LinJwDemoMqtt_1672223216180\" prio=5 tid=43 Blocked\n  | group=\"main\" sCount=1 dsCount=0 flags=1 obj=0x13782748 self=0x7d44472c00\n  | sysTid=4945 nice=0 cgrp=default sched=0/0 handle=0x7d30d0d4f0\n  | state=S schedstat=( 9939123 3184420 14 ) utm=0 stm=0 core=3 HZ=100\n  | stack=0x7d30c0a000-0x7d30c0c000 stackSize=1041KB\n  | held mutexes=\n  at d.d.e.c.k.b.f.f(:-1)\n  - waiting to lock <0x0ab63ad6> (a d.d.e.c.k.b.f) held by thread 21\n  at d.d.e.c.k.b.e.a(:-1)\n  at d.d.e.c.k.a.a(:2)\n  at d.d.e.c.a.a(:3)\n  at d.d.e.c.j.d.a(:24)\n  at d.d.e.c.j.b.a(:1)\n  at d.d.e.c.h.e$a.a(:11)\n  at g.b.a.a.a.l.c.d(:12)\n  at g.b.a.a.a.l.c.run(:-1)\n  at java.lang.Thread.run(Thread.java:764)\n...\n```\n\ntid=21就是我们之前那个卡在flush的线程。\n\n也就是说mqtt连接成功之后都会调用到localsocket的写入,写入之前我们的代码里面对代码块进行加锁,然后就都在等第一个线程的flush退出while循环,导致mqtt库接收不到broker的响应自动断开。\n\n所以现在已经可以定位是提供的sdk的问题,接下来就需要处理sdk里面没有读取的异常情况。","tags":["技术相关","Android"]},{"title":"FFmpeg入门 - 格式转换","url":"/2022/11/27/FFmpeg入门-格式转换/","content":"\n系列文章:\n\n1. [FFmpeg入门 - 视频播放](https://blog.islinjw.cn/2022/09/04/FFmpeg%E5%85%A5%E9%97%A8-%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/)\n2. [FFmpeg入门 - rtmp推流](https://blog.islinjw.cn/2022/09/08/FFmpeg%E5%85%A5%E9%97%A8-rtmp%E6%8E%A8%E6%B5%81/)\n3. [FFmpeg入门 - Android移植](https://blog.islinjw.cn/2022/10/25/FFmpeg%E5%85%A5%E9%97%A8-Android%E7%A7%BB%E6%A4%8D/)\n4. [FFmpeg入门 - 格式转换](https://blog.islinjw.cn/2022/11/27/FFmpeg%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/)\n\n我们现在已经能在安卓上播放视频画面了,但是声音部分还是缺失的,这篇博客就来把视频的音频播放模块也加上。\n\n为了音频和视频可以分别解码播放,我们需要对之前的代码做重构,将媒体流的读取和解码解耦:\n\n{% plantuml %}\nclass MediaReader {\n    + AVPacket *NextPacket(int streamIndex)\n    + std::vector<AVStream *> GetStreams()\n    + AVStream *GetStream(int index)\n}\n\nclass StreamDecoder {\n    + bool Init(MediaReader *reader, int streamIndex)\n    + void Destroy()\n    + AVFrame *NextFrame()\n}\n\nclass VideoStreamDecoder extends StreamDecoder {\n    + int GetVideoWidth()\n    + int GetVideoHeight()\n}\n\nclass AudioStreamDecoder extends StreamDecoder {\n    + int GetSampleRate()\n    + int GetChannelCount()\n    + int GetBytePerSample()\n}\n\nStreamDecoder --> MediaReader\n{% endplantuml %}\n\nMediaReader从文件流中读取出AVPacket交由VideoStreamDecoder和AudioStreamDecoder做视频与音频的解码。我们在MediaReader里加上线程安全机制,使得视频和音频可以分别在各自的工作线程中进行解码。\n\n\n# 音频分⽚(plane)与打包(packed)\n\n解码出来的AVFrame,它的data字段放的是视频像素数据或者音频的PCM裸流数据,linesize字段放的是对齐后的画面行长度或者音频的分片长度:\n\n```\n   /**\n    * For video, size in bytes of each picture line.\n    * For audio, size in bytes of each plane.\n    *\n    * For audio, only linesize[0] may be set. For planar audio, each channel\n    * plane must be the same size.\n    *\n    * For video the linesizes should be multiples of the CPUs alignment\n    * preference, this is 16 or 32 for modern desktop CPUs.\n    * Some code requires such alignment other code can be slower without\n    * correct alignment, for yet other it makes no difference.\n    *\n    * @note The linesize may be larger than the size of usable data -- there\n    * may be extra padding present for performance reasons.\n    */\n    int linesize[AV_NUM_DATA_POINTERS];\n```\n\n视频相关的在之前的[博客](https://blog.islinjw.cn/2022/10/25/FFmpeg%E5%85%A5%E9%97%A8-Android%E7%A7%BB%E6%A4%8D/#linesize)中有介绍,音频的话可以看到它只有linesize[0]会被设置,如果有多个分片,每个分片的size都是相等的。\n\n要理解这里的分片size,先要理解音频数据的两种存储格式分⽚(plane)与打包(packed)。以常见的双声道音频为例子,\n\n分⽚存储的数据左声道和右声道分开存储,左声道存储在data[0],右声道存储在data[1],他们的数据buffer的size都是linesize[0]。\n\n打包存储的数据按照LRLRLR...的形式交替存储在data[0]中,这个数据buffer的size是linesize[0]。\n\nAVSampleFormat枚举音频的格式,带P后缀的格式是分配存储的:\n\n```\nAV_SAMPLE_FMT_U8P,         ///< unsigned 8 bits, planar\nAV_SAMPLE_FMT_S16P,        ///< signed 16 bits, planar\nAV_SAMPLE_FMT_S32P,        ///< signed 32 bits, planar\nAV_SAMPLE_FMT_FLTP,        ///< float, planar\nAV_SAMPLE_FMT_DBLP,        ///< double, planar\n```\n不带P后缀的格式是打包存储的:\n\n```\nAV_SAMPLE_FMT_U8,          ///< unsigned 8 bits\nAV_SAMPLE_FMT_S16,         ///< signed 16 bits\nAV_SAMPLE_FMT_S32,         ///< signed 32 bits\nAV_SAMPLE_FMT_FLT,         ///< float\nAV_SAMPLE_FMT_DBL,         ///< double\n```\n\n# 音频数据的实际长度\n\n这里有个坑点备注里面也写的很清楚了,linesize标明的大小可能会大于实际的音视频数据大小,因为可能会有额外的填充。\n\n> * @note The linesize may be larger than the size of usable data -- there\n> * may be extra padding present for performance reasons.\n\n所以音频数据实际的长度需要用音频的参数计算出来:\n\n```\nint channelCount = audioStreamDecoder.GetChannelCount();\nint bytePerSample = audioStreamDecoder.GetBytePerSample();\nint size = frame->nb_samples * channelCount * bytePerSample;\n```\n\n# 音频格式转换\n\n视频之前的demo中已经可以使用OpenGL播放,而音频可以交给OpenSL来播放,之前我写过一篇[《OpenSL ES 学习笔记》](https://blog.islinjw.cn/2018/09/01/OpenSLES%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/)详细的使用细节我就不展开介绍了,直接将[代码](https://github.com/bluesky466/OpenSLDemo/blob/master/app/src/main/cpp/opensl_helper.c)拷贝来使用。\n\n但是由于OpenSLES只支持打包的几种音频格式:\n\n```\n#define SL_PCMSAMPLEFORMAT_FIXED_8\t((SLuint16) 0x0008)\n#define SL_PCMSAMPLEFORMAT_FIXED_16\t((SLuint16) 0x0010)\n#define SL_PCMSAMPLEFORMAT_FIXED_20 \t((SLuint16) 0x0014)\n#define SL_PCMSAMPLEFORMAT_FIXED_24\t((SLuint16) 0x0018)\n#define SL_PCMSAMPLEFORMAT_FIXED_28 \t((SLuint16) 0x001C)\n#define SL_PCMSAMPLEFORMAT_FIXED_32\t((SLuint16) 0x0020)\n```\n\n这里我们指的AudioStreamDecoder的目标格式为AV\\_SAMPLE\\_FMT\\_S16,如果原始音频格式不是它,则对音频做转码:\n\n```c++\naudioStreamDecoder.Init(reader, audioIndex, AVSampleFormat::AV_SAMPLE_FMT_S16);\n\n\nbool AudioStreamDecoder::Init(MediaReader *reader, int streamIndex, AVSampleFormat sampleFormat) {\n    ...\n\n    bool result = StreamDecoder::Init(reader, streamIndex);\n\n    if (sampleFormat == AVSampleFormat::AV_SAMPLE_FMT_NONE) {\n        mSampleFormat = mCodecContext->sample_fmt;\n    } else {\n        mSampleFormat = sampleFormat;\n    }\n\n    if (mSampleFormat != mCodecContext->sample_fmt) {\n        mSwrContext = swr_alloc_set_opts(\n                NULL,\n                mCodecContext->channel_layout,\n                mSampleFormat,\n                mCodecContext->sample_rate,\n                mCodecContext->channel_layout,\n                mCodecContext->sample_fmt,\n                mCodecContext->sample_rate,\n                0,\n                NULL);\n        swr_init(mSwrContext);\n\n        // 虽然前面的swr_alloc_set_opts已经设置了这几个参数\n        // 但是用于接收的AVFrame不设置这几个参数也会接收不到数据\n        // 原因是后面的swr_convert_frame函数会通过av_frame_get_buffer创建数据的buff\n        // 而av_frame_get_buffer需要AVFrame设置好这些参数去计算buff的大小\n        mSwrFrame = av_frame_alloc();\n        mSwrFrame->channel_layout = mCodecContext->channel_layout;\n        mSwrFrame->sample_rate = mCodecContext->sample_rate;\n        mSwrFrame->format = mSampleFormat;\n    }\n    return result;\n}\n\nAVFrame *AudioStreamDecoder::NextFrame() {\n    AVFrame *frame = StreamDecoder::NextFrame();\n    if (NULL == frame) {\n        return NULL;\n    }\n    if (NULL == mSwrContext) {\n        return frame;\n    }\n\n    swr_convert_frame(mSwrContext, mSwrFrame, frame);\n    return mSwrFrame;\n}\n```\n\n这里我们使用swr\\_convert\\_frame进行转码:\n\n```c++\nint swr_convert_frame(SwrContext *swr,     // 转码上下文\n                      AVFrame *output,     // 转码后输出到这个AVFrame\n                      const AVFrame *input // 原始输入AVFrame\n);\n```\n\n这个方法要求输入输出的AVFrame都设置了channel_layout、 sample_rate、format参数,然后回调用av_frame_get_buffer为output创建数据buff:\n\n```c++\n/**\n * ...\n *\n * Input and output AVFrames must have channel_layout, sample_rate and format set.\n *\n * If the output AVFrame does not have the data pointers allocated the nb_samples\n * field will be set using av_frame_get_buffer()\n * is called to allocate the frame.\n * ...\n */\nint swr_convert_frame(SwrContext *swr,\n                      AVFrame *output, const AVFrame *input);\n```\n\nSwrContext为转码的上下文,通过swr\\_alloc\\_set\\_opts和swr\\_init创建,需要把转码前后的音频channel\\_layout、 sample\\_rate、format信息传入:\n\n```c++\nstruct SwrContext *swr_alloc_set_opts(struct SwrContext *s,\n                                      int64_t out_ch_layout, enum AVSampleFormat out_sample_fmt, int out_sample_rate,\n                                      int64_t  in_ch_layout, enum AVSampleFormat  in_sample_fmt, int  in_sample_rate,\n                                      int log_offset, void *log_ctx);\n\nint swr_init(struct SwrContext *s);\n```\n\n# 视频格式转换\n\n之前的demo里面我们判断了视频格式不为AV\\_PIX\\_FMT\\_YUV420P则直接报错,这里我们仿照音频转换的例子,判断原始视频格式不为AV\\_PIX\\_FMT\\_YUV420P则使用sws\\_scale进行格式转换:\n\n```c++\nbool VideoStreamDecoder::Init(MediaReader *reader, int streamIndex, AVPixelFormat pixelFormat) {\n    ...\n    bool result = StreamDecoder::Init(reader, streamIndex);\n    if (AVPixelFormat::AV_PIX_FMT_NONE == pixelFormat) {\n        mPixelFormat = mCodecContext->pix_fmt;\n    } else {\n        mPixelFormat = pixelFormat;\n    }\n\n    if (mPixelFormat != mCodecContext->pix_fmt) {\n        int width = mCodecContext->width;\n        int height = mCodecContext->height;\n\n        mSwrFrame = av_frame_alloc();\n\n        // 方式一,使用av_frame_get_buffer创建数据存储空间,av_frame_free的时候会自动释放\n        mSwrFrame->width = width;\n        mSwrFrame->height = height;\n        mSwrFrame->format = mPixelFormat;\n        av_frame_get_buffer(mSwrFrame, 0);\n\n        // 方式二,使用av_image_fill_arrays指定存储空间,需要我们手动调用av_malloc、av_free去创建、释放空间\n//        unsigned char* buffer = (unsigned char *)av_malloc(\n//                av_image_get_buffer_size(mPixelFormat, width, height, 16)\n//        );\n//        av_image_fill_arrays(mSwrFrame->data, mSwrFrame->linesize, buffer, mPixelFormat, width, height, 16);\n\n        mSwsContext = sws_getContext(\n                mCodecContext->width, mCodecContext->height, mCodecContext->pix_fmt,\n                width, height, mPixelFormat, SWS_BICUBIC,\n                NULL, NULL, NULL\n        );\n    }\n    return result;\n}\n\n\nAVFrame *VideoStreamDecoder::NextFrame() {\n    AVFrame *frame = StreamDecoder::NextFrame();\n    if (NULL == frame) {\n        return NULL;\n    }\n    if (NULL == mSwsContext) {\n        return frame;\n    }\n\n    sws_scale(mSwsContext, frame->data,\n              frame->linesize, 0, mCodecContext->height,\n              mSwrFrame->data, mSwrFrame->linesize);\n    return mSwrFrame;\n}\n```\n\nsws\\_scale看名字虽然是缩放,但它实际上也会对format进行转换,转换的参数由SwsContext提供:\n\n```c++\nstruct SwsContext *sws_getContext(\n    int srcW,                     // 源图像的宽\n    int srcH,                     // 源图像的高\n    enum AVPixelFormat srcFormat, // 源图像的格式\n    int dstW,                     // 目标图像的宽\n    int dstH,                     // 目标图像的高\n    enum AVPixelFormat dstFormat, // 目标图像的格式\n    int flags,                    // 暂时可忽略\n    SwsFilter *srcFilter,         // 暂时可忽略\n    SwsFilter *dstFilter,         // 暂时可忽略\n    const double *param           // 暂时可忽略\n);\n```\n\nsws\\_scale支持区域转码,可以如我们的demo将整幅图像进行转码,也可以将图像切成多个区域分别转码,这样方便实用多线程加快转码效率:\n\n```c++\nint sws_scale(\n    struct SwsContext *c,             // 转码上下文\n    const uint8_t *const srcSlice[],  // 源画面区域像素数据,对应源AVFrame的data字段\n    const int srcStride[],            // 源画面区域行宽数据,对应源AVFrame的linesize字段\n    int srcSliceY,                    // 源画面区域起始Y坐标,用于计算应该放到目标图像的哪个位置\n    int srcSliceH,                    // 源画面区域行数,用于计算应该放到目标图像的哪个位置\n    uint8_t *const dst[],             // 转码后图像数据存储,对应目标AVFrame的data字段\n    const int dstStride[]             // 转码后行宽数据存储,对应目标AVFrame的linesize字段\n);\n```\nsrcSlice和srcStride存储了源图像部分区域的图像数据,srcSliceY和srcSliceH告诉转码器这部分区域的坐标范围,用于计算偏移量将转码结果存放到dst和dstStride中。\n\n例如下面的代码就将一幅完整的图像分成上下两部分分别进行转码:\n\n```c++\nint halfHeight = mCodecContext->height / 2;\n\n// 转码上半部分图像\nuint8_t *dataTop[AV_NUM_DATA_POINTERS] = {\n        frame->data[0],\n        frame->data[1],\n        frame->data[2]\n};\nsws_scale(mSwsContext, dataTop,\n            frame->linesize, 0,\n            halfHeight,\n            mSwrFrame->data, mSwrFrame->linesize);\n\n// 转码下半部分图像\nuint8_t *dataBottom[AV_NUM_DATA_POINTERS] = {\n        frame->data[0] + (frame->linesize[0] * halfHeight),\n        frame->data[1] + (frame->linesize[1] * halfHeight),\n        frame->data[2] + (frame->linesize[2] * halfHeight),\n};\nsws_scale(mSwsContext, dataBottom,\n            frame->linesize, halfHeight,\n            mCodecContext->height - halfHeight,\n            mSwrFrame->data, mSwrFrame->linesize);\n```\n\n# AVFrame内存管理机制\n\n我们创建了一个新的AVFrame用于接收转码后的图像:\n\n```c++\nmSwrFrame = av_frame_alloc();\n\n// 方式一,使用av_frame_get_buffer创建数据存储空间,av_frame_free的时候会自动释放\nmSwrFrame->width = width;\nmSwrFrame->height = height;\nmSwrFrame->format = mPixelFormat;\nav_frame_get_buffer(mSwrFrame, 0);\n\n// 方式二,使用av_image_fill_arrays指定存储空间,需要我们手动调用av_malloc、av_free去创建、释放buffer的空间\n// int bufferSize = av_image_get_buffer_size(mPixelFormat, width, height, 16);\n// unsigned char* buffer = (unsigned char *)av_malloc(bufferSize);\n// av_image_fill_arrays(mSwrFrame->data, mSwrFrame->linesize, buffer, mPixelFormat, width, height, 16);\n```\n\nav\\_frame\\_alloc创建出来的AVFrame只是一个壳,我们需要为它提供实际存储像素数据和行宽数据的内存空间,如上所示有两种方法:\n\n1.通过av\\_frame\\_get\\_buffer创建存储空间,data成员的空间实际上是由buf[0]->data提供的:\n\n```c++\nLOGD(\"mSwrFrame --> buf : 0x%X~0x%X, data[0]: 0x%X, data[1]: 0x%X, data[2]: 0x%X\",\n    mSwrFrame->buf[0]->data,\n    mSwrFrame->buf[0]->data + mSwrFrame->buf[0]->size,\n    mSwrFrame->data[0],\n    mSwrFrame->data[1],\n    mSwrFrame->data[2]\n);\n// mSwrFrame --> buf : 0x2E6E8AC0~0x2E753F40, data[0]: 0x2E6E8AC0, data[1]: 0x2E7302E0, data[2]: 0x2E742100\n```\n\n2. 通过av\\_image\\_fill\\_arrays指定外部存储空间,data成员的空间就是我们指的的外部空间,而buf成员是NULL:\n\n```c++\nLOGD(\"mSwrFrame --> buffer : 0x%X~0x%X, buf : 0x%X, data[0]: 0x%X, data[1]: 0x%X, data[2]: 0x%X\",\n    buffer,\n    buffer + bufferSize,\n    mSwrFrame->buf[0],\n    mSwrFrame->data[0],\n    mSwrFrame->data[1],\n    mSwrFrame->data[2]\n);\n// FFmpegDemo: mSwrFrame --> buffer : 0x2DAE4DC0~0x2DB4D5C0, buf : 0x0, data[0]: 0x2DAE4DC0, data[1]: 0x2DB2A780, data[2]: 0x2DB3BEA0\n```\n\n而av\\_frame\\_free内部会去释放AVFrame里buf的空间,对于data成员它只是简单的把指针赋值为0,所以通过av\\_frame\\_get\\_buffer创建存储空间,而通过av\\_image\\_fill\\_arrays指定外部存储空间需要我们手动调用av\\_free去释放外部空间。\n\n# align\n\n细心的同学可能还看到了av\\_image\\_get\\_buffer\\_size和av\\_image\\_fill\\_arrays都传了个16的align,这里对应的就是之前讲的linesize的字节对齐,会填充数据让linesize变成16、或者32的整数倍:\n\n```c++\n@param align         the value used in src for linesize alignment\n```\n\n这里如果为0会填充失败:\n\n{% img /FFmpeg入门格式转换/1.png %}\n\n\n而为1不做填充会出现和实际解码中的linesize不一致导致画面异常:\n\n{% img /FFmpeg入门格式转换/2.png %}\n\nav\\_frame\\_get\\_buffer则比较人性化,它推荐你填0让它自己去判断应该按多少对齐:\n\n```\n * @param align Required buffer size alignment. If equal to 0, alignment will be\n *              chosen automatically for the current CPU. It is highly\n *              recommended to pass 0 here unless you know what you are doing.\n```\n\n# 完整代码\n\n完整的demo代码已经放到[Github](https://github.com/bluesky466/FFmpegAndroidDemo/tree/feature_conversion)上,感兴趣的同学可以下载来看看","tags":["技术相关","Android","音视频"]},{"title":"当Gson遇上data class","url":"/2022/11/01/当Gson遇上data-class/","content":"\n当Gson遇上kotlin data class,会发生一些很有意思的现象:\n\n现象1: 非空类型失效\n\n```\ndata class TestData(\n    val a: String,\n    val b: String\n)\nval data = Gson().fromJson(\"{}\", TestData::class.java)\nprintln(\"a:${data.a}, b:${data.b}\") //输出: a:null, b:null\n```\n\n现象2: 构造函数不会被调用\n```\ndata class TestData(\n    val a: String,\n    val b: String\n) {\n    init {\n        println(\"TestData init!!!\") // 这一行代码不会执行到\n    }\n}\nval data = Gson().fromJson(\"{}\", TestData::class.java)\n```\n\n现象3: 默认值失效\n\n```\ndata class TestData(\n    val a: String,\n    val b: String = \"bbb\"\n)\nval data = Gson().fromJson(\"{\\\"a\\\":\\\"aaa\\\"}\", TestData::class.java)\nprintln(\"$data\") //输出: TestData(a=aaa, b=null)\n```\n\n现象4: 当全部成员都有默认值的时候默认值和构造函数又生效了\n\n```\ndata class TestData(\n    val a: String = \"\",\n    val b: String = \"bbb\"\n) {\n    init {\n        println(\"TestData init!!!\") // 这一行代码能执行到\n    }\n}\nval data = Gson().fromJson(\"{\\\"a\\\":\\\"aaa\\\"}\", TestData::class.java)\nprintln(\"$data\") //输出: TestData(a=aaa, b=bbb)\n```\n\n# Gson解析流程\n\n要理解上面的现象我们先要了解Gson是怎样工作的。\n\nGson解析json分两步,创建对象实例和给成员变量赋值.\n\n创建对象实例是通过ConstructorConstructor.get(TypeToken\\<T\\> typeToken)方法获取到构造器去创建的:\n\n```\npublic <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\n    final Type type = typeToken.getType();\n    final Class<? super T> rawType = typeToken.getRawType();\n\n    // 从instanceCreators中查找,我们可以用GsonBuilder.registerTypeAdapter指定某种类型的构造器,默认情况下instanceCreators是空的\n    final InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\n    if (typeCreator != null) {\n      return new ObjectConstructor<T>() {\n        @Override public T construct() {\n          return typeCreator.createInstance(type);\n        }\n      };\n    }\n\n    // 这里还是在instanceCreators里查找,只不过用rawType当key\n    final InstanceCreator<T> rawTypeCreator =\n        (InstanceCreator<T>) instanceCreators.get(rawType);\n    if (rawTypeCreator != null) {\n      return new ObjectConstructor<T>() {\n        @Override public T construct() {\n          return rawTypeCreator.createInstance(type);\n        }\n      };\n    }\n\n    // 查找一些特殊集合如EnumSet、EnumMap的构造器\n    ObjectConstructor<T> specialConstructor = newSpecialCollectionConstructor(type, rawType);\n    if (specialConstructor != null) {\n      return specialConstructor;\n    }\n\n    // 通过rawType.getDeclaredConstructor()反射获取类的无参构造函数\n    FilterResult filterResult = ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, rawType);\n    ObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType, filterResult);\n    if (defaultConstructor != null) {\n      return defaultConstructor;\n    }\n\n    // 查找普通的Collection或者Map,如ArrayList、HashMap等的构造器\n    ObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\n    if (defaultImplementation != null) {\n      return defaultImplementation;\n    }\n\n    // 判断类型是否可以实例化,例如接口和抽象类就不能实例化\n    final String exceptionMessage = checkInstantiable(rawType);\n    if (exceptionMessage != null) {\n      return new ObjectConstructor<T>() {\n        @Override public T construct() {\n          throw new JsonIOException(exceptionMessage);\n        }\n      };\n    }\n\n    // 最后使用sun.misc.Unsafe去兜底创建实例\n    if (filterResult == FilterResult.ALLOW) {\n      return newUnsafeAllocator(rawType);\n    } else {\n      final String message = \"Unable to create instance of \" + rawType + \"; ReflectionAccessFilter \"\n          + \"does not permit using reflection or Unsafe. Register an InstanceCreator or a TypeAdapter \"\n          + \"for this type or adjust the access filter to allow using reflection.\";\n      return new ObjectConstructor<T>() {\n        @Override public T construct() {\n          throw new JsonIOException(message);\n        }\n      };\n    }\n  }\n```\n\n获取到对象的构造器,之后就能用它去创建对象实例,然后遍历json字段查找对象是否有对应的成员变量,如果有就通过反射设置进去:\n\n```\n@Override\npublic T read(JsonReader in) throws IOException {\n  if (in.peek() == JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n\n  // 通过ConstructorConstructor.get(TypeToken\\<T\\> typeToken)查询的构造器创建实例对象\n  A accumulator = createAccumulator();\n\n  try {\n    in.beginObject();\n    // 遍历json\n    while (in.hasNext()) {\n      String name = in.nextName();\n\n      // 从对象的成员变量列表查询是否有该字段\n      BoundField field = boundFields.get(name);\n      if (field == null || !field.deserialized) {\n        // 对象没有该成员变量则跳过\n        in.skipValue();\n      } else {\n        // 对象有该成员变量则读取json的值,通过反射设置给对象\n        readField(accumulator, in, field);\n      }\n    }\n  } catch (IllegalStateException e) {\n    throw new JsonSyntaxException(e);\n  } catch (IllegalAccessException e) {\n    throw ReflectionHelper.createExceptionForUnexpectedIllegalAccess(e);\n  }\n  in.endObject();\n  return finalize(accumulator);\n}\n```\n\n# 非空类型失效和构造函数不会被调用的原理\n\n了解了Gson的解析流程之后我们再来看看问题1的data class对应的java代码:\n\n```\n// kotlin代码\ndata class TestData(\n    val a: String,\n    val b: String\n)\n\n// java对应的类\npublic final class TestData {\n   private final String a;\n   private final String b;\n   ...\n   public final String getA() {\n      return this.a;\n   }\n   public final String getB() {\n      return this.b;\n   }\n   ...\n   public TestData(@NotNull String a, @NotNull String b) {\n      Intrinsics.checkNotNullParameter(a, \"a\");\n      Intrinsics.checkNotNullParameter(b, \"b\");\n      super();\n      this.a = a;\n      this.b = b;\n   }\n   ...\n   @NotNull\n   public String toString() {\n      return \"TestData(a=\" + this.a + \", b=\" + this.b + \")\";\n   }\n   ...\n}\n```\n\n可以看到只有在构造函数里面做了判空,但是它并没有无参构造函数所以gson是通过Unsafe去兜底创建TestData实例的。Unsafe创建类的实例并不会调用到构造函数,所以就绕过类判空的步骤。\n\n同理也能解释现象2构造函数不会被调用的问题。\n\n## Unsafe\n\n> Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。 -- [Java魔法类：Unsafe应用解析](https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html)\n\n我们可以通过下面的代码创建TestData实例而不调用TestData的构造函数:\n\n```\nval unsafeClass = Class.forName(\"sun.misc.Unsafe\")\nval theUnsafe = unsafeClass.getDeclaredField(\"theUnsafe\")\ntheUnsafe.isAccessible = true\nval unsafe = theUnsafe.get(null)\nval allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class::class.java)\nval testData = allocateInstance.invoke(unsafe, TestData::class.java) as TestData\n```\n\n## data class 默认值的原理\n\n接着我们继续来看现象3默认值失效的问题,这里会牵扯到data class默认值的原理,我们来看看对应的java代码:\n\n```\n// kotlin代码\ndata class TestData(\n    val a: String,\n    val b: String = \"bbb\"\n)\n\n// java对应的类\npublic final class TestData {\n   private final String a;\n   private final String b;\n\n   ...\n\n   public TestData(@NotNull String a, @NotNull String b) {\n      Intrinsics.checkNotNullParameter(a, \"a\");\n      Intrinsics.checkNotNullParameter(b, \"b\");\n      super();\n      this.a = a;\n      this.b = b;\n   }\n\n   public TestData(String var1, String var2, int var3, DefaultConstructorMarker var4) {\n      if ((var3 & 2) != 0) {\n         var2 = \"bbb\";\n      }\n\n      this(var1, var2);\n   }\n   ...\n}\n```\n\n可以看到,kotlin的默认参数并不是通过重载实现的,而是新增一个构造函数,用一个int的各个bit位来表示前面的参数是否需要设置成默认值。\n\n\n```\n// 例如下面这行kotlin代码:\nval testData = TestData(\"aaa\")\n\n// 对应的java代码是这样的:\nTestData testData = new TestData(\"aaa\", (String)null, 2, (DefaultConstructorMarker)null);\n```\n\n这样做的好处在于只需要新建一个构造函数。用下面这种java传统的函数重载来做,如果有很多的默认值的话需要创建很多的构造函数:\n\n```\npublic final class TestData {\n   ...\n\n   public TestData(@NotNull String a, @NotNull String b) {\n      ...\n   }\n\n   public TestData(String var1) {\n      this(var1, \"bbb\");\n   }\n   ...\n}\n```\n\n除了这个之外它也能比较方便的去支持任意位置的默认值。\n\n到这里我们也能理解现象3默认值失效的原因了,和前面的两个现象一样是因为没有调用到TestData的构造函数,所以就没有赋默认值.\n\n## DefaultConstructorMarker\n\n另外在生成的构造函数里我们还看到了一个DefaultConstructorMarker参数:\n\n```\npublic TestData(String var1, String var2, int var3, DefaultConstructorMarker var4)\n```\n\n这个参数会在kotlin自动生成的构造函数里面出现,目的是为了防止和我们自己定义的构造函数碰撞:\n\n```\n// kotlin代码\ndata class TestData(\n    val a: String,\n    val b: String = \"bbb\"\n) {\n    constructor(a: String, b: String, i: Int) : this(a, b) {\n\n    }\n}\n\n// 对应的java代码\npublic final class TestData {\n   private final String a;\n   private final String b;\n\n   public TestData(@NotNull String a, @NotNull String b) {\n      ...\n   }\n\n   // 假设没有DefaultConstructorMarker参数,下面的两个构造函数就会撞车了\n   public TestData(String var1, String var2, int var3, DefaultConstructorMarker var4) {\n      ...\n   }\n\n   public TestData(@NotNull String a, @NotNull String b, int i) {\n      Intrinsics.checkNotNullParameter(a, \"a\");\n      Intrinsics.checkNotNullParameter(b, \"b\");\n      this(a, b);\n   }\n   ...\n}\n\n```\n\n# 全部成员都有默认值的情况\n\n最后我们来分析下现象4当全部成员都有默认值的情况:\n\n```\n// kotlin代码\ndata class TestData(\n    val a: String = \"\",\n    val b: String = \"bbb\"\n) {\n    init {\n        println(\"TestData init!!!\")\n    }\n}\n\n// 对应的java代码\npublic final class TestData {\n   private final String a;\n   private final String b;\n\n   ...\n\n   public TestData(@NotNull String a, @NotNull String b) {\n      Intrinsics.checkNotNullParameter(a, \"a\");\n      Intrinsics.checkNotNullParameter(b, \"b\");\n      super();\n      this.a = a;\n      this.b = b;\n      String var3 = \"TestData init!!!\";\n      boolean var4 = false;\n      System.out.println(var3);\n   }\n\n   public TestData(String var1, String var2, int var3, DefaultConstructorMarker var4) {\n      if ((var3 & 1) != 0) {\n         var1 = \"\";\n      }\n\n      if ((var3 & 2) != 0) {\n         var2 = \"bbb\";\n      }\n\n      this(var1, var2);\n   }\n\n   public TestData() {\n      this((String)null, (String)null, 3, (DefaultConstructorMarker)null);\n   }\n\n   ...\n}\n```\n\n可以看到当所有成员都有默认值的时候,会生成无参构造函数,这样的话Gson就会调用无参构造函数去创建实例。\n\n# 解决思路\n\n了解完原理我们来看看怎么解决默认值无效的问题,下面有一些思路:\n\n1. 当需要使用默认值的时候全部成员变量都加上默认值\n2. 使用代码生成的方式创建InstanceCreator并注册到gson,在里面创建实例并预先填好默认值\n3. 改用对kotlin支持更好的[kotlinx.serialization](https://github.com/Kotlin/kotlinx.serialization)或者[moshi](https://github.com/square/moshi)\n\n\n\n## kotlinx.serialization原理\n\nkotlinx.serialization的原理在于@Serializable注解的data class对应的java代码会多出一个$serializer类,它会记录所有构造参数对应的json key,然后在解析出来的json里面读取出value去传入构造函数:\n\n```\n// kotlin代码\n@Serializable\ndata class TestData(\n    val a: String,\n    val b: String = \"aaa\"\n)\n\n// java对应的类\npublic final class TestData {\n   private final String a;\n   private final String b;\n\n   ...\n   \n   public static final class $serializer implements GeneratedSerializer {\n      ...\n      private static final SerialDescriptor $$serialDesc;\n      \n      static {\n         TestData.$serializer var0 = new TestData.$serializer();\n         INSTANCE = var0;\n         PluginGeneratedSerialDescriptor var1 = new PluginGeneratedSerialDescriptor(\"me.linjw.demo.debugtool.TestData\", (GeneratedSerializer)INSTANCE, 2);\n         var1.addElement(\"a\", false);\n         var1.addElement(\"b\", true);\n         $$serialDesc = var1;\n      }\n      ...\n      public TestData deserialize(@NotNull Decoder decoder) {\n         Intrinsics.checkNotNullParameter(decoder, \"decoder\");\n         SerialDescriptor var2 = $$serialDesc;\n         int var4 = 0;\n         String var5 = null;\n         String var6 = null;\n         Decoder decoder = decoder.beginStructure(var2);\n         if (decoder.decodeSequentially()) {\n            var5 = decoder.decodeStringElement(var2, 0);\n            var6 = decoder.decodeStringElement(var2, 1);\n            var4 = Integer.MAX_VALUE;\n         } else {\n            label19:\n            while(true) {\n               int var3 = decoder.decodeElementIndex(var2);\n               switch(var3) {\n               case -1:\n                  break label19;\n               case 0:\n                  var5 = decoder.decodeStringElement(var2, 0);\n                  var4 |= 1;\n                  break;\n               case 1:\n                  var6 = decoder.decodeStringElement(var2, 1);\n                  var4 |= 2;\n                  break;\n               default:\n                  throw (Throwable)(new UnknownFieldException(var3));\n               }\n            }\n         }\n\n         decoder.endStructure(var2);\n         return new TestData(var4, var5, var6, (SerializationConstructorMarker)null);\n      }\n      ...\n   }\n}\n```\n\n毕竟是kotlin官方的库,能够对生成的字节码任意的做改动去实现。\n\n## moshi原理\n\nmoshi则比较委婉,通过kotlin的反射机制遍历构造函数的参数,判断有没有可选参数,如果有的话就走callBy方法通过key-value map的方式传入参数,如果没有可选参数则通过vararg可变参数列表的方式顺序传入参数:\n\n```\n// Confirm all parameters are present, optional, or nullable.\nvar isFullInitialized = allBindings.size == constructorSize\nfor (i in 0 until constructorSize) {\n  if (values[i] === ABSENT_VALUE) {\n    when {\n      constructor.parameters[i].isOptional -> isFullInitialized = false\n      constructor.parameters[i].type.isMarkedNullable -> values[i] = null // Replace absent with null.\n      else -> throw missingProperty(\n        constructor.parameters[i].name,\n        allBindings[i]?.jsonName,\n        reader\n      )\n    }\n  }\n}\n\n// Call the constructor using a Map so that absent optionals get defaults.\nval result = if (isFullInitialized) {\n  constructor.call(*values)\n} else {\n  constructor.callBy(IndexedParameterMap(constructor.parameters, values))\n}\n\n```","tags":["技术相关","Android"]},{"title":"FFmpeg入门 - Android移植","url":"/2022/10/25/FFmpeg入门-Android移植/","content":"\n系列文章:\n\n1. [FFmpeg入门 - 视频播放](https://blog.islinjw.cn/2022/09/04/FFmpeg%E5%85%A5%E9%97%A8-%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/)\n2. [FFmpeg入门 - rtmp推流](https://blog.islinjw.cn/2022/09/08/FFmpeg%E5%85%A5%E9%97%A8-rtmp%E6%8E%A8%E6%B5%81/)\n3. [FFmpeg入门 - Android移植](https://blog.islinjw.cn/2022/10/25/FFmpeg%E5%85%A5%E9%97%A8-Android%E7%A7%BB%E6%A4%8D/)\n4. [FFmpeg入门 - 格式转换](https://blog.islinjw.cn/2022/11/27/FFmpeg%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/)\n\n前两篇文章介绍了如何使用ffmpeg推流和拉流,这篇我们来看看怎样将之前的代码移植到安卓上。\n\n# FFmpeg编译与集成\n\nFFmpeg的安卓交叉编译网上有很多的资料,基本上都是些编译配置而已。可以直接将我的[脚本](https://github.com/bluesky466/FFmpegAndroidDemo/blob/master/ffmpeg-4.4.2/build_ffmpeg.sh)放到ffmpeg源码根目录,修改下NDK的路径和想要编译的ABI之后直接执行。然后就能在android目录里面得到编译好的so和.h\n\n如果的确编译出现问题,也可以直接用我编出来的[库](https://github.com/bluesky466/FFmpegAndroidDemo/tree/master/app/jniLibs)。\n\n将库放到AndroidStudio工程的jniLibs目录,将include目录放到app/src/main/cpp下,然后修改CMakeLists.txt添加ffmpeg头文件路径、库路径、链接配置等:\n\n```\ncmake_minimum_required(VERSION 3.18.1)\n\nproject(\"ffmpegdemo\")\n\nadd_library(ffmpegdemo SHARED ffmpeg_demo.cpp video_sender.cpp opengl_display.cpp egl_helper.cpp video_decoder.cpp)\n\nfind_library(log-lib log)\n\n# 头文件路径\ninclude_directories(${CMAKE_SOURCE_DIR}/include)\n\n# ffmpeg库依赖\nadd_library(avcodec SHARED IMPORTED)\nset_target_properties(avcodec PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/../../../jniLibs/${ANDROID_ABI}/libavcodec.so)\n\nadd_library(avfilter SHARED IMPORTED)\nset_target_properties(avfilter PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/../../../jniLibs/${ANDROID_ABI}/libavfilter.so)\n\nadd_library(avformat SHARED IMPORTED)\nset_target_properties(avformat PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/../../../jniLibs/${ANDROID_ABI}/libavformat.so)\n\nadd_library(avutil SHARED IMPORTED)\nset_target_properties(avutil PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/../../../jniLibs/${ANDROID_ABI}/libavutil.so)\n\nadd_library(swresample SHARED IMPORTED)\nset_target_properties(swresample PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/../../../jniLibs/${ANDROID_ABI}/libswresample.so)\n\nadd_library(swscale SHARED IMPORTED)\nset_target_properties(swscale PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/../../../jniLibs/${ANDROID_ABI}/libswscale.so)\n\ntarget_link_libraries(\n        ffmpegdemo\n\n        # log\n        ${log-lib}\n\n        EGL\n        GLESv2\n        android\n\n        # FFmpeg libs\n        avcodec\n        avfilter\n        avformat\n        avutil\n        swresample\n        swscale\n)\n```\n\n这样一套下来其实ffmpeg的安卓环境就整好了,我们把之前的[video_sender.cpp](https://github.com/bluesky466/FFmpegDemo/blob/main/video_sender.cpp)和[video_sender.h](https://github.com/bluesky466/FFmpegDemo/blob/main/video_sender.h)拷贝过来添加个jni的接口验证下推流:\n\n```\n// java\nFile file = new File(getFilesDir(), \"video.flv\");\n\ntry {\n    InputStream is = getAssets().open(\"video.flv\");\n    OutputStream os = new FileOutputStream(file);\n    FileUtils.copy(is, os);\n} catch (Exception e) {\n    Log.d(\"FFmpegDemo\", \"err\", e);\n}\n\nnew Thread(new Runnable() {\n    @Override\n    public void run() {\n        send(file.getAbsolutePath(), \"rtmp://\" + SERVER_IP + \"/live/livestream\");\n    }\n}).start();\n```\n\n```\n//jni\nextern \"C\" JNIEXPORT void JNICALL\nJava_me_linjw_demo_ffmpeg_MainActivity_send(\n        JNIEnv *env,\n        jobject /* this */,\n        jstring srcFile,\n        jstring destUrl) {\n    const char *src = env->GetStringUTFChars(srcFile, NULL);\n    const char *dest = env->GetStringUTFChars(destUrl, NULL);\n    LOGD(\"send: %s -> %s\", src, dest);\n    VideoSender::Send(src, dest);\n}\n```\n\n然后就可以用安卓去推流,在pc上用之前的demo进行播放验证。\n\n# OpenGLES播放FFmpeg\n\n之前的[demo](https://blog.islinjw.cn/2022/09/04/FFmpeg%E5%85%A5%E9%97%A8-%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/)使用SDL2播放视频,但是安卓上更常规的做法是通过OpenGLES去播放。其实之前在做摄像教程的时候已经有介绍过OpenGLES的使用了:\n\n[安卓特效相机(二) EGL基础](https://blog.islinjw.cn/2019/09/13/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%BA%8C-EGL%E5%9F%BA%E7%A1%80/)\n\n[安卓特效相机(三) OpenGL ES 特效渲染](https://blog.islinjw.cn/2019/09/22/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%B8%89-OpenGL-ES-%E7%89%B9%E6%95%88%E6%B8%B2%E6%9F%93/)\n\n这篇我们就只补充下之前没有提到的部分。\n\n\n## YUV \n\n首先有个很重要的知识点在于我们的视频很多情况下解码出来都是[YUV格式](https://zh.wikipedia.org/zh-sg/YUV)的画面而不是安卓应用开发常见的RGB格式。\n\nYUV是编译true-color颜色空间（color space）的种类，Y'UV, YUV, YCbCr，YPbPr等专有名词都可以称为YUV，彼此有重叠。“Y”表示明亮度（Luminance、Luma），“U”和“V”则是色度、浓度（Chrominance、Chroma）,也就是说通过UV可以选择到一种颜色:\n\n\n{% img /FFmpeg入门Android移植/1.png %}\n\n然后再加上这种颜色的亮度就能代表我们实际看到的颜色。\n\nYUV的发明是由于彩色电视与黑白电视的过渡时期,黑白电视只有亮度的值(Y)到了彩色电视的时代为了兼容之前的黑白电视,于是在亮度值后面加上了UV值指定颜色,如果忽略了UV那么剩下的Y,就和黑白电视的信号保持一致。\n\n这种情况下数据是以 **平面格式(planar formats)** 去保存的,类似YYYYUUUUVVVV,YUV三者分开存放。\n另外也有和常见的RGB存放方式类似的 **紧缩格式(packed formats)** ,类似YUVYUVYUV,每个像素点的YUV数据连续存放。\n\n由于人的肉眼对亮度敏感对颜色相对不敏感,所以我们可以相邻的几个像素共用用UV信息,减少数据带宽。\n\n这里的共用UV信息并没有对多个像素点做UV数据的均值,而是简单的跳过一些像素点不去读取他们的UV数据。\n\n### YUV444\n\n每个像素都有自己的YUV数据,每个像素占用Y + U + V = 8 + 8 + 8 = 24 bits\n\n{% img /FFmpeg入门Android移植/YUV444.png %}\n\n444的含义是同一行相邻的4个像素,分别采样4个Y,4个U,4个V\n\n### YUV422 \n\n每两个像素共用一对UV分量,每像素平均占用Y + U + V = 8 + 4 + 4 = 16 bits\n\n{% img /FFmpeg入门Android移植/YUV422.png %}\n\n422的含义是同一行相邻的4个像素,分别采样4个Y,2个U,2个V\n\n### YUV420\n\n每四个像素共用一对UV分量,每像素平均占用Y + U + V = 8 + 2 + 2 = 12 bits\n\n{% img /FFmpeg入门Android移植/YUV420.png %}\n\nYUV420在YUV422的基础上再隔行扫描UV信息,一行只采集U,下一行只采集V\n\n420的含义是同一行相邻的4个像素,分别采样4个Y,2个U,0个V,或者4个Y,0个U,2个V\n\n\n## OpenGLES显示YUV图像\n\n由于OpenGLES使用RGB色彩,所以我们需要在fragmentShader里面将YUV转成RGB,转换公式如下:\n\nR = Y + 1.4075 * V;  \nG = Y - 0.3455 * U - 0.7169*V;  \nB = Y + 1.779 * U;\n\n由于解码之后的数据使用平面格式(planar formats)保存,所以我们可以创建三张灰度图图片分别存储YUV的分量,另外由于OpenGLES里面色彩的值范围是0\\~1.0,而UV分量的取值范围是-0.5\\~0.5所以我们UV分量统一减去0.5做偏移.于是fragmentShader代码如下:\n\n```\nstatic const string FRAGMENT_SHADER = \"#extension GL_OES_EGL_image_external : require\\n\"\n                                      \"precision highp float;\\n\"\n                                      \"varying vec2 vCoord;\\n\"\n                                      \"uniform sampler2D texY;\\n\"\n                                      \"uniform sampler2D texU;\\n\"\n                                      \"uniform sampler2D texV;\\n\"\n                                      \"varying vec4 vColor;\\n\"\n                                      \"void main() {\\n\"\n                                      \"    float y = texture2D(texY, vCoord).x;\\n\"\n                                      \"    float u = texture2D(texU, vCoord).x - 0.5;\\n\"\n                                      \"    float v = texture2D(texV, vCoord).x - 0.5;\\n\"\n                                      \"    float r = y + 1.4075 * v;\\n\"\n                                      \"    float g = y - 0.3455 * u - 0.7169 * v;\\n\"\n                                      \"    float b = y + 1.779 * u;\\n\"\n                                      \"    gl_FragColor = vec4(r, g, b, 1);\\n\"\n                                      \"}\";\n```\n\n接着由于OpenGLES里面纹理坐标原点是左下角,而解码的画面原点是左上角,所以纹理坐标需要上下调换一下:\n\n```\nstatic const float VERTICES[] = {\n        -1.0f, 1.0f,\n        -1.0f, -1.0f,\n        1.0f, -1.0f,\n        1.0f, 1.0f\n};\n\n// 由于OpenGLES里面纹理坐标原点是左下角,而解码的画面原点是左上角,所以纹理坐标需要上下调换一下\nstatic const float TEXTURE_COORDS[] = {\n        0.0f, 0.0f,\n        0.0f, 1.0f,\n        1.0f, 1.0f,\n        1.0f, 0.0f\n};\n\nstatic const short ORDERS[] = {\n        0, 1, 2, // 左下角三角形\n\n        2, 3, 0  // 右上角三角形\n};\n```\n\n最后就只要将每帧解析出来的图像交给OpenGLES去渲染就好:\n\n```\nAVFrame *frame;\nwhile ((frame = decoder.NextFrame()) != NULL) {\n    eglHelper.MakeCurrent();\n    display.Render(frame->data, frame->linesize);\n    eglHelper.SwapBuffers();\n}\n```\n## linesize\n\n接着我们就需要根据这些YUV数据创建三个灰度图分别存储各个分量的数据。这里有个知识点,解码得到的YUV数据,高是对应分量的高,但是宽却不一定是对应分量的宽.\n\n这是因为在做视频解码的时候会对宽进行对齐,让宽是16或者32的整数倍,具体是16还是32由cpu决定.例如我们的video.flv视频,原始画面尺寸是289\\*160,如果按32去对齐的话,他的Y分量的宽则是320.\n\n对齐之后的宽在ffmpeg里面称为linesize,而由于我们这个demo只支持YUV420的格式,它的Y分量的高度为原始图像的高度,UV分量的高度由于是隔行扫描,所以是原生图像高度的一半:\n\n```\nvoid OpenGlDisplay::Render(uint8_t *yuv420Data[3], int lineSize[3]) {\n    // 解码得到的YUV数据,高是对应分量的高,但是宽却不一定是对应分量的宽\n    // 这是因为在做视频解码的时候会对宽进行对齐,让宽是16或者32的整数倍,具体是16还是32由cpu决定\n    // 例如我们的video.flv视频,原始画面尺寸是689x405,如果按32去对齐的话,他的Y分量的宽则是720\n    // 对齐之后的宽在ffmpeg里面称为linesize\n    // 而对于YUV420来说Y分量的高度为原始图像的高度,UV分量的高度由于是隔行扫描,所以是原生图像高度的一半\n    setTexture(0, \"texY\", yuv420Data[0], lineSize[0], mVideoHeight);\n    setTexture(1, \"texU\", yuv420Data[1], lineSize[1], mVideoHeight / 2);\n    setTexture(2, \"texV\", yuv420Data[2], lineSize[2], mVideoHeight / 2);\n\n    // 由于对齐之后创建的纹理宽度大于原始画面的宽度,所以如果直接显示,视频的右侧会出现异常\n    // 所以我们将纹理坐标进行缩放,忽略掉右边对齐多出来的部分\n    GLint scaleX = glGetAttribLocation(mProgram, \"aCoordScaleX\");\n    glVertexAttrib1f(scaleX, mVideoWidth * 1.0f / lineSize[0]);\n\n    glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);\n    glDrawElements(GL_TRIANGLES, sizeof(ORDERS) / sizeof(short), GL_UNSIGNED_SHORT, ORDERS);\n}\n```\n\n另外由于对齐之后创建的纹理宽度大于原始画面的宽度,所以如果直接显示,视频的右侧会出现异常:\n\n{% img /FFmpeg入门Android移植/2.png %}\n\n所以我们将纹理坐标进行缩放,忽略掉右边对齐多出来的部分:\n\n```\n// VERTICES_SHADER\nvCoord = vec2(aCoord.x * aCoordScaleX, aCoord.y);\n```\n\n## 保持视频长宽比\n\n虽然视频能正常播放了，但是可以看到整个视频是铺满屏幕的。所以我们需要对视频进行缩放让他保持长宽比然后屏幕居中:\n\n```\nvoid OpenGlDisplay::SetVideoSize(int videoWidth, int videoHeight) {\n    mVideoWidth = videoWidth;\n    mVideoHeight = videoHeight;\n\n    // 如果不做处理(-1.0f, 1.0f),(-1.0f, -1.0f),(1.0f, -1.0f),(1.0f, 1.0f)这个矩形会铺满整个屏幕导致图像拉伸\n    // 由于坐标的原点在屏幕中央,所以只需要判断是横屏还是竖屏然后对x轴或者y轴做缩放就能让图像屏幕居中,然后恢复原始视频的长宽比\n    if (mWindowHeight > mWindowWidth) {\n        // 如果是竖屏的话,图像的宽不需要缩放,图像的高缩小使其竖直居中\n        GLint scaleX = glGetAttribLocation(mProgram, \"aPosScaleX\");\n        glVertexAttrib1f(scaleX, 1.0f);\n\n        // y坐标 * mWindowWidth / mWindowHeight 得到屏幕居中的正方形\n        // 然后再 * videoHeight / videoWidth 就能恢复原始视频的长宽比\n        float r = 1.0f * mWindowWidth / mWindowHeight * videoHeight / videoWidth;\n        GLint scaleY = glGetAttribLocation(mProgram, \"aPosScaleY\");\n        glVertexAttrib1f(scaleY, r);\n    } else {\n        // 如果是横屏的话,图像的高不需要缩放,图像的宽缩小使其水平居中\n        GLint scaleY = glGetAttribLocation(mProgram, \"aPosScaleY\");\n        glVertexAttrib1f(scaleY, 1.0f);\n\n        // x坐标 * mWindowHeight / mWindowWidth 得到屏幕居中的正方形\n        // 然后再 * videoWidth / videoHeight 就能恢复原始视频的长宽比\n        float r = 1.0f * mWindowHeight / mWindowWidth * videoWidth / videoHeight;\n        GLint scaleX = glGetAttribLocation(mProgram, \"aPosScaleX\");\n        glVertexAttrib1f(scaleX, r);\n    }\n}\n```\n\n```\n// VERTICES_SHADER\ngl_Position = vec4(aPosition.x * aPosScaleX, aPosition.y * aPosScaleY, 0, 1);\n```\n\n{% img /FFmpeg入门Android移植/3.jpeg %}\n\n\n# Demo工程\n\n完整的代码已经上传到[Github](https://github.com/bluesky466/FFmpegAndroidDemo)","tags":["技术相关","Android","音视频"]},{"title":"安卓系统的启动流程与各种死法","url":"/2022/09/30/安卓系统的启动流程与各种死法/","content":"\n最近遇到了蛮多framework挂掉引发的问题,这里做个总结分享.在看具体bug之前先简单了解下安卓系统的启动流程可以帮助我们定位和分析问题:\n\n# 系统启动流程\n\n开机的流程图如下:\n\n{% plantuml %}\nstart\n:BootLoader;\n:Linux Kernel;\n:init;\n  fork\n    :zygote;\n    :SystemServer;\n  fork\n    : PMS;\n  fork again\n    : WMS;\n  fork again\n    : AMS;\n    fork\n      : SystemUi;\n    fork again\n      : Launcher;\n    fork again\n      : ...;\n    end merge\n  fork again\n    : ...;\n  end merge\nfork again\n  :servicemanager;\nfork again\n  :surfaceflinger;\nfork again\n  :...;\nend merge\nstop\n{% endplantuml %}\n\n大概的步骤为:\n\n1. 启动BootLoader: 开机引导可以初始化硬件设备、建立内存空间映射图等,然后拉起LinuxKerne\n2. 启动LinuxKernel: 设置缓存、加载驱动等,然后启动init进程\n3. init进程根据init.rc进行初始化: init.rc可以看做一个脚本,可以在里面修改文件权限、设置属性、拉起进程等,zygote、servicemanager、surfaceflinger这些系统进程就是它拉起来的\n4. 启动zygote: zygote启动的时候会孵化system\\_server进程\n5. 启动system\\_server: system\\_server会启动PMS、WMS、AMS等系统服务\n6. 启动AMS: AMS启动的时候会去启动一些ui相关的进程如SystemUi、Launcher等\n\n# 系统奔溃重启流程\n\n再来分析下当system\\_server挂掉的时候的重启流程:\n\n1. 由于java层的进程都是zygote fork出来的,它会监听子进程退出的信号,然后判断如果是system\\_server退出则kill掉自己\n\n```\n// https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/jni/com_android_internal_os_Zygote.cpp?q=com_android_internal_os_Zygote.cpp\n\n// This signal handler is for zygote mode, since the zygote must reap its children\n\nstatic jint com_android_internal_os_Zygote_nativeForkSystemServer(\n        JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids,\n        jint runtime_flags, jobjectArray rlimits, jlong permitted_capabilities,\n        jlong effective_capabilities) {\n  ...\n  // 保存system_server的pid\n  gSystemServerPid = pid;\n  ...\n}\n\nstatic void SigChldHandler(int /*signal_number*/, siginfo_t* info, void* /*ucontext*/) {\n    pid_t pid;\n    ...\n    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {\n        ...\n        // 如果system_server死掉了就把自己干掉\n        if (pid == gSystemServerPid) {\n            async_safe_format_log(ANDROID_LOG_ERROR, LOG_TAG,\n                                  \"Exit zygote because system server (pid %d) has terminated\", pid);\n            kill(getpid(), SIGKILL);\n        }\n    }\n    ...\n}\n```\n\n2. zygote死掉之后init进程会重新把它拉起来\n\n因为zygote的rc文件里面配置了在zygote重启的时候会重新启动audioserver、cameraserver等进程,所以他们也会重启\n\n```\nservice zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote\n    class main\n    priority -20\n    user root\n    group root readproc reserved_disk\n    socket zygote stream 660 root system\n    socket usap_pool_primary stream 660 root system\n    onrestart exec_background - system system -- /system/bin/vdc volume abort_fuse\n    onrestart write /sys/power/state on\n    onrestart restart audioserver\n    onrestart restart cameraserver\n    onrestart restart media\n    onrestart restart netd\n    onrestart restart wificond\n    task_profiles ProcessCapacityHigh MaxPerformance\n```\n\n然后zygote启动的时候又会重新启动system\\_server进程.接着就回到了正常开机的流程:PMS、WMS、AMS这些系统服务和SystemUi、Launcher被启动\n\n# 系统开机之后死掉\n\n## 死法一: 看门狗干掉\n\n问题: 我们的某个应用打不开\n\n直接原因: 从anr的trace定位到该应用启动的时候会调用嵌入式组提供的某个so库,调用里面的某个方法卡死造成anr。\n\n本来到这里锅应该就转给底层去看了,但是底层说他也看不出具体原因,希望我们协助分析下.\n\n一通搜索之后在发现anr里面有系统的trace文件:\n\n```\n// 这里是trace文件首行,意味着system_server出现卡死所以打印的堆栈\n----- pid 4129 at 2021-11-04 19:08:03 -----\nCmd line: system_server\nBuild fingerprint: 'ViewSonic/IFP8650-5/IFP8650-5:11.0.0/20220907.130307/release-keys'\nABI: 'arm64'\nBuild type: optimized\nZygote loaded classes=21210 post zygote classes=3385\nDumping registered class loaders\n#0 dalvik.system.PathClassLoader: [], parent #1\n#1 java.lang.BootClassLoader: [], no parent\n```\n\n我还是第一次在anr目录下见到system\\_server卡死的堆栈,真是涨见识了。\n\n既然看到堆栈文件了证明system\\_server挂过然后自动重启了,所以我们在日志文件里找下19:08:03附件的日志看看,能看到system\\_server由于StorageManagerService阻塞被看门狗干掉了:\n\n```\n...\n11-04 19:08:10.436312  4129  4154 W Watchdog: *** WATCHDOG KILLING SYSTEM PROCESS: Blocked in monitor com.android.server.StorageManagerService on foreground thread (android.fg)\n11-04 19:08:10.436985  4129  4154 W Watchdog: android.fg annotated stack trace:\n11-04 19:08:10.437073  4129  4154 W Watchdog:     at android.os.MessageQueue.nativePollOnce(Native Method)\n11-04 19:08:10.437120  4129  4154 W Watchdog:     at android.os.MessageQueue.next(MessageQueue.java:335)\n11-04 19:08:10.437161  4129  4154 W Watchdog:     at android.os.Looper.loop(Looper.java:183)\n11-04 19:08:10.437202  4129  4154 W Watchdog:     at android.os.HandlerThread.run(HandlerThread.java:67)\n11-04 19:08:10.437244  4129  4154 W Watchdog:     at com.android.server.ServiceThread.run(ServiceThread.java:44)\n11-04 19:08:10.437272  4129  4154 W Watchdog: *** GOODBYE!\n--------- switch to main\n11-04 19:08:10.437306  4129  4154 I Process : Sending signal. PID: 4129 SIG: 9\n...\n11-04 19:08:11.591232  3900  3900 E Zygote  : Exit zygote because system server (pid 4129) has terminated\n```\n\n然后它会自动重启:\n\n```\n然后framework重启:\n11-04 19:08:11.990854 10300 10300 D AndroidRuntime: >>>>>> START com.android.internal.os.ZygoteInit uid 0 <<<<<<\n```\n那系统重启了为什么会导致so方法卡死呢?\n\n从系统哥那了解到so内部实际是和某个由init.rc启动的服务进程做通讯,该进程需要调用system\\_server的某些方法。\n\nsystem\\_server crash重启,并不会引发这个服务进程重启,也不会通知到这个服务,所以这个服务保存着之前挂掉的system\\_server的通讯链路,通讯失败然后就出现问题了。\n\n## 死法二: 出现未捕获异常被干掉\n\n过了几天在另外一个方案上又出现了同样卡死的问题,容易联想到应该也是system\\_server挂掉了。正常情况下system\\_server进程号是在1000以内的,用ps命令查看进程号发现它比较大,所以大概率的确是挂过了:\n\n> ps -A | grep system_server\n\n其实我们可以直接通过\"Exit zygote\"关键字查找日志,石锤它是否真的挂过:\n\n```\n> grep -rn \"Exit zygote\"\n./logd/logcat.099:12670:09-19 06:19:39.800634   301   301 E Zygote  : Exit zygote because system server (pid 618) has terminated\n```\n\n从崩溃的时间点开始往上找618进程的日志可以看到他是因为创建IpClient失败崩溃:\n\n```\n--------- switch to crash\n09-19 06:19:38.510179   618   700 E AndroidRuntime: *** FATAL EXCEPTION IN SYSTEM PROCESS: WifiHandlerThread\n09-19 06:19:38.510179   618   700 E AndroidRuntime: java.lang.IllegalStateException: Could not create IpClient\n09-19 06:19:38.510179   618   700 E AndroidRuntime: \tat com.android.wifi.x.android.net.networkstack.NetworkStackClientBase.lambda$makeIpClient$1(NetworkStackClientBase.java:74)\n09-19 06:19:38.510179   618   700 E AndroidRuntime: \tat com.android.wifi.x.android.net.networkstack.-$$Lambda$NetworkStackClientBase$vgsHk-RCpPUAYmE-7YTwKKaAuFA.accept(Unknown Source:6)\n09-19 06:19:38.510179   618   700 E AndroidRuntime: \tat com.android.wifi.x.android.net.networkstack.NetworkStackClientBase.requestConnector(NetworkStackClientBase.java:119)\n09-19 06:19:38.510179   618   700 E AndroidRuntime: \tat com.android.wifi.x.android.net.networkstack.NetworkStackClientBase.makeIpClient(NetworkStackClientBase.java:70)\n09-19 06:19:38.510179   618   700 E AndroidRuntime: \tat com.android.wifi.x.android.net.ip.IpClientUtil.makeIpClient(IpClientUtil.java:80)\n09-19 06:19:38.510179   618   700 E AndroidRuntime: \tat com.android.server.wifi.FrameworkFacade.makeIpClient(FrameworkFacade.java:202)\n09-19 06:19:38.510179   618   700 E AndroidRuntime: \tat com.android.server.wifi.ClientModeImpl.setupClientMode(ClientModeImpl.java:3606)\n09-19 06:19:38.510179   618   700 E AndroidRuntime: \tat com.android.server.wifi.ClientModeImpl.access$3600(ClientModeImpl.java:164)\n09-19 06:19:38.510179   618   700 E AndroidRuntime: \tat com.android.server.wifi.ClientModeImpl$ConnectModeState.enter(ClientModeImpl.java:3790)\n09-19 06:19:38.510179   618   700 E AndroidRuntime: \tat com.android.wifi.x.com.android.internal.util.StateMachine$SmHandler.invokeEnterMethods(StateMachine.java:1037)\n09-19 06:19:38.510179   618   700 E AndroidRuntime: \tat com.android.wifi.x.com.android.internal.util.StateMachine$SmHandler.performTransitions(StateMachine.java:879)\n09-19 06:19:38.510179   618   700 E AndroidRuntime: \tat com.android.wifi.x.com.android.internal.util.StateMachine$SmHandler.handleMessage(StateMachine.java:819)\n09-19 06:19:38.510179   618   700 E AndroidRuntime: \tat android.os.Handler.dispatchMessage(Handler.java:106)\n09-19 06:19:38.510179   618   700 E AndroidRuntime: \tat android.os.Looper.loop(Looper.java:223)\n09-19 06:19:38.510179   618   700 E AndroidRuntime: \tat android.os.HandlerThread.run(HandlerThread.java:67)\n09-19 06:19:38.510179   618   700 E AndroidRuntime: Caused by: android.os.DeadObjectException\n09-19 06:19:38.510179   618   700 E AndroidRuntime: \tat android.os.BinderProxy.transactNative(Native Method)\n09-19 06:19:38.510179   618   700 E AndroidRuntime: \tat android.os.BinderProxy.transact(BinderProxy.java:550)\n09-19 06:19:38.510179   618   700 E AndroidRuntime: \tat com.android.wifi.x.android.net.INetworkStackConnector$Stub$Proxy.makeIpClient(INetworkStackConnector.java:226)\n09-19 06:19:38.510179   618   700 E AndroidRuntime: \tat com.android.wifi.x.android.net.networkstack.NetworkStackClientBase.lambda$makeIpClient$1(NetworkStackClientBase.java:72)\n09-19 06:19:38.510179   618   700 E AndroidRuntime: \t... 14 more\n--------- switch to events\n09-19 06:19:38.510843   618   700 I am_crash: [618,0,system_server,-1,android.os.DeadObjectException,Could not create IpClient,BinderProxy.java,-2]\n```\n\n## 死法三: 系统关键服务奔溃导致系统重启\n\n过了一个星期，又又出现了同样的卡死问题。但是这次直接过滤\"Exit zygote\"关键字找不到信息, 但是看system\\_server进程号是4677,大概率还是挂过\n\n> system         4677   4416 6 02:47:25 ?     00:05:48 system_server\n\n然后再搜索zygote启动的关键字\" START com.android.internal.os.ZygoteInit\"发现的确系统在中间重启过:\n\n> ./logd/logcat.028:3181:09-29 02:47:22.978333  4416  4416 D AndroidRuntime: >>>>>> START com.android.internal.os.ZygoteInit uid 0 <<<<<<\n\n去这个时间往上找可以看到一些native的堆栈错误:\n\n```\n--------- switch to crash\n09-29 02:47:21.762310  4403  4403 F DEBUG   : *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***\n09-29 02:47:21.762564  4403  4403 F DEBUG   : Build fingerprint: 'Droidlogic/t982_ar301/AVS-7500:11/RD2A.211001.002/eng.user5.20220811.094633:user/test-keys'\n09-29 02:47:21.762637  4403  4403 F DEBUG   : Revision: '0'\n09-29 02:47:21.762742  4403  4403 F DEBUG   : ABI: 'arm'\n09-29 02:47:21.763405  4403  4403 F DEBUG   : Timestamp: 2022-09-29 02:47:21-0400\n09-29 02:47:21.763549  4403  4403 F DEBUG   : pid: 343, tid: 3098, name: composer@2.4-se  >>> /vendor/bin/hw/android.hardware.graphics.composer@2.4-service.droidlogic <<<\n09-29 02:47:21.763584  4403  4403 F DEBUG   : uid: 1000\n09-29 02:47:21.763614  4403  4403 F DEBUG   : signal 11 (SIGSEGV), code 2 (SEGV_ACCERR), fault addr 0xf26ea000\n09-29 02:47:21.763695  4403  4403 F DEBUG   : Cause: [GWP-ASan]: Buffer Overflow, 0 bytes right of a 24-byte allocation at 0xf26e9fe8\n09-29 02:47:21.763743  4403  4403 F DEBUG   :     r0  f26e9fe8  r1  0000000c  r2  00000000  r3  00000000\n09-29 02:47:21.763774  4403  4403 F DEBUG   :     r4  00000000  r5  0000001a  r6  e87d9088  r7  f0444160\n09-29 02:47:21.763803  4403  4403 F DEBUG   :     r8  e87d9080  r9  e87d8ec8  r10 f26e9fe8  r11 f0e3f760\n09-29 02:47:21.763836  4403  4403 F DEBUG   :     ip  f0e3db20  sp  e87d8ea0  lr  f0e18db3  pc  f1d9ceca\n09-29 02:47:21.776427  4403  4403 F DEBUG   : backtrace:\n09-29 02:47:21.776600  4403  4403 F DEBUG   :       #00 pc 00002eca  /vendor/lib/libamgralloc_ext.so (am_gralloc_get_width(native_handle const*)+8) (BuildId: e6b2c270ca2b92162da0e931af324ab6)\n09-29 02:47:21.776802  4403  4403 F DEBUG   :       #01 pc 00058daf  /vendor/lib/hw/hwcomposer.amlogic.so (NnProcessor::asyncProcess(std::__1::shared_ptr<DrmFramebuffer>&, std::__1::shared_ptr<DrmFramebuffer>&, int&)+310) (BuildId: 0ed81d2b4576c8a8b13c166d0020f67a)\n09-29 02:47:21.776907  4403  4403 F DEBUG   :       #02 pc 0004a82f  /vendor/lib/hw/hwcomposer.amlogic.so (MultiplanesWithDiComposition::runProcessor(MultiplanesWithDiComposition::DisplayPair&, int&, int&)+210) (BuildId: 0ed81d2b4576c8a8b13c166d0020f67a)\n09-29 02:47:21.776977  4403  4403 F DEBUG   :       #03 pc 0004d9e1  /vendor/lib/hw/hwcomposer.amlogic.so (MultiplanesWithDiComposition::commit(bool)+976) (BuildId: 0ed81d2b4576c8a8b13c166d0020f67a)\n09-29 02:47:21.777048  4403  4403 F DEBUG   :       #04 pc 0003d1bb  /vendor/lib/hw/hwcomposer.amlogic.so (Hwc2Display::presentVideo(int*)+58) (BuildId: 0ed81d2b4576c8a8b13c166d0020f67a)\n09-29 02:47:21.777102  4403  4403 F DEBUG   :       #05 pc 0004370f  /vendor/lib/hw/hwcomposer.amlogic.so (VideoTunnelThread::handleGameMode()+154) (BuildId: 0ed81d2b4576c8a8b13c166d0020f67a)\n09-29 02:47:21.777154  4403  4403 F DEBUG   :       #06 pc 00043375  /vendor/lib/hw/hwcomposer.amlogic.so (VideoTunnelThread::gameModeThreadMain(void*)+56) (BuildId: 0ed81d2b4576c8a8b13c166d0020f67a)\n09-29 02:47:21.777213  4403  4403 F DEBUG   :       #07 pc 000808b3  /apex/com.android.runtime/lib/bionic/libc.so (__pthread_start(void*)+40) (BuildId: 7bc8508bdbcc8163b9a5fbf3443efa72)\n09-29 02:47:21.777261  4403  4403 F DEBUG   :       #08 pc 00039d23  /apex/com.android.runtime/lib/bionic/libc.so (__start_thread+30) (BuildId: 7bc8508bdbcc8163b9a5fbf3443efa72)\n09-29 02:47:21.777295  4403  4403 F DEBUG   : deallocated by thread 445:\n```\n\n这个堆栈我看们可以看出pid 343这个进程在libamgralloc\\_ext.so的am\\_gralloc\\_get\\_width方法里面出现了野指针\n\n然后往下翻一点可以看到一堆的系统服务died:\n\n```\n09-29 02:47:22.551747   394  3624 E csound  : [HIDLServer]:serviceDied, droid tvserver daemon a client died cookie:2\n09-29 02:47:22.551817   394  3624 E csound  : tvserver daemon client:2 died\n09-29 02:47:22.551865   394  3624 E csound  : handleServiceDeath, client size:5\n09-29 02:47:22.551956   323   411 E SystemControl: systemcontrol daemon client died cookie:1\n09-29 02:47:22.637123   493   621 W AudioSystem: AudioFlinger server died!\n09-29 02:47:22.079547   393   393 E HwcComposer: executeCommands failed because of Status(EX_TRANSACTION_FAILED): 'DEAD_OBJECT: '\n09-29 02:47:22.114335  1020  1358 W SurfaceComposerClient: ComposerService remote (surfaceflinger) died [0xf24d2c10]\n09-29 02:47:22.450807   323   411 E SystemControl: systemcontrol daemon client died cookie:0\n09-29 02:47:22.451031   394  3624 E csound  : [HIDLServer]:serviceDied, droid tvserver daemon a client died cookie:4\n09-29 02:47:22.451104   394  3624 E csound  : tvserver daemon client:4 died\n09-29 02:47:22.451150   394  3624 E csound  : handleServiceDeath, client size:5\n```\n\n而且上一个system\\_server(pid 777)最后的打印是为343创建墓碑文件,接着Zygote就重启了,所以大概率是这个系统服务的奔溃引发了整个系统的奔溃:\n\n```\n09-29 02:47:22.009985   777   996 W NativeCrashListener: Couldn't find ProcessRecord for pid 343\n--------- switch to main\n09-29 02:47:22.010605   291   291 E tombstoned: Tombstone written to: /data/tombstones/tombstone_08\n--------- switch to system\n09-29 02:47:22.017120   777   811 I BootReceiver: Copying /data/tombstones/tombstone_08 to DropBox (SYSTEM_TOMBSTONE)\n09-29 02:47:22.018136   777   811 I DropBoxManagerService: add tag=SYSTEM_TOMBSTONE isTagEnabled=true flags=0x2\n--------- switch to events\n09-29 02:47:22.042284   777   811 I dropbox_file_copy: [/data/tombstones/tombstone_08,65536,SYSTEM_TOMBSTONE]\n09-29 02:47:22.047667   777   811 I commit_sys_config_file: [log-files,5]\n...\n09-29 02:47:22.978333  4416  4416 D AndroidRuntime: >>>>>> START com.android.internal.os.ZygoteInit uid 0 <<<<<<\n```\n\n由于log里面并没有搜索到Zygote exit或者crash的信息,那么有可能是日志被冲掉了\n\n还有可能是zygote被restart了,我们看这个进程的rc文件可以看他如果他重启的话会重启surfaceflinger:\n\n```\nservice vendor.hwcomposer-2-4 /vendor/bin/hw/android.hardware.graphics.composer@2.4-service.droidlogic\n    class hal animation\n    user system\n    group graphics drmrpc\n    capabilities SYS_NICE\n    onrestart restart surfaceflinger\n    ...\n```\n\n然后看surfaceflinger的rc文件发现它会重启zygote:\n```\nservice surfaceflinger /system/bin/surfaceflinger\n\tclass core animation\n\tuser system\n\tgroup graphics drmrpc readproc\n\tcapabilities SYS_NICE\n\tonrestart restart zygote\n\t...\n```\n\n所以死因就清晰了\n1. /vendor/bin/hw/android.hardware.graphics.composer@2.4-service.droidlogic出现野指针crash重启\n2. /vendor/bin/hw/android.hardware.graphics.composer@2.4-service.droidlogic重启的时候会重启surfaceflinger\n3. surfaceflinger重启的时候又会重启zygote\n\n\n**为了以后不再受这个卡死问题的困扰,让系统哥在zygote的rc文件里面配置zygote重启的时候把那个异常的服务也同步重启就可以了。**\n\n# 系统开机死掉导致开不了机\n\n## 死法四: native奔溃导致卡logo\n\n问题: 升级软件之后开机卡logo开不了机\n\n出现这个问题首先要分析日志,但是串口直接logcat的话刷的太快不好排查所有些抓日志的小技巧:\n\n1. 使用重定向把日志导出到文件,例如/storage目录下:\n\n> logcat > /storage/log.log\n\n然后就能用busybox vi去编辑查看了\n\n2. 插入u盘将日志文件导出到u盘(需要root)\n\n由于开机没有成功,u盘可能还没有挂载上去,需要我们手动挂载。\n\n首先需要用blkid命令列出所有文件系统,找到u盘(u盘名字就叫PTT)的设备节点为/dev/sda1:\n\n```shell\nconsole:/storage # blkid\n/dev/zram0: UUID=\"12a21a37-1a08-42e6-97e3-90cb1a1ba60a\" TYPE=\"swap\"\n/dev/mmcblk0p16: TYPE=\"squashfs\"\n/dev/mmcblk0p18: TYPE=\"squashfs\"\n/dev/mmcblk0p20: UUID=\"57f8f4bc-abf4-655f-bf67-946fc0f9f25b\" TYPE=\"ext4\"\n/dev/mmcblk0p32: SEC_TYPE=\"msdos\" UUID=\"5278-5278\" TYPE=\"vfat\"\n/dev/mmcblk0p39: UUID=\"57f8f4bc-abf4-655f-bf67-946fc0f9f25b\" TYPE=\"ext4\"\n/dev/block/mmcblk0p56: LABEL=\"/\" UUID=\"5ac835d7-e53a-59f8-a2c4-b8a6967b849e\" TYPE=\"ext4\"\n/dev/block/mmcblk0p58: LABEL=\"vendor\" UUID=\"c7f6b4dc-c6f7-59d6-90cf-bc83aed55ec7\" TYPE=\"ext4\"\n/dev/block/mmcblk0p60: UUID=\"cf81e7c0-047f-404a-81da-7d188dd0ccc0\" TYPE=\"ext4\"\n/dev/sda1: LABEL=\"PTT\" UUID=\"B4BE-1BCC\" TYPE=\"vfat\"\n```\n\n然后随便找个地方例如就在/storage,创建一个目录并且将u盘mount过去,接着将日志拷贝过去:\n\n```\nmkdir sda\nmount /dev/sda1 sda/\ncp /storage/log.log /storage/sda\nsync\n```\n\n然后我们就能把u盘拔出来插到我们自己的电脑上分析日志了,从这个日志里面由于zygote还没启动成功,所以前面用的\"Exit zygote\"关键字是找不到日志的,但是能看到一直在报native层的堆栈。\n\n创建java虚拟机的时候找不到libaccelerator\\_base.so触发断言导致系统奔溃:\n\n```\n09-22 11:34:20.119  2233  2233 I tombstoned: received crash request for pid 3174\n09-22 11:34:20.128  3209  3209 F DEBUG   : *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***\n09-22 11:34:20.129  3209  3209 F DEBUG   : Build fingerprint: 'cvt/mt9950_cn/mt9950_cn:11/RP1A.200720.011/6182:user/release-keys'\n09-22 11:34:20.129  3209  3209 F DEBUG   : Revision: '0'\n09-22 11:34:20.129  3209  3209 F DEBUG   : ABI: 'arm64'\n09-22 11:34:20.129  3209  3209 F DEBUG   : Timestamp: 2022-09-22 11:34:20+0800\n09-22 11:34:20.130  3209  3209 F DEBUG   : pid: 3174, tid: 3174, name: main  >>> zygote64 <<<\n09-22 11:34:20.130  3209  3209 F DEBUG   : uid: 0\n09-22 11:34:20.130  3209  3209 F DEBUG   : signal 6 (SIGABRT), code -1 (SI_QUEUE), fault addr --------\n09-22 11:34:20.130  3209  3209 F DEBUG   : Abort message: 'Error preloading public library libaccelerator_base.so: dlopen failed: library \"libaccelerator_base.so\" not found'\n09-22 11:34:20.130  3209  3209 F DEBUG   :     x0  0000000000000000  x1  0000000000000c66  x2  0000000000000006  x3  0000007fe9f17ef0\n09-22 11:34:20.130  3209  3209 F DEBUG   :     x4  0000007c1de1e000  x5  0000007c1de1e000  x6  0000007c1de1e000  x7  000000000000168c\n09-22 11:34:20.130  3209  3209 F DEBUG   :     x8  00000000000000f0  x9  0000007c192b17f8  x10 ffffff80fffffbdf  x11 0000000000000001\n09-22 11:34:20.130  3209  3209 F DEBUG   :     x12 0000000000000000  x13 0000000000000655  x14 0000007fe9f16d10  x15 00008b1aad54c6e4\n09-22 11:34:20.130  3209  3209 F DEBUG   :     x16 0000007c1934ac80  x17 0000007c1932bf20  x18 0000007c1d608000  x19 00000000000000ac\n09-22 11:34:20.130  3209  3209 F DEBUG   :     x20 0000000000000c66  x21 00000000000000b2  x22 0000000000000c66  x23 00000000ffffffff\n09-22 11:34:20.130  3209  3209 F DEBUG   :     x24 0000007987636000  x25 0000000000000002  x26 0000007987013c07  x27 000000000000002b\n09-22 11:34:20.130  3209  3209 F DEBUG   :     x28 0000007987638000  x29 0000007fe9f17f70\n09-22 11:34:20.130  3209  3209 F DEBUG   :     lr  0000007c192df0c4  sp  0000007fe9f17ed0  pc  0000007c192df0f4  pst 0000000000000000\n09-22 11:34:20.151  3209  3209 F DEBUG   : backtrace:\n09-22 11:34:20.151  3209  3209 F DEBUG   :       #00 pc 000000000004e0f4  /apex/com.android.runtime/lib64/bionic/libc.so (abort+180) (BuildId: c78cdff5b820a550771130d6bde95081)\n09-22 11:34:20.151  3209  3209 F DEBUG   :       #01 pc 0000000000565bc8  /apex/com.android.art/lib64/libart.so (art::Runtime::Abort(char const*)+2320) (BuildId: a0e45eb7480266d293a7de84fc1c7a3c)\n09-22 11:34:20.151  3209  3209 F DEBUG   :       #02 pc 0000000000013ab0  /system/lib64/libbase.so (android::base::SetAborter(std::__1::function<void (char const*)>&&)::$_3::__invoke(char const*)+80) (BuildId: 6d398535cd6d9315930f056432520bb9)\n09-22 11:34:20.151  3209  3209 F DEBUG   :       #03 pc 0000000000006ec8  /system/lib64/liblog.so (__android_log_assert+336) (BuildId: c92329feece7a2d7fa4d9fb6acc815f9)\n09-22 11:34:20.151  3209  3209 F DEBUG   :       #04 pc 000000000000ebcc  /apex/com.android.art/lib64/libnativeloader.so (android::nativeloader::LibraryNamespaces::Initialize()+324) (BuildId: 4e6450569b3bdee211e32baf7d0dfba7)\n09-22 11:34:20.151  3209  3209 F DEBUG   :       #05 pc 000000000000e044  /apex/com.android.art/lib64/libnativeloader.so (InitializeNativeLoader+36) (BuildId: 4e6450569b3bdee211e32baf7d0dfba7)\n09-22 11:34:20.151  3209  3209 F DEBUG   :       #06 pc 000000000039066c  /apex/com.android.art/lib64/libart.so (JNI_CreateJavaVM+732) (BuildId: a0e45eb7480266d293a7de84fc1c7a3c)\n09-22 11:34:20.151  3209  3209 F DEBUG   :       #07 pc 00000000000a023c  /system/lib64/libandroid_runtime.so (android::AndroidRuntime::startVm(_JavaVM**, _JNIEnv**, bool, bool)+9060) (BuildId: 88ac6961382cb34f5fac714acaf48103)\n09-22 11:34:20.151  3209  3209 F DEBUG   :       #08 pc 00000000000a0890  /system/lib64/libandroid_runtime.so (android::AndroidRuntime::start(char const*, android::Vector<android::String8> const&, bool)+464) (BuildId: 88ac6961382cb34f5fac714acaf48103)\n09-22 11:34:20.151  3209  3209 F DEBUG   :       #09 pc 0000000000003570  /system/bin/app_process64 (main+1320) (BuildId: d4686d3f8282764488eb9ca7cc518583)\n09-22 11:34:20.151  3209  3209 F DEBUG   :       #10 pc 00000000000495b4  /apex/com.android.runtime/lib64/bionic/libc.so (__libc_init+108) (BuildId: c78cdff5b820a550771130d6bde95081)\n09-22 11:34:20.192  3175  3175 F libc    : Fatal signal 6 (SIGABRT), code -1 (SI_QUEUE) in tid 3175 (main), pid 3175 (main)\n```\n\n像这种native的奔溃,如果logcat里面定位不到根因的话可以分析/data/tombstones下的墓碑文件,里面的信息比较全:\n\n```\nconsole:/data/tombstones # ls\ntombstone_00  tombstone_07  tombstone_14  tombstone_21  tombstone_28\ntombstone_01  tombstone_08  tombstone_15  tombstone_22  tombstone_29\ntombstone_02  tombstone_09  tombstone_16  tombstone_23  tombstone_30\ntombstone_03  tombstone_10  tombstone_17  tombstone_24  tombstone_31\ntombstone_04  tombstone_11  tombstone_18  tombstone_25\ntombstone_05  tombstone_12  tombstone_19  tombstone_26\ntombstone_06  tombstone_13  tombstone_20  tombstone_27\n```\n\n## 死法五: 系统应用签名错误导致系统崩溃开不了机\n\n有时候我们在手动替换系统应用的时候会出现开不了机的情况,那么由于是替换完应用才出现问题的,所以我们可以直接接入串口过滤应用包名:\n\n```\nconsole:/storage # blkid logcat | grep me.linjw.demo\n09-21 23:19:10.932  3611  3611 E AndroidRuntime: java.lang.IllegalStateException: Signature mismatch on system package me.linjw.demo for shared user SharedUserSetting{5a1fdd7 android.uid.system/1000}\n```\n\n从上面的信息就能很明显的看到是me.linjw.demo的签名错误导致抛出异常。\n\n如果是编译系统的时候应用签名就错了,升级软件就开不了机,我们用前面的方法把logcat导出来,还是过滤下\"Exit zygote\"关键字,也是能看到日志的:\n\n> 09-21 23:19:11.061  3541  3541 E Zygote  : Exit zygote because system server (pid 3611) has terminated\n\n同样再往上搜索3611进程的日志可以看到是PackageManagerService在开机的时候搜索所有安装的apk的时候触发到了应用系统签名错误的异常:\n\n```\n09-21 23:19:10.932  3611  3611 E AndroidRuntime: *** FATAL EXCEPTION IN SYSTEM PROCESS: main\n09-21 23:19:10.932  3611  3611 E AndroidRuntime: java.lang.IllegalStateException: Signature mismatch on system package me.linjw.demo for shared user SharedUserSetting{5a1fdd7 android.uid.system/1000}\n09-21 23:19:10.932  3611  3611 E AndroidRuntime: \tat com.android.server.pm.PackageManagerService.reconcilePackagesLocked(PackageManagerService.java:16568)\n09-21 23:19:10.932  3611  3611 E AndroidRuntime: \tat com.android.server.pm.PackageManagerService.addForInitLI(PackageManagerService.java:9537)\n09-21 23:19:10.932  3611  3611 E AndroidRuntime: \tat com.android.server.pm.PackageManagerService.scanDirLI(PackageManagerService.java:9131)\n09-21 23:19:10.932  3611  3611 E AndroidRuntime: \tat com.android.server.pm.PackageManagerService.scanDirTracedLI(PackageManagerService.java:9083)\n09-21 23:19:10.932  3611  3611 E AndroidRuntime: \tat com.android.server.pm.PackageManagerService.<init>(PackageManagerService.java:3111)\n09-21 23:19:10.932  3611  3611 E AndroidRuntime: \tat com.android.server.pm.PackageManagerService.main(PackageManagerService.java:2599)\n09-21 23:19:10.932  3611  3611 E AndroidRuntime: \tat com.android.server.SystemServer.startBootstrapServices(SystemServer.java:851)\n09-21 23:19:10.932  3611  3611 E AndroidRuntime: \tat com.android.server.SystemServer.run(SystemServer.java:590)\n09-21 23:19:10.932  3611  3611 E AndroidRuntime: \tat com.android.server.SystemServer.main(SystemServer.java:408)\n09-21 23:19:10.932  3611  3611 E AndroidRuntime: \tat java.lang.reflect.Method.invoke(Native Method)\n09-21 23:19:10.932  3611  3611 E AndroidRuntime: \tat com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:592)\n09-21 23:19:10.932  3611  3611 E AndroidRuntime: \tat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:925)\n09-21 23:19:10.933  3611  3611 E AndroidRuntime: Error reporting crash\n09-21 23:19:10.933  3611  3611 E AndroidRuntime: java.lang.NullPointerException: Attempt to invoke interface method 'void android.app.IActivityManager.handleApplicationCrash(android.os.IBinder, android.app.ApplicationErrorReport$ParcelableCrashInfo)' on a null object reference\n09-21 23:19:10.933  3611  3611 E AndroidRuntime: \tat com.android.internal.os.RuntimeInit$KillApplicationHandler.uncaughtException(RuntimeInit.java:158)\n09-21 23:19:10.933  3611  3611 E AndroidRuntime: \tat java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:1073)\n09-21 23:19:10.933  3611  3611 E AndroidRuntime: \tat java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:1068)\n09-21 23:19:10.933  3611  3611 E AndroidRuntime: \tat java.lang.Thread.dispatchUncaughtException(Thread.java:2203)\n09-21 23:19:10.933  3611  3611 I Process : Sending signal. PID: 3611 SIG: 9\n09-21 23:19:11.061  3541  3541 E Zygote  : Zygote failed to write to system_server FD: Connection refused\n09-21 23:19:11.061  3541  3541 I Zygote  : Process 3611 exited due to signal 9 (Killed)\n09-21 23:19:11.061  3541  3541 E Zygote  : Exit zygote because system server (pid 3611) has terminated\n```\n\n# 总结\n\n1.如果发现system\\_server的进程号比较大,那么大概率重启过\n\n2.可以用\"Exit zygote\"关键字去搜索找到system\\_server挂掉的时间,如果没有这个找不到这个关机字的话也能搜索下\"START com.android.internal.os.ZygoteInit\"看看重启的时间,然后往上搜索下面的关键字找具体死因:\n\n- DEBUG : native 层出现异常的时候会有堆栈的打印\n- crash : 奔溃信息打印\n- kill : 一些异常触发系统被强杀\n- tombstone : 虚拟机、c层的错误触发墓碑文件生成\n- died : 某些服务死掉\n\n","tags":["技术相关","Android"]},{"title":"FFmpeg入门 - rtmp推流","url":"/2022/09/08/FFmpeg入门-rtmp推流/","content":"\n系列文章:\n\n\n1. [FFmpeg入门 - 视频播放](https://blog.islinjw.cn/2022/09/04/FFmpeg%E5%85%A5%E9%97%A8-%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/)\n2. [FFmpeg入门 - rtmp推流](https://blog.islinjw.cn/2022/09/08/FFmpeg%E5%85%A5%E9%97%A8-rtmp%E6%8E%A8%E6%B5%81/)\n3. [FFmpeg入门 - Android移植](https://blog.islinjw.cn/2022/10/25/FFmpeg%E5%85%A5%E9%97%A8-Android%E7%A7%BB%E6%A4%8D/)\n4. [FFmpeg入门 - 格式转换](https://blog.islinjw.cn/2022/11/27/FFmpeg%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/)\n\n[上一篇博客](https://blog.islinjw.cn/2022/09/04/FFmpeg%E5%85%A5%E9%97%A8-%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/)介绍了怎样用ffmpeg去播放视频.\n\n里面用于打开视频流的avformat\\_open\\_input函数除了打开本地视频之外,实际上也能打开rtmp协议的远程视频,实现拉流:\n\n```\n./demo -p 本地视频路径\n\n./demo -p rtmp://服务器ip/视频流路径\n```\n\n这篇文章我们来讲下怎样实现推流,然后和之前的demo代码配合就能完成推流、拉流的整个过程,实现直播。\n\n# rtmp服务器\n\n整个直播的功能分成下面三个模块:\n\n\n{% plantuml %}\n\ncloud {\n  [服务器]\n}\n\n[推流端] -> [服务器]\n[服务器] -> [拉流端]\n\n{% endplantuml %}\n\n从上图我们可以看到rtmp是需要服务器做转发的,我们选用开源的[srs](https://github.com/ossrs/srs).直接从github上把它的源码拉下来编译,然后直接启动即可:\n\n```\ngit clone git@github.com:ossrs/srs.git\ncd srs/trunk\n./configure\nmake\n./etc/init.d/srs start\n```\n\n如果是本地的电脑,这个时候就能在局域网内直接用它的内网ip去访问了.但如果是腾讯云、阿里云之类的云服务器还需要配置安全组开放下面几个端口的访问权限:\n\n```\nlisten              1935;\nmax_connections     1000;\n#srs_log_tank        file;\n#srs_log_file        ./objs/srs.log;\ndaemon              on;\nhttp_api {\n    enabled         on;\n    listen          1985;\n}\nhttp_server {\n    enabled         on;\n    listen          8080;\n    dir             ./objs/nginx/html;\n}\nrtc_server {\n    enabled on;\n    listen 8000; # UDP port\n    # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/webrtc#config-candidate\n    candidate $CANDIDATE;\n}\n...\n```\n\n当然如果这几个端口已经被占用的话可以修改配置文件conf/srs.conf去修改\n\n服务器到这里就准备好了,浏览器访问下面网址对srs进行调试、配置:\n\n> http://服务器ip:8080/players/rtc_publisher.html\n> http://服务器ip:1985/console/ng_index.html\n\n# 推流\n\n## 准备输出流\n\n我们选择推送本地的视频到rtmp服务器,所以第一步仍然是打开本地视频流:\n\n```c++\nbool VideoSender::Send(const string& srcUrl, const string& destUrl) {\n    ...\n    // 打开文件流读取文件头解析出视频信息如轨道信息、时长等\n    // mFormatContext初始化为NULL,如果打开成功,它会被设置成非NULL的值\n    // 这个方法实际可以打开多种来源的数据,url可以是本地路径、rtmp地址等\n    // 在不需要的时候通过avformat_close_input关闭文件流\n    if(avformat_open_input(&inputFormatContext, srcUrl.c_str(), NULL, NULL) < 0) {\n        cout << \"open \" << srcUrl << \" failed\" << endl;\n        break;\n    }\n\n    // 对于没有文件头的格式如MPEG或者H264裸流等,可以通过这个函数解析前几帧得到视频的信息\n    if(avformat_find_stream_info(inputFormatContext, NULL) < 0) {\n        cout << \"can't find stream info in \" << srcUrl << endl;\n        break;\n    }\n\n    // 打印输入视频信息\n    av_dump_format(inputFormatContext, 0, srcUrl.c_str(), 0);\n    ...\n}\n```\n\n本地视频打开之后,我们创建输出视频流上下文,然后为输出流创建轨道,最后打开输出视频流:\n\n```c++\n// 创建输出流上下文,outputFormatContext初始化为NULL,如果打开成功,它会被设置成非NULL的值,在不需要的时候使用avformat_free_context释放\n// 输出流使用flv格式\nif(avformat_alloc_output_context2(&outputFormatContext, NULL, \"flv\", destUrl.c_str()) < 0) {\n    cout << \"can't alloc output context for \" << destUrl << endl;\n    break;\n}\n\n// 拷贝编解码参数\nif(!createOutputStreams(inputFormatContext, outputFormatContext)) {\n    break;\n}\n\n// 打印输出视频信息\nav_dump_format(outputFormatContext, 0, destUrl.c_str(), 1);\n\n// 打开输出流,结束的时候使用avio_close关闭\nif(avio_open(&outputFormatContext->pb, destUrl.c_str(), AVIO_FLAG_WRITE) < 0) {\n    cout << \"can't open avio \" << destUrl << endl;\n    break;\n}\n```\n\n这里有个createOutputStreams用于根据本地视频文件的轨道信息,为输出流创建同样的轨道:\n\n```c++\nstatic bool createOutputStreams(AVFormatContext* inputFormatContext, AVFormatContext* outputFormatContext) {\n    // 遍历输入流的所有轨道,拷贝编解码参数到输出流\n    for(int i = 0 ; i < inputFormatContext->nb_streams ; i++) {\n        // 为输出流创建轨道\n        AVStream* stream = avformat_new_stream(outputFormatContext, NULL);\n        if(NULL == stream) {\n            cout << \"can't create stream, index \" << i << endl;\n            return false;\n        }\n\n        // 编解码参数在AVCodecParameters中保存,从输入流拷贝到输出流\n        if(avcodec_parameters_copy(stream->codecpar, inputFormatContext->streams[i]->codecpar) < 0) {\n            cout << \"can't copy codec paramters, stream index \" << i << endl;\n            return false;\n        }\n\n        // codec_tag代表了音视频数据采用的码流格式,不同的封装格式如flv、mp4等的支持情况是不一样的\n        // 上面的avcodec_parameters_copy将输出流的codec_tag从输入拷贝过来变成了一样的\n        // 由于我们输出流在avformat_alloc_output_context2的时候写死了flv格式\n        // 如果输入流不是flv而是mp4等格式的话就可能会出现mp4里某种codec_tag在flv不支持导致推流失败的情况\n        // 这里我们可以用av_codec_get_id从输出流的oformat的支持的codec_tag列表里面查找codec_id\n        // 如果和codecpar的codec_id不一致的话代表不支持\n        if(av_codec_get_id(outputFormatContext->oformat->codec_tag, stream->codecpar->codec_tag) != stream->codecpar->codec_id) {\n            // 这里将codec_tag设置为0,FFmpeg会根据编码codec_id从封装格式的codec_tag列表中找到一个codec_tag\n            stream->codecpar->codec_tag = 0;\n        }\n    }\n    return true;\n}\n```\n\n## codec\\_id和codec\\_tag\n\n这里可以看到对于编码器有codec\\_id和codec\\_tag两个字段去描述,codec\\_id代表的是数据的编码类型.而codec\\_tag用于更详细的描述编解码的格式信息,它对应的是FourCC(Four-Character Codes)数据。\n\n例如codec\\_id都是AV\\_CODEC\\_ID\\_RAWVIDEO的裸数据,但它可能是YUV的裸数据也可能是RGB的裸数据:\n\n```c++\n// libavformat/isom.c\n{ AV_CODEC_ID_RAWVIDEO, MKTAG('r', 'a', 'w', ' ') }, /* uncompressed RGB */\n{ AV_CODEC_ID_RAWVIDEO, MKTAG('y', 'u', 'v', '2') }, /* uncompressed YUV422 */\n{ AV_CODEC_ID_RAWVIDEO, MKTAG('2', 'v', 'u', 'y') }, /* uncompressed 8-bit 4:2:2 */\n{ AV_CODEC_ID_RAWVIDEO, MKTAG('y', 'u', 'v', 's') }, /* same as 2VUY but byte-swapped */\n```\n\n又例如codec\\_id都是AV\\_CODEC\\_ID\\_H264,但实际上也有许多细分类型:\n\n```c++\n// libavformat/isom.c\n{ AV_CODEC_ID_H264, MKTAG('a', 'v', 'c', '1') }, /* AVC-1/H.264 */\n{ AV_CODEC_ID_H264, MKTAG('a', 'v', 'c', '2') },\n{ AV_CODEC_ID_H264, MKTAG('a', 'v', 'c', '3') },\n{ AV_CODEC_ID_H264, MKTAG('a', 'v', 'c', '4') },\n{ AV_CODEC_ID_H264, MKTAG('a', 'i', '5', 'p') }, /* AVC-Intra  50M 720p24/30/60 */\n{ AV_CODEC_ID_H264, MKTAG('a', 'i', '5', 'q') }, /* AVC-Intra  50M 720p25/50 */\n{ AV_CODEC_ID_H264, MKTAG('a', 'i', '5', '2') }, /* AVC-Intra  50M 1080p25/50 */\n{ AV_CODEC_ID_H264, MKTAG('a', 'i', '5', '3') }, /* AVC-Intra  50M 1080p24/30/60 */\n{ AV_CODEC_ID_H264, MKTAG('a', 'i', '5', '5') }, /* AVC-Intra  50M 1080i50 */\n{ AV_CODEC_ID_H264, MKTAG('a', 'i', '5', '6') }, /* AVC-Intra  50M 1080i60 */\n{ AV_CODEC_ID_H264, MKTAG('a', 'i', '1', 'p') }, /* AVC-Intra 100M 720p24/30/60 */\n{ AV_CODEC_ID_H264, MKTAG('a', 'i', '1', 'q') }, /* AVC-Intra 100M 720p25/50 */\n{ AV_CODEC_ID_H264, MKTAG('a', 'i', '1', '2') }, /* AVC-Intra 100M 1080p25/50 */\n```\n\n可以看出来codec\\_tag是通过4个字母去表示的,我们来看看MKTAG的定义:\n\n```c++\n#define MKTAG(a,b,c,d) ((a) | ((b) << 8) | ((c) << 16) | ((unsigned)(d) << 24))\n```\n\n最终它得到的是一个整数,例如MKTAG('a', 'v', 'c', '1')得到的值是0x31637661\n\n- 0x31 =1\n- 0x63 = c\n- 0x76 = v\n- 0x61 = a\n\n我们可以用av\\_fourcc2str这个函数将最终的整数转换回字符串\n\n回过头来看看这个判断:\n\n```c++\nif(av_codec_get_id(outputFormatContext->oformat->codec_tag, stream->codecpar->codec_tag) != stream->codecpar->codec_id)\n```\n\n大部分情况下如果codec\\_tag在输出流不支持的情况下av\\_codec\\_get\\_id拿到的是AV\\_CODEC\\_ID\\_NONE,所以大部分情况可以等价于:\n\n```c++\nif(av_codec_get_id(outputFormatContext->oformat->codec_tag, stream->codecpar->codec_tag) != AV_CODEC_ID_NONE)\n```\n\n不过也存在都是MKTAG('l', 'p', 'c', 'm'),但codec\\_id可能是AV\\_CODEC\\_ID\\_PCM\\_S16BE或者AV\\_CODEC\\_ID\\_PCM\\_S16LE的情况:\n\n```\n{ AV_CODEC_ID_PCM_S16BE,       MKTAG('l', 'p', 'c', 'm') },\n{ AV_CODEC_ID_PCM_S16LE,       MKTAG('l', 'p', 'c', 'm') },\n```\n\n所以最好还是和原本的codec\\_id做比较会靠谱点。\n\n## 写入视频数据\n\n接着就是视频数据的写入了,主要有三个步骤,写入文件头、读取本地视频包并写入输出视频流、写入文件结尾:\n\n```c++\n// 设置flvflags为no_duration_filesize用于解决下面的报错\n// [flv @ 0x14f808e00] Failed to update header with correct duration.\n// [flv @ 0x14f808e00] Failed to update header with correct filesize\nAVDictionary * opts = NULL;\nav_dict_set(&opts, \"flvflags\", \"no_duration_filesize\", 0);\nif(avformat_write_header(outputFormatContext, opts ? &opts : NULL) < 0) {\n    cout << \"write header to \" << destUrl << \" failed\" << endl;\n    break;\n}\n\n// 创建创建AVPacket接收数据包\n// 无论是压缩的音频流还是压缩的视频流,都是由一个个数据包组成的\n// 解码的过程实际就是从文件流中读取一个个数据包传给解码器去解码\n// 对于视频，它通常应包含一个压缩帧\n// 对于音频，它可能是一段压缩音频、包含多个压缩帧\n// 在不需要的时候可以通过av_packet_free释放\npacket = av_packet_alloc();\nif(NULL == packet) {\n    cout << \"can't alloc packet\" << endl;\n    break;\n}\n\n...\n\n// 从文件流里面读取出数据包,这里的数据包是编解码层的压缩数据\nwhile(av_read_frame(inputFormatContext, packet) >= 0) {\n    // 我们以视频轨道为基准去同步时间\n    // 如果时间还没有到就添加延迟,避免向服务器推流速度过快\n    ...\n\n    // 往输出流写入数据\n    av_interleaved_write_frame(outputFormatContext, packet);\n\n    // 写入成之后压缩数据包的数据就不需要了,将它释放\n    av_packet_unref(packet);\n}\n\n// 写入视频尾部信息\nav_write_trailer(outputFormatContext);\n```\n\n## 帧同步\n\n由于av\\_read\\_frame这里读取出来的是未解码的压缩数据速度很快,如果不做控制一下子就发送完成了,会造成数据堆积在服务器上。这里我们忽略网络传输耗时,依然通过视频包的pts做一定的同步:\n\n```c++\nwhile(av_read_frame(inputFormatContext, packet) >= 0) {\n    // 我们以视频轨道为基准去同步时间\n    // 如果时间还没有到就添加延迟,避免向服务器推流速度过快\n    if(videoStreamIndex == packet->stream_index) {\n        if(AV_NOPTS_VALUE == packet->pts) {\n            // 有些视频流不带pts数据,按30fps将间隔统一成32ms\n            av_usleep(32000);\n        } else {\n            // 带pts数据的视频流,我们计算出每一帧应该在什么时候播放\n            int64_t nowTime = av_gettime() - startTime;\n            int64_t pts = packet->pts * 1000 * 1000 * timeBaseFloat;\n            if(pts > nowTime) {\n                av_usleep(pts - nowTime);\n            }\n        }\n    }\n    // 往输出流写入数据\n    av_interleaved_write_frame(outputFormatContext, packet);\n\n    // 写入成之后压缩数据包的数据就不需要了,将它释放\n    av_packet_unref(packet);\n}\n```\n\n## 资源释放\n\n等视频流读写完成之后就是最后的资源释放收尾工作了:\n\n```c++\nif(NULL != packet) {\n    av_packet_free(&packet);\n}\n\nif(NULL != outputFormatContext) {\n    if(NULL != outputFormatContext->pb) {\n        avio_close(outputFormatContext->pb);\n    }\n    avformat_free_context(outputFormatContext);\n}\n\nif(NULL != inputFormatContext) {\n    avformat_close_input(&inputFormatContext);\n}\n```\n\n# 其他\n\n[源码](https://github.com/bluesky466/FFmpegDemo/blob/main/video_sender.cpp)和上篇博客的是同一个[仓库](https://github.com/bluesky466/FFmpegDemo),编译之后可以通过-s参数推流到服务器:\n\n> ./demo -s video.flv rtmp://服务器ip/live/livestream\n\n推流的同时就能使用-p参数去拉流进行实时播放:\n\n> ./demo -p rtmp://服务器ip/live/livestream\n\n这个demo只是简单的将本地视频文件推到服务器,实际上我们可以对他做些修改就能实现将摄像头的视频流推到服务器了。","tags":["技术相关","音视频"]},{"title":"FFmpeg入门 - 视频播放","url":"/2022/09/04/FFmpeg入门-视频播放/","content":"\n系列文章:\n\n1. [FFmpeg入门 - 视频播放](https://blog.islinjw.cn/2022/09/04/FFmpeg%E5%85%A5%E9%97%A8-%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/)\n2. [FFmpeg入门 - rtmp推流](https://blog.islinjw.cn/2022/09/08/FFmpeg%E5%85%A5%E9%97%A8-rtmp%E6%8E%A8%E6%B5%81/)\n3. [FFmpeg入门 - Android移植](https://blog.islinjw.cn/2022/10/25/FFmpeg%E5%85%A5%E9%97%A8-Android%E7%A7%BB%E6%A4%8D/)\n4. [FFmpeg入门 - 格式转换](https://blog.islinjw.cn/2022/11/27/FFmpeg%E5%85%A5%E9%97%A8-%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/)\n\n音视频最好从能够直接看到东西,也更加贴近用户的播放开始学起.\n\n# 音视频编解码基础\n\n我们可以通过http、rtmp或者本地的视频文件去播放视频。这里的\"视频\"实际上指的是mp4、avi这种既有音频也有视频的文件格式。\n\n这样的视频文件可能会有多条轨道例如视频轨道、音频轨道、字幕轨道等.\n有些格式限制比较多,例如AVI视频轨道只能有一条,音频轨道也只能有一条.\n而有些格式则比较灵活,例如OGG视频的视频、音频轨道都能有多条.\n\n像音频、视频这种数据量很大的轨道,上面的数据实际上都是通过压缩的。\n视频轨道上可能是H264、H256这样压缩过的图像数据,通过解码可以还原成YUV、RGB等格式的图像数据。\n音频轨道上可能是MP3、AAC这样压缩过的的音频数据,通过解码可以还原成PCM的音频裸流。\n\n\n{% plantuml %}\n\n@startuml\n@startjson\n{\n    \"视频文件\":{\n        \"视频轨道\":{\"H264、H265等格式的压缩音频\":[\"YUV、RGB等格式的图像\"]}, \n        \"音频轨道\":{\"AAC、MP3等格式的压缩音频\":[\"PCM格式的音频\"]}, \n        \"字幕轨道\":\"\"\n    }\n}\n@endjson\n@enduml\n\n{% endplantuml %}\n\n实际上使用ffmpeg去播放视频也就是根据文件的格式一步步还原出图像数据交给显示设备显示、还原出音频数据交给音频设备播放:\n\n{% plantuml %}\npartition 协议层 {\n(*) --> 数据\nnote right\nhttp,rtmp,file...\nend note\n}\n\npartition 封装格式层 {\n-->[解协议] 封装格式数据\nnote right\nmkv,mp4,mpegts,avi...\nend note\n}\n\nif 解封装并且分流 then\n\npartition 编解码层 {\n-->[音频] 音频码流数据\nnote right\naac,mp3,...\nend note\n}\n\npartition 原始数据层 {\n--> [音频解码] 音频采样数据\nnote right\npcm\nend note\n}\n-->音频设备播放\n\nelse\n\npartition 编解码层 {\n-->[视频] 视频码流数据\nnote right\nh264,h265,mpeg2...\nend note\n}\n\npartition 原始数据层 {\n--> [视频解码] 视频像素数据\nnote right\nyuv420p,yuv422p,rgb888...\nend note\n}\n--> 显示设备显示\n\nendif\n{% endplantuml %}\n\n# ffmpeg简单入门\n\n了解了视频的播放流程之后我们来做一个简单的播放器实际入门一下ffmpeg。由于这篇博客是入门教程,这个播放器功能会进行简化:\n\n1. 使用ffmpeg 4.4.2版本 - 4.x的版本被使用的比较广泛,而且最新的5.x版本资料比较少\n1. 只解码一个视频轨道的画面进行播放 - 不需要考虑音视频同步的问题\n2. 使用SDL2在主线程解码 - 不需要考虑多线程同步问题\n3. 使用源码+Makefile构建 - 在MAC和Ubuntu上验证过,Windows的同学需要自己创建下vs的工程了\n\n使用ffmpeg去解码大概有下面的几个步骤和关键函数,大家可以和上面的流程图对应一下:\n\n### 解析文件流(解协议和解封装)\n\n1. avformat\\_open\\_input : 可以打开File、RTMP等协议的数据流,并且读取文件头解析出视频信息,如解析出各个轨道和时长等\n2. avformat\\_find\\_stream\\_info : 对于没有文件头的格式如MPEG或者H264裸流等,可以通过这个函数解析前几帧得到视频的信息\n\n### 创建各个轨道的解码器(分流)\n\n1. avcodec\\_find\\_decoder: 查找对应的解码器\n2. avcodec\\_alloc\\_context3: 创建解码器上下文\n3. avcodec\\_parameters\\_to\\_context: 设置解码所需要的参数\n4. avcodec\\_open2: 打开解码器\n\n### 使用对应的解码器解码各个轨道(解码)\n\n1. av\\_read\\_frame: 从视频流读取视频数据包\n2. avcodec\\_send\\_packet: 发送视频数据包给解码器解码\n3. avcodec\\_receive\\_frame: 从解码器读取解码后的帧数据\n\n为了几种精力在音视频部分，我拆分出了专门进行解码的VideoDecoder类和专门进行画面显示的SdlWindow类,大家主要关注VideoDecoder部分即可。\n\n# 视频流解析\n\n由于实际解码前的解析文件流和创建解码器代码比较固定化,我直接将代码贴出来,大家可能跟着注释看下每个步骤的含义:\n\n```c++\nbool VideoDecoder::Load(const string& url) {\n    mUrl = url;\n\n    // 打开文件流读取文件头解析出视频信息如轨道信息、时长等\n    // mFormatContext初始化为NULL,如果打开成功,它会被设置成非NULL的值,在不需要的时候可以通过avcodec_free_context释放。\n    // 这个方法实际可以打开多种来源的数据,url可以是本地路径、rtmp地址等\n    // 在不需要的时候通过avformat_close_input关闭文件流\n    if(avformat_open_input(&mFormatContext, url.c_str(), NULL, NULL) < 0) {\n        cout << \"open \" << url << \" failed\" << endl;\n        return false;\n    }\n\n    // 对于没有文件头的格式如MPEG或者H264裸流等,可以通过这个函数解析前几帧得到视频的信息\n    if(avformat_find_stream_info(mFormatContext, NULL) < 0) {\n        cout << \"can't find stream info in \" << url << endl;\n        return false;\n    }\n\n    // 查找视频轨道,实际上我们也可以通过遍历AVFormatContext的streams得到,代码如下:\n    // for(int i = 0 ; i < mFormatContext->nb_streams ; i++) {\n    //     if(mFormatContext->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n    //         mVideoStreamIndex = i;\n    //         break;\n    //     }\n    // }\n    mVideoStreamIndex = av_find_best_stream(mFormatContext, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0);\n    if(mVideoStreamIndex < 0) {\n        cout << \"can't find video stream in \" << url << endl;\n        return false;\n    }\n\n    // 获取视频轨道的解码器相关参数\n    AVCodecParameters* codecParam = mFormatContext->streams[mVideoStreamIndex]->codecpar;\n    cout << \"codec id = \" << codecParam->codec_id << endl;\n    \n    // 通过codec_id获取到对应的解码器\n    // codec_id是enum AVCodecID类型,我们可以通过它知道视频流的格式,如AV_CODEC_ID_H264(0x1B)、AV_CODEC_ID_H265(0xAD)等\n    // 当然如果是音频轨道的话它的值可能是AV_CODEC_ID_MP3(0x15001)、AV_CODEC_ID_AAC(0x15002)等\n    AVCodec* codec = avcodec_find_decoder(codecParam->codec_id);\n    if(codec == NULL) {\n        cout << \"can't find codec\" << endl;\n        return false;\n    }\n\n    // 创建解码器上下文,解码器的一些环境就保存在这里\n    // 在不需要的时候可以通过avcodec_free_context释放\n    mCodecContext = avcodec_alloc_context3(codec);\n    if (mCodecContext == NULL) {\n        cout << \"can't alloc codec context\" << endl;\n        return false;\n    }\n\n\n    // 设置解码器参数\n    if(avcodec_parameters_to_context(mCodecContext, codecParam) < 0) {\n        cout << \"can't set codec params\" << endl;\n        return false;\n    }\n\n    // 打开解码器,从源码里面看到在avcodec_free_context释放解码器上下文的时候会close,\n    // 所以我们可以不用自己调用avcodec_close去关闭\n    if(avcodec_open2(mCodecContext, codec, NULL) < 0) {\n        cout << \"can't open codec\" << endl;\n        return false;\n    }\n\n    // 创建创建AVPacket接收数据包\n    // 无论是压缩的音频流还是压缩的视频流,都是由一个个数据包组成的\n    // 解码的过程实际就是从文件流中读取一个个数据包传给解码器去解码\n    // 对于视频，它通常应包含一个压缩帧\n    // 对于音频，它可能是一段压缩音频、包含多个压缩帧\n    // 在不需要的时候可以通过av_packet_free释放\n    mPacket = av_packet_alloc();\n    if(NULL == mPacket) {\n        cout << \"can't alloc packet\" << endl;\n        return false;\n    }\n\n    // 创建AVFrame接收解码器解码出来的原始数据(视频的画面帧或者音频的PCM裸流)\n    // 在不需要的时候可以通过av_frame_free释放\n    mFrame = av_frame_alloc();\n    if(NULL == mFrame) {\n        cout << \"can't alloc frame\" << endl;\n        return false;\n    }\n\n    // 可以从解码器上下文获取视频的尺寸\n    // 这个尺寸实际上是从AVCodecParameters里面复制过去的,所以直接用codecParam->width、codecParam->height也可以\n    mVideoWidth = mCodecContext->width;\n    mVideoHegiht =  mCodecContext->height;\n\n    // 可以从解码器上下文获取视频的像素格式\n    // 这个像素格式实际上是从AVCodecParameters里面复制过去的,所以直接用codecParam->format也可以\n    mPixelFormat = mCodecContext->pix_fmt;\n\n    return true;\n}\n```\n\n我们使用VideoDecoder::Load打开视频流并准备好解码器。之后就是解码的过程,解码完成之后再调用VideoDecoder::Release去释放资源:\n\n```c++\nvoid VideoDecoder::Release() {\n    mUrl = \"\";\n    mVideoStreamIndex = -1;\n    mVideoWidth = -1;\n    mVideoHegiht = -1;\n    mDecodecStart = -1;\n    mLastDecodecTime = -1;\n    mPixelFormat = AV_PIX_FMT_NONE;\n\n    if(NULL != mFormatContext) {\n        avformat_close_input(&mFormatContext);\n    }\n\n    if (NULL != mCodecContext) {\n        avcodec_free_context(&mCodecContext);\n    }\n    \n    if(NULL != mPacket) {\n        av_packet_free(&mPacket);\n    }\n\n    if(NULL != mFrame) {\n        av_frame_free(&mFrame);\n    }\n}\n```\n\n# 视频解码\n\n解码器创建完成之后就可以开始解码了:\n\n```c++\nAVFrame* VideoDecoder::NextFrame() {\n    if(av_read_frame(mFormatContext, mPacket) < 0) {\n        return NULL;\n    }\n\n    AVFrame* frame = NULL;\n    if(mPacket->stream_index == mVideoStreamIndex\n        && avcodec_send_packet(mCodecContext, mPacket) == 0\n        && avcodec_receive_frame(mCodecContext, mFrame) == 0) {\n        frame = mFrame;\n\n        ... //1.解码速度问题\n    }\n\n    av_packet_unref(mPacket); // 2.内存泄漏问题\n\n    if(frame == NULL) {\n        return NextFrame(); // 3.AVPacket帧类型问题\n    }\n\n    return frame;\n}\n```\n\n它的核心逻辑其实就是下面这三步:\n1. 使用av\\_read\\_frame 从视频流读取视频数据包\n2. 使用avcodec\\_send\\_packet 发送视频数据包给解码器解码\n3. 使用avcodec\\_receive\\_frame 从解码器读取解码后的帧数据\n\n除了关键的三个步骤之外还有些细节需要注意:\n\n### 1.解码速度问题\n\n由于解码的速度比较快,我们可以等到需要播放的时候再去解码下一帧。这样可以降低cpu的占用,也能减少绘制线程堆积画面队列造成内存占用过高.\n\n由于这个demo没有单独的解码线程,在渲染线程进行解码,sdl渲染本身就耗时,所以就算不延迟也会发现画面是正常速度播放的.可以将绘制的代码注释掉,然后在该方法内加上打印,会发现一下子就解码完整个视频了。\n\n### 2.内存泄漏问题\n\n解码完成之后压缩数据包的数据就不需要了,需要使用av\\_packet\\_unref将AVPacket释放。\n\n其实AVFrame在使用完成之后也需要使用av\\_frame\\_unref去释放AVFrame的像画面素数据,但是在avcodec\\_receive\\_frame内会调用av_frame_unref将上一帧的内存清除,而最后一帧的数据也会在Release的时候被av\\_frame\\_free清除,所以我们不需要手动调用av\\_frame\\_unref.\n\n### 3.AVPacket帧类型问题\n\n由于视频压缩帧存在i帧、b帧、p帧这些类型,并不是每种帧都可以直接解码出原始画面,b帧是双向差别帧，也就是说b帧记录的是本帧与前后帧的差别,还需要后面的帧才能解码.\n\n如果这一帧AVPacket没有解码出数据来的话,就递归调用NextFrame解码下一帧,直到解出下一帧原生画面来\n\n## PTS同步\n\nAVFrame有个pts的成员变量,代表了画面在什么时候应该显示.由于视频的解码速度通常会很快,例如一个1分钟的视频可能一秒钟就解码完成了.所以我们需要计算出这一帧应该在什么时候播放,如果时间还没有到就添加延迟。\n\n有些视频流不带pts数据,按30fps将每帧间隔统一成32ms:\n\n```c++\nif(AV_NOPTS_VALUE == mFrame->pts) {\n    int64_t sleep = 32000 - (av_gettime() - mLastDecodecTime);\n    if(mLastDecodecTime != -1 && sleep > 0) {\n        av_usleep(sleep);\n    }\n    mLastDecodecTime = av_gettime();\n} else {\n    ...\n}\n```\n\n如果视频流带pts数据,我们需要计算这个pts具体是视频的第几微秒.\n\npts的单位可以通过AVFormatContext找到对应的AVStream,然后再获取AVStream的time\\_base得到:\n\n```c++\nAVRational timebase = mFormatContext->streams[mPacket->stream_index]->time_base;\n```\n\nAVRational是个分数,代表几分之几秒:\n\n```c++\n/**\n * Rational number (pair of numerator and denominator).\n */\ntypedef struct AVRational{\n    int num; ///< Numerator\n    int den; ///< Denominator\n} AVRational;\n```\n\n我们用timebase.num * 1.0f / timebase.den计算出这个分数的值,然后乘以1000等到ms,再乘以1000得到us.后半部分的计算其实可以放到VideoDecoder::Load里面保存到成员变量,但是为了讲解方便就放在这里了:\n\n```c++\nint64_t pts = mFrame->pts * 1000 * 1000 * timebase.num * 1.0f / timebase.den;\n```\n\n这个pts都是以视频开头开始计算的,所以我们需要先保存第一帧的时间戳,然后再去计算当前播到第几微秒.完整代码如下:\n\n```c++\nif(AV_NOPTS_VALUE == mFrame->pts) {\n    ...\n} else {\n    AVRational timebase = mFormatContext->streams[mPacket->stream_index]->time_base;\n    int64_t pts = mFrame->pts * 1000 * 1000 * timebase.num * 1.0f / timebase.den;\n\n    // 如果是第一帧就记录开始时间\n    if(-1 == mDecodecStart) {\n        mDecodecStart = av_gettime() - pts;\n    }\n\n    // 当前时间减去开始时间,得到当前播放到了视频的第几微秒\n    int64_t now = av_gettime() - mDecodecStart;\n\n    // 如果这一帧的播放时间还没有到就等到播放时间到了再返回\n    if(pts > now) {\n        av_usleep(pts - now);\n    }\n}\n```\n\n# 其他\n\n完整的[Demo](https://github.com/bluesky466/FFmpegDemo)已经放到Github上,图像渲染的部分在SdlWindow类中,它使用SDL2去做ui绘制,由于和音视频编解码没有关系就不展开讲了.视频解码部分在VideoDecoder类中.\n\n编译的时候需要修改Makefile里面ffmpeg和sdl2的路径,然后make编译完成之后用下面命令即可播放视频:\n\n> demo -p 视频路径播放视频\n\nPS: \n\n某些函数会有数字后缀,如avcodec_alloc_context3、avcodec_open2等，实际上这个数字后缀是这个函数的第几个版本的意思,从源码的doc/APIchanges可以看出来:\n\n```\n2011-07-10 - 3602ad7 / 0b950fe - lavc 53.8.0\n  Add avcodec_open2(), deprecate avcodec_open().\n  NOTE: this was backported to 0.7\n\n  Add avcodec_alloc_context3. Deprecate avcodec_alloc_context() and\n  avcodec_alloc_context2().\n```","tags":["技术相关","音视频"]},{"title":"Android多用户的一些坑","url":"/2022/08/04/Android多用户的一些坑/","content":"\n\n最近关于多用户功能报了几个bug,我觉得蛮有意思的这里记录一下。\n\n起因是是测试报了打开了多用户功能并且切到另外一个用户之后,系统功能异常。调试发现我们的中间层服务启动了两个进程:\n\n```\nsystem         6074   2524 14649520 96244 SyS_epoll_wait      0 S me.linjw.demo.multiuser\nu10_system     7991   2524 14582664 94148 SyS_epoll_wait      0 S me.linjw.demo.multiuser\n```\n\n从上面可以看出me.linjw.demo.multiuser这个应用分别在USER为system和u10\\_system各起了一个进程。查找了下资料发现正常情况下一个应用进程的确是不能跨用户访问的,会在不同的用户下启动新的进程。\n\n# android:singleUser配置\n\n由于历史代码原因,我们系统上的硬件操控接口的确不支持多个进程访问,也不好修改。只能靠我们应用做规避。使用ps命令查看了下,发现像system\\_server这样的系统服务在多用户下也只有一个进程。谷歌应该会考虑到这种多用户共用一个进程的场景,于是在开发者文档中找到多用户相关[文档](https://source.android.google.cn/devices/tech/admin/multiuser-apps?hl=zh-cn):\n\n> 如需将应用识别为单例，请将 android:singleUser=”true” 添加至 Android 清单中的服务、接收器或提供程序。\n\n由于现象是多个进程，我下意识认为这个singleUser配置是针对应用的,所以在AndroidManifest.xml的application标签中配置上去,但是发现没有作用:\n\n```\n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:singleUser=\"true\"\n        android:theme=\"@style/Theme.MultiuserDemo\">\n```\n\n由于文档里面没有其他信息，从网上搜索找到的类似需要系统签名、android:persistent需要为true这样的信息也确认过没有效果。本来还怀疑是我们framework里面做了什么修改导把这块改坏了。\n\n于是去看这部分相关的framework源码,主要逻辑在[ActiveServices.retrieveServiceLocked](https://cs.android.com/android/platform/superproject/+/android-11.0.0_r9:frameworks/base/services/core/java/com/android/server/am/ActiveServices.java;l=2342)里面,子用户里启动服务的时候会去通过isSingleton判断是否使用主用户的进程,如果是的话就使用主用户的进程,不需要新启动一个进程::\n\n```\n// frameworks/base/services/core/java/com/android/server/am/ActiveServices.java\nprivate ServiceLookupResult retrieveServiceLocked(Intent service,\n        String instanceName, String resolvedType, String callingPackage,\n        int callingPid, int callingUid, int userId,\n        boolean createIfNeeded, boolean callingFromFg, boolean isBindExternal,\n        boolean allowInstant) {\n    ...\n    // 这里在不同userId下查询出来的rInfo就是不一样的\n    ResolveInfo rInfo = mAm.getPackageManagerInternalLocked().resolveService(service,\n            resolvedType, flags, userId, callingUid);\n    ServiceInfo sInfo = rInfo != null ? rInfo.serviceInfo : null;\n    ...\n    // userId不为0代表子用户下运行\n    if (userId > 0) {\n        if (mAm.isSingleton(sInfo.processName, sInfo.applicationInfo,\n                sInfo.name, sInfo.flags)\n                && mAm.isValidSingletonCall(callingUid, sInfo.applicationInfo.uid)) {\n            // 如果组件isSingleton判断为true\n            // 则将userId改成0,并使用clearCallingIdentity清除调用进程的用户信息,重新查询\n            // 则查出来的rInfoForUserId0为主用户的缓存  \n            userId = 0;\n            smap = getServiceMapLocked(0);\n            // Bypass INTERACT_ACROSS_USERS permission check\n            final long token = Binder.clearCallingIdentity();\n            try {\n                ResolveInfo rInfoForUserId0 = mAm.getPackageManagerInternalLocked().resolveService(service,\n                                resolvedType, flags, userId, callingUid);\n                if (rInfoForUserId0 == null) {\n                    Slog.w(TAG_SERVICE,\n                            \"Unable to resolve service \" + service + \" U=\" + userId\n                                    + \": not found\");\n                    return null;\n                }\n                // 然后用这个rInfoForUserId0.serviceInfo去替换之前查出来的rInfo.serviceInfo,保证多用户下都用主用户下的同一个进程\n                sInfo = rInfoForUserId0.serviceInfo;\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n        }\n        sInfo = new ServiceInfo(sInfo);\n        sInfo.applicationInfo = mAm.getAppInfoForUser(sInfo.applicationInfo, userId);\n    }\n    ...\n}\n\n```\n\n判断是否在多用户下只启动单个进程主要靠[isSingleton](https://cs.android.com/android/platform/superproject/+/android-11.0.0_r9:frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java;l=15103)这个方法:\n\n```\n// frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java\nboolean isSingleton(String componentProcessName, ApplicationInfo aInfo,\n        String className, int flags) {\n    boolean result = false;\n    // For apps that don't have pre-defined UIDs, check for permission\n    if (UserHandle.getAppId(aInfo.uid) >= FIRST_APPLICATION_UID) {\n        if ((flags & ServiceInfo.FLAG_SINGLE_USER) != 0) {\n            if (ActivityManager.checkUidPermission(\n                    INTERACT_ACROSS_USERS,\n                    aInfo.uid) != PackageManager.PERMISSION_GRANTED) {\n                ComponentName comp = new ComponentName(aInfo.packageName, className);\n                String msg = \"Permission Denial: Component \" + comp.flattenToShortString()\n                        + \" requests FLAG_SINGLE_USER, but app does not hold \"\n                        + INTERACT_ACROSS_USERS;\n                Slog.w(TAG, msg);\n                throw new SecurityException(msg);\n            }\n            // Permission passed\n            result = true;\n        }\n    } else if (\"system\".equals(componentProcessName)) {\n        result = true;\n    } else if ((flags & ServiceInfo.FLAG_SINGLE_USER) != 0) {\n        // Phone app and persistent apps are allowed to export singleuser providers.\n        result = UserHandle.isSameApp(aInfo.uid, PHONE_UID)\n                || (aInfo.flags & ApplicationInfo.FLAG_PERSISTENT) != 0;\n    }\n    if (DEBUG_MU) Slog.v(TAG_MU,\n            \"isSingleton(\" + componentProcessName + \", \" + aInfo + \", \" + className + \", 0x\"\n            + Integer.toHexString(flags) + \") = \" + result);\n    return result;\n}\n```\n打开DEBUG\\_MU之后查看打印,发现singleUser是按组件来配置的:\n\n```\n08-03 13:45:20.092  3289  4023 V ActivityManager_MU: isSingleton(me.linjw.demo.multiuser, ApplicationInfo{417a0ea me.linjw.demo.multiuser}, me.linjw.demo.multiuser.TestService, 0x0) = false\n```\n\n所以应该在service里面配置:\n\n```\n<service\n    android:name=\".TestService\"\n    android:exported=\"true\"\n    android:singleUser=\"true\">\n```\n\n\n实际上如果我一开始看到是[英文文档](https://source.android.google.cn/devices/tech/admin/multiuser-apps),应该就不会出现这样的误解了:\n\n> To identify an app as a singleton, add android:singleUser=”true” to your service, receiver, or provider in the Android manifest.\n\n# android:exported被自动关闭\n\n修改完成自检通过,开开心心上传代码原本以为问题已经解决。没想到一天之后另外一个客户的软件报了连接不上我们的Service的问题:\n\n```\n08-03 12:13:22.108  3185  3557 W ActivityManager: Permission Denial: Accessing service me.linjw.demo.multiuser/.TestService from pid=5994, uid=10055 that is not exported from uid 1000\n08-03 12:13:22.112  5994  5994 E AndroidRuntime: Caused by: java.lang.SecurityException: Not allowed to bind to service Intent { act=me.linjw.multiuser.service pkg=me.linjw.demo.multiuser }\n```\n\n从日志上来看TestService没有export,但是从AndroidManifest.xml上看android:exported的确设置成true了。而且尝试把android:singleUser改成fasle又能连上。这就意味着android:singleUser陪着会影响到android:exported。\n\n\n但这里又有个问题,当初我修改完android:singleUser=\"true\"之后是有自检通过的,如果exported为false,那自检为什么能通过?\n\n\n最终排查发现我们的应用设置了sharedUserId声明为系统进程:\n\n```\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"me.linjw.demo.multiuser\"\n    android:sharedUserId=\"android.uid.system\">\n```\n\n当初自检的时候的那个应用的sharedUserId也是android.uid.system,所以相当于他们是同一个应用,可以相互访问exported为false的组件。\n\n\n原因排查清楚了,那要怎么解决呢?还是只能从framework源码开始翻起,先去[报错的地方](https://cs.android.com/android/platform/superproject/+/android-11.0.0_r9:frameworks/base/services/core/java/com/android/server/am/ActiveServices.java;l=2532)看起,找找为什么exported会被自动改成false:\n\n```\n// frameworks/base/services/core/java/com/android/server/am/ActiveServices.java\nprivate ServiceLookupResult retrieveServiceLocked(Intent service,\n          String instanceName, String resolvedType, String callingPackage,\n          int callingPid, int callingUid, int userId,\n          boolean createIfNeeded, boolean callingFromFg, boolean isBindExternal,\n          boolean allowInstant) {\n      ServiceRecord r = null;\n      ...\n      if (mAm.checkComponentPermission(r.permission,\n              callingPid, callingUid, r.appInfo.uid, r.exported) != PERMISSION_GRANTED) {\n          if (!r.exported) {\n              Slog.w(TAG, \"Permission Denial: Accessing service \" + r.shortInstanceName\n                      + \" from pid=\" + callingPid\n                      + \", uid=\" + callingUid\n                      + \" that is not exported from uid \" + r.appInfo.uid);\n              return new ServiceLookupResult(null, \"not exported from uid \"\n                      + r.appInfo.uid);\n          }\n          Slog.w(TAG, \"Permission Denial: Accessing service \" + r.shortInstanceName\n                  + \" from pid=\" + callingPid\n                  + \", uid=\" + callingUid\n                  + \" requires \" + r.permission);\n          return new ServiceLookupResult(null, r.permission);\n      }\n      ...\n}\n```\n\n从这里看r的exported为false导致了这个异常,我们需要在retrieveServiceLocked里面一路追踪r的exported是怎么被singleUser影响的,由于这部分代码比较曲折我也找了很久才找到关键代码。\n\n在[PackageManagerService](https://cs.android.com/android/platform/superproject/+/android-11.0.0_r9:frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java;l=11783)扫描应用信息的时候,会判断SCAN\\_AS\\_PRIVILEGED这个flag,如果没有设置就会执行markNotActivitiesAsNotExportedIfSingleUser\n\n```\n// frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java\nif ((scanFlags & SCAN_AS_PRIVILEGED) == 0) {\n    parsedPackage\n            .markNotActivitiesAsNotExportedIfSingleUser();\n}\n```\n\n\n[markNotActivitiesAsNotExportedIfSingleUser](https://cs.android.com/android/platform/superproject/+/android-11.0.0_r9:frameworks/base/services/core/java/com/android/server/pm/parsing/pkg/PackageImpl.java;l=454;drc=da9304867216e65874eae45db56d8d3fd3674105;bpv=1;bpt=1)顾名思义,就会在配置了SingleUser的时候去修改exported,实际上它里面除了Activity不修改,其他的三个组件都修改了:\n\n```\npublic PackageImpl markNotActivitiesAsNotExportedIfSingleUser() {\n    // ignore export request for single user receivers\n    int receiversSize = receivers.size();\n    for (int index = 0; index < receiversSize; index++) {\n        ParsedActivity receiver = receivers.get(index);\n        if ((receiver.getFlags() & ActivityInfo.FLAG_SINGLE_USER) != 0) {\n            receiver.setExported(false);\n        }\n    }\n\n    // ignore export request for single user services\n    int servicesSize = services.size();\n    for (int index = 0; index < servicesSize; index++) {\n        ParsedService service = services.get(index);\n        if ((service.getFlags() & ActivityInfo.FLAG_SINGLE_USER) != 0) {\n            service.setExported(false);\n        }\n    }\n\n    // ignore export request for single user providers\n    int providersSize = providers.size();\n    for (int index = 0; index < providersSize; index++) {\n        ParsedProvider provider = providers.get(index);\n        if ((provider.getFlags() & ActivityInfo.FLAG_SINGLE_USER) != 0) {\n            provider.setExported(false);\n        }\n    }\n\n    return this;\n}\n```\n\n那问题就在于我们的应用没有携带SCAN\\_AS\\_PRIVILEGED,所以在singleUser为true的时候exported会被改成false。那我们要怎么带上这个flag呢?搜索了下[资料](https://wrlus.com/android-security/system-apps-and-cve-2020-0391/)发现这个flag代表着特权应用,只要预装到下面目录的就能成为特权应用\n\n```\n/system/framework\n/system/priv-app\n/vendor/priv-app\n/odm/priv-app\n/product/priv-app\n/system_ext/priv-app\n```\n\n最终将预装路径从/syste/app改到/syste/priv-app解决问题。\n\n# 全局浮动框在子用户不显示\n\n没想到过了两天又报了另外一个问题,我们通过WindowManager.addView添加的全局浮动框在子用户不显示,在主用户是好的。又踩了一个隐藏的坑。\n\n既然不显示,那么首先考虑是不是addView失败了,于是用dumpsys window看看有没有add成功:\n\n```\nconsole:/ # dumpsys window | grep me.linjw.demo.multiuser\n    mPackageName=me.linjw.demo.multiuser\n  Window #0 Window{a03fb0 u0 me.linjw.demo.multiuser}:\n    mOwnerUid=1000 showForAllUsers=false package=me.linjw.demo.multiuser appop=SYSTEM_ALERT_WINDOW\n```\n\n从打印上来看是add成功的,但是里面有个showForAllUsers引起了我的注意,大概猜测是addView的时候有个showForAllUsers的flag没有设置,于是在源码里面搜索还真找到了:\n\n```\n// android/view/WindowManager.java\n@SystemApi\n@RequiresPermission(permission.INTERNAL_SYSTEM_WINDOW)\npublic static final int SYSTEM_FLAG_SHOW_FOR_ALL_USERS = 0x00000010;\n```\n\n但是它的值和FLAG\\_NOT\\_TOUCHABLE重复了:\n\n```\npublic static final int FLAG_NOT_TOUCHABLE      = 0x00000010;\n```\n\n于是从搜索了下它,发现需要设置到WindowManager.LayoutParams.privateFlags而不是WindowManager.LayoutParams.flags\n\n可惜的是无论是privateFlags还是SYSTEM\\_FLAG\\_SHOW\\_FOR\\_ALL\\_USERS都是系统api,所以只能用反射去设置:\n\n```\nprivate int SYSTEM_FLAG_SHOW_FOR_ALL_USERS = 0x00000010;\n\n// 多用户下需要设置这个flag才能在其他用户显示\nField privateFlags = null;\ntry {\n    privateFlags = WindowManager.LayoutParams.class.getDeclaredField(\"privateFlags\");\n    privateFlags.set(wmParams, SYSTEM_FLAG_SHOW_FOR_ALL_USERS);\n} catch (Exception e) {\n    Log.e(\"testtest\", \"err\", e);\n}\n```\n\n设置之后的确在子用户下也显示成功了,用dumpsys window查看showForAllUsers也变成了true:\n\n```\nconsole:/ # dumpsys window | grep me.linjw.demo.multiuser\n    mPackageName=me.linjw.demo.multiuser\n  Window #0 Window{3655208 u0 me.linjw.demo.multiuser}:\n    mOwnerUid=1000 showForAllUsers=true package=me.linjw.demo.multiuser appop=SYSTEM_ALERT_WINDOW\n```\n\n# 结尾吐槽\n\n这系列问题前前后后差不多一个月才弄完,framework部分源码的源码看得人都晕了,也不知道还会不会有其他意料之外的坑。当个安卓应用开发太难了...","tags":["技术相关","Android"]},{"title":"Jni多线程与类加载","url":"/2022/06/13/Jni多线程与类加载/","content":"\n在JNI中我们可以通过JNIEnv的FindClass方法查找到java的类然后进行类似反射的调用。\n\n如果通过java代码调用的Jni函数,此时c的函数与Java运行在同一个线程中。无论是在主线程还是java启动的子线程中FindClass都能正常工作。\n\n# native子线程加载不了自定义的Class\n\n但如果是通过pthread\\_create之类的方法在native层创建了子线程,则在这个子线程中FindClass方法查不到我们Apk中定义的class。会返回0并且在Java层抛出ClassNotFoundException:\n\n```\nProcess: me.linjw.demo.jni, PID: 2759\njava.lang.ClassNotFoundException: Didn't find class \"me.linjw.demo.jni.MainActivity\" on path: DexPathList[[directory \".\"],nativeLibraryDirectories=[/system/lib64, /vendor/lib64, /system/lib64, /vendor/lib64]]\n       at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:125)\n       at java.lang.ClassLoader.loadClass(ClassLoader.java:379)\n       at java.lang.ClassLoader.loadClass(ClassLoader.java:312)\n```\n\n我们可以通过JNIEnv的ExceptionClear方法清除java层出现的Exception,然后对返回的jclass进行判空处理防止应用崩溃:\n\n```\njclass clazz = env->FindClass(className);\nif(clazz != 0) {\n    ...\n}\nenv->ExceptionClear();\n```\n\n从上面的异常日志可以看到这里是通过BaseDexClassLoader而不是应用层常见的PathClassLoader去加载class的。我们从官方的[JNI tips](https://developer.android.com/training/articles/perf-jni#faq_FindClass)文档里面可以得到回答:\n\n```\nThis usually does what you want. You can get into trouble if you create a thread yourself (perhaps by calling pthread_create and then attaching it with AttachCurrentThread). Now there are no stack frames from your application. If you call FindClass from this thread, the JavaVM will start in the \"system\" class loader instead of the one associated with your application, so attempts to find app-specific classes will fail.\n```\n\n实际上JNIEnv从也是通过classloader去加载类的,如果一个Jni的方法是由java调用下来的那么它将沿用java层的classloader,这个classloader是在loadLibrary的时候设置进去的:\n\n```\npublic final class System {\n    ...\n    public static void loadLibrary(String libname) {\n        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n    }\n    ...\n}\n\npublic class Runtime {\n    ...\n    void loadLibrary0(Class<?> fromClass, String libname) {\n        ClassLoader classLoader = ClassLoader.getClassLoader(fromClass);\n        loadLibrary0(classLoader, fromClass, libname);\n    }\n    ...\n    private synchronized void loadLibrary0(ClassLoader loader, Class<?> callerClass, String libname) {\n        ...\n        String error = nativeLoad(filename, loader, callerClass);\n        ...\n    }\n    ...\n}\n```\n\n但如果是native创建的子线程那么它默认是和java虚拟机没有关联的,所以也就没有JNIEnv和对应的classloader。例如我们通过JavaVM的GetEnv方法是不能获取到JNIEnv的:\n\n```\njint result = javaVM->GetEnv((void **) &env, JNI_VERSION_1_4);\n// result 等于JNI_EDETACHED(-2) \n```\n\n我们需要手动调用JavaVM的AttachCurrentThread方法将将native线程和java虚拟机相关联。在关联上java虚拟机的时候获取到的classloader实际上是系统classloader,也就是这里的BaseDexClassLoader而不是我们应用的PathClassLoader。\n\n因此它并不能加载我们在apk里面定义的MainActivity等类,但是如果是一些系统的类比如java.lang.String、android.util.Log、android.app.Activity是可以加载到的:\n\n```\n3332  3359 D JniDemo : java/lang/String : 9\n3332  3359 D JniDemo : android/util/Log : 17\n3332  3359 D JniDemo : android/app/Activity : 37\n3332  3359 D JniDemo : me/linjw/demo/jni/MainActivity : 0\n```\n\n# 解决方法\n\n正常情况下我们都推荐在java层创建子线程去调用jni方法实现并发。但是有些特殊的情况可能的确需要在native中创建子线程访问java代码。\n\n有的同学可能会说既然在native子线程中加载不到这个类,那么我们能不能在java线程中先加载出来在native子线程中使用呢?\n\n答案是可以的,但是如果直接将jclass保存到全局引用会出现异常:\n\n```\n06-11 16:50:16.656  3507  3507 F DEBUG   : Abort message: 'java_vm_ext.cc:534] JNI DETECTED ERROR IN APPLICATION: use of deleted local reference 0x75'\n```\n\n我之前写过一篇[JNI内存管理](https://blog.islinjw.cn/2020/04/08/JNI%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/)的笔记有讲到相关的知识点,在java线程中FindClass得到的jclass是局部引用,局部引用在退出jni函数回到java代码的时候就被回收了。我们需要创建全局引用或者弱全局引用去保存:\n\n```\nclazzMainActivity = (jclass) env->NewGlobalRef(clazz);\n```\n\n之后我们就能在子线程中使用这个jclass通过类似反射的操作调用java代码了:\n\n```\njfieldID field = env->GetStaticFieldID(clazzMainActivity, \"DATA_IN_JAVA\", \"I\");\nint data = env->GetStaticIntField(clazzMainActivity, field);\nLOGD(\"data in threadFunc : %d\", data);\n\n// 日志如下\n// 3427  3427 D JniDemo : data : 123\n```\n\n完整Demo代码已上传[Github](https://github.com/bluesky466/JNIClassLoaderDemo/blob/master/app/src/main/cpp/native-lib.cpp)","tags":["技术相关","Android","C/C++"]},{"title":"安卓录制MP3(二) - LAME使用","url":"/2022/05/30/安卓录制MP3-二-LAME使用/","content":"\n[上篇文章](https://blog.islinjw.cn/2022/05/26/%E5%AE%89%E5%8D%93%E5%BD%95%E5%88%B6MP3-%E4%B8%80-%E6%95%B0%E5%AD%97%E9%9F%B3%E9%A2%91%E5%9F%BA%E7%A1%80/)介绍了数字音频的基础知识,这篇文章我们来看看代码应该怎么写:\n\n# 录音PCM\n\n第一步我们先用AudioRecord录制PCM音频:\n\n```\nprivate lateinit var buffer: ByteArray\n\nfun start(audioSource: Int, sampleRate: Int, channelConfig: Int, audioFormat: Int): Boolean {\n    ...\n    val bufferSize = AudioRecord.getMinBufferSize(sampleRate, channelConfig, audioFormat)\n\n    buffer = ByteArray(bufferSize)\n    recorder = AudioRecord(audioSource, sampleRate, channelConfig, audioFormat, bufferSize)\n\n    recorderThread = RecordThread()\n    recorderThread?.start()\n    return true\n}\n\ninner class RecordThread : Thread() {\n    override fun run() {\n        super.run()\n\n        var readLen: Int\n        recorder?.startRecording()\n        while (recorder?.recordingState == AudioRecord.RECORDSTATE_RECORDING) {\n            readLen = recorder?.read(buffer, 0, buffer.size) ?: break\n            listener.onRecord(buffer, readLen)\n        }\n        recorder = null\n    }\n}\n```\n\n可以看到AudioRecord的使用很简单，就是创建一个AudioRecord对象然后在子线程中不断地read就好,audioSource指的是通过哪个设备录音,其他的几个参数在基础部分都有讲过,就不过多介绍了:\n\n```\nprivate const val AUDIO_SOURCE = MediaRecorder.AudioSource.MIC\nprivate const val SAMPLE_RATE = 44100\nprivate const val AUDIO_FORMAT = AudioFormat.ENCODING_PCM_16BIT\nprivate const val CHANNEL_CONFIG = AudioFormat.CHANNEL_IN_MONO // 单通道\n//private const val CHANNEL_CONFIG = AudioFormat.CHANNEL_IN_STEREO // 双通道\nrecorder.start(AUDIO_SOURCE, SAMPLE_RATE, CHANNEL_CONFIG, AUDIO_FORMAT)\n```\n\n当然,记得需要申请录音权限:\n\n```\n<uses-permission android:name=\"android.permission.RECORD_AUDIO\" />\n```\n\n# 使用LAME进行MP3编码\n\n得到PCM裸流之后我们就需要对他进行MP3编码,LAME就是一个开源的MP3音频压缩软件,也是公认有损MP3中压缩效果最好的编码器。\n\n## 编译\n\n使用LAME需要自行编译出静态库,首先我们从LAME的[官网](https://lame.sourceforge.io/download.php)下载最新版本的LAME源码。从源码文件目录结构中可以看出它使用AutoMake编译,之前写过几篇AutoMake的[学习笔记](https://blog.islinjw.cn/2017/03/17/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-helloworld/),感兴趣的同学可以看看。\n\n或者也可以直接修改Demo工程的[build-lame.sh](https://github.com/bluesky466/AndroidLameDemo/blob/master/lame/lame-3.100/build-lame.sh)。修改开头的NDK路径、安卓版本、abi这几个参数接口直接运行在output目录生成出.a文件和.h文件:\n\n```\n#!/bin/zsh\n\nNDK_ROOT=/Users/linjw/Library/Android/sdk/ndk/22.1.7171670\nANDROID_API_VERSION=21\nNDK_TOOLCHAIN_ABI_VERSION=4.9\nABIS=(armeabi armeabi-v7a arm64-v8a x86 x86_64)\n...\n```\n\n## 导入AndroidStudio\n\n得到静态库之后在CMake中导入静态库:\n\n```\ncmake_minimum_required(VERSION 3.18.1)\n\n\nproject(\"lame\")\n\nadd_library(\n        lame\n        SHARED\n        native-lib.cpp)\n\n# 导入lame头文件\ninclude_directories(${CMAKE_SOURCE_DIR}/include)\n\n#导入lame静态库\nadd_library(mp3lame STATIC IMPORTED)\nset_target_properties(\n        mp3lame\n        PROPERTIES IMPORTED_LOCATION\n        ${CMAKE_SOURCE_DIR}/../../../jniLibs/${ANDROID_ABI}/libmp3lame.a)\n\nfind_library(\n        log-lib\n        log)\n\ntarget_link_libraries(\n        lame\n        mp3lame # 链接lame静态库\n        ${log-lib})\n```\n\n# lame基本使用\n\n## 初始化\n\n在了解了MP3的基础知识之后其实很容易上手lame。\n\n第一步无非就是一些音频参数的初始化设置:\n```\n第一步: 创建lame_global_flags*\nlame_global_flags *client = lame_init();\n\n第二步: 配置参数\nlame_set_in_samplerate(client, 44100);    // 输入采样率\nlame_set_out_samplerate(client, 44100);   // 输出采样率44100\nlame_set_num_channels(client, 2);         // 通道数2\nlame_set_brate(client, 128);              // 比特率128kbps\nlame_set_quality(client, 2);              // 编码质量2\nlame_init_params(client);                 // 初始化参数\n```\n\n### 编码质量\n\n上面的参数大部分都在前一篇介绍过了,只剩一个编码质量没讲过,他其实是用来选择压缩算法的。算法编号从0到9,0音质最好但是算法最复杂也最耗时,9音质最差但算法效率最高。一般会选择2。\n\n比特率和压缩算法都能决定MP3的音质。压缩前的PCM裸流音质最好，大小最大。\n\n由于MP3的大小等于比特率乘时长，压缩后的MP3比特率越大，那么它的大小就越大，就越接近压缩前的PCM，损失的信息也就越少，解压之后就越接近原本的PCM的曲线，音质自然就越好。\n\n而选择压缩算法的意义在于，在相同比特率的情况下( MP3文件大小相同)，好的压缩算法解压出来的声音曲线能更接近原本的PCM曲线，但是相应的它的计算量就会更大。\n\n可以说选择大的比特率是用存储空间换音质，而选择音质高的压缩算法则是用cpu资源换音质。\n\n\n## MP3编码\n\n配置好初始化参数之后就只要将PCM数据传递给LAME进行压缩即可,这里有几种PCM的传递方式:\n\n**1. 左右通道分开输入**\n\n双通道立体声,有时候左右通道的数据会放在不同的文件里面,可以使用下面的方法去编码MP3:\n\n```\nint CDECL lame_encode_buffer (\n        lame_global_flags*  gfp,           /* global context handle         */\n        const short int     buffer_l [],   /* PCM data for left channel     */\n        const short int     buffer_r [],   /* PCM data for right channel    */\n        const int           nsamples,      /* number of samples per channel */\n        unsigned char*      mp3buf,        /* pointer to encoded MP3 stream */\n        const int           mp3buf_size ); /* number of valid octets in this stream */\n```\n\n- gfp : lame\\_init返回的lame_global_flags*\n- buffer\\_l : 左通道数据\n- buffer\\_r : 右通道数据\n- nsamples : 每个通道的采样点数量。例如当AudioFormat为16bit的时候, 一个采样点大小为2byte, 则nsamples = buffer\\_l有效数据长度(byte) / 2\n- mp3buf : 编码后的MP3会存放到这里\n- mp3buf\\_size : mp3buf的大小,它可以通过采样率、比特率和前面的nsamples计算出来,不过LAME提供了一个最大buffer大小计算的简单算法(1.25*nsamples + 7200 byte)\n\n\n他的返回值如下:\n\n- \\>=0 : 编码后的MP3数据的大小,即存储到mp3buf的MP3音频的byte数\n- -1 : mp3buf的大小太小\n- -2 : malloc()方法出现问题\n- -3 : lame\\_init\\_params()没有调用\n- -4 : 音频数据异常\n\n参考代码:\n\n```\nint encodeSize = lame_encode_buffer_interleaved(client, pcm, numSamples, result, resultSize);\n```\n\n**2. 单通道输入**\n\n有时候我们的数据只会有一个通道的数据,例如AudioRecord的ChannelConfig配置成AudioFormat.CHANNEL\\_IN\\_MONO。\n\n这个时候我们只需要把right输入设置成NULL即可:\n\n```\nint encodeSize = lame_encode_buffer(client, left, null, numSamples, result, resultSize);\n```\n\n**3. 多通道混合输入**\n\n当AudioRecord的ChannelConfig配置成AudioFormat.CHANNEL\\_IN\\_STEREO。左右声道的数据会交叉存储在PCM裸流中。或者其他更多通道混合输入的时候我们可以用lame_encode_buffer_interleaved方法进行编码:\n\n```\nint CDECL lame_encode_buffer_interleaved(\n        lame_global_flags*  gfp,           /* global context  handlei */\n        short int           pcm[],         /* PCM data for left and right channel, interleaved */\n        int                 num_samples,   /* number of samples per channel,  _not_ number of samples in pcm [] */\n        unsigned char*      mp3buf,        /* pointer to encoded MP3 stream */\n        int                 mp3buf_size ); /* number of valid octets in this stream */ \n```\n\n指的注意的是,这里的num\\_samples指的是每个通道的采样点数,而不是所有通道的采样点数之和。\n\n例如当AudioFormat为16bit、双通道输入的时候, 一个采样点大小为2byte, 则\n\nnsamples = buffer\\_l有效数据长度(byte) / 2(16bite为2byte) / 2(通道数为2)\n\n```\nint encodeSize = lame_encode_buffer_interleaved(client, pcm, numSamples, result, resultSize);\n```\n\n## 清理工作\n\n当编码结束之后我们可以用lame\\_close方法进行清理:\n\n```\nlame_close(client);\n```\n\n# 结合JNI进行使用\n\n由于LAEM的使用需要保存lame\\_global\\_flags*,我们可以将它强转成long传到java进行保存,在需要的时候再讲传入的long强转回lame\\_global\\_flags*:\n\n```\nclass LameMp3 {\n    private var lameClientPtr: Long = createLameMp3Client()\n\n    fun destroy(): Int {\n        val ret = close(lameClientPtr)\n        lameClientPtr = 0\n        return ret\n    }\n\n    ...\n    private external fun createLameMp3Client(): Long\n    private external fun close(client: Long): Int\n    ...\n}\n\nextern \"C\" JNIEXPORT jlong JNICALL\nJava_me_linjw_lib_lame_LameMp3_createLameMp3Client(\n        JNIEnv *env,\n        jobject thiz) {\n    lame_global_flags *client = lame_init();\n    LOGD(\"createLameMp3Client: %ld\", (long) client);\n    return reinterpret_cast<jlong>(client);\n}\n\n\nextern \"C\" JNIEXPORT int JNICALL\nJava_me_linjw_lib_lame_LameMp3_close(\n        JNIEnv *env,\n        jobject thiz,\n        jlong clientPtr) {\n    lame_global_flags *client = reinterpret_cast<lame_global_flags *>(clientPtr);\n    LOGD(\"close(%ld)\", client);\n    return lame_close(client);\n}\n```\n\n详细代码参考[LameMp3.kt](https://github.com/bluesky466/AndroidLameDemo/blob/master/lame/src/main/java/me/linjw/lib/lame/LameMp3.kt)和[native-lib.cpp](https://github.com/bluesky466/AndroidLameDemo/blob/master/lame/src/main/cpp/native-lib.cpp)\n\n# DEMO代码\n\nDEMO代码已经放到[github](https://github.com/bluesky466/AndroidLameDemo)上","tags":["技术相关","Android","音视频"]},{"title":"安卓录制MP3(一) - 数字音频基础","url":"/2022/05/26/安卓录制MP3-一-数字音频基础/","content":"\n在安卓上实现录音功能有两种方式使用AudioRecord录制PCM裸流,或者用MediaRecorder录制编码后的音频流。但是MediaRecorder的编码格式并不包括MP3格式:\n\n```\n/**\n * Defines the audio encoding. These constants are used with\n * {@link MediaRecorder#setAudioEncoder(int)}.\n */\npublic final class AudioEncoder {\n    /* Do not change these values without updating their counterparts\n     * in include/media/mediarecorder.h!\n     */\n    private AudioEncoder() {}\n    public static final int DEFAULT = 0;\n    /** AMR (Narrowband) audio codec */\n    public static final int AMR_NB = 1;\n    /** AMR (Wideband) audio codec */\n    public static final int AMR_WB = 2;\n    /** AAC Low Complexity (AAC-LC) audio codec */\n    public static final int AAC = 3;\n    /** High Efficiency AAC (HE-AAC) audio codec */\n    public static final int HE_AAC = 4;\n    /** Enhanced Low Delay AAC (AAC-ELD) audio codec */\n    public static final int AAC_ELD = 5;\n    /** Ogg Vorbis audio codec (Support is optional) */\n    public static final int VORBIS = 6;\n    /** Opus audio codec */\n    public static final int OPUS = 7;\n}\n```\n\n所以如果想要将录制的音频保存成MP3,就需要我们自行对PCM裸流进行编码。常用的是[LAME](https://lame.sourceforge.io/)库去编码,不过在学习怎样使用LAME之前我们先稍微了解下数字音频的一些基础知识。\n\n# 数字音频基础\n\n我们都知道声音是一种波:\n\n{% img /安卓录制MP3一/1.png %}\n\n它在时间上是连续的,如果我们想把他保存成2进制的音频数据,就只能隔一段时间对这个波形进行一次采样,读取那个时刻声波的具体数值:\n\n{% img /安卓录制MP3一/2.png %}\n\n## 采样率\n\n采样的间隔越短,就越接近原始的音波,录制下来的音质也就越好。一般我们不直接用采样间隔,而是使用采样率来描述。采样率代表一秒钟采样的次数,单位为Hz。例如8000 Hz就代表1秒钟采样8000次。所以采样率越高采样间隔就越短。\n\n常见的采样率有8000Hz、11025Hz、32000Hz 、44100Hz等。根据奈奎斯特定理（也称为采样定理, 根据奈奎斯特定理(也称为采样定理),当采样频率大于信号中最高频率的2倍时,采样之后的数字信号完整地保留了原始信号中的信息。由于人耳能听到的声音频率为20Hz~20000Hz,所以采样率一般会使用44100Hz\n\n## AudioFormat\n\nAudioFormat代表我们可以用8bit、16bit或者一个浮点数去保存每一次采样获取的数字:\n\n```\n/** Audio data format: PCM 16 bit per sample. Guaranteed to be supported by devices. */\npublic static final int ENCODING_PCM_16BIT = 2;\n\n/** Audio data format: PCM 8 bit per sample. Not guaranteed to be supported by devices. */\npublic static final int ENCODING_PCM_8BIT = 3;\n\n/** Audio data format: single-precision floating-point per sample */\npublic static final int ENCODING_PCM_FLOAT = 4;\n```\n\n## 通道数\n\n由于左右耳朵听到的声音并不完全一样,所以常见的pcm流会有左右两个通道的数据,意味着我们可以从中拆分出两条音波曲线分别播放给左右耳朵:\n\n```\n/**\n * 单通道\n */\npublic static final int CHANNEL_IN_MONO = CHANNEL_IN_FRONT;\n\n/**\n * 双通道\n */\npublic static final int CHANNEL_IN_STEREO = (CHANNEL_IN_LEFT | CHANNEL_IN_RIGHT);\n```\n\n## PCM大小计算\n\n假设我们录制44100Hz、16bit、双通道的音频数据:\n\n- 1秒钟的数据大小为 44100 * 16 * 2 = 1411200 bit = 176400 byte = 172 KB\n- 1分钟的数据大小为 172 * 60 = 10320 KB = 10 MB\n\n# MP3编码\n\n从上面的计算我们可以得知,如果直接使用PCM裸流去保存,一首歌大约三到五分钟就有30~50MB。这样的数据量的确过于庞大了，所以我们对其进行压缩编码得到AAC、MP3、Ogg等格式的音频文件。\n\n这篇文章就只介绍MP3格式，在MP3里面有个很重要的概念是bitrate(比特率),它代表的是1秒钟的音频MP3格式需要用多少bit去表示,单位为bps(Bit Per Second)或者kbps(1kbps = 1000bps)。\n\nmp3的比特率默认是128kbps,也就是说这种比特率的MP3文件:\n\n- 1秒钟的数据大小为 128000 bit = 16000 byte = 15 KB\n- 1分钟的数据大小为 15 * 60 = 240 KB\n\n\n## CBR\n\nMP3中常用固定比特率CBR(Constant Bit-Rate)去进行压缩,这种类型的mp3每一帧的比特率都是固定的。\n\nCBR由于每秒的bit数是固定的:\n\n1. 音频时长可以通过文件大小计算 - 时长 = (文件大小 - 文件头大小) / bitrate\n2. seek操作容易实现 - 文件位置 = 文件头大小 + 目标时间 * bitrate\n\n但是一般来讲一个声音片段音调越高,代表它的频率越高,数据就越密集,压缩之后的大小也就越大。相反如果一个声音音调低,理论上我们压缩之后他的数据大小会越小。但是由于我们使用了固定的bitrate,那么在低音部分就会有部分的数据冗余。\n\n## VBR\n\n可变比特率VBR(Variable Bit-Rate)就很好的解决了这个这个数据冗余问题,这种类型每一帧的比特率是不固定的,在数据复杂的地方bitrate高,在数据简单的地方bitrate低。它的好处显而易见是可以节约更多的空间。但是也有下面缺点:\n\n1. 音频时长需要额外的字段去保存,或者解析整个MP3文件去计算\n2. seek操作复杂,需要保存关键时间点的文件位置,然后进行计算和插值\n\n## ABR\n\nMP3格式还存在一种平均比特率ABR(Average Bit-Rate)的编码，它大多数音频帧以固定bitrate编码,但会在个别的帧使用高bitrate编码。但是通常这些帧一般比较少,所以在文件大小上跟CBR相比没有太大的差异,因此这种类型并不常见。\n\n## MP3帧长度\n\n上面其实也有提到MP3的帧,在不同的规范中每一帧包含的采样点数量是不一样的:\n\n|MPEG 1 | MPEG 2 (LSF) | MPEG 2.5 (LSF)|\n|-|-|-|\n|Layer I|384|384|384|\n|Layer II|1152|1152|1152|\n|Layer III|1152|576|576|\n\n以常见的Layer II为例子,假设采样率为44100Hz,一秒钟有44100个采样点,一帧只包含1152个,那么: \n\n一帧的时长 = 1152 / 44100 = 0.02608s = 26.08ms\n\n这也是MP3一帧26ms的由来","tags":["技术相关","Android","音视频"]},{"title":"深入理解Dart Mixin","url":"/2022/04/27/深入理解Dart-Mixin/","content":"\n\n假设我们需要实现一个动物世界的功能。Animal作为基类派生出哺乳类、鸟类、鱼类三种类型,各个类型又能派生出具体的动物。每种动物都具有步行、游泳、飞行三种能力中的某几种能力:\n\n{% img /深入理解Dart_Mixin/1.png %}\n\n由于Java和kotlin都不允许多继承，我们可以将walk、swim、fly定义成interface，让各个具体的动物类去实现这几个接口。在java7里面需要在不同动物类中写同样的实现代码，但如果用java8或者kotlin，可以在interface中编写默认实现去避免重复代码。而在dart中我们要怎么实现呢?\n\n# dart extends & implements\n\n首先dart里面是没有interface的, 但是我们可以把class当做接口被实现。使用implements把某个class当做接口来实现要求我们重写这个class的**所有**方法, 而使用extends继承某个class则可以继承父类实现了的方法:\n\n```\nclass Base {\n  void foo1() {\n  }\n\n  void foo2() {\n  }\n}\n\nclass Child1 implements Base {\n  @override\n  void foo1() {\n    // TODO: implement foo1\n  }\n\n  @override\n  void foo2() {\n    // TODO: implement foo2\n  }\n}\n\nclass Child2 extends Base {\n  \n}\n```\n\nimplements会将class的实现抹掉就不存在默认实现一说,而dart也是不允许多继承的。那么我们只能将walk、swim、fly三个接口在不同动物类中重复实现一遍吗?\n\n其实dart里有个叫做mixin的概念可以解决上面的问题\n\n# mixin\n\nmixin实际上也是面向对象编程中的概念,在[维基百科](https://zh.wikipedia.org/wiki/Mixin)上对它的解释如下:\n\n> Mixin是面向对象程序设计语言中的类，提供了方法的实现。其他类可以访问mixin类的方法而不必成为其子类。[1]Mixin有时被称作\"included\"而不是\"inherited\"。mixin为使用它的class提供额外的功能，但自身却不单独使用（不能单独生成实例对象，属于抽象类）。因为有以上限制，Mixin类通常作为功能模块使用，在需要该功能时“混入”，而且不会使类的关系变得复杂。用户与Mixin不是“is-a”的关系，而是“-able”关系\n\ndart语言里面我们可以使用with关键字实现mixin,将一个或者多个class混入另一个类:\n\n```\nclass Base1 {\n  void foo1() {\n    print(\"foo1\");\n  }\n}\n\nclass Base2 {\n  void foo2() {\n    print(\"foo2\");\n  }\n}\n\nclass Child2 with Base1, Base2 {\n\n}\n```\n\n没错,通过with多个类,可以实现类似多继承的效果。\n\n既然允许with多个类,那么如果这些类中有个相同方法,那会出现什么事情。实际上kotlin、java8使用接口的默认实现也会出现一样的问题，他们的处理方法是当出现相同方法的时候实现类需要手动指定使用哪个接口的默认实现,要不然编译会报错:\n\n```java\n// java8\ninterface IBase1 {\n    default void foo() {\n        System.out.println(\"1\");\n    }\n}\n\ninterface IBase2 {\n    default void foo() {\n        System.out.println(\"2\");\n    }\n}\n\nclass Child implements IBase1, IBase2 {\n\n    @Override\n    public void foo() {\n        IBase2.super.foo();\n    }\n}\n```\n\n```kotlin\n//kotlin\ninterface IBase1 {\n    fun foo() {\n        println(\"1\")\n    }\n}\n\ninterface IBase2 {\n    fun foo() {\n        println(\"2\")\n    }\n}\n\nclass Child : IBase1, IBase2 {\n    override fun foo() {\n        super<IBase2>.foo()\n    }\n}\n```\n\n# 线性化\n\n而在dart with里面越后面的类优先级越高:\n\n```\nclass Base1 {\n  void foo() {\n    print(\"1\");\n  }\n}\n\nclass Base2 {\n  void foo() {\n    print(\"2\");\n  }\n}\n\nclass Base3 {\n  void foo() {\n    print(\"3\");\n  }\n}\n\nclass Child extends Base1 with Base2, Base3 {}\n```\n\n这个时候调用Child.foo方法实际会优先调用Base3.foo。原因是dart实际是通过创建中间类继承实现的mixin,上面的代码相当于:\n\n\n{% plantuml %}\nclass Base1 {\n  + foo()\n}\n\nclass Base1WithBase2 extends Base1 {\n  + foo()\n}\n\nclass Base1WithBase2WithBase3 extends Base1WithBase2 {\n  + foo()\n}\n\nclass Child extends Base1WithBase2WithBase3\n{% endplantuml %}\n\n通过从左到右的顺序生成中间父类去继承将extends、with线性化成一个单继承链。所以**Base2、Base3实际上不是Child的父类**\n\n# mixin关键字\n\n在上面的例子中我们使用普通的class去with，但dart实际上提供了一个mixin关键字，它定义了不能实例化，也不能extends只能with的类:\n\n```\nmixin Base {\n\n}\n\n// 编译失败: mixin类不能extends\n// class Child extends Base {\n//\n// }\n\n// 编译成功: mixin类可以with\nclass Child with Base {\n\n}\n\nvoid main() {\n  // 编译失败: mixin类不能实例化\n  // Base()\n}\n```\n\n这样的类实际上和java、kotlin里面的interface已经很像了。\n\n另外我们可以通过mixin ... on 限定某个类只能由某些类去with:\n\n```\nclass Base1 {\n  void foo() {\n    print(\"1\");\n  }\n}\n\nclass Base2 {\n  void foo() {\n    print(\"2\");\n  }\n}\n\nmixin Base3 on Base1 {\n  void foo() {\n    super.foo();\n    print(\"3\");\n  }\n}\n\nclass Child extends Base1 with Base2, Base3 {}\n```\n\n上面的demo中Base3只能由Base1去with,那就以为着这个with Base3的类一定是继承或者with了 Base1,所以可以调用这个类的super.foo方法。要注意的是，这个super.foo并不指定一定调用的是Base1.foo。例如上面的代码调用Child().foo()之后的打印实际上是:\n\n```\n2\n3\n```\n\n它们线性化的到的继承关系和前面全是class的代码并没有差别:\n\n\n{% plantuml %}\nclass Base1 {\n  + foo()\n}\n\nclass Base1WithBase2 extends Base1 {\n  + foo()\n}\n\nclass Base1WithBase2WithBase3 extends Base1WithBase2 {\n  + foo()\n}\n\nclass Child extends Base1WithBase2WithBase3\n\nnote left of Base1::foo\n  print(\"1\");\nend note\n\nnote left of Base1WithBase2::foo\n  print(\"2\");\nend note\n\nnote left of Base1WithBase2WithBase3::foo\n  super.foo();\n  print(\"3\");\nend note\n{% endplantuml %}\n\n\n从上面的uml图我们就能理解为什么打印是23了\n\n理解了这个简单的例子之后我们再来看一个复杂一点的例子:\n\n```\nclass Base1 {\n  void foo1() {\n    print(\"Base1.foo1\");\n    foo2();\n  }\n\n  void foo2() {\n    print(\"Base1.foo2\");\n  }\n}\n\nmixin Base2 on Base1 {\n  void foo1() {\n    super.foo1();\n    print(\"Base2.foo1\");\n  }\n\n  void foo2() {\n    print(\"Base2.foo2\");\n  }\n}\n\nclass Child with Base1,Base2 {}\n\nvoid main() {\n  Child().foo1();\n}\n```\n\n它的输出是:\n\n```\nBase1.foo1\nBase2.foo2\nBase2.foo1\n```\n\n原因是Base2.foo1中的super.foo1实际上调用的是Base1.foo1,而Base1.foo1中的foo2,由于继承的多态特性,调用的是Base2.foo2。我们可以通过下面uml图辅助理解,**注意看继承关系里面是没有Base1、Base2的因为它们都是通过with混入的,并不是Child的父类**:\n\n{% plantuml %}\nclass WithBase1 {\n  + foo1()\n  + foo2()\n}\n\nclass WithBase1WithBase2 extends WithBase1 {\n  + foo1()\n  + foo2()\n}\n\nclass Child extends WithBase1WithBase2\n\n\nnote left of WithBase1::foo1\n  print(\"Base1.foo1\");\n  foo2();\nend note\n\nnote left of WithBase1WithBase2::foo1\n  super.foo1();\n  print(\"Base2.foo1\");\nend note\n\nnote left of WithBase1WithBase2::foo2\n  print(\"Base2.foo2\");\nend note\n{% endplantuml %}\n\n# with的类不能有构造函数\n\n另外,with的class和mixin类型都是不允许有构造函数的,因为mixin机制语义上是向一个类混入其他类的方法或者成员变量,使得我们可以在混合类中访问到混入类的方法或者属性。而混入其他类的构造函数实际上是没有意义的,因为不会有人手动去调用这个混入类的构造函数。\n\n```\nclass Base1 {\n  Base1() {}\n}\n\n// 编译失败: 不能with一个带有构造函数的类\n// class Child with Base1 {}\n\n// 编译失败: mixin类型只能with,所以不能有构造函数\n// mixin Base2 {\n//   Base2() {}\n// }\n```\n\n# 参考博客\n\nhttps://medium.com/flutter-community/dart-what-are-mixins-3a72344011f3\n\nhttps://www.jianshu.com/p/f4efaa6b8fe6","tags":["技术相关","Dart"]},{"title":"JNI调用速度优化","url":"/2022/03/29/JNI调用速度优化/","content":"\n\n# FastJNI\n\n最近在看JNI HOOK的时候看到了个叫做fastJNI的东西,它可以加速JNI方法的调用,比较有意思。\n\n首先我们都知道RegisterNativeMethods用于动态注册JNI方法:\n\n```\nstatic const JNINativeMethod jniNativeMethod[] = {\n        {\"stringFromJNI\", \"()Ljava/lang/String;\", (void *) (stringFromJNI)},\n};\n\nJNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *javaVm, void *pVoid) {\n    JNIEnv *jniEnv = nullptr;\n    jint result = javaVm->GetEnv(reinterpret_cast<void **>(&jniEnv), JNI_VERSION_1_6); \n    if (result != JNI_OK) {\n        return -1;\n    }\n    \n    jclass jniClass = jniEnv->FindClass(\"me/linjw/demo/MainActivity\");\n    jniEnv->RegisterNatives(\n        jniClass, \n        jniNativeMethod,\n        sizeof(jniNativeMethod) / sizeof(JNINativeMethod)\n    );\n    return JNI_VERSION_1_6;\n}\n```\n\n如果我们在方法签名的前面加上\"!\",就可以指定使用fastJNI的方式去调用这个native方法:\n\n```\nstatic const JNINativeMethod jniNativeMethod[] = {\n        {\"stringFromJNI\", \"!()Ljava/lang/String;\", (void *) (stringFromJNI)},\n};\n```\n\n查看RegisterNativeMethods可以知道,它实际上是给Native方法设置了kAccFastNative标志位:\n\n```\n// jni_internal.cc\nstatic jint RegisterNativeMethods(JNIEnv* env, jclass java_class, const JNINativeMethod* methods,\n                                jint method_count, bool return_errors) {\n    ...\n    for (jint i = 0; i < method_count; ++i) {\n        const char* name = methods[i].name;\n        const char* sig = methods[i].signature;\n        const void* fnPtr = methods[i].fnPtr;\n\n        ...\n        bool is_fast = false;\n        // Notes about fast JNI calls:\n        //\n        // On a normal JNI call, the calling thread usually transitions\n        // from the kRunnable state to the kNative state. But if the\n        // called native function needs to access any Java object, it\n        // will have to transition back to the kRunnable state.\n        //\n        // There is a cost to this double transition. For a JNI call\n        // that should be quick, this cost may dominate the call cost.\n        //\n        // On a fast JNI call, the calling thread avoids this double\n        // transition by not transitioning from kRunnable to kNative and\n        // stays in the kRunnable state.\n        //\n        // There are risks to using a fast JNI call because it can delay\n        // a response to a thread suspension request which is typically\n        // used for a GC root scanning, etc. If a fast JNI call takes a\n        // long time, it could cause longer thread suspension latency\n        // and GC pauses.\n        //\n        // Thus, fast JNI should be used with care. It should be used\n        // for a JNI call that takes a short amount of time (eg. no\n        // long-running loop) and does not block (eg. no locks, I/O,\n        // etc.)\n        //\n        // A '!' prefix in the signature in the JNINativeMethod\n        // indicates that it's a fast JNI call and the runtime omits the\n        // thread state transition from kRunnable to kNative at the\n        // entry.\n        if (*sig == '!') {\n            is_fast = true;\n            ++sig;\n        }\n        ...\n        m->RegisterNative(fnPtr, is_fast);\n        ...\n    }\n\n    return JNI_OK;\n}\n\n// art_method.cc\nvoid ArtMethod::RegisterNative(const void* native_method, bool is_fast) {\n    CHECK(IsNative()) << PrettyMethod(this);\n    CHECK(!IsFastNative()) << PrettyMethod(this);\n    CHECK(native_method != nullptr) << PrettyMethod(this);\n    if (is_fast) {\n        SetAccessFlags(GetAccessFlags() | kAccFastNative);\n    }\n    SetEntryPointFromJni(native_method);\n}\n```\n\n源码的注释里面也描述了fastJNI的原理:\n\n1. java方法运行在kRunnable state，native方法运行在kNative state\n2. java进入native方法，从kRunnable state切换到kNative state会消耗时间\n3. 如果native方法需要调到java的代码，从kNative state切换回kRunnable state也会耗时\n4. 如果在方法签名前面加上\"!\"可以将native方法定义成fastJNI方法\n5. fastJNI方法运行在kRunnable state，避免了state的切换耗时\n\n以我的理解是这样的,默认情况下虚拟机栈和本地方法栈在两个不同的state下,相当于退出和进入java虚拟机环境,所以会有一系列的环境的存储与恢复:\n\n{% plantuml %}\n\ncard 普通JNI{\n    frame kNativeState {\n        node nativeStack [\n            ---\n            ---\n            ---\n            本地方法栈\n        ]\n    }\n\n    frame kRunnableState {\n        node javaStack [\n            ---\n            ---\n            ---\n            虚拟机栈\n        ]\n    }\n\n    javaStack -> nativeStack : 进入JNI方法: 退出java虚拟机环境\n    javaStack <- nativeStack : 调用java代码: 进入java虚拟机环境\n}\n{% endplantuml %}\n\n虚拟机是c/c++写的,而fastJNI相当于在执行虚拟机栈的环境上直接调用了native方法,所以java和本地方法是直接相互调用的:\n\n{% plantuml %}\ncard fastJNI {\n    \n    frame kRunnableState {\n        node nativeStack [\n            ---\n            ---\n            ---\n            本地方法栈\n        ]\n        node javaStack [\n            ---\n            ---\n            ---\n            虚拟机栈\n        ]\n    }\n\n    javaStack -> nativeStack : 进入JNI方法: 直接调用\n    javaStack <- nativeStack : 调用java代码: 直接调用\n}\n{% endplantuml %}\n\nJAVA GC的stop the work实际上只是停止了java虚拟机的世界,并没没有办法停止native层的代码。\n\n普通jni会有java虚拟机环境的进出,单纯的执行native代码对虚拟机环境没有任何影响,所以只需要在进入虚拟机的时候判断是否已经停止。\n\n但fastJNI由于native代码会直接调用运行java层的代码,所以stop the work的时候反而需要判断是否在fastJNI过程中,以避免stop the work的过程中java代码被native层执行。\n\n因此fastJNI使用的时候需要注意:\n\n> fastJNI会导致Java GC之类的线程挂起请求操作被推迟,所以fastJNI方法需要尽量的短小和不要在里面做一些阻塞操作\n\n# @FastNative & @CriticalNative\n\nfastJNI在安卓8.0之后就被废弃了:\n\n```\n// jni_internal.cc\nstatic jint RegisterNativeMethods(JNIEnv* env, jclass java_class, const JNINativeMethod* methods,\n                                jint method_count, bool return_errors) {\n    ...\n    for (jint i = 0; i < method_count; ++i) {\n        const char* name = methods[i].name;\n        const char* sig = methods[i].signature;\n        const void* fnPtr = methods[i].fnPtr;\n\n        ...\n        if (*sig == '!') {\n            is_fast = true;\n            ++sig;\n        }\n        ...\n        if (UNLIKELY(is_fast)) {\n            // There are a few reasons to switch:\n            // 1) We don't support !bang JNI anymore, it will turn to a hard error later.\n            // 2) @FastNative is actually faster. At least 1.5x faster than !bang JNI.\n            //    and switching is super easy, remove ! in C code, add annotation in .java code.\n            // 3) Good chance of hitting DCHECK failures in ScopedFastNativeObjectAccess\n            //    since that checks for presence of @FastNative and not for ! in the descriptor.\n            LOG(WARNING) << \"!bang JNI is deprecated. Switch to @FastNative for \" << m->PrettyMethod();\n            is_fast = false;\n            // TODO: make this a hard register error in the future.\n        }\n\n        const void* final_function_ptr = m->RegisterNative(fnPtr, is_fast);\n        ...\n    }\n\n    return JNI_OK;\n}\n```\n\n注释上说高版本的安卓提供了@FastNative去替代fastJNI。我们从[官方文档](https://source.android.google.cn/devices/tech/dalvik/improvements?hl=zh-cn)上可以找到它和另外一个叫 @CriticalNative 的东西:\n\n### 更快速的原生方法\n\n\n使用 [@FastNative](https://android.googlesource.com/platform/libcore/+/master/dalvik/src/main/java/dalvik/annotation/optimization/FastNative.java) 和 [@CriticalNative](https://android.googlesource.com/platform/libcore/+/master/dalvik/src/main/java/dalvik/annotation/optimization/CriticalNative.java) 注解可以更快速地对 Java 原生接口 (JNI) 进行原生调用。这些内置的 ART 运行时优化可以加快 JNI 转换速度，并取代了现已弃用的 !bang JNI 标记。这些注解对非原生方法没有任何影响，并且仅适用于 bootclasspath 上的平台 Java 语言代码（无 Play 商店更新）。\n\n@FastNative 注解支持非静态方法。如果某种方法将 jobject 作为参数或返回值进行访问，请使用此注解。\n\n利用 @CriticalNative 注解，可更快速地运行原生方法，但存在以下限制：\n\n- 方法必须是静态方法 - 没有参数、返回值或隐式 this 的对象。\n- 仅将基元类型传递给原生方法。\n- 原生方法在其函数定义中不使用 JNIEnv 和 jclass 参数。\n- 方法必须使用 RegisterNatives 进行注册，而不是依靠动态 JNI 链接。\n\n> @FastNative 和 @CriticalNative 注解在执行原生方法时会停用垃圾回收。不要与长时间运行的方法一起使用，包括通常很快但一般不受限制的方法。\n> \n> 停顿垃圾回收可能会导致死锁。如果锁尚未得到本地释放（即尚未返回受管理代码），请勿在原生快速调用期间获取锁。此要求不适用于常规的 JNI 调用，因为 ART 将正执行的原生代码视为已暂停的状态。\n\n@FastNative 可以使原生方法的性能提升高达 3 倍，而 @CriticalNative 可以使原生方法的性能提升高达 5 倍。例如，在 Nexus 6P 设备上测量的 JNI 转换如下：\n\n|Java 原生接口 (JNI) 调用 |\t执行时间（以纳秒计）|\n|-|-|\n|常规 JNI|115|\n|!bang JNI|60|\n|@FastNative|35|\n|@CriticalNative|25|\n\n### 使用@FastNative和@CriticalNative\n\n这两个东西的效果这么好,Framework里面也大量用到了。那么当我们充分了解了它们的影响之后,可以在适当的情景下使用。\n\n但是如果你直接import它们的话会发现,在Android Studio里面报红色的Error,找不到具体的定义:\n\n```\nimport dalvik.annotation.optimization.CriticalNative;\nimport dalvik.annotation.optimization.FastNative;\n```\n\n原因是它们都是Hide的接口对应用层隐藏。网上有不少调用隐藏API的方式,但是可能这两个类的位置比较特别,我也没有能从隐藏接口里面找到它们。于是乎我用了一个比较取巧的方式,直接把它们的代码拷贝了下来,在自己的工程里面创建同样的package去放:\n\n{% img /JNI调用速度优化/1.png %}\n\n从结果来看,速度的确是有比较明显的优化的:\n\n{% img /JNI调用速度优化/2.png %}\n\n完整的DEMO可以到[Github](https://github.com/bluesky466/FastNativeDemo)上下载","tags":["技术相关","Android","C/C++"]},{"title":"Kotlin原理-object关键字","url":"/2022/02/27/Kotlin原理-object关键字/","content":"\nobject关键字有下面的三种用法:\n\n1. 对象声明\n2. 伴生对象\n3. 对象表达式\n\n我们逐一来看看它们的实现原理\n\n# 对象声明\n\nobject类可以看成是java里面的单例模式在kotlin的便捷实现:\n\n```\nobject TestObject {\n    const val TAG = \"TestObject\"\n\n    fun foo() {\n    }\n}\n\n// kotlin 中调用\nTestObject.foo()\n\n// java 中调用\nTestObject.INSTANCE.foo();\n```\n\n从java的用法里面能看出来,对象声明的原理实际上是将其转换成了java的单例模式:\n\n```\npublic final class TestObject {\n    @NotNull\n    public static final String TAG = \"TestObject\";\n    @NotNull\n    public static final TestObject INSTANCE;\n\n    public final void foo() {\n    }\n\n    private TestObject() {\n    }\n\n    static {\n        TestObject var0 = new TestObject();\n        INSTANCE = var0;\n    }\n}\n```\n\n如果与java混用的时候，需要使用INSTANCE获取单例比较麻烦,可以使用@JvmStatic注解将方法修饰成静态方法:\n\n```\nobject TestObject {\n    @JvmStatic\n    fun foo() {\n    }\n}\n```\n\n转换出来的java类就会把foo()定义为静态方法:\n\n```\npublic final class TestObject {\n    @NotNull\n    public static final TestObject INSTANCE;\n\n    // 这里是静态方法\n    @JvmStatic\n    public static final void foo() {\n    }\n\n    private TestObject() {\n    }\n\n    static {\n        TestObject var0 = new TestObject();\n        INSTANCE = var0;\n    }\n}\n```\n\n# 伴生对象\n\nKotlin中并没有静态成员的概念,但是我们可以使用伴生对象达到类似的效果:\n\n```\nclass TestClass {\n    companion object {\n        var data = 123\n        fun foo() {}\n    }\n}\n\n\n// kotlin 中调用\nTestClass.foo()\n\n// java 中调用\nTestClass.Companion.foo();\n```\n\n同样可以在java调用中看出来它实际是生成了TestClass的Companion静态内部类:\n\n```\npublic final class TestClass {\n    private static int data = 123;\n\n    @NotNull\n    public static final TestClass.Companion Companion = new TestClass.Companion((DefaultConstructorMarker)null);\n\n    ...\n   \n    public static final class Companion {\n        public final void foo() {\n        }\n\n        private Companion() {\n        }\n\n        public final int getData() {\n            return TestClass.data;\n        }\n\n        public final void setData(int var1) {\n            TestClass.data = var1;\n        }\n        ...\n    }\n}\n```\n\n同样在java调用的时候需要引用Companion静态成员变量,我们可以用@JvmField和@JvmStatic去简化:\n\n```\nclass TestClass {\n    companion object {\n        @JvmField\n        var data = 123\n\n        @JvmStatic\n        fun foo() {}\n    }\n}\n```\n\n上面kotlin代码转换的java代码如下:\n\n```\npublic final class TestClass {\n    public static int data = 123;\n\n    public static final TestClass.Companion Companion = new TestClass.Companion((DefaultConstructorMarker)null);\n\n    public static final void foo() {\n        Companion.foo();\n    }\n\n    public static final class Companion {\n        @JvmStatic\n        public final void foo() {\n        }\n\n        private Companion() {\n        }\n\n        ...\n    }\n}\n```\n\n# 对象表达式\n\n对象表达式实际上就是java的匿名内部类:\n\n```\nvar listener = object : View.OnClickListener {\n    override fun onClick(p0: View?) {\n\n    }\n}\n```\n\n它转换成的java代码如下:\n\n```\nOnClickListener var10000 = new OnClickListener() {\n    public void onClick(@Nullable View p0) {\n    }\n};\n```","tags":["技术相关","Android"]},{"title":"Kotlin原理-by关键字","url":"/2022/01/29/Kotlin原理-by关键字/","content":"\n委托模式也叫代理模式,指的是一个对象接收到请求之后将请求转交由另外的对象来处理,它也是继承的一种很好的替代方式,可以实现用组合替代继承。\n\nKotlin内置了一个by关键字,可以很方便的实现代理.\n\n# 委托类\n\n借用[Kotlin中文站](https://www.kotlincn.net/docs/reference/delegation.html)的例子:\n\n```\ninterface Base {\n    fun print()\n}\n\nclass BaseImpl(val x: Int) : Base {\n    override fun print() { print(x) }\n}\n\nclass Derived(b: Base) : Base by b\n\nfun main() {\n    val b = BaseImpl(10)\n    Derived(b).print()\n}\n```\n\nDerived的所有请求会被转发给传入的b对象,它的实现原理实际上是编译器帮我们补全了Derived的方法,将传入的b对象保存起来,然后在补全的方法内去调用b对象:\n\n```\npublic final class Derived implements Base {\n    private final /* synthetic */ Base $$delegate_0;\n\n    public void print() {\n        this.$$delegate_0.print();\n    }\n\n    public Derived(Base b) {\n        Intrinsics.checkNotNullParameter(b, \"b\");\n        this.$$delegate_0 = b;\n    }\n}\n```\n\nby关键字的好处在于如果Base接口有多个方法需要实现,而我们只想对其中一个方法进行改造,例如统计print的调用次数,那么可以在Derived里面只实现print方法,而其他的方法由by关键字自动生成:\n\n```\ninterface Base {\n    fun print()\n    fun method1()\n    fun method2()\n    fun method3()\n    fun method4()\n    fun method5()\n}\n\nclass Derived(private val b: Base) : Base by b {\n    var printInvokeCount = 0\n        private set\n\n    override fun print() {\n        printInvokeCount++\n        this.b.print()\n    }\n}\n```\n\nby关键字虽然方便但是也有限制,那就是它只能委托接口的方法,如果把Base改成class而不是interface,Derived就不能使用by去委托了。\n\n# 委托属性\n\n除了整个类进行委托之外,我们也可能对类的成员变量进行委托:\n\n```\nclass StringDelegate {\n    private lateinit var str: String\n\n    // 实现get委托方法\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {\n        println(\"get $thisRef.${property.name}\")\n        return str\n    }\n\n    // 实现set委托方法\n    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {\n        println(\"set $thisRef.${property.name} to $value\")\n        str = value\n    }\n}\n\nclass Data {\n    var str by StringDelegate()\n}\n```\n\n它的原理实际上是在Data类里面将这个StringDelegate给保存了起来,然后在getStr/setStr里面去调用它的对应方法:\n\n```\npublic final class Data {\n   // $FF: synthetic field\n   static final KProperty[] $$delegatedProperties = new KProperty[]{(KProperty)Reflection.mutableProperty1(new MutablePropertyReference1Impl(Data.class, \"str\", \"getStr()Ljava/lang/String;\", 0))};\n\n   @NotNull\n   private final StringDelegate str$delegate = new StringDelegate();\n\n   @NotNull\n   public final String getStr() {\n      return this.str$delegate.getValue(this, $$delegatedProperties[0]);\n   }\n\n   public final void setStr(@NotNull String var1) {\n      Intrinsics.checkNotNullParameter(var1, \"<set-?>\");\n      this.str$delegate.setValue(this, $$delegatedProperties[0], var1);\n   }\n}\n```\n\n## by lazy原理\n\n基于上面的属性委托原理,我们很容易就能实现自己的by lazy:\n\n```\nclass MyLazy<T>(initializer: () -> T) {\n    companion object {\n        val UNINITIALIZED_VALUE = Object()\n    }\n\n    private var initializer: (() -> T)? = initializer\n    private var value: Any? = UNINITIALIZED_VALUE\n\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): T {\n        if (value == UNINITIALIZED_VALUE) {\n            value = initializer!!()\n            initializer = null // 把初始化方法置空,避免其引用外部类引用造成内存泄露\n        }\n        return value as T\n    }\n}\n\nclass Data {\n    val data by MyLazy { null }\n}\n```\n\n实际上kotlin的lazy原理也差不多是这样了:\n\n```\npublic actual fun <T> lazy(initializer: () -> T): Lazy<T> = SynchronizedLazyImpl(initializer)\n\nprivate class SynchronizedLazyImpl<out T>(initializer: () -> T, lock: Any? = null) : Lazy<T>, Serializable {\n    private var initializer: (() -> T)? = initializer\n\n    @Volatile private var _value: Any? = UNINITIALIZED_VALUE\n\n    private val lock = lock ?: this\n\n    override val value: T\n        get() {\n            val _v1 = _value\n            if (_v1 !== UNINITIALIZED_VALUE) {\n                @Suppress(\"UNCHECKED_CAST\")\n                return _v1 as T\n            }\n\n            return synchronized(lock) {\n                val _v2 = _value\n                if (_v2 !== UNINITIALIZED_VALUE) {\n                    @Suppress(\"UNCHECKED_CAST\") (_v2 as T)\n                } else {\n                    val typedValue = initializer!!()\n                    _value = typedValue\n                    initializer = null\n                    typedValue\n                }\n            }\n        }\n\n    ...\n}\n```\n\n而且可以看到lazy在初始化对象的时候会对初始化的代码块使用synchronized上锁,所以是线程安全的。这个锁我们可以外部传入,也可以默认使用SynchronizedLazyImpl的this指针\n\n当然如果我们觉得这个synchronized加锁会影响性能,也可以使用lazy的重载方法去指定线程安全策略:\n\n```\npublic actual fun <T> lazy(mode: LazyThreadSafetyMode, initializer: () -> T): Lazy<T> =\n    when (mode) {\n        LazyThreadSafetyMode.SYNCHRONIZED -> SynchronizedLazyImpl(initializer)  // 使用synchronized加锁\n        LazyThreadSafetyMode.PUBLICATION -> SafePublicationLazyImpl(initializer) //使用cas机制保证线程安全\n        LazyThreadSafetyMode.NONE -> UnsafeLazyImpl(initializer) // 不加锁,不考虑线程安全问题\n    }\n```\n","tags":["技术相关","Android"]},{"title":"Kotlin原理-闭包","url":"/2022/01/26/Kotlin原理-闭包/","content":"\n讲kotlin的闭包我想从java的闭包讲起。\n\n# Java不完整闭包\n\nJava的闭包是不完整的,它要求匿名内部类使用外部的变量必现是final的,这就使我们不能在匿名内部类里面修改外部变量的值:\n\n```\nfinal Integer data = 0; // 必须是final\n\nView.OnClickListener listener = new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        Log.d(TAG, \" data = \" + data);\n    }\n};\nfindViewById(R.id.button).setOnClickListener(listener);\n```\n\n这个要求的根本原因在于方法内的临时变量是存放在栈区的,一旦方法调用完成,这部分的内存就会被释放。如果我们再去修改这块的内存就会造成不可预期的后果。\n\n但是问题又来了,如果一旦方法调用完成,上面例子的data这个引用的内存就会被回收。那么在onClick的时候为什么还能读取到值呢?\n\n原因在于java实现匿名内部类的原理是Java编译器会给它生成一个实际的类,将外部变量保存到这个类的成员变量里,我们可以通过下面的代码打印出这个生成的类:\n\n```\nLog.d(TAG, \"class \" + listener.getClass() + \" { \");\nfor (Field field : listener.getClass().getDeclaredFields()) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"\\t\");\n\n    if (Modifier.isFinal(field.getModifiers())) {\n        sb.append(\"final \");\n    }\n\n    sb.append(field.getType().getName())\n            .append(\" \")\n            .append(field.getName())\n            .append(\";\");\n\n    Log.d(TAG, sb.toString());\n}\nLog.d(TAG, \"}\");\n```\n\n输出如下:\n\n```\nD closure : class class me.linjw.demo.MainActivity$1 {\nD closure :      final me.linjw.demo.MainActivity this$0;\nD closure :      final java.lang.Integer val$data;\nD closure : }\n```\n\n可以看到这个类除了用成员变量保存了外部的data的副本之外,还保存了外部类MainActivity的引用。这也是匿名内部类/非静态内部类持有外部类引用的原理。\n\n# 突破Java不完整闭包限制\n\n知道了Java匿名内部类持有外部对象引用的原理之后,我们其实是可以通过下面的方法绕过不能修改外部对象的限制的:\n\n```\nfinal Integer[] data = new Integer[]{0};\n\nView.OnClickListener listener = new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        data[0]++;\n        Log.d(TAG, \" data = \" + data[0]);\n    }\n};\n```\n\n这种做法的原理在于,data这个引用本身的内存在栈区,方法调用完会被回收,但是它所指向的数组的内存在堆区,只有还有引用指向它就不会被回收。而Java编译器生成的这个类巧合就有个成员变量保存了data的副本,指向了这个数组。\n\n用c++的话来讲就是,指针在方法结束的时候被回收了,但是指针所指向的堆内存没有被回收。\n\n# Kotlin闭包原理\n\nKotlin闭包的原理实际上就是上面讲的突破Java不完整闭包限制的原理。用工具查看下面Kotlin代码生成的Java字节码:\n\n```\nvar data = 0\nfindViewById<Button>(R.id.button).setOnClickListener {\n    data++\n    Log.d(TAG,\"data = $data\")\n}\n```\n\n可以看到data实际指向了一个IntRef的堆内存,在IntRef的element成员里面保存的才是实际的值:\n\n```\nfinal IntRef data = new IntRef();\ndata.element = 0;\n((Button)this.findViewById(1000095)).setOnClickListener((OnClickListener)(new OnClickListener() {\n   public final void onClick(View it) {\n      int var10001 = data.element++;\n      Log.d(MainActivity.this.TAG, \"data = \" + data.element);\n   }\n}));\n```\n","tags":["技术相关","Android"]},{"title":"Kotlin原理-拓展函数","url":"/2022/01/25/Kotlin原理-拓展函数/","content":"\n# 原理\n\n拓展函数是kotlin里一个比较常用的特性,例如我们可以给Context拓展一个toast方法:\n\n```\n// MainActivity.kt\nfun Context.toast(msg: String) {\n    Toast.makeText(this, msg, Toast.LENGTH_SHORT).show()\n}\n\nprivate fun foo(context: Context) {\n    context.toast(\"hello world\")\n}\n```\n\n它的原理其实很简单,就是生成了一个toast方法。拓展函数的this指针实际上是这个生成方法的第一个参数:\n\n```\n/* compiled from: MainActivity.kt */\npublic final class MainActivityKt {\n\n\tpublic static final void toast(Context $this$toast, String msg) {\n\t\t//参数判空\n\t    ...\n\n\t    // 拓展函数代码\n\t    Toast.makeText($this$toast, msg, 0).show();\n\t}\n}\n```\n\n\n所以这个this指针实际上是由函数调用的地方传入的对象引用:\n\n```\nprivate final void foo(Context context) {\n    MainActivityKt.toast(context, \"hello world\");\n}\n```\n\n# 限制\n\n知道了拓展函数的实现原理之后我们就能从原理去理解拓展函数的种种限制.\n\n## 不能访问私有成员\n\n由于编译成java之后,生成的拓展方法实际是靠第一个参数出入对象引用,然后使用这个对象引用去调用对象的方法。因此我们并没有权限在拓展函数里面调用私有方法:\n\n```\nclass TestClass {\n    fun publicFun() {}\n    private fun privateFun() {}\n}\n\nfun TestClass.extFun() {\n    publicFun() // 正确,可以调用公有方法\n\n    privateFun() // 错误,不能调用私有方法\n}\n```\n\n## 拓展函数不能实现多态\n\n由于拓展函数并不是真的给类增加一个成员函数,所以父类和子类的同名拓展函数并没有多态的特性。\n\n例如我们为父类和子类拓展同一个foo()函数:\n\n```\nopen class Parent\nclass Child : Parent()\n\nfun Parent.foo() {\n    println(\"parent\")\n}\n\nfun Child.foo() {\n    println(\"child\")\n}\n```\n\n然后只要将子类转换成父类,调用的拓展函数就是父类的拓展函数:\n\n```\nval child = Child()\nchild.foo()\n(child as Parent).foo()\n\n// 输出:\n// child\n// parent\n```\n\n## 成员函数优先级高,拓展函数不能实现重写\n\n当拓展函数与类本身或者父类的成员函数相同,在实际调用的时候会优先调用成员函数,并不会出现类似重写的效果.\n\n例如我们为一个类编写了一个与成员函数相同的拓展函数,实际优先调用类成员函数:\n\n```\nopen class Parent {\n    fun foo() {\n        println(\"foo\")\n    }\n}\n\nfun Parent.foo() {\n    println(\"parent\")\n}\n\nParent().foo()\n\n// 输出:\n// foo\n```\n\n就算是为子类编写了一个与父类成员函数相同的拓展函数,也会优先调用父类的成员函数:\n\n```\nopen class Parent {\n    fun foo() {\n        println(\"foo\")\n    }\n}\n\nclass Child : Parent()\n\nfun Child.foo() {\n    println(\"child\")\n}\n\nChild().foo()\n\n// 输出:\n// foo\n```\n","tags":["技术相关","Android"]},{"title":"Bitmap内存回收机制","url":"/2021/12/04/Bitmap内存回收机制/","content":"\nBitmap可以说是安卓里面最常见的内存消耗大户了，我们开发过程中遇到的oom问题很多都是由它引发的。谷歌官方也一直在迭代它的像素内存管理策略。从 Android 2.3.3以前的分配在native上，到2.3-7.1之间的分配在java堆上，又到8.0之后的回到native上。几度变迁，它的回收方法也在跟着变化。\n\n# Android 2.3.3以前\n\n2.3.3以前Bitmap的像素内存是分配在natvie上，而且不确定什么时候会被回收。根据[官方文档](https://developer.android.com/topic/performance/graphics/manage-memory)的说法我们需要手动调用Bitmap.recycle()去回收:\n\n> 在 Android 2.3.3（API 级别 10）及更低版本上，位图的后备像素数据存储在本地内存中。它与存储在 Dalvik 堆中的位图本身是分开的。本地内存中的像素数据并不以可预测的方式释放，可能会导致应用短暂超出其内存限制并崩溃。\n\n> 在 Android 2.3.3（API 级别 10）及更低版本上，建议使用 `recycle()`。如果您在应用中显示大量位图数据，则可能会遇到 `OutOfMemoryError` 错误。利用 `recycle()` 方法，应用可以尽快回收内存。\n\n> **注意**：只有当您确定位图已不再使用时才应该使用 `recycle()`。如果您调用 `recycle()` 并在稍后尝试绘制位图，则会收到错误：`\"Canvas: trying to use a recycled bitmap\"`。\n\n# Android 3.0~Android 7.1\n\n虽然3.0~7.1的版本Bitmp的像素内存是分配在java堆上的，但是实际是在natvie层进行decode的，而且会在native层创建一个c++的对象和java层的Bitmap对象进行关联。\n\n从BitmapFactory的源码我们可以看到它一路调用到nativeDecodeStream这个native方法:\n\n```c++\n// BitmapFactory.java\npublic static Bitmap decodeFile(String pathName, Options opts) {\n\t...\n\tstream = new FileInputStream(pathName);\n\tbm = decodeStream(stream, null, opts);\n\t...\n\treturn bm;\n}\n\npublic static Bitmap decodeStream(InputStream is, Rect outPadding, Options opts) {\n\t...\n\tbm = decodeStreamInternal(is, outPadding, opts);\n\t...\n\treturn bm;\n}\n\nprivate static Bitmap decodeStreamInternal(InputStream is, Rect outPadding, Options opts) {\n\t...\n\treturn nativeDecodeStream(is, tempStorage, outPadding, opts);\n}\n```\n\nnativeDecodeStream实际上会通过jni创建java堆的内存,然后读取io流解码图片将像素数据存到这个java堆内存里面:\n\n```c++\n\n// BitmapFactory.cpp\nstatic jobject nativeDecodeStream(JNIEnv* env, jobject clazz, jobject is, jbyteArray storage,\n        jobject padding, jobject options) {\n    ...\n    bitmap = doDecode(env, bufferedStream, padding, options);\n    ...\n    return bitmap;\n}\n\nstatic jobject doDecode(JNIEnv* env, SkStreamRewindable* stream, jobject padding, jobject options) {\n\t...\n\t// outputAllocator是像素内存的分配器,会在java堆上创建内存给像素数据,可以通过BitmapFactory.Options.inBitmap复用前一个bitmap像素内存\n\tSkBitmap::Allocator* outputAllocator = (javaBitmap != NULL) ?\n            (SkBitmap::Allocator*)&recyclingAllocator : (SkBitmap::Allocator*)&javaAllocator;\n    ...\n    // 将内存分配器设置给解码器\n    decoder->setAllocator(outputAllocator);\n    ...\n    //解码\n    if (decoder->decode(stream, &decodingBitmap, prefColorType, decodeMode)\n                != SkImageDecoder::kSuccess) {\n        return nullObjectReturn(\"decoder->decode returned false\");\n    }\n    ...\n\treturn GraphicsJNI::createBitmap(env, javaAllocator.getStorageObjAndReset(),\n            bitmapCreateFlags, ninePatchChunk, ninePatchInsets, -1);\n}\n\n// Graphics.cpp\njobject GraphicsJNI::createBitmap(JNIEnv* env, android::Bitmap* bitmap,\n        int bitmapCreateFlags, jbyteArray ninePatchChunk, jobject ninePatchInsets,\n        int density) {\n\n    // java层的Bitmap对象实际上是natvie层new出来的\n    // native层也会创建一个android::Bitmap对象与java层的Bitmap对象绑定\n    // bitmap->javaByteArray()代码bitmap的像素数据其实是存在java层的byte数组中\n    jobject obj = env->NewObject(gBitmap_class, gBitmap_constructorMethodID,\n            reinterpret_cast<jlong>(bitmap), bitmap->javaByteArray(),\n            bitmap->width(), bitmap->height(), density, isMutable, isPremultiplied,\n            ninePatchChunk, ninePatchInsets);\n    ...\n    return obj;\n}\n```\n\n我们可以看最后会调用javaAllocator.getStorageObjAndReset()创建一个android::Bitmap类型的native层Bitmap对象，然后通过jni调用java层的Bitmap构造函数去创建java层的Bitmap对象，同时将native层的Bitmap对象保存到mNativePtr:\n\n```java\n\n// Bitmap.java\n// Convenience for JNI access\nprivate final long mNativePtr;\n\n/**\n * Private constructor that must received an already allocated native bitmap\n * int (pointer).\n */\n// called from JNI\nBitmap(long nativeBitmap, byte[] buffer, int width, int height, int density,\n        boolean isMutable, boolean requestPremultiplied,\n        byte[] ninePatchChunk, NinePatch.InsetStruct ninePatchInsets) {\n    ...\n    mNativePtr = nativeBitmap;\n    ...\n}\n```\n\n从上面的源码我们也能看出来，Bitmap的像素是存在java堆的，所以如果bitmap没有人使用了，垃圾回收器就能自动回收这块的内存，但是在native创建出来的nativeBitmap要怎么回收呢？从Bitmap的源码我们可以看到在Bitmap构造函数里面还会创建一个BitmapFinalizer去管理nativeBitmap:\n\n```java\n/**\n * Private constructor that must received an already allocated native bitmap\n * int (pointer).\n */\n// called from JNI\nBitmap(long nativeBitmap, byte[] buffer, int width, int height, int density,\n        boolean isMutable, boolean requestPremultiplied,\n        byte[] ninePatchChunk, NinePatch.InsetStruct ninePatchInsets) {\n    ...\n    mNativePtr = nativeBitmap;\n    mFinalizer = new BitmapFinalizer(nativeBitmap);\n    ...\n}\n```\n\nBitmapFinalizer的原理十分简单。Bitmap对象被销毁的时候BitmapFinalizer也会同步被销毁，然后就可以在BitmapFinalizer.finalize()里面销毁native层的nativeBitmap:\n\n```java\nprivate static class BitmapFinalizer {\n    private long mNativeBitmap;\n    ...\n    BitmapFinalizer(long nativeBitmap) {\n        mNativeBitmap = nativeBitmap;\n    }\n    ...\n    @Override\n    public void finalize() {\n        try {\n            super.finalize();\n        } catch (Throwable t) {\n            // Ignore\n        } finally {\n            setNativeAllocationByteCount(0);\n            nativeDestructor(mNativeBitmap);\n            mNativeBitmap = 0;\n        }\n    }\n}\n```\n\n# Android 8.0之后\n\n8.0以后像素内存又被放回了native上，所以依然需要在java层的Bitmap对象回收之后同步回收native的内存。\n\n虽然BitmapFinalizer同样可以实现，但是Java的finalize方法实际上是不推荐使用的，所以谷歌也换了NativeAllocationRegistry去实现:\n\n```java\n/**\n * Private constructor that must received an already allocated native bitmap\n * int (pointer).\n */\n// called from JNI\nBitmap(long nativeBitmap, int width, int height, int density,\n        boolean isMutable, boolean requestPremultiplied,\n    ...\n    mNativePtr = nativeBitmap;\n    long nativeSize = NATIVE_ALLOCATION_SIZE + getAllocationByteCount();\n    NativeAllocationRegistry registry = new NativeAllocationRegistry(\n        Bitmap.class.getClassLoader(), nativeGetNativeFinalizer(), nativeSize);\n    registry.registerNativeAllocation(this, nativeBitmap);\n}\n```\n\nNativeAllocationRegistry底层实际上使用了sun.misc.Cleaner,可以为对象注册一个清理的Runnable。当对象内存被回收的时候jvm就会调用它。\n\n```java\nimport sun.misc.Cleaner;\n\npublic Runnable registerNativeAllocation(Object referent, Allocator allocator) {\n    ...\n    CleanerThunk thunk = new CleanerThunk();\n    Cleaner cleaner = Cleaner.create(referent, thunk);\n    ..\n}\n\nprivate class CleanerThunk implements Runnable {\n    ...\n    public void run() {\n        if (nativePtr != 0) {\n            applyFreeFunction(freeFunction, nativePtr);\n        }\n        registerNativeFree(size);\n    }\n    ...\n}\n```\n\n这个Cleaner的原理也很暴力,首先它是一个虚引用,registerNativeAllocation实际上创建了一个Bitmap的虚引用:\n\n```java\n// Cleaner.java\npublic class Cleaner extends PhantomReference {\n    ...\n    public static Cleaner create(Object ob, Runnable thunk) {\n        ...\n        return add(new Cleaner(ob, thunk));\n    }\n    ...\n    private Cleaner(Object referent, Runnable thunk) {\n        super(referent, dummyQueue);\n        this.thunk = thunk;\n    }\n    ...\n    public void clean() {\n        ...\n        thunk.run();\n        ...\n    }\n    ...\n}\n```\n\n虚引用的话我们都知道需要配合一个ReferenceQueue使用，当对象的引用被回收的时候，jvm就会将这个虚引用丢到ReferenceQueue里面。而ReferenceQueue在插入的时候居然通过instanceof判断了下是不是Cleaner:\n\n```java\n// ReferenceQueue.java\nprivate boolean enqueueLocked(Reference<? extends T> r) {\n    ...\n    if (r instanceof Cleaner) {\n        Cleaner cl = (sun.misc.Cleaner) r;\n        cl.clean();\n        ...\n    }\n    ...\n}\n```\n\n也就是说Bitmap对象被回收,就会触发Cleaner这个虚引用被丢入ReferenceQueue，而ReferenceQueue里面会判断丢进来的虚引用是不是Cleaner，如果是就调用Cleaner.clean()方法。而clean方法内部就会再去执行我们注册的清理的Runnable。\n","tags":["技术相关","Android"]},{"title":"怎样获取Java泛型的具体类型","url":"/2021/11/20/怎样获取Java泛型的具体类型/","content":"之前写过一篇[博客](https://blog.islinjw.cn/2018/01/06/java%E6%B3%9B%E5%9E%8B%E9%82%A3%E4%BA%9B%E4%BA%8B/)介绍过Java泛型的类型擦除机制，实际上Java的泛型是使用所有类的公共父类Object去实现:\n\n```java\n//错误,泛型的类型被擦除了,T在运行时实际上是Object,不能直接new出来\npublic <T> void foo(T arg) {\n    return arg != null ? arg : new T();\n}\n```\n\n那是不是运行的时候就真的无法获取到泛型使用的实际类型呢？\n\n我们可以从一些第三方库找到答案,例如Gson,它就支持解析泛型类型:\n\n```java\npublic static class Foo<T> {\n\tT data;\n}\n\nType type = new TypeToken<Foo>() {}.getType();\nFoo foo = new Gson().fromJson(json, type);\n```\n\n它是怎么做到的呢？\n\n# 为什么拿不到泛型的具体类型\n\n我们一步步来探索这个问题。先写一个简单的例子:\n\n```java\nimport java.lang.reflect.Field;\n\npublic class GenericsDemo {\n\tpublic static void main(String[] args) throws NoSuchFieldException {\n\t\tFoo<String> foo = new Foo<String>();\n        Class fooClass = foo.getClass();\n        Field field = fooClass.getField(\"data\");\n    \n        System.out.println(fooClass);\n        System.out.println(field.getType());\n        System.out.println(field.getGenericType());\n\t}\n\n\tpublic static class Foo<T> {\n\t\tpublic T data;\n\t}\n}\n```\n\n执行之后看到打印里面泛型的实际类型String已经不见了，变成了Object:\n\n> class GenericsDemo$Foo\n> class java.lang.Object\n> T\n\n所以我们也就没有办法知道new Foo的时候指定的String类型。\n\n# 继承泛型类指定泛型类型\n\n这里还涉及到一个类加载的知识点，getClass方法拿到的实际是类加载器加载的类信息，而类信息在编译的时候就已经确定了。我们用\"javac GenericsDemo.java\"编译这个java代码，可以看到它生成了两个.class文件:\n\n> GenericsDemo$Foo.class GenericsDemo.class     GenericsDemo.java\n\nGenericsDemo$Foo.class就是内部类Foo的信息了，使用\"javap GenericsDemo\\$Foo\"命令查看内容,可以发现它里面没有运行时的类型信息，**也就是说在编译Foo类的时候，编译器没有办法确定它的具体泛型类型**:\n\n```\nCompiled from \"GenericsDemo.java\"\npublic class GenericsDemo$Foo<T> {\n  public T data;\n  public GenericsDemo$Foo();\n}\n```\n\n但是如果我们继承Foo并且指定泛型类型:\n\n```java\npublic static class StringFoo extends Foo<String> {\n}\n```\n\n再使用\"javap GenericsDemo\\$StringFoo\"命令去查看它编译生成的GenericsDemo$StringFoo.class文件:\n\n```\nCompiled from \"GenericsDemo.java\"\npublic class GenericsDemo$StringFoo extends GenericsDemo$Foo<java.lang.String> {\n  public GenericsDemo$StringFoo();\n}\n```\n\n会发现class文件里携带了泛型的类型信息，**也就是说StringFoo在编译的时候就能确定其泛型类型**。既然class文件携带了信息，那么java虚拟机在加载的时候就能把这些信息加载进去。\n\n但是要怎么获取到它呢？如果使用getClass().getSuperclass()去获取父类信息是拿不到泛型的信息的，但是java提供了一个getGenericSuperclass的方法可以获取:\n\n```java\nimport java.lang.reflect.Field;\n\npublic class GenericsDemo {\n\tpublic static void main(String[] args) throws NoSuchFieldException {\n\t\tFoo<String> foo = new StringFoo();\n        System.out.println(foo.getClass().getSuperclass());\n        System.out.println(foo.getClass().getGenericSuperclass());\n\t}\n\n\tpublic static class Foo<T> {\n\t\tpublic T data;\n\t}\n\n\tpublic static class StringFoo extends Foo<String> {\n\t}\n}\n```\n\n> class GenericsDemo$Foo\n> GenericsDemo$Foo<java.lang.String>\n\n如果父类使用了泛型那么getGenericSuperclass拿到的Type实际是ParameterizedType类型，可以通过其getActualTypeArguments方法获取泛型参数:\n\n```java\nFoo<String> foo = new StringFoo();\nParameterizedType superGenericSuperclass = (ParameterizedType) foo.getClass().getGenericSuperclass();\nfor (Type arg : superGenericSuperclass.getActualTypeArguments()) {\n\tSystem.out.println(arg);\t\n}\n```\n\n打印如下:\n\n> class java.lang.String\n\n所以我们可以再配合class的getTypeParameters方法确定在运行的时候每个泛型参数对应的具体是什么:\n\n```java\nFoo<String> foo = new StringFoo();\nParameterizedType superGenericSuperclass = (ParameterizedType) foo.getClass().getGenericSuperclass();\nClass superClass = foo.getClass().getSuperclass();\nfor (int i = 0; i < superGenericSuperclass.getActualTypeArguments().length; i++) {\n    System.out.println(superClass.getTypeParameters()[i] + \" -> \" + superGenericSuperclass.getActualTypeArguments()[i]);\n}\n```\n\n打印如下:\n\n> T -> class java.lang.String\n\n# 封装工具类\n\n所以如果需要在运行的时候获取泛型的具体类型，可以写一个子类去继承它，然后使用getGenericSuperclass获取父类的泛型信息。但是这样的方式比较死板，有没有什么好的方式可以不用继承去实现呢?\n\n我们看看下面的代码:\n\n```java\nSystem.out.println(new Foo<String>().getClass().getGenericSuperclass());\nSystem.out.println(new Foo<String>(){}.getClass().getGenericSuperclass());\n```\n\n它的打印如下：\n\n> class java.lang.Object\n> GenericsDemo$Foo<java.lang.String>\n\n可以看到我们只是在new的后面加上了{},就能通过getClass().getGenericSuperclass()去获取泛型信息了。\n\n这样是因为加上{}之后实际上已经是一个匿名内部类了。通过“javac GenericsDemo.java”命令编译，可以看到编出出来多了个“GenericsDemo$1.class”文件。\n\n匿名内部类的实现原理实际上就是给它创建一个名为GenericsDemo$XXX的子类,所以从他的class信息里面可以看到父类的泛型信息:\n\n```\nCompiled from \"GenericsDemo.java\"\nfinal class GenericsDemo$1 extends GenericsDemo$Foo<java.lang.String> {\n  GenericsDemo$1();\n}\n```\n\n基于上面的知识点:\n\n1. 匿名内部类会生成一个子类\n2. 生成的子类携带了父类的泛型信息\n\n我们可以写一个抽象的Token类,强制必须创建匿名内部类。然后通过查找父类的泛型信息的方式获取具体的泛型类型:\n\n```java\npublic class GenericsDemo {\n    @Test\n    public void main() {\n        new Token<Foo<String>>() {}.parseGenericInfo();\n    }\n\n    public static class Foo<T> {\n        T data;\n    }\n\n    public static abstract class Token<T> {\n        public void parseGenericInfo() {\n            // GenericsDemo$Token<GenericsDemo$Foo<java.lang.String>>\n            ParameterizedType genericSuperclass = (ParameterizedType) this.getClass().getGenericSuperclass();\n\n            // GenericsDemo$Foo<java.lang.String>\n            ParameterizedType targetGenericClass = (ParameterizedType) genericSuperclass.getActualTypeArguments()[0];\n\n            // class GenericsDemo$Foo\n            Class targetClass = (Class) targetGenericClass.getRawType();\n\n            for (int i = 0; i < targetGenericClass.getActualTypeArguments().length; i++) {\n                System.out.println(targetClass.getTypeParameters()[i] + \" -> \" + targetGenericClass.getActualTypeArguments()[i]);\n            }\n        }\n    }\n}\n```\n\n可以看到这个代码已经和Gson里面解析泛型的代码类似了:\n\n```java\nType type = new TypeToken<Foo>() {}.getType();\nFoo foo = new Gson().fromJson(json, type);\n```\n\n","tags":["技术相关","java"]},{"title":"安卓IPC机制之LocalSocket","url":"/2021/11/13/安卓IPC机制之LocalSocket/","content":"LocalSocket作为安卓提供的一种IPC机制，可能应用层的同学比较陌生，我实际也是在这段时间做项目使用到才注意到它并去了解的。不过实际上framework层里面被频繁使用到了，例如我很久前写的博客[从源码看安卓应用的启动过程](https://blog.islinjw.cn/2018/03/08/%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9C%8B%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/)里面提到其他进程和Zygote进程之间的通信使用的是LocalSocket。\n\n那么LocalSocket和Socket到底有什么不同呢？[官方文档](https://developer.android.com/reference/android/net/LocalServerSocket)里面其实提到了它其实是基于UNIX-domain socket的:\n\n> Non-standard class for creating an inbound UNIX-domain socket in the Linux abstract namespace.\n\nSocket本来是用来做不同主机间的网络通信的，如果有人想拿来做本机的IPC通信就会发现它的性能堪忧(例如实现binder机制做不到的传输大文件)，因为它需要走网络协议栈、打包拆包、计算校验等，如果是TCP还需要走三次握手和应答。\n\n于是后面就发展出了UNIX-domain socket (LocalSocket)，它的api和socket的基本一致，但是本质上只是一种IPC通信，不可和外部主机通信，但是因为IPC通信是可靠通信，直接将数据拷贝到目标进程内存即可，所以没有之前说的那些耗时的操作。\n\n# 使用方式\n\n我们先来看看它的使用方式:\n\n```java\nprivate void demoClient() throws IOException {\n    LocalSocket client = new LocalSocket();\n    client.connect(new LocalSocketAddress(\"me.linjw.localsocket\"));\n    client.getOutputStream().write(123);\n    int read = client.getInputStream().read();\n    Log.d(TAG, \"response from server : \" + read);\n    client.close();\n}\n\nprivate void demoServer() throws IOException {\n    LocalServerSocket server = new LocalServerSocket(\"me.linjw.localsocket\");\n    LocalSocket client = server.accept();\n    int read = client.getInputStream().read();\n    Log.d(TAG, \"request from client :\" + read);\n    client.getOutputStream().write(read + 1);\n    client.getOutputStream().flush();\n    client.close();\n}\n\n// 打印\n// request from client :123\n// response from server : 124\n```\n\n没错，看起来和普通Socket的用法很类似了。\n\n# 性能\n\n性能是评判一种ipc进制好坏的重要指标，例如我们常用的Binder机制就是用了mmap机制实现了数据的一次拷贝提高了传输速度。\n\n于是我写了一个[测试程序](https://github.com/bluesky466/IPCSpeechTest)来对比AIDL、LocalSocket和TCP Socket的传输速度。测试的逻辑大概是:\n\n1. 每次传输读或者写1024 byte数据\n2. 计算3000次读或者写的耗时(也就是计算读3000k或者写3000k数据的总耗时)\n3. LocalSocket和TCP Socket每次传输完数据都断开连接,下次需要重新连接\n\n在我们的产品设备上得到的实际数据如下:\n\n| 方式        | 方向 | 第一次3000k | 第二次3000k | 第三次3000k | 第四次3000k | 平均时间 |\n| ----------- | ---- | ----------- | ----------- | ----------- | ----------- | --------- |\n| AIDL        | 读   | 1.711s      | 1.195s      | 1.25s       | 1.169s      | 1.33125s  |\n| LocalSocket | 读   | 1.674s      | 1.286s      | 1.185s      | 1.219s      | 1.341s    |\n| TCP Socket  | 读   | 10.188s     | 8.926s      | 8.865s      | 8.803s      | 9.1955s   |\n| AIDL        | 写   | 1.261s      | 1.212s      | 1.175s      | 1.23s       | 1.2195s   |\n| LocalSocket | 写   | 1.387s      | 1.323s      | 1.23s       | 1.35s       | 1.3225s   |\n| TCP Socket  | 写   | 8.284s      | 8.242s      | 8.324s      | 8.285s      | 8.28375s  |\n\n从上面的数据可以看出来LocalSocket虽然会比AIDL慢但是也差的不多，而tcp的耗时就比较多了。虽然我没有具体看过LocalSocket的底层原理，但是想来既然它在framework层被频繁使用，那么谷歌应该也应该会考虑到性能这一点。\n\n# 优缺点\n\n优点:\n\n1. 可以进行数据流读写,没有大小限制\n2. 比TCP Socket会更加安全，因为不能通过抓包监听传输的数据\n3. 不会开启线程池(Zygote之所以使用它而不是Binder也是因为Binder机制默认会启动线程池，而fork在多线程下只会fork出当前线程)\n\n缺点:\n\n1. 比Binder的速度还是会稍微慢那么一点点\n2. 没有像AIDL这样的高层封装，需要自己实现\n3. 和TCP Socket对比起来不能跨主机通信\n\n# 需要注意的地方\n\n1. 虽然不是真正的网络传输，但是也需要声明android.permission.INTERNET权限，要不然同样会报java.net.SocketException: Permission denied异常\n2. 虽然可以通过LocalSocket和framework层直接通信，但是如果系统打开了SeLinux就会出现Permission denied异常\n3. 在模拟器上LocalSocket的flush用多了耗时有时候会比较严重(Tcp没有问题，实机测试LocalSocket也没有出现问题，猜测和系统相关)","tags":["技术相关","Android"]},{"title":"Flutter线程模型","url":"/2021/10/24/Flutter线程模型/","content":"\n事件循环在UI框架里面应该算是一个常见的东西，例如安卓主线程里面就有个Looper一直在MessageQueue里面读取事件。Flutter里面也有类似的东西。\n\n实际上Flutter的事件循环应该是Dart语言层面就支持的东西。Dart是单线程模型的编程语言，它的一个线程对应一个Isolate，而一个Isolate就会带有一个事件循环。值得注意的是虽然你可以启动多个Isolate来实现多线程，但是正如它的名字\"隔离\"，Isolate之间是内存隔离的，它们有独立的堆内存，这意味着两个Isolate不会出现线程安全问题:\n\n\n{% img /Flutter线程模型/1.png %}\n\nIsolate启动之后就会默认开启事件循环，并不需要我们干些什么。这里有个比较有意思的事情是，不像其他语言，main函数执行完成之后整个程序就结束并退出了。Dart的main函数执行完之后会进入事件循环，监听事件并且进行回调，这些事件包括按键事件、Timer事件等:\n\n\n{% img /Flutter线程模型/2.png %}\n\n所以从这个角度看，Dart的main函数更像是一个init函数，它意味着Dart程序的启动，但它退出后Dart程序还会进行运行。例如下面的代码:\n\n```dart\nvoid main() {\n  print(\"main begin\");\n  Timer(Duration(seconds: 3), () {\n    print(\"on timer\");\n  });\n  print(\"main begin finish\");\n}\n```\n\n通过打印我们可以看到，就算main函数退出了，等3秒后Timer时间到达依然会打印\"on timer\":\n\n```\nI/flutter (15551): main begin\nI/flutter (15551): main begin finish\nI/flutter (15551): on timer\n```\n\n# 消息队列\n\n消息循环一般和消息队列配套使用，就例如安卓里面的Looper和MessageQueue。而Dart里面有两条消息队列microtask队列和event队列，时间循环会执行microtask队列内的任务，microtask队列为空之后再去执行event队列里面的任务:\n\n{% img /Flutter线程模型/3.png %}\n\nevent队列包含Dart和来自系统其它位置的事件。但microtask队列只包含来自当前isolate的内部代码。如果我们希望在这次事件循环处理完成之后，下一次事件循环处理之前做一些事情，就可以往microtask队列里面加入任务:\n\n```Dart\nvoid main() {\n  new Future(() {\n    scheduleMicrotask(()=>print(\"in microtask queue 1\"));\n    print(\"in event queue 1\");\n  });\n  new Future(() {\n    scheduleMicrotask(()=>print(\"in microtask queue 2\"));\n    print(\"in event queue 2\");\n  });\n  new Future(() {\n    scheduleMicrotask(()=>print(\"in microtask queue 3\"));\n    print(\"in event queue 3\");\n  });\n}\n```\n\n在main函数里面我们使用Future往event队列插入了3个task，但是执行到每个task的时候，又会往microtask队列插入microtask，这就造成task执行完之后重新遍历microtask队列发现microtask去执行:\n\n```\nin event queue 1\nin microtask queue 1\nin event queue 2\nin microtask queue 2\nin event queue 3\nin microtask queue 3\n```\n\nFuture有个then方法，可以在Future执行完之后执行指定操作:\n\n```Dart\nvoid main() {\n  new Future(() {\n    scheduleMicrotask(()=>print(\"in microtask queue 1\"));\n    print(\"in event queue 1\");\n    return \"a\";\n  }).then((a) {\n    scheduleMicrotask(()=>print(\"in microtask queue 2\"));\n    print(\"in event queue 2 -> $a\");\n    return new Future(() { return \"b\";});\n  }).then((b) {\n    scheduleMicrotask(()=>print(\"in microtask queue 3\"));\n    print(\"in event queue 3 -> $b\");\n  });\n}\n```\n\n一开始我理解错误，以为是在这个Future task后面插入另一个Future，其实实际上then里面的是callback，它的参数是上一个callback的返回值。callback会在Future执行完之后立即执行，而不会插入event队列。但如果上一个callback的返回值是Future的话，就会往event队列插入任务，而后面的callback实际上监听的是这个返回的Future。所以上面的代码打印如下:\n\n````\nI/flutter (23893): in event queue 1\nI/flutter (23893): in event queue 2 -> a\nI/flutter (23893): in microtask queue 1\nI/flutter (23893): in microtask queue 2\nI/flutter (23893): in event queue 3 -> b\nI/flutter (23893): in microtask queue 3\n````\n\n# 单线程模型\n\n## 线程阻塞\n\n另外正如一开始说的Dart是单线程模型，由于这个事件循环是在单个线程内的，所以如果我们的task耗时比较长就会阻塞后面的task:\n\n```Dart\nvoid main() {\n  print('start time :' + DateTime.now().toString()); // 当前时间\n  Timer(Duration(seconds: 1), () {\n    //callback function\n    print('first timer :' + DateTime.now().toString()); // 1s之后\n    sleep(Duration(seconds: 3));\n  });\n  Timer(Duration(seconds: 2), () {\n    //callback function\n    print('second timer :' + DateTime.now().toString()); // 2s之后\n  });\n}\n```\n\n所以我们的第二个Timer虽然设定是在2秒后执行，但是实际上它会被第一个timer的3秒sleep阻塞住,等到第一个Timer结束才执行:\n\n```\nI/flutter (21196): start time :2021-10-20 21:30:11.794680\nI/flutter (21196): first timer :2021-10-20 21:30:12.835643\nI/flutter (21196): second timer :2021-10-20 21:30:15.841398\n```\n\n因此我们不能过分的信任这些定时任务。\n\n## 未捕获的异常\n\n不像java、kotlin这些语言多线程语言，如果一个线程中出现了未捕获的异常，那么这个线程就被强制结束了。由于采用事件循环的机制来运行相对独立的task，Dart不要求我们必须处理异常。当一个task出现了异常，虽然会结束这个task，但是并不影响整个线程，后续的其他task仍可以继续执行:\n\n```dart\nvoid main() {\n  new Future(() {\n    print(\"task1 begin\");\n    throw new Exception();\n    print(\"task1 finish\");\n  });\n  new Future(() {\n    print(\"task2 begin\");\n    print(\"task2 finish\");\n  });\n}\n```\n\ntask1被中断了，但是task2依然会执行:\n\n```\ntask1 begin\nError: Exception\n    at Object.throw_ [as throw] (http://localhost:64924/dart_sdk.js:5041:11)\n    at http://localhost:64924/packages/myflutter/main.dart.lib.js:365:17\n    at http://localhost:64924/dart_sdk.js:32040:31\n    at internalCallback (http://localhost:64924/dart_sdk.js:24253:11)\ntask2 begin\ntask2 finish\n```\n\n# 在Dart里面实现多线程\n\n虽然通过Dart的async await可以实现类似kotlin的协程的功能，但是如果不做特殊操作，这些协程实际上是跑在同一个线程中的。一旦某个协程做了些耗时操作如复杂计算等，就会造成ui卡顿。这个时候我们可以创建多个Isolate去实现类似多线程的操作:\n\n```Dart\nint globalData = 1;\n\nvoid otherIsolate(SendPort sendPort) {\n  while(true){\n    globalData ++;\n    sleep(Duration(seconds: 1));\n    sendPort.send(\"globalData from otherIsolate $globalData\");\n  }\n}\n\nvoid main() {\n  globalData = 100;\n\n  ReceivePort receivePort = ReceivePort();\n  receivePort.listen((message) {\n    print(message);\n  });\n\n  Isolate.spawn(otherIsolate, receivePort.sendPort);\n  Future.delayed(Duration(seconds: 3), ()=>{\n    print(\"globalData in Future : $globalData\")\n  });\n}\n```\n\n我们可以通过ReceivePort这种类似管道的东西来进行Isolate之间的通信。正如之前所说Isolate是内存隔离的，它更像一个进程的概念。所以并不能像其他语言的多线程一样通过全局变量来交换数据:\n\n```\nI/flutter (17503): globalData from otherIsolate 2\nI/flutter (17503): globalData from otherIsolate 3\nI/flutter (17503): globalData in Future : 100\nI/flutter (17503): globalData from otherIsolate 4\nI/flutter (17503): globalData from otherIsolate 5\nI/flutter (17503): globalData from otherIsolate 6\n```\n\n\n# 参考\n\n学习这部分知识的时候参考了下面的文章，有兴趣的同学可以看看:\n\n[给 Android 开发者的 Flutter 指南](https://flutter.cn/docs/get-started/flutter-for/android-devs#what-is-the-equivalent-of-runonuithread-in-flutter)\n\n[Dart asynchronous programming: Isolates and event loops](https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a)\n\n[Dart与消息循环机制[翻译]](https://www.jianshu.com/p/7549b63a72d7)\n\n","tags":["技术相关","Flutter"]},{"title":"安卓BLE开发笔记(二) API使用指南","url":"/2021/10/08/安卓BLE开发笔记-二-API使用指南/","content":"\n[上一篇](https://blog.islinjw.cn/2021/09/29/%E5%AE%89%E5%8D%93BLE%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-%E4%B8%80-BLE%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/)简单介绍了Ble协议，这篇来看看安卓上的代码具体要怎么写。\n\n# 权限与功能\n\n要在代码中使用蓝牙功能需要先申请到对应的权限，在AndroidManifest.xml文件中添加权限声明\n\n```xml\n<uses-permission android:name=\"android.permission.BLUETOOTH\" />\n<uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\" />\n<uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />\n```\n\nBle属于蓝牙的功能，所以我们需要打开手机的蓝牙功能\n\n```kotlin\n// 打开蓝牙功能\nval bluetoothManager = getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager\nif (!bluetoothManager.adapter.isEnabled) {\n    registerForActivityResult(ActivityResultContracts.StartActivityForResult()) {\n        startScan()\n    }.launch(Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE))\n    return\n}\n```\n\n而且虽然我们使用的是蓝牙功能，但是除了蓝牙的相关权限之外，还需要额外申请一个模糊定位的权限。要不然会启动蓝牙扫描失败:\n\n> 09-11 09:33:47.143 13249 13292 I BtGatt.ScanManager: Cannot start unfiltered scan in location-off. This scan will be resumed when location is on: 6\n\n原因是我们可以通过检查周边蓝牙设备信号的强度，来实现模糊定位。这个权限是需要动态申请的:\n\n```kotlin\n// 判断是否有模糊定位的权限\nif (PERMISSION_DENIED == PermissionChecker.checkCallingOrSelfPermission(this, ACCESS_COARSE_LOCATION)) {\n    requestPermissions(arrayOf(ACCESS_COARSE_LOCATION), REQUEST_CODE_ACCESS_COARSE_LOCATION)\n    return\n}\n\n// 判断GPS是否打开\nval locationManager = getSystemService(LOCATION_SERVICE) as LocationManager\nif (!locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)) {\n    Toast.makeText(this, \"GPS功能没有打开\", Toast.LENGTH_SHORT).show()\n    return\n}\n```\n\nPS : 我司的大板上实际上没有GPS功能，所以最终让系统哥在framework里面把这个判断去掉了:\n\n```java\n// packages/apps/Bluetooth/src/com/android/bluetooth/gatt/ScanManager.java\n// 将这个if判断直接删掉就好，这里只是用来做安全判断的，实际上蓝牙的功能并不依赖gps\nif (!locationEnabled && !isFiltered) {\n    Log.i(TAG, \"Cannot start unfiltered scan in location-off. This scan will be\"\n            + \" resumed when location is on: \" + client.scannerId);\n    mSuspendedScanClients.add(client);\n    if (client.stats != null) {\n        client.stats.recordScanSuspend(client.scannerId);\n    }\n    return;\n}\n```\n\n# 搜索蓝牙设备\n\n功能和权限正常之后我们就能开始扫描周边的蓝牙设备。我看网上很多的教程都是通过BluetoothAdapter.startLeScan去实现的，实际上这个方法已经被标记为过时了，我们这里用新的api去实现:\n\n```Kotlin\nobject : ScanCallback() {\n    override fun onScanResult(callbackType: Int, result: ScanResult?) {\n        super.onScanResult(callbackType, result)\n        // result里面可以拿到信号强度rssi、设备信息device、广播信息scanRecord等\n    }\n}\n\nval manager = context.getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager\nval adapter = manager.adapter\nscanner = adapter?.bluetoothLeScanner ?: return false\nscanner.startScan(callback)\n```\n\n# 连接蓝牙设备\n\n蓝牙设备的连接直接调用onScanResult的result.device的connect方法即可:\n\n```kotlin\nprivate var gatt: BluetoothGatt? = null\nprivate val gattCallback = object : BluetoothGattCallback() {\n    override fun onConnectionStateChange(gatt: BluetoothGatt?, status: Int, newState: Int) {\n        super.onConnectionStateChange(gatt, status, newState)\n        this@BleHelper.gatt = gatt ?: return\n\n        if (newState == BluetoothProfile.STATE_CONNECTED) {\n            connectCallback?.onConnected(gatt)\n        }\n    }\n    ...\n}\n\nfun connectDevice(context: Context,device: BluetoothDevice,callback: ConnectCallback) {\n    connectCallback = callback\n    device.connectGatt(context, true, gattCallback)\n}\n```\n\n连接成功之后我们需要手动去扫描Ble设备提供的服务:\n\n```kotlin\nprivate var gatt: BluetoothGatt? = null\nprivate val gattCallback = object : BluetoothGattCallback() {\n    ...\n    override fun onServicesDiscovered(gatt: BluetoothGatt?, status: Int) {\n        super.onServicesDiscovered(gatt, status)\n        val services = gatt?.services ?: return\n        discoverServicesCallback?.onServicesDiscovered(services)\n    }\n    ...\n}\n\nfun discoverServices(gatt: BluetoothGatt, callback: DiscoverServicesCallback) {\n    discoverServicesCallback = callback\n    gatt.discoverServices()\n}\n```\n\n可以看到，连接和服务发现都是通过BluetoothGattCallback来回调的。实际上所有的GATT相关操作者如读写Characteristic、修改MTU等都是在这里回调的。\n\n# Characteristic读写与监听\n\n设备服务发现成功之后，我们就可以在BluetoothGatt里面遍历services和其中的characteristics。当然我们也可以通过uuid去搜索指定的characteristic:\n\n```kotlin\nprivate var gatt: BluetoothGatt? = null\nfun getCharacteristic(serviceUuid: String, characteristicUuid: String): BluetoothGattCharacteristic? {\n    return gatt\n        ?.getService(UUID.fromString(serviceUuid))\n        ?.getCharacteristic(UUID.fromString(characteristicUuid))\n}\n```\n\n通过characteristic的properties属性我们可以判断到characteristic是不是可读、可写或者可监听的:\n\n```kotlin\nfun isCharacteristicReadable(characteristic: BluetoothGattCharacteristic): Boolean {\n    return (characteristic.properties and BluetoothGattCharacteristic.PROPERTY_READ) != 0\n}\n\nfun isCharacteristicWriteable(characteristic: BluetoothGattCharacteristic): Boolean {\n    return (characteristic.properties and BluetoothGattCharacteristic.PROPERTY_WRITE) != 0\n}\n\nfun isCharacteristicNotify(characteristic: BluetoothGattCharacteristic): Boolean {\n    return (characteristic.properties and BluetoothGattCharacteristic.PROPERTY_NOTIFY) != 0\n}\n```\n\n## 读取characteristic\n\n读取characteristic很简单，直接调用BluetoothGatt.readCharacteristic方法即可:\n\n```kotlin\nprivate var gatt: BluetoothGatt? = null\nprivate val gattCallback = object : BluetoothGattCallback() {\n    ...\n    override fun onCharacteristicRead(\n        gatt: BluetoothGatt?,\n        characteristic: BluetoothGattCharacteristic?,\n        status: Int\n    ) {\n        super.onCharacteristicRead(gatt, characteristic, status)\n        //characteristic?.value 即为读取出来的具体ByteArray\n    }\n    ...\n}\n\nfun readCharacteristic(characteristic: BluetoothGattCharacteristic, callback: ReadCharacteristicCallback) {\n    readCharacteristicCallback = callback\n    gatt?.readCharacteristic(characteristic)\n}\n```\n\n## 写入characteristic\n\n写入的话上一篇有提到过安卓上默认MTU为23，最多一次只能写入20个字节的数据，所以如果数据量比较大的话需要设置一下mtu:\n\n```kotlin\nprivate var gatt: BluetoothGatt? = null\nprivate val gattCallback = object : BluetoothGattCallback() {\n        ...\n        override fun onMtuChanged(gatt: BluetoothGatt?, mtu: Int, status: Int) {\n            super.onMtuChanged(gatt, mtu, status)\n            Log.d(TAG, \"onMtuChanged $mtu\")\n        }\n        ...\n}\n\nfun setMtu(mtu: Int) {\n    gatt?.requestMtu(mtu)\n}\n```\n\n等MTU设置成功之后再调用BluetoothGatt.writeCharacteristic方法写入\n\n```kotlin\nprivate var gatt: BluetoothGatt? = null\nprivate val gattCallback = object : BluetoothGattCallback() {\n        ...\n        override fun onCharacteristicWrite(\n            gatt: BluetoothGatt?,\n            characteristic: BluetoothGattCharacteristic?,\n            status: Int\n        ) {\n            super.onCharacteristicWrite(gatt, characteristic, status)\n            Log.d(TAG, \"onCharacteristicWrite ${characteristic?.uuid} ${status}\")\n        }\n        ...\n}\n\nfun writeCharacteristic(characteristic: BluetoothGattCharacteristic, bytes: ByteArray) {\n    characteristic.value = bytes\n    gatt?.writeCharacteristic(characteristic)\n}\n```\n\n## 监听characteristic\n\n监听characteristic，如上一篇所说，需要先修改其Client Characteristic Configuration Descriptor(uuid 0x2902):\n\n```kotlin\nprivate var gatt: BluetoothGatt? = null\n\nfun startCharacteristicChangeNotify(characteristic: BluetoothGattCharacteristic, callback: CharacteristicChangedCallback) {\n    val gatt = gatt ?: return\n    characteristicChangedCallback = callback\n    if (gatt.setCharacteristicNotification(characteristic, true)) {\n        val descriptor = characteristic.getDescriptor(\n            UUID.fromString(UUID_DESCRIPTOR_CLIENT_CHARACTERISTIC_CONFIGURATION)\n        )\n        descriptor.value = BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE\n        gatt.writeDescriptor(descriptor)\n    }\n}\n```\n\n然后才能接受到值改变的回调:\n\n```kotlin\nprivate val gattCallback = object : BluetoothGattCallback() {\n    ...\n    override fun onCharacteristicChanged(\n        gatt: BluetoothGatt?,\n        characteristic: BluetoothGattCharacteristic?\n    ) {\n        super.onCharacteristicChanged(gatt, characteristic)\n        if (characteristic != null) {\n            characteristicChangedCallback?.onCharacteristicChanged(characteristic)\n        }\n    }\n    ...\n}\n```\n\n# 配对\n\n经典蓝牙的配对是通过BluetoothDevice.createBond()方法实现的，如果在扫描到设备之后直接调用，则可以配对成功。但如果先使用ble connect连接上去之后再去调用就会失败。据说是因为BluetoothDevice.createBond内部也会先判断是否connect，如果connect成功就不继续(这里我没有去找实际的源码验证，存疑)。\n\n但是我发现在原生的Setting蓝牙设置里面，就算是我已经ble connect成功的设备，再去点击连接也是可以绑定的（这里用了我司的一个智能笔设备验证）。于是直接查看原生Setting源码。发现可以通过bluetooth服务去实现:\n\n```kotlin\nprivate const val PACKAGE_BLUETOOTH = \"com.android.bluetooth\"\nprivate const val ACTION_BLUETOOTH = \"android.bluetooth.IBluetoothHidHost\"\n\n\nprivate var hidHost: IBluetoothHidHost? = null\n\n\nfun init(application: Application) {\n    this.application = application\n\n    val intent = Intent(ACTION_BLUETOOTH)\n    intent.setPackage(PACKAGE_BLUETOOTH)\n\n    Log.d(TAG, \"init\")\n    application.bindService(\n        intent,\n        object : ServiceConnection {\n            override fun onServiceConnected(name: ComponentName?, service: IBinder?) {\n                Log.d(TAG, \"IBluetoothHidHost onServiceConnected\")\n                hidHost = IBluetoothHidHost.Stub.asInterface(service)\n            }\n\n            override fun onServiceDisconnected(name: ComponentName?) {\n                Log.d(TAG, \"IBluetoothHidHost onServiceDisconnected\")\n            }\n        },\n        Context.BIND_AUTO_CREATE\n    )\n}\n\n/**\n * 绑定设备\n */\nfun bond(device: BluetoothDevice) {\n    val result = hidHost?.connect(device)\n    Log.d(TAG,\"bond $result\")\n}\n```\n\nIBluetoothHidHost实际上在AndroidSdk内部没有提供，可以直接拷贝系统源码中生成的aidl代码来使用。\n\n# 完整Demo\n\n完整demo已经上传到[github](https://github.com/bluesky466/BleDemo)感兴趣的同学可以clone下来参考","tags":["技术相关","Android"]},{"title":"安卓BLE开发笔记(一) BLE协议入门","url":"/2021/09/29/安卓BLE开发笔记-一-BLE协议入门/","content":"\n最近遇到了一个BLE的项目，花时间恶补了下相关的知识，这里记录下来备忘。这篇笔记是纯协议的，先大概了解ble的协议和流程，能帮助我们更好的编码\n\n# Ble设备发现\n\nBle设备的发现实际上靠的是Advertising(广播)机制。广播也有人管它叫做Beacon,我没有在官方文档里面查找到这个词，但是从网络上的文章来看，它们差不多就是同一个东西。\n\n基于广播发现Ble设备有两种方式:\n\n1. Ble设备设定间隔不断发送广播，手机只要接收到这个广播就能从里面携带的设备信息发现这个设备。同时广播里面也能携带一些特定的数据去实现一些特定的功能，如苹果开发的[*IBeacon*](https://baike.baidu.com/item/iBeacon/13826305?fr=aladdin)。\n2. 手机发送Scan Request广播，Ble设备监听到这个设备之后响应一个Scan Response广播\n\n由于这两种方式都基于广播，所以它们的数据格式是一样的。广播会自带一些信息，例如设备的名称、MAC地址等。除了自带的数据之外，我们还能携带一些额外的信息数据。根据[官方](https://www.bluetooth.com/specifications/specs/core-specification/)的[文档](https://www.bluetooth.org/DocMan/handlers/DownloadDoc.ashx?doc_id=521059)，可以看到这个额外数据的具体格式如下:\n\n\n{% img /安卓BLE开发笔记一/1.png %}\n\n可以看到广播数据里面包含多个AD Structure。每个AD Structure分为两个部分:数据段长度(1字节)+数据段(N字节)。数据段又分为头1个字节的AD Type标识类型和剩余的AD Data具体数据。\n\n注意看最后的Non-significant part,有时候在安卓的回调里面会在byte数组的最后看到一堆的0x0，这个实际上也是定义在协议里面正常的无意义数据，我们直接忽略它们就好。\n\n举个实际的例子，在手机上使用ble搜索应用搜索我司开发的蓝牙设备，查看其广播数据:\n\n\n{% img /安卓BLE开发笔记一/2.png %}\n\n可以看到广播数据0x0319C703020104030312180C094D41584559455F353146300C16791300000002000000735C，实际有5个AD Structure。\n\nAD Type如上图所说可以去蓝牙协议的[官方](https://www.bluetooth.com/specifications/assigned-numbers/)查看[Generic Access Profile文档](https://btprodspecificationrefs.blob.core.windows.net/assigned-numbers/Assigned%20Number%20Types/Generic%20Access%20Profile.pdf)，可以看到这五个字段类型分别是:\n\n| Data Type Value | Data Type Name                                | Reference for Definition                                     |\n| --------------- | --------------------------------------------- | ------------------------------------------------------------ |\n| 0x19            | «Appearance»                                  | Bluetooth Core Specification:Core Specification Supplement, Part A, section 1.12 |\n| 0x01            | «Flags»                                       | Bluetooth Core Specification:Vol. 3, Part C, section 8.1.3 (v2.1 + EDR, 3.0 + HS and 4.0)Vol. 3, Part C, sections 11.1.3 and 18.1 (v4.0)Core Specification Supplement, Part A, section 1.3 |\n| 0x03            | «Complete List of 16-bit Service Class UUIDs» | Bluetooth Core Specification:Vol. 3, Part C, section 8.1.1 (v2.1 + EDR, 3.0 + HS and 4.0)Vol. 3, Part C, sections 11.1.1 and 18.2 (v4.0)Core Specification Supplement, Part A, section 1.1 |\n| 0x09            | «Complete Local Name»                         | Bluetooth Core Specification:Vol. 3, Part C, section 8.1.2 (v2.1 + EDR, 3.0 + HS and 4.0)Vol. 3, Part C, sections 11.1.2 and 18.4 (v4.0)Core Specification Supplement, Part A, section 1.2 |\n| 0x16            | «Service Data»                                | Bluetooth Core Specification:Vol. 3, Part C, sections 11.1.10 and 18.10 (v4.0) |\n\n根据这里找到的DataType我们又可以去[官方](https://www.bluetooth.com/specifications/specs/)的[Core Specification Supplement 10文档](https://www.bluetooth.com/specifications/specs/core-specification-supplement-10/)查看Value的具体格式。这里我就不展开了。\n\n# GATT协议结构\n\n虽然基于广播的机制我们已经能够实现手机与Ble设备的通信了，但是这种通信能实现的功能比较基础。所以Ble的协议还支持连接之后一对一的通信方式。\n\nBle的连接都基于 GATT (Generic Attribute Profile) 协议之上，GATT 是一个在蓝牙连接之上的发送和接收很短的数据段的通用规范。\n\nGATT的结构如下:\n\n\n{% img /安卓BLE开发笔记一/3.png %}\n\nBle设备里面会提供多个Service，这些Service会提供一些特定的功能。而每个Service里面有会有多个Characteristic，这些Characteristic里面的value实际就是功能具体的属性值。\n\n例如电池服务Battery Service里面就有一个Characteristic叫做Battery Level，手机可以读取这个Characteristic的value值来获取Ble设备当前的电量。\n\n我们来看看实际设备读取出来的数据:\n\n\n{% img /安卓BLE开发笔记一/4.png %}\n\n可以看到这里有Generic Access、Generic Attribute、Device Information三个Service。而Device Information Service下面又有四个Characteristic\n\n这些Service、Characteristic都会有一个UUID去做标识，例如Generic Access Service的UUID是0x1800。虽然我们这里看到的UUID都是16bit的，但是实际上它们的完整形式应该是0x0000xxxx-0000-1000-8000-00805F9B34FB。中间的xxxx就是截图中显示的16位uuid，即Generic Access Service的完整UUID是0x00001800-0000-1000-8000-00805F9B34FB。\n\nService的UUID映射表可以到[官方](https://www.bluetooth.com/specifications/assigned-numbers/)的[16-bit UUIDs文档](https://btprodspecificationrefs.blob.core.windows.net/assigned-values/16-bit%20UUID%20Numbers%20Document.pdf)查看。\n\n## Characteristic\n\n### Properties\n\n截图里面的Characteristic的Properties都是READ，代表这个Characteristic是可读取的。它实际上是描述了这个Characteristic可以如何使用。Properties在安卓ble的sdk里面靠一个int类型的变量表示，每一个二进制位都标识了一直能力。我们可以通过按位与的方式判断是否支持:\n\n| **Properties**         | **Value** | **Description**                                              |\n| ---------------------- | --------- | ------------------------------------------------------------ |\n| Broadcast              | 0x01      | 该Characteristic会被广播出来                                 |\n| Read                   | 0x02      | 该Characteristic可读                                         |\n| Write Without Response | 0x04      | 该Characteristic可写,写入完成后Ble设备不需要返回响应         |\n| Write                  | 0x08      | 该Characteristic可写,写入完成后Ble设备需要返回响应,可以监听到回调 |\n| Notify                 | 0x10      | 该Characteristic在改变的时候会发送通知,例如可以监听电量改变的消息去刷新ui |\n| Indicate               | 0x20      | 它和Notify类似，只不过主机(手机)在接收到通知的时候会返回一个响应给从机(Ble设备)，这样能够保证通知一定会被接收到 |\n| Authenticated          | 0x40      | 该Characteristic需要先配对绑定才能写入                       |\n| Extended               | 0x80      | 该Characteristic拥有 Extended Properties                     |\n\n上面的机制实际上我只验证了Read、Write、Notify。其他的我都是根据根据[官方](https://www.bluetooth.com/specifications/specs/core-specification/)的[文档](https://www.bluetooth.org/DocMan/handlers/DownloadDoc.ashx?doc_id=521059)的“Table 3.5: Characteristic Properties bit field”表格自己理解的，可能会有错误，大家可以参考官方文档去理解。\n\n\n### Descriptors\n\n除了Properties之外，Characteristic还有一个十分重要的数据段叫做Descriptors。一个Characteristic可能有0个或者多个Descriptor去描述它。\n\n例如当一个Characteristic是Notify或者Indicate的时候它会携带一个Client Characteristic Configuration Descriptor(uuid 0x2902)描述当前Characteristic是否打开通知功能。也就是说通知功能是可以通过修改Client Characteristic Configuration Descriptor主动打开或者关闭的，通过Descriptor携带数据的二进制位去标识功能的打开关闭:\n\n| **Configuration** | **Bit** **Number** | **Description**  |\n| ----------------- | ------------------ | ---------------- |\n| Notification      | 0                  | 打开Notify功能   |\n| Indication        | 1                  | 打开Indicate功能 |\n|                   | 其他二进制位       | 保留未来使用     |\n\nDescriptor的UUID映射表同样可以到[官方](https://www.bluetooth.com/specifications/assigned-numbers/)的[16-bit UUIDs文档](https://btprodspecificationrefs.blob.core.windows.net/assigned-values/16-bit%20UUID%20Numbers%20Document.pdf)查看。\n\n# MTU\n\nMTU指的是最大传输单元MAXIMUM TRANSMISSION UNIT,表示一次数据传输最多能传多大的数据，我们直接看它的官方说明:\n\n\n{% img /安卓BLE开发笔记一/5.jpeg %}\n\n可以看到我圈出来的地方,MTU最小需要支持23个字节，但是实际上这23三个字节也不是全部用来放数据，它的头三个字节需要携带操作类型和属性的16位uuid。所以只剩下23-3=20个字节用于传输数据:\n\n{% img /安卓BLE开发笔记一/6.png %}\n\n这里实际上有个坑，安卓默认MTU就是23也就是每次最多只能写入20字节的数据，所以最开始我写入一些比较大的数据的时候直接就失败了。需要先使用requestMtu将mtu设大。\n","tags":["技术相关","Android"]},{"title":"记一个主线程卡死却没有ANR的BUG","url":"/2021/09/01/记一个主线程卡死却没有ANR的BUG/","content":"\n今天测试报了个BUG，分析了一波顺利解决问题。但是感觉中间的一些思路、技巧和知识点比较有意思，所以记录下来。\n\n# 问题定位与分析\n\n首先这个问题是是个概率性问题，在压测整机复位功能的时候出现的。我负责的某个服务在开机的时候会自启动，测试发现某一次复位完成开机之后功能没有办法正常使用，立马叫我过去看。\n\n1. 首先我到的时候现场是还在的，由于这是个Service，ui上看不出异常。所以adb 连接上机器之后使用PS命令查看进程，发现服务的进程是存在的\n2. 其次查看log，没有发现任何的异常打印或者奔溃重启的痕迹\n3. 接着查找关键日志发现异常，这个服务在子线程做完一些初始化操作之后会同步回主线程打开功能:\n\n```java\nLog.d(TAG, \"child thread finish\");\nmHandler.sendEmptyMessage(MSG_START_FUNCTION);\n```\n\n子线程的打印找到了，而且它的下一行就是用Handler发送Message，但是主线程接的打印没有找到。\n\n由于这部分的代码十分简单，不存在什么bug，除非Handler机制出问题了。由于我们的机器还在研发阶段，系统哥调试的时候不小心改出什么奇怪的问题也是可能的，但是我们不能一上来就这么想，要不然把问题转给系统哥也会一脸懵逼无从入手。\n\n由于Handler的Message是逐个执行的，所以如果某个Message堵死了也会造成后面的Message没法处理。由于这次是主线程的Handler，如果我们的主线程卡死了也会出现这种问题。\n\n但是主线程卡死的话已经十几分钟过去了也没有出现ANR，/data/anr/下面也是空的。不过我们可以使用kill -3 \\<pid\\>命令强制输出trace文件，查看应用当前所有线程的调用栈。然后分析主线程现在是个啥情况:\n\n```\n\"main\" prio=5 tid=1 Waiting\n  | group=\"main\" sCount=1 dsCount=0 flags=1 obj=0x7137cc28 self=0xe3f82a10\n  | sysTid=1208 nice=0 cgrp=default sched=0/0 handle=0xf09e6470\n  | state=S schedstat=( 456814323 745320630 635 ) utm=40 stm=5 core=0 HZ=100\n  | stack=0xff1c8000-0xff1ca000 stackSize=8192KB\n  | held mutexes=\n  at java.lang.Object.wait(Native method)\n  - waiting on <0x017f64da> (a java.lang.Object)\n  at java.lang.Object.wait(Object.java:442)\n  at java.lang.Object.wait(Object.java:568)\n  at h.a.a.a.a.l.q.f(:4)\n  - locked <0x017f64da> (a java.lang.Object)\n  at h.a.a.a.a.l.q.e(:2)\n  at d.d.a.d.f.d.b(:3)\n  at d.d.a.d.f.a.run(lambda:-1)\n  at android.os.Handler.handleCallback(Handler.java:938)\n  at android.os.Handler.dispatchMessage(Handler.java:99)\n  at android.os.Looper.loop(Looper.java:223)\n  at android.app.ActivityThread.main(ActivityThread.java:7666)\n  at java.lang.reflect.Method.invoke(Native method)\n  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:592)\n  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:952)\n```\n\n很给力，立马就验证了问题，主线程果然卡死在Object.wait了。\n\n但是代码里面搜索了一圈并没有直接使用这个wait方法，倒是有个第三方库的类似的操作可能会用到它。由于之前一直没报过这种问题，应该是小概率实际所以我们必须给出实锤并且解决，要不然问题的回归比较难。\n\n代码被混淆了，虽然我们可以用mapping.txt文件来还原，但是由于这个项目的配套还不成熟，版本号机制都还没有加上去，所以找到对应的版本和mapping.txt文件比较困难。\n\n于是我选择将apk从机器里面adb pull扣出来用[jadx](https://github.com/skylot/jadx)反编译找到h.a.a.a.a.l.q.f这个方法看看:\n\n{% img /一个主线程卡死却没有ANR的BUG/1.png %}\n\n可以看到一些字符串和大概的代码逻辑。和之前猜测的第三方库做对比，发现的确我们的猜测是正确的，然后一步步对应整理回整个堆栈。发现的确是第三方库的某个方法wait一直阻塞住了主线程。这应该是第三方库的bug，幸好它有个重载方法可以传入超时时间，所以我们添加了个3秒的超时时间，超时之后重试去解决问题。另外在主线程等待也不是个好的习惯，我们可以将它挪到子线程中。\n\n# ANR原理\n\n虽然问题解决了，但是其实还有些知识点比较有意思值得去深究。我们都知道不能在主线程不能做耗时操作，要不然会ANR。但是这个问题主线程都阻塞十几分钟了，就算我们的是Service也应该最多200s后(后台服务)就会ANR，为啥就是没有ANR呢？\n\n我恢复堆栈之后发现，这个wait的阻塞是在Application.onCreate的时候调用的，也就是说Application.onCreate的卡顿并不会导致ANR。\n\n我们来回顾下ANR的4种类型:\n\n**1. KeyDispatchTimeout** : input事件在5S内没有处理完成发生ANR\n\n**2. ServiceTimeout** : bind,create,start,unbind等操作,前台Service在20s内,后台Service在200s内没有处理完成发生ANR\n\n**3. BroadcastTimeout** : BroadcastReceiver onReceiver处理事务时前台广播在10S内,后台广播在60s内. 没有处理完成发生ANR\n\n**4. ProcessContentProviderPublishTimedOutLocked** : ContentProvider publish在10s内没有处理完成发 生ANR\n\n的确上面Service、Broadcast、ContentProvider的ANR原因都是对应组件的生命周期回调超时，他们ANR的计算并没有包括Application.onCreate因为这个回调是进程的初始化，并不在四大组件中。\n\n另外一个知识点是并没有Activity生命周期的ANR，也就是说我们在Activity的onCreate、onStart这些生命周期中阻塞并不会造成ANR。\n\nActivity的ANR都是input事件例如按键和触摸消息处理耗时导致的。\n\n## 定时炸弹机制\n\nServiceTimeout、BroadcastTimeout、ProcessContentProviderPublishTimedOutLocked的原理都是类似的\n\n1. 在处理前使用Handler.sendMessageDelayed发送一个ANR消息\n2. 在处理完成之后使用Handler.removeMessages删除ANR消息\n\n这里可以类比成一个定时炸弹，在处理前埋下定时炸弹，只要没有再规定的时间内完成处理并且拆除炸弹，就会爆炸。\n\n我们这里只举一个Service的例子。在AMS里面调用Service.onCreate之前会sendMessageDelayed一个SERVICE\\_TIMEOUT\\_MSG的Message:\n\n```java\n// AMS start service核心代码\nprivate final void realStartServiceLocked(ServiceRecord r, ProcessRecord app, boolean execInFg) throws RemoteException {\n    ...\n    // 在bumpServiceExecutingLocked里面会发送SERVICE_TIMEOUT_MSG\n    bumpServiceExecutingLocked(r, execInFg, \"create\");\n    ...\n    // 异步调用Service.onCreate\n    app.thread.scheduleCreateService(r, r.serviceInfo,\n                    mAm.compatibilityInfoForPackage(r.serviceInfo.applicationInfo),\n                    app.getReportedProcState());\n    ...\n}\n\n// 下面的代码追踪bumpServiceExecutingLocked是如何发生SERVICE_TIMEOUT_MSG的\nprivate final void bumpServiceExecutingLocked(ServiceRecord r, boolean fg, String why) {\n    ...\n    scheduleServiceTimeoutLocked(r.app);\n    ...\n}\n\nprivate final void bumpServiceExecutingLocked(ServiceRecord r, boolean fg, String why) {\n    ...\n    scheduleServiceTimeoutLocked(r.app);\n    ...\n}\n\nvoid scheduleServiceTimeoutLocked(ProcessRecord proc) {\n    if (proc.executingServices.size() == 0 || proc.thread == null) {\n        return;\n    }\n    Message msg = mAm.mHandler.obtainMessage(\n            ActivityManagerService.SERVICE_TIMEOUT_MSG);\n    msg.obj = proc;\n    mAm.mHandler.sendMessageDelayed(msg,\n            proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);\n}\n```\n\n而在ActivityThread里面Service.onCreate调用完成之后会通知AMS:\n\n```java\nprivate void handleCreateService(CreateServiceData data) {\n    ...\n    // 创建service\n    service = packageInfo.getAppFactory().instantiateService(cl, data.info.name, data.intent);\n    // 调用onCreate生命周期\n    service.onCreate();\n    ...\n    // 告诉AMS,Service.onCreate已经调用完成\n    ActivityManager.getService().serviceDoneExecuting(\n                        data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);\n  ...\n}\n```\n\nAMS就会再serviceDoneExecutingLocked里面拆炸弹:\n\n```java\nprivate void serviceDoneExecutingLocked(ServiceRecord r, boolean inDestroying, boolean finishing) {\n    ...\n    // 删除SERVICE_TIMEOUT_MSG\n    mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);\n    ...\n}\n```\n\n这种机制打个比方就是歹徒(AMS)在你家装了个定时炸弹，然后威胁你去干一件事，你必须在规定时间内完成然后告诉他停止计时，要不然就会把你家炸上天(ANR)\n\n## KeyDispatchTimeout原理\n\nActivity的ANR并不是通过上面所说的埋定时炸弹的方式实现的，它有另外一套逻辑。\n\n前面我们也有说Activity的生命周期是不会触发ANR的，它的ANR实际上是在处理input事件的时候产生的。例如在按键消息或者触摸消息处理里面耗时太久。\n\ninput事件的底层分发逻辑以前写过[两篇博客](https://blog.islinjw.cn/2020/01/23/Android-Input%E7%B3%BB%E7%BB%9F-%E4%B8%80-%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%8E%B7%E5%8F%96%E6%B5%81%E7%A8%8B/)感兴趣的同学可以详细了解下。我们这篇来补充上input事件分发的ANR检测原理。\n\n相关代码在native层的InputDispatcher.cpp里面，每个input事件都会唤醒Dispatcher线程进行分发处理，我们以按键消息为例:\n\n```cpp\nvoid InputDispatcher::dispatchOnce() {\n    ...\n    dispatchOnceInnerLocked(&nextWakeupTime);\n    ...\n}\n\nvoid InputDispatcher::dispatchOnceInnerLocked(nsecs_t* nextWakeupTime) {\n    ...\n    // Ready to start a new event.\n  // If we don't already have a pending event, go grab one.\n    if (! mPendingEvent) {\n        ...\n        resetANRTimeoutsLocked();\n    }\n    ...\n\n    switch (mPendingEvent->type) {\n        ...\n        case EventEntry::TYPE_KEY: {\n            ...\n            done = dispatchKeyLocked(currentTime, typedEntry, &dropReason, nextWakeupTime);\n            ...\n        }\n        ...\n    }\n    ...\n}\n```\n\n假设我们的应用接收到了它的第一个input事件KEY\\_DOWN。可以看到dispatchOnceInnerLocked里面判断如果是一个新的事件，就调用resetANRTimeoutsLocked清除ANR的标记，然后使用dispatchKeyLocked进行分发。\n\nresetANRTimeoutsLocked里面最重要的一步是将mInputTargetWaitCause设置成INPUT\\_TARGET\\_WAIT\\_CAUSE\\_NONE:\n\n```cpp\nvoid InputDispatcher::resetANRTimeoutsLocked() {\n    ...\n    mInputTargetWaitCause = INPUT_TARGET_WAIT_CAUSE_NONE;\n    ...\n}\n```\n\ndispatchKeyLocked里面回去获取当前的焦点windows分发按键消息:\n\n```cpp\nbool InputDispatcher::dispatchKeyLocked(nsecs_t currentTime, KeyEntry* entry,\n        DropReason* dropReason, nsecs_t* nextWakeupTime) {\n    ...\n    int32_t injectionResult = findFocusedWindowTargetsLocked(currentTime,\n            entry, inputTargets, nextWakeupTime);\n    ...\n}\n\nint32_t InputDispatcher::findFocusedWindowTargetsLocked(nsecs_t currentTime,\n        const EventEntry* entry, Vector<InputTarget>& inputTargets, nsecs_t* nextWakeupTime) {\n    ...\n    reason = checkWindowReadyForMoreInputLocked(currentTime,\n            mFocusedWindowHandle, entry, \"focused\");\n    if (!reason.isEmpty()) {\n        injectionResult = handleTargetsNotReadyLocked(currentTime, entry,\n                mFocusedApplicationHandle, mFocusedWindowHandle, nextWakeupTime, reason.string());\n        ...\n    }\n    ...\n}\n```\n\n由于是一个新的事件，所以windows没有正在处理的消息。checkWindowReadyForMoreInputLocked拿到的reson是empty的，不会进入handleTargetsNotReadyLocked，而是正常向这个window分发。\n\n如果应用处理KEY\\_DOWN卡死了，那么在用户抬起手指触发KEY\\_UP事件的时候mPendingEvent则不为NULL，__不会__清除ANR标记，而且checkWindowReadyForMoreInputLocked返回的reason不是empty，就会进入handleTargetsNotReadyLocked方法:\n\n```cpp\nint32_t InputDispatcher::handleTargetsNotReadyLocked(nsecs_t currentTime,\n        const EventEntry* entry,\n        const sp<InputApplicationHandle>& applicationHandle,\n        const sp<InputWindowHandle>& windowHandle,\n        nsecs_t* nextWakeupTime, const char* reason) {\n    ...\n    if (mInputTargetWaitCause != INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY) {\n        ...\n        mInputTargetWaitCause = INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY;\n        ...\n        mInputTargetWaitTimeoutTime = currentTime + timeout;\n        ...\n    }\n    ...\n    if (currentTime >= mInputTargetWaitTimeoutTime) {\n        onANRLocked(currentTime, applicationHandle, windowHandle,\n                entry->eventTime, mInputTargetWaitStartTime, reason);\n        ...\n    } else {\n        *nextWakeupTime = mInputTargetWaitTimeoutTime;\n        ...\n    }\n }\n```\n\n我们看到这个方法里面判断mInputTargetWaitCause不是INPUT\\_TARGET\\_WAIT\\_CAUSE\\_APPLICATION\\_NOT\\_READY（因为KEY\\_DOWN已经在resetANRTimeoutsLocked里面将它设置成INPUT\\_TARGET\\_WAIT\\_CAUSE\\_NONE了），所以会进入if里面设置mInputTargetWaitTimeoutTime和mInputTargetWaitCause。\n\n后面的\"currentTime >= mInputTargetWaitTimeoutTime\"判断因为是刚设置的mInputTargetWaitTimeoutTime所以不会进入，而是会去到else里面设置nextWakeupTime，然后线程会睡眠。也就是说这个KEY\\_UP时间会被延迟timeout时间再执行。\n\n等时间到了线程被唤醒的时候mInputTargetWaitCause，已经是INPUT\\_TARGET\\_WAIT\\_CAUSE\\_APPLICATION\\_NOT\\_READY了，所以不会被修改，然后\"currentTime >= mInputTargetWaitTimeoutTime\"判断会成功进入onANRLocked触发应用的ANR。\n\n简单来讲就是KEY\\_UP事件到来的时候发现之前上个事件还没有处理完，于是延迟5s再来看看，如果这个时候上个事件依然没有处理完，则触发ANR。\n\n这种机制有个特点就是假设你在KEY\\_UP里面卡死了，但是界面是没有任何动画，也不去触发input事件。那么虽然主线程卡死了，但是无论过多久都不会报ANR。如果这个时候你再去触发input事件(例如触摸或者按键)，就会发现过多5秒就出现ANR了。\n\n同样打个比方这种机制就像一个暴躁的恐怖分子(Input事件)去找神父(FocusWindow)忏悔,如果发现神父已经在接客了,就会过一会再来看看,如果到时候神父还是没空,就会引爆炸弹一了百了(ANR)。\n\n# 感想\n\n随着年纪的增长，脑子就像个长时间运行的硬盘，塞满了各种有用的没用的东西。加载速度和检索的命中率越来越低。就像是以前明明有去专门看过ANR的原理，但是看到这个问题我的第一反应也是主线程不可能卡死要不然就ANR了。所以除了各种死记硬背的八股文知识，我认为更应该重视调试技巧和解决问题能力，这才是老年程序员的核心竞争力。\n\n\n","tags":["技术相关","Android"]},{"title":"源码阅读计划 - EventBus","url":"/2021/08/12/源码阅读计划-EventBus/","content":"EventBus的api很简单:\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        findViewById(R.id.btn).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                EventBus.getDefault().post(new MyEvent(123));\n            }\n        });\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        EventBus.getDefault().register(this);\n    }\n\n    @Override\n    protected void onPause() {\n        super.onPause();\n        EventBus.getDefault().unregister(this);\n    }\n\n    @Subscribe(threadMode = ThreadMode.MAIN)\n    public void onMyEvent(MyEvent event) {\n        Log.d(\"testtest\", \"onMyEvent \" + event.data);\n    }\n}\n\nclass MyEvent {\n    public int data;\n\n    MyEvent(int data) {\n        this.data = data;\n    }\n}\n```\n\n# 注册监听的原理\n\n坦白讲内部的实现原理也挺简单的，我们从注册开始看:\n\n```java\npublic void register(Object subscriber) {\n    Class<?> subscriberClass = subscriber.getClass();\n    // 从subscriber的class从查找回调方法\n    List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);\n    synchronized (this) {\n        for (SubscriberMethod subscriberMethod : subscriberMethods) {\n            // SubscriberMethod里面是方法的反射，所以需要绑定回调方法和观察者对象\n            subscribe(subscriber, subscriberMethod);\n        }\n    }\n}\n\nprivate void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {\n    Class<?> eventType = subscriberMethod.eventType;\n    Subscription newSubscription = new Subscription(subscriber, subscriberMethod);\n    // 使用Event的class做key，查找这个Event的所有观察者\n    CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);\n    ...\n    // 按照优先级插入观察者\n    int size = subscriptions.size();\n    for (int i = 0; i <= size; i++) {\n        if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {\n            subscriptions.add(i, newSubscription);\n            break;\n        }\n    }\n    ...\n}\n```\n\n使用Finder从对象的Class中查找注册的回调方法的信息，使用Subscription将调用者与方法信息绑定起来，然后使用Event的Class作为key将它放到subscriptionsByEventType这个map中。由于同一种Event可能会有多个观察者，所以map的value是一个按优先级排序的List。\n\nSubscriberMethod和Subscription的定义如下:\n\n```java\npublic class SubscriberMethod {\n    final Method method;         // 回调方法\n    final ThreadMode threadMode; // 回调的线程策略\n    final Class<?> eventType;    // 监听的事件类型\n    final int priority;          // 优先级\n    final boolean sticky;        // 是否监听粘性事件\n    ...\n}\n\nfinal class Subscription {\n    final Object subscriber; //观察者的对象引用，可以用来反射调用subscriberMethod.method\n    final SubscriberMethod subscriberMethod;\n    ...\n}\n```\n\n从上面可以大概猜出来，事件的分发实际是反射调用的方法。\n\n也就是说当我们使用post方法发送Event的时候就能用Event的Class查找到所有的Subscription，通过Subscription的subscriber找到注册的对象、subscriberMethod找到注册的方法，接着就能使用反射去进行分发。\n\n整个注册的流程大体上是比较清晰的，但是findSubscriberMethods的查找注册信息流程中有些小的细节也比较值得学习。\n\n## 1.缓存\n\n第一点是扫描完一个class之后会将监听的信息放入METHOD\\_CACHE缓存中，例如我们的demo，onResume的时候register，onPause的时候unregister，就能减少第二次onResume的耗时。\n\n```java\nList<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {\n    // METHOD_CACHE会保存查找过的subscriberClass的监听信息，防止重复查找耗时\n    List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);\n    if (subscriberMethods != null) {\n        return subscriberMethods;\n    }\n    ...\n    subscriberMethods = findUsingInfo(subscriberClass);\n    ...\n    // 加入缓存，下次可以直接使用\n    METHOD_CACHE.put(subscriberClass, subscriberMethods);\n    return subscriberMethods;\n    ...\n}\n```\n\n## 2.APT生成索引\n\n第二点就是由于反射遍历类方法去查找被@Subscribe修饰的方法比较耗时，所以可以使用apt编译时根据注解生成代码的方式直接生成索引:\n\n```java\nprivate List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {\n        FindState findState = prepareFindState();\n        findState.initForSubscriber(subscriberClass);\n        while (findState.clazz != null) {\n            // 优先从apt生成的索引查找，如果找不到就是用反射去遍历class，查找@Subscribe修饰的方法\n            findState.subscriberInfo = getSubscriberInfo(findState);\n            if (findState.subscriberInfo != null) {\n                ...\n            } else {\n                // 使用反射查找\n                findUsingReflectionInSingleClass(findState);\n            }\n            findState.moveToSuperclass();\n        }\n        return getMethodsAndRelease(findState);\n    }\n```\n\napt创建索引的使用方法见[官方文档](https://greenrobot.org/eventbus/documentation/subscriber-index/)\n\n## 3.对象池减少内存碎片\n\n第三就是FindState是一个辅助查找的工具类，为了避免应用初始化的时候多个类都在注册到EventBus，导致这个FindState创建消耗多次，产生内存碎片，所以它使用类对象池技术:\n\n```java\n// 获取\nprivate FindState prepareFindState() {\n    synchronized (FIND_STATE_POOL) {\n        for (int i = 0; i < POOL_SIZE; i++) {\n            FindState state = FIND_STATE_POOL[i];\n            if (state != null) {\n                FIND_STATE_POOL[i] = null;\n                return state;\n            }\n        }\n    }\n    return new FindState();\n}\n\n// 回收\nprivate List<SubscriberMethod> getMethodsAndRelease(FindState findState) {\n    List<SubscriberMethod> subscriberMethods = new ArrayList<>(findState.subscriberMethods);\n    findState.recycle();\n    synchronized (FIND_STATE_POOL) {\n        for (int i = 0; i < POOL_SIZE; i++) {\n            if (FIND_STATE_POOL[i] == null) {\n                FIND_STATE_POOL[i] = findState;\n                break;\n            }\n        }\n    }\n    return subscriberMethods;\n}\n```\n\n# 消息分发原理\n\n上面我们看完了注册，实际上分发的流程大概也能猜出来了。不过这里面还是有蛮多小细节同样值得学习的。\n\n## 1.Event Queue\n\nEventBus的Event分发并不是直接循环遍历观察者进行分发，而是先将Event放到队列中，然后再去队列里面拿出来分发。\n\nPostingThreadState使用了ThreadLocal，每条线程都有自己的Event队列，而且isPosting能够记录当前的线程是否正在分发Event。\n\n也就是说如果在Event的回调中再去post一个Event，并不会立刻分发，而是会等之前的Event都分发完之后在去分发。\n\n```java\npublic void post(Object event) {\n    PostingThreadState postingState = currentPostingThreadState.get();\n    List<Object> eventQueue = postingState.eventQueue;\n    //将Event丢到队列中\n    eventQueue.add(event);\n\n    if (!postingState.isPosting) { // 是否正在分发,例如在监听的回调中post,isPosting就是true\n        postingState.isMainThread = isMainThread();\n        postingState.isPosting = true;\n        if (postingState.canceled) {\n            throw new EventBusException(\"Internal error. Abort state was not reset\");\n        }\n        try {\n            // 从队列中拿出Event进行分发，直至队列为空\n            while (!eventQueue.isEmpty()) {\n                postSingleEvent(eventQueue.remove(0), postingState);\n            }\n        } finally {\n            postingState.isPosting = false;\n            postingState.isMainThread = false;\n        }\n    }\n}\n```\n\n__这里有个小坑:threadMode是POSTING，只能代表回调是在post的线程调用的，并不能代表post方法里面会立即调用__\n\n## 2.eventInheritance\n\n当一个观察者监听的是父类，如果post了一个子类的Event，默认情况下观察者是可以接收到这个子类的Event。这是因为默认情况下EventBusBuilder.eventInheritance为true:\n\n```java\nboolean eventInheritance = true;\n```\n\n如果不想要这个功能我们可以设置成false。它的原理在postSingleEvent里面可以看到:\n\n```java\nprivate void postSingleEvent(Object event, PostingThreadState postingState) throws Error {\n    Class<?> eventClass = event.getClass();\n    boolean subscriptionFound = false;\n    if (eventInheritance) {\n        // 如果eventInheritance为true，查找eventClass的父类、实现的interface等去分发\n        List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);\n        int countTypes = eventTypes.size();\n        for (int h = 0; h < countTypes; h++) {\n            Class<?> clazz = eventTypes.get(h);\n            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);\n        }\n    } else {\n        // eventInheritance为false则只分发这个eventClass\n        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);\n    }\n    ...\n}\n```\n\npostSingleEventForEventType方法就是根据Class查找register的对应Subscription，调用postToSubscription进行实际的分发操作\n\n```java\nprivate boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {\n    CopyOnWriteArrayList<Subscription> subscriptions;\n    synchronized (this) {\n        subscriptions = subscriptionsByEventType.get(eventClass);\n    }\n    if (subscriptions != null && !subscriptions.isEmpty()) {\n        for (Subscription subscription : subscriptions) {\n            ...\n            postToSubscription(subscription, event, postingState.isMainThread);\n            ...\n        }\n        return true;\n    }\n    return false;\n}\n```\n\n## 3.threadMode原理\n\npostToSubscription内部就会根据不同的threadMode在不同线程使用反射调用注册的方法:\n\n```java\nprivate void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {\n    switch (subscription.subscriberMethod.threadMode) {\n        case POSTING:\n            ..\n            break;\n        case MAIN:\n            ...\n            break;\n        case MAIN_ORDERED:\n            ...\n            break;\n        case BACKGROUND:\n            ...\n            break;\n        case ASYNC:\n            ...\n            break;\n        default:\n            ...\n    }\n}\n```\n\n","tags":["技术相关","Android"]},{"title":"Flutter三棵树创建原理","url":"/2021/07/13/Flutter三棵树创建原理/","content":"\nflutter的渲染机制基本就是靠Widget、Element、RenderObject三棵树去实现的，这篇博客就来讲讲这三棵树是怎么创建的。\n\n首先我们来看看这三者到底是个啥:\n\n- Widget: 描述一个UI元素的配置数据，不可变，修改信息需要重新new\n\n- Element: 通过Widget配置实例化出来的对象,它是可变的\n- RenderObject: 真正的渲染对象\n\n让我们用一个简单的demo来做讲解:\n\n```dart\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Demo',\n      home: HelloWorldPage(),\n    );\n  }\n}\n\nclass HelloWorldPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Text(\"Hello World\", style: TextStyle(color: Colors.blue)),\n    );\n  }\n}\n```\n\n上面的代码正在屏幕的中间显示了一个Hello World字符串。\n\n{% img /Flutter三棵树创建原理/1.png %}\n\n# runApp\n\n在main函数里面只有一行runApp调用，追踪下去我们可以看到它主要做了三件事情:\n\n```dart\nvoid runApp(Widget app) {\n  WidgetsFlutterBinding.ensureInitialized()\n    ..scheduleAttachRootWidget(app)\n    ..scheduleWarmUpFrame();\n}\n\nvoid scheduleAttachRootWidget(Widget rootWidget) {\n    Timer.run(() {\n      attachRootWidget(rootWidget);\n    });\n}\n  \nvoid attachRootWidget(Widget rootWidget) {\n    ...\n    _renderViewElement = RenderObjectToWidgetAdapter<RenderBox>(\n      container: renderView,\n      debugShortDescription: '[root]',\n      child: rootWidget,\n    ).attachToRenderTree(buildOwner!, renderViewElement as RenderObjectToWidgetElement<RenderBox>?);\n    ...\n}\n\nRenderObjectToWidgetElement<T> attachToRenderTree(BuildOwner owner, [ RenderObjectToWidgetElement<T>? element ]) {\n    ...\n    element = createElement();\n    ...\n    element!.mount(null, null);\n    ...\n  return element!;\n}\n```\n\n1. 创建RenderObjectToWidgetAdapter作为Widget树的根，将传入的Widget挂上去\n2. 调用RenderObjectToWidgetAdapter.createElement创建Element\n3. 调用Element.mount将它挂到Element树上，Element树的根节点的parent为null\n\n# Element.mount\n\nElement的mount方法是三棵树创建流程的关键步骤，不同类型的Element mount的流程不太一样。\n\n## 1.RenderObjectElement会创建RenderObject\n\n如果Element是RenderObjectElement类型的，那么它对应的Widget一定是RenderObjectWidget类型的，这是它的构造函数决定的:\n\n```dart\nabstract class RenderObjectElement extends Element {\n  RenderObjectElement(RenderObjectWidget widget) : super(widget);\n  ...\n}\n```\n\n它在mount的时候会调用RenderObjectWidget.createRenderObject创建RenderObject然后将它挂到RenderObject树上:\n\n```dart\nRenderObject get renderObject => _renderObject!;\n\nRenderObject? _renderObject;\n\nvoid mount(Element? parent, Object? newSlot) {\n    ...\n    _renderObject = widget.createRenderObject(this);\n    ...\n    attachRenderObject(newSlot);\n    ...\n}\n\n\nvoid attachRenderObject(Object? newSlot) {\n    ...\n    // 插入RenderObject树\n    _ancestorRenderObjectElement = _findAncestorRenderObjectElement();\n    _ancestorRenderObjectElement?.insertRenderObjectChild(renderObject, newSlot);\n    ...\n}\n```\n\n这个_findAncestorRenderObjectElement方法比较魔性，找的是祖先RenderObjectElement，其实就是往parent一层层查找，直到找的RenderObjectElement:\n\n```dart\nRenderObjectElement? _findAncestorRenderObjectElement() {\n    Element? ancestor = _parent;\n    while (ancestor != null && ancestor is! RenderObjectElement)\n      ancestor = ancestor._parent;\n    return ancestor as RenderObjectElement?;\n}\n```\n\ninsertRenderObjectChild方法将创建的RenderObject插入成为祖先RenderObjectElement的RenderObject的子节点，这样就把创建的RenderObject挂到了RenderObject树上。\n\n## 2.创建子Element并mount到Element树\n\n处理完本节点的RenderObject之后，就会创建子Element将它的parent设置成自己，mount到Element树上。\n\nElement都是通过Widget.createElement创建的，而Element会保存创建它的Widget。所以可以通过这个Widget去获取子Widget，然后用子Widget去创建子Element。\n\n子Widget的获取有两种方式，如果是在Widget的构造函数传入的，那么直接可以拿到它，例如上面的RenderObjectToWidgetAdapter，然后用它去createElement创建子Element:\n\n```dart\n// 子widget是child参数传进去的\nRenderObjectToWidgetAdapter<RenderBox>(\n      container: renderView,\n      debugShortDescription: '[root]',\n      child: rootWidget,\n)\n\n\nvoid mount(Element? parent, Object? newSlot) {\n    ...\n    _rebuild();\n    ...\n}\n\nvoid _rebuild() {\n    ...\n    // widget.child拿到构造函数传进去的子widget，即rootWidget\n    _child = updateChild(_child, widget.child, _rootChildSlot);\n    ...\n}\n\nElement? updateChild(Element? child, Widget? newWidget, Object? newSlot) {\n    ...\n    newChild = inflateWidget(newWidget, newSlot);\n    ...\n}\n\nElement inflateWidget(Widget newWidget, Object? newSlot) {\n    ...\n  // 创建子Element\n    final Element newChild = newWidget.createElement();\n    ...\n  // 调用子Element的mount方法将它挂到Element树上，parent是第一个参数this\n  newChild.mount(this, newSlot);\n  ...\n    return newChild;\n}\n```\n\n像StatelessWidget这种子widget是build出来的，则在mount的时候会调用它的build方法创建子widget，然后用它去createElement创建子Element:\n\n```dart\nvoid mount(Element? parent, Object? newSlot) {\n    ...\n    _firstBuild();\n    ...\n}\n\nvoid _firstBuild() {\n    rebuild();\n}\n\nvoid rebuild() {\n    ...\n    performRebuild();\n    ...\n}\n\nvoid performRebuild() {\n    ...\n    built = build();\n    //updateChild在上面也有追踪这里就不列出来了，内部调用了built.createElement创建子Element并返回\n    _child = updateChild(_child, built, slot);\n    ...\n}\n\nWidget build() => widget.build(this);\n```\n\n最终得到的三棵树大概长下面的样子，由于没有分成所以看上去是链表而不是树，但是这不影响我们理解，一旦某些节点有多个child节点就是输了:\n\n{% img /Flutter三棵树创建原理/2.png %}\n\nElement通过widget成员持有Widget，如果是RenderObjectElement还通过renderObject成员持有RenderObject，可以看出来Element是连接Widget和RenderObject的桥梁。三个树的构建也都是通过递归mount Element去实现的。\n\n当RenderObject树创建出来之后，Flutter的引擎就能遍历它去执行绘制将画面渲染出来了。\n\n# mount流程解析\n\n从上面的代码可以看得出来，mount是一个递归的过程，总结下来有下面几个步骤\n\n1. Element如果是RenderObjectElement则创建RenderObject，并从祖先找到上一个RenderObjectElement，然后调用祖先RenderObjectElement的RenderObject的insertRenderObjectChild方法插入创建的RenderObject\n2. 如果子widget需要build出来就调用build方法创建子widget，如果不需要直接在成员变量可以拿到子widget\n3. 调用子widget的createElement创建子Element\n4. 调用子Element的mount方法将子Element的parent设置成自己，然后子Element去到第1步\n\n下面的动图展示了整个流程:\n\n{% img /Flutter三棵树创建原理/3.gif %}\n\n或者可以下载[PPT](https://github.com/bluesky466/bluesky466.github.io/blob/develop/source/Flutter%E4%B8%89%E6%A3%B5%E6%A0%91%E5%88%9B%E5%BB%BA%E5%8E%9F%E7%90%86/Flutter%E4%B8%89%E6%A3%B5%E6%A0%91%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B.pptx)查看","tags":["技术相关","Flutter"]},{"title":"Gradle构建原理","url":"/2021/06/22/Gradle构建原理/","content":"\n\n# Gradle的构建的三个阶段\n\n根据Gradle的[官方文档](https://docs.gradle.org/current/userguide/build_lifecycle.html),Gradle的构建分成三个阶段:\n\n- **Initialization** (初始化)\n\nGradle允许multi-project，也就是android studio里面的项目+模块的形式。安卓项目被称为Root Project，而每个模块其实都是一个子project。Root Project肯定是要参与编译的，但Gradle是怎么知道哪些子Project需要参与编译呢?其实它就是在Initialization阶段执行settings.gradle脚本得到的，这个脚本会将子Project给include进来。\n\n- **Configuration** (配置)\n\n每个Project都与一个build.gradle文件一一对应，build.gradle可以说就是Project的配置脚本。在配置阶段Gradle会执行所有参与编译的Project的build.gradle脚本，这个脚本对Project进行配置并创建一系列Task，这些Task之间会有依赖关系，构成一个有向无环图。\n\n- **Execution** (执行)\n\n执行阶段我们可以选择一个或者多个Task去执行。被执行到的Task可能会依赖其他的Task，Gradle保证这些Task按照依赖关系的顺序执行，并且每个任务只执行一次。\n\n我们可以通过添加打印查看settings.gradle和build.gradle被执行的时机:\n\n```groovy\n//settings.gradle\ninclude ':app'\nrootProject.name='My Application'\n\nprintln(\"---> settings.gradle\")\n```\n\n```groovy\n// 根目录的build.gradle\nprintln(\"---> build.gradle for Root Project\")\n\nbuildscript {\n    repositories {\n        google()\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:3.5.1'\n    }\n}\n...\n```\n\n```groovy\n// app下的build.gradle\nprintln(\"---> build.gradle for app Project\")\n\napply plugin: 'com.android.application'\n\nandroid {\n    ...\n}\n...\n```\n\n然后执行.gradlew build查看打印:\n\n```shell\n./gradlew build\n---> settings.gradle\n\n> Configure project :\n---> build.gradle for Root Project\n\n> Configure project :app\n---> build.gradle for app Project\n\n> Task :app:lint\n...\n```\n\n# Project的配置\n\n上面我们讲到每个Project都与一个build.gradle文件一一对应，每个Project都有一个Project实例，而build.gradle实际上调用的是这个实例的方法。这个实例名字是project，可以被省略，也就是说build.gradle的完整形态应该是这样的:\n\n```groovy\nproject.apply([plugin: 'com.android.application'])\n\nproject.android({\n    compileSdkVersion 30\n    buildToolsVersion \"30.0.2\"\n    defaultConfig {\n        ...\n    }\n    buildTypes {\n        ...\n    }\n})\n\nproject.dependencies({\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation 'androidx.appcompat:appcompat:1.3.0'\n    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.2'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'\n})\n```\n\n所以build.gradle配置Project的本质其实就是对project对象调用了一系列的方法。\n\n# Task\n\nTask表示构建的单个原子工作，例如编译类或生成javadoc，Project本质上是Task对象的集合。\n\n我们可以通过Project的task方法创建一个Task:\n\n```groovy\n// app build.gradle\ndef ADemoTask = project.task(\"ADemoTask\")\n```\n\n这样创建的Task默认分组是other:\n\n{% img /Gradle构建原理/1.jpeg %}\n\n我们可以在创建的时候给它指定分组:\n\n```groovy\ndef ADemoTask = project.task(\"ADemoTask\", group: \"build\")\n```\n\n{% img /Gradle构建原理/2.jpeg %}\n\nTask是由一个Action列表组成的，Action实际上是一个*闭包函数*。我们可以用doFirst往列表头插入Action，也能用doLast往列表尾插入Action:\n\n```groovy\ndef ADemoTask = project.task(\"ADemoTask\", group: \"build\")\nADemoTask.doFirst({ println(\"1\") })\nADemoTask.doFirst({ println(\"2\") })\nADemoTask.doLast({ println(\"3\") })\nADemoTask.doLast({ println(\"4\") })\n//基于groovy语法我们也可以省略圆括号，写成下面的样子:\n//ADemoTask.doFirst {println(\"1\")}\n//ADemoTask.doFirst {println(\"2\")}\n//ADemoTask.doLast {println(\"3\")}\n//ADemoTask.doLast {println(\"4\")}\n```\n\n执行这个Task，最终得到的打印是这样的:\n\n```\n> Task :app:ADemoTask\n2\n1\n3\n4\n```\n\n## Task DSL定义原理\n\n由于task方法支持直接传入一个闭包函数进行配置，所以我们可以写成下面的方式:\n\n````groovy\nproject.task(\"ADemoTask\",\n        {\n            //下面的方法调用都省略了圆括号\n            it.doFirst{ println(\"1\") }\n            it.doFirst{ println(\"2\") }\n            it.doLast{ println(\"3\") }\n            it.doLast{ println(\"4\") }\n        }\n)\n````\n\n也就是说在Configuration阶段，build.gradle脚本会调用project.task方法，将Task的配置以闭包函数的形式传入，task方法内部会去执行这个闭包。\n\n基于groovy语法，我们可以将这个闭包移出圆括号:\n\n```groovy\nproject.task(\"ADemoTask\") {\n    it.doFirst{ println(\"1\") }\n    it.doFirst{ println(\"2\") }\n    it.doLast{ println(\"3\") }\n    it.doLast{ println(\"4\") }\n}\n```\n\n为了更加的简洁,我们可以省略project和it对象，然后把task方法函数调用的圆括号也省略:\n\n```groovy\ntask \"ADemoTask\" {\n    doFirst{ println(\"1\") }\n    doFirst{ println(\"2\") }\n    doLast{ println(\"3\") }\n    doLast{ println(\"4\") }\n}\n```\n\nGradle在处理build.gradle的时候会有一个转换，将task identifier arg转换成task \"identifier\" arg(下面的是Gladle的源码从[知乎](https://zhuanlan.zhihu.com/p/365577252)上看到的):\n\n```java\nif (args.getExpression(0) instanceof MapExpression && args.getExpression(1) instanceof VariableExpression) {\n    // Matches: task <name-value-pairs>, <identifier>, <arg>?\n    // Map to: task(<name-value-pairs>, '<identifier>', <arg>?)\n    transformVariableExpression(call, 1);\n} else if (args.getExpression(0) instanceof VariableExpression) {\n    // Matches: task <identifier>, <arg>?\n    transformVariableExpression(call, 0);\n}\n```\n\n也就是说我们的task名称的双引号也是可以省略的，虽然这不属于groovy的语法糖，但在构建的时候Gradle会对我们的代码进行转换。于是就变成了我们常见的task定义方式:\n\n```groovy\ntask ADemoTask {\n    println(\"ADemoTask...\")\n    doFirst{ println(\"1\") }\n    doFirst{ println(\"2\") }\n    doLast{ println(\"3\") }\n    doLast{ println(\"4\") }\n}\n```\n\n所以ADemoTask后方的闭包内的代码(如println)在配置阶段执行，而doFirst/doLast后方的闭包实际是Action，会在执行阶段执行。\n\n## Task的依赖关系\n\n如同第一节所说Task之间是会有依赖关系的:\n\n```groovy\n\ntask TaskA {\n    doLast {\n        println(\"TaskA run...\")\n    }\n}\n\ntask TaskB {\n    doLast {\n        println(\"TaskB run...\")\n    }\n}\n\n\ntask TaskC {\n    doLast {\n        println(\"TaskC run...\")\n    }\n}\n\nTaskC.dependsOn TaskA\nTaskC.dependsOn TaskB\n//上面的代码实际是下面代码的省略形式\n//project.TaskC.dependsOn(project.TaskA)\n//project.TaskC.dependsOn(project.TaskB)\n```\n\ntask方法为project对象拓展了Task成员变量，我们可以调用Task的dependsOn方法给它添加依赖，Gradle在执行一个Task之前，会先执行它所依赖的Task:\n\n```\n./gradlew TaskC\n\n> Task :app:TaskA\nTaskA run...\n\n> Task :app:TaskB\nTaskB run...\n\n> Task :app:TaskC\nTaskC run...\n```\n\n## 增量编译\n\n编译一般情况下是通过一些输入的文件来执行编译动作，然后输出另外的文件。在输入文件没有改变的情况下，实际上不需要每次都执行边编译:\n\n```groovy\ntask ADemoTask {\n    def srcFile = new File(\"src.txt\")\n    def destFile = new File(\"dest.txt\")\n\n    inputs.file(srcFile)\n    outputs.file(destFile)\n\n    doLast {\n        println(\"run...\")\n        destFile.delete()\n        srcFile.eachLine {line ->\n            destFile.append(\"${line}\\n\")\n        }\n    }\n}\n```\n\n像上面的例子我们指定了task的inputs和outputs，只要outputs已经被生成，且inputs没有修改，那么doLast加入的Action就不会被执行。\n\n# Project、Task、Action间的关系\n\n经过上面的讲解我们大概可以理解Project、Task、Action之间的关系大概如下图:\n\n{% img /Gradle构建原理/3.png %}\n\nProject间存在依赖，每个Project包含多个存在依赖的Task，Task内部有一个Action列表，Task的执行实际上就是内部Action的顺序执行。\n\n# 插件\n\n让我们回到build.gradle脚本，里面默认调用了project的apply、android、dependencies方法:\n\n```groovy\nproject.apply([plugin: 'com.android.application'])\n\nproject.android({\n    compileSdkVersion 30\n    buildToolsVersion \"30.0.2\"\n    defaultConfig {\n        ...\n    }\n    buildTypes {\n        ...\n    }\n})\n\nproject.dependencies({\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation 'androidx.appcompat:appcompat:1.3.0'\n    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.2'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'\n})\n```\n\ndependencies方法配置了Project的依赖，Project可以依赖编译好的库，也能依赖其他的Project(android studio里面的表现是module间的依赖)。\n\nandroid方法配置了一些安卓相关的配置项，但是实际上Gradle并不是专门给安卓使用的，为什么Project里面会有android这个方法呢?\n\n答案就在apply方法传入的插件。\n\nGradle执行com.android.application这个插件的时候会将Project的对象传给插件，插件内部就能为这个Project新增一些拓展方法和Task。我们熟悉的build、assemble、assembleDebug这些Task都是在这个插件里面定义的。\n\n插件的原理我就不细讲了，刚兴趣的同学可以看[这篇笔记](https://blog.islinjw.cn/2019/04/14/%E4%B8%80%E8%B5%B7%E5%85%A5%E9%97%A8gradle%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E4%B8%80/)，这里只简单举个添加拓展方法的例子:\n\n```groovy\n// app build.gradle\n\n// 创建自定义类\nclass MyExt {\n    String data1\n    String data2\n\n    MyExt() {\n        this.data1 = null\n        this.data2 = null\n    }\n\n    void data1(String data1) {\n        this.data1 = data1\n    }\n\n    void data2(String data2) {\n        this.data2 = data2\n    }\n}\n\n//实例化对象\nMyExt ext = new MyExt()\n\n//为project拓展myExt方法\nproject.extensions.add(\"myExt\", ext)\n\n// 下面的myExt实际是project.myExt省略project对象，函数调用的圆括号也被省略了\nmyExt {\n    data1(\"111\")\n    data2(\"222\")\n}\n\nprintln(myExt.data1)\nprintln(myExt.data2)\n```","tags":["技术相关","Android"]},{"title":"源码阅读计划 - OkHttp复用连接池","url":"/2021/05/19/源码阅读计划-OkHttp复用连接池/","content":"蛮久之前写过一篇博客[OkHttp源码解析](https://blog.islinjw.cn/2017/12/30/OkHttp%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/)，相信大多数同学也看过或者了解过OkHttp的整体架构使用的是基于责任链模式的拦截器链。\n\n其实这个库的其他设计也是蛮有意思的，这篇笔记我们就来看看它的Http连接是怎么实现的。\n\n这部分的代码我们从ConnectInterceptor这个拦截器看起，它主要就是负责http的连接。新版本的OkHttp已经用kotlin重写了，所以下面的代码都是kotlin的:\n\n```kotlin\nobject ConnectInterceptor : Interceptor {\n  @Throws(IOException::class)\n  override fun intercept(chain: Interceptor.Chain): Response {\n    val realChain = chain as RealInterceptorChain\n    val exchange = realChain.call.initExchange(chain)\n    val connectedChain = realChain.copy(exchange = exchange)\n    return connectedChain.proceed(realChain.request)\n  }\n}\n\nclass RealCall(...) : Call {\n\tinternal fun initExchange(chain: RealInterceptorChain): Exchange {\n\t\t...\n\t\tval codec = exchangeFinder.find(client, chain)\n\t\tval result = Exchange(this, eventListener, exchangeFinder, codec)\n\t\t...\n\t\treturn result\n\t}\n}\n```\n\nConnectInterceptor的代码很简单，主要的功能就是初始化RealCall的Exchange。这个Exchange的功能就是基于http的Connection进行数据交换。\n\n# Connect缓存\n\n在代码里面我们可以看到这个Exchange的codec是find出来的，codec的功能就算http报文的编解码。一般来讲用find的话就意味着它可能存在缓存:\n\n```kotlin\nclass ExchangeFinder(\n  private val connectionPool: RealConnectionPool,\n  internal val address: Address,\n  private val call: RealCall,\n  private val eventListener: EventListener\n) {\n\t...\n\tfun find(client: OkHttpClient, chain: RealInterceptorChain ): ExchangeCodec {\n\t\t...\n\t\tval resultConnection = findHealthyConnection(...)\n\t\treturn resultConnection.newCodec(client, chain)\n\t\t...\n\t}\n\n\tprivate fun findHealthyConnection(...): RealConnection {\n\t\t...\n\t\tval candidate = findConnection(...)\n\t\t...\n\t}\n\n\tprivate fun findConnection(...): RealConnection {\n\t\t...\n    // 从连接池里面查找可用连接\n\t\tif (connectionPool.callAcquirePooledConnection(address, call, null, false)) {\n\t\t\tval result = call.connection!!\n\t\t\teventListener.connectionAcquired(call, result)\n\t\t\treturn result\n\t\t}\n\t\t...\n    // 找不到的话创建新的连接\n\t\tval newConnection = RealConnection(connectionPool, route)\n\t\t...\n    // 连接socket\n\t\tnewConnection.connect(...）\n\t\t...\n    // 将新连接丢到连接池\n\t\tconnectionPool.put(newConnection)\n    // 绑定RealCall和连接\n\t\tcall.acquireConnectionNoEvents(newConnection)\n\t\t...\n\t\treturn newConnection\n\t}\n\t...\n}\n\nclass RealCall(...) : Call {\n\tfun acquireConnectionNoEvents(connection: RealConnection) {\n\t\t...\n\t\tthis.connection = connection\n\t\tconnection.calls.add(CallReference(this, callStackTrace))\n\t}\n}\n```\n\n从上面的代码我们可以看出来，实际上并不是codec有缓存，而是http的Connection有缓存。codec是通过这个缓存的Connection创建出来的。\n\nConnection实际上就维护着一条socket连接，我们可以看newConnection.connect的具体实现:\n\n```kotlin\nfun connect(...) {\n\t...\n\tconnectSocket(connectTimeout, readTimeout, call, eventListener)\n\t...\n}\n\nprivate fun connectSocket(...) {\n\tval proxy = route.proxy\n\tval address = route.address\n\n\tval rawSocket = when (proxy.type()) {\n\t\tProxy.Type.DIRECT, Proxy.Type.HTTP -> address.socketFactory.createSocket()!!\n\t\telse -> Socket(proxy)\n\t}\n\t...\n\tPlatform.get().connectSocket(rawSocket, route.socketAddress, connectTimeout)\n\t...\n}\n```\n\n也就是并不是每次请求都会创建一条新的socket连接:\n\n{% img /OkHttp复用连接池/1.png %}\n\n# 请求计数\n\nHTTP/1.0中，每次http请求都要创建一个tcp连接，而tcp连接的创建会消耗时间和资源(需要三次握手)。HTTP/1.1中引入了重用连接的机制，就是在http请求头中加入`Connection: keep-alive`来告诉对方这个请求响应完成后不要关闭，下次请求可以继续使用这条链接。\n\nHTTP 1.X中一条连接同时只能进行一次请求，也就是说必须一个将上次Request的Response完全读取之后才能发送下一次Request，而HTTP 2中添加了链路复用的机制同时可以发送多个Request。\n\n于是这里就存在了请求计数和请求数量计算的问题，那么OkHttp是如何实现的呢?\n\n前面章节中创建或者复用Connect的时候都会调用到RealCall.acquireConnectionNoEvents，将RealCall的弱引用丢到connection.calls里面，于是就完成了请求的计数:\n\n```kotlin\nclass RealCall(...) : Call {\n\tfun acquireConnectionNoEvents(connection: RealConnection) {\n\t\t...\n\t\tthis.connection = connection\n\t\tconnection.calls.add(CallReference(this, callStackTrace))\n\t}\n}\n\ninternal class CallReference(...) : WeakReference<RealCall>(referent)\n```\n\n有add就有remove，正如我们上面所说，一次请求实际上就是发送一个Request并将它的Response完全读取。我们用Response.string举例，它最终是通过Exchange使用socket从服务端读取的数据:\n\n```kotlin\nabstract class ResponseBody : Closeable {\n\t@Throws(IOException::class)\n\tfun string(): String = source().use { source ->\n\t\tsource.readString(charset = source.readBomAsCharset(charset()))\n\t}\n}\n\nclass Exchange(...) {\n\toverride fun read(sink: Buffer, byteCount: Long): Long {\n\t\t...\n\t\tval read = delegate.read(sink, byteCount)\n\t\t...\n\t\tif (read == -1L) {\n\t\t\tcomplete(null)\n\t\t\treturn -1L\n\t\t}\n\t\tval newBytesReceived = bytesReceived + read\n\t\t...\n\t\tif (newBytesReceived == contentLength) {\n\t\t\tcomplete(null)\n\t\t}\n\t\treturn read\n\t\t...\n    }\n}\n```\n\n中间的过程过于曲折我就不一步步跟踪了，大家只要知道最终会调到Exchange.read方法。里面有两种情况读取到-1代表与服务器已经断开连接，读取的长度等于Response header里面的Content-Length字段，代表本次Response的全部数据已经读取完成。\n\n这两者都代表这这次请求已经完成，会调用complete方法，最终调到RealCall.releaseConnectionNoEvents将它从connection.calls里面删掉:\n\n```kotlin\nclass Exchange(...) {\n\t...\n\tfun <E : IOException?> complete(e: E): E {\n\t\t...\n\t\treturn bodyComplete(bytesReceived, responseDone = true, requestDone = false, e = e)\n\t}\n\t...\n\tfun <E : IOException?> bodyComplete(...): E {\n\t\t...\n\t\treturn call.messageDone(this, requestDone, responseDone, e)\n\t}\n\t...\n}\n\nclass RealCall(...) : Call {\n\t...\n\tinternal fun <E : IOException?> messageDone(...): E {\n\t\treturn callDone(e)\n\t}\n\t...\n\tprivate fun <E : IOException?> callDone(e: E): E {\n\t\treleaseConnectionNoEvents()\n\t}\n\t...\n\tinternal fun releaseConnectionNoEvents(): Socket? {\n\t\t...\n\t\tval calls = connection.calls\n\t\tval index = calls.indexOfFirst { it.get() == this@RealCall }\n\t\t...\n\t\tcalls.removeAt(index)\n\t\t...\n\t\tif (calls.isEmpty()) {\n\t\t\tconnection.idleAtNs = System.nanoTime()\n\t\t\t...\n\t\t}\n\t\t...\n\t}\n\t...\n}\n```\n\n这里就涉及到两个使用OkHttp容易不小心出现的错误:\n\n1. Response.string只能调用一次\n2. Response必须被读取\n\n由于Response.string读取完成之后这次请求其实就已经结束了，而且OkHttp并没有对这个结果做缓存，所以下次再读取就会出现java.lang.IllegalStateException: closed异常。\n\n而我们从上面的流程知道，connection.calls的remove要Response读取完成后执行，如果我们得到一个Response之后一直不去读取的话实际上它会一直占中这这个Connect，下次HTTP 1.X的请求就不能复用这套链接，要新建一条Connect。\n\n# 请求限制\n\n通过connection.calls我们能知道当前有多少个请求在占用这条connection，所以在连接池里面就能对次数进行限制。\n\n从前面篇幅我们知道ExchangeFinder是通过RealConnectionPool.callAcquirePooledConnection从连接缓存池查找的Connection:\n\n```kotlin\nfun callAcquirePooledConnection(...): Boolean {\n\tfor (connection in connections) {\n\t\tsynchronized(connection) {\n\t\t\tif (requireMultiplexed && !connection.isMultiplexed) return@synchronized\n\t\t\tif (!connection.isEligible(address, routes)) return@synchronized\n\t\t\tcall.acquireConnectionNoEvents(connection)\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n```\n\nconnection.isEligible里面除了判断address是否相等之外还会判断请求数量是否已满:\n\n```kotlin\ninternal fun isEligible(address: Address, routes: List<Route>?): Boolean {\n\t...\n\t// 连接次数是否已满,在HTTP 1.X的情况下allocationLimit总是为1\n\tif (calls.size >= allocationLimit || noNewExchanges) return false\n\n\t// 判断地址是否线条\n\tif (!this.route.address.equalsNonHost(address)) return false\n\n\t// 判断host是否相同\n\tif (address.url.host == this.route().address.url.host) {\n\t\treturn true // This connection is a perfect match.\n\t}\n\t...\n}\n```\n\nallocationLimit在HTTP 1.X的情况下allocationLimit总是为1就保证了HTTP 1.X的情况下每次只能跑一个请求。\n\n# 连接的断开\n\n从上面的流从我们看到，连接在请求完成之后是不会断开的，等待下次请求复用。如果一直不去断开的话，就会有一个资源占用的问题。那么OkHttp是在什么时候断开连接的呢?\n\n其实RealConnectionPool内部会有个cleanupTask专门用于连接的清理\n\n```kotlin\nprivate val cleanupTask = object : Task(\"$okHttpName ConnectionPool\") {\n\toverride fun runOnce() = cleanup(System.nanoTime())\n}\n```\n\n它会在RealConnectionPool的put(加入新连接)、connectionBecameIdle(有连接空闲)里面被调用:\n\n```kotlin\nfun put(connection: RealConnection) {\n    connection.assertThreadHoldsLock()\n\n    connections.add(connection)\n    cleanupQueue.schedule(cleanupTask)\n}\n\nfun connectionBecameIdle(connection: RealConnection): Boolean {\n  connection.assertThreadHoldsLock()\n\n  return if (connection.noNewExchanges || maxIdleConnections == 0) {\n    connection.noNewExchanges = true\n    connections.remove(connection)\n    if (connections.isEmpty()) cleanupQueue.cancelAll()\n    true\n  } else {\n    cleanupQueue.schedule(cleanupTask)\n    false\n  }\n}\n```\n\ncleanupQueue会根据Task.runOnce的返回值等待一段时间再次调用runOnce:\n\n```kotlin\nabstract class Task(...) {\n  ...\n  /** Returns the delay in nanoseconds until the next execution, or -1L to not reschedule. */\n  abstract fun runOnce(): Long\n  ...\n}\n```\n\n这里的runOnce实际就是cleanup方法，我们看看里面干了啥:\n\n```kotlin\nfun cleanup(now: Long): Long {\n    var inUseConnectionCount = 0\n    var idleConnectionCount = 0\n    var longestIdleConnection: RealConnection? = null\n    var longestIdleDurationNs = Long.MIN_VALUE\n\n    // 找到下一次空闲连接超时的时间\n    for (connection in connections) {\n      synchronized(connection) {\n        // 如果这个connection还在使用(Response还没有读完)，就计数然后继续搜索\n        if (pruneAndGetAllocationCount(connection, now) > 0) {\n          inUseConnectionCount++\n        } else {\n          idleConnectionCount++\n\n          // 这个连接已经空闲,计算它空闲了多久，并且保存空闲了最久的连接\n          val idleDurationNs = now - connection.idleAtNs\n          if (idleDurationNs > longestIdleDurationNs) {\n            longestIdleDurationNs = idleDurationNs\n            longestIdleConnection = connection\n          } else {\n            Unit\n          }\n        }\n      }\n    }\n\n    when {\n      longestIdleDurationNs >= this.keepAliveDurationNs\n          || idleConnectionCount > this.maxIdleConnections -> {\n        // 如果空闲最久的连接比keepAliveDurationNs这个值要大就回收\n        val connection = longestIdleConnection!!\n        ...\n        // 关闭socket\n        connection.socket().closeQuietly()\n        if (connections.isEmpty()) cleanupQueue.cancelAll()\n\n        // 我们只回收了空闲超时最久的连接，可能还会有其他连接也超时了，返回0让它立马进行下一次清理\n        return 0L\n      }\n\n      idleConnectionCount > 0 -> {\n        // 如果有空闲连接，就计算最近的一次空闲超时的时间，去等待\n        return keepAliveDurationNs - longestIdleDurationNs\n      }\n\n      inUseConnectionCount > 0 -> {\n        // 如果所有连接都在使用，就等待这个超时时间去重新检查清理\n        return keepAliveDurationNs\n      }\n\n      else -> {\n        // 如果没有连接，就不需要再检查了\n        return -1\n      }\n    }\n}\n```\n\n也就是说这里面会查找空闲过久的连接，然后关闭它的socket。然后计算下一次进行cleanup的等待时长。\n\npruneAndGetAllocationCount返回的是正在占用的请求数，用于检测连接是否空闲。但是其实它内部还会去回收泄露的Response:\n\n```kotlin\nprivate fun pruneAndGetAllocationCount(connection: RealConnection, now: Long): Int {\n    connection.assertThreadHoldsLock()\n\n    val references = connection.calls\n    var i = 0\n    while (i < references.size) {\n      val reference = references[i]\n\n      if (reference.get() != null) {\n        i++\n        continue\n      }\n\n      // We've discovered a leaked call. This is an application bug.\n      val callReference = reference as CallReference\n      val message = \"A connection to ${connection.route().address.url} was leaked. \" +\n          \"Did you forget to close a response body?\"\n      Platform.get().logCloseableLeak(message, callReference.callStackTrace)\n\n      references.removeAt(i)\n      connection.noNewExchanges = true\n\n      // If this was the last allocation, the connection is eligible for immediate eviction.\n      if (references.isEmpty()) {\n        connection.idleAtNs = now - keepAliveDurationNs\n        return 0\n      }\n    }\n\n    return references.size\n}\n```\n\n这里的\"A connection to ${connection.route().address.url} was leaked. Did you forget to close a response body?\"指定就是前面请求计数那里讲的容易出现问题的第二点：得到一个Response之后一直不去读取的话实际上它会一直占中这这个Connect，具体可能是下面的样子:\n\n```kotlin\nclient.newCall(getRequest()).enqueue(new Callback() {\n  @Override\n  public void onFailure(@NotNull Call call, @NotNull IOException e) {\n  }\n\n  @Override\n  public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {\n    // 啥都不干\n  }\n});\n```\n\nonResponse传入的response没有人去读取数据，就会一直占用连接，但是由于它在后面又没有人引用就会被GC回收导致这条连接再也不能断开。\n\npruneAndGetAllocationCount里面就通过弱引用get返回null的方式去检查到这样的异常，进行清理动作。\n\n# 低版本的清理流程\n\n上面讲的是最新版本的清理流程，低版本的流程稍微有点差异但是原理大致相同:\n\n```java\nprivate final Runnable cleanupRunnable = new Runnable() {\n    @Override public void run() {\n      while (true) {\n        long waitNanos = cleanup(System.nanoTime());\n        if (waitNanos == -1) return;\n        if (waitNanos > 0) {\n          long waitMillis = waitNanos / 1000000L;\n          waitNanos -= (waitMillis * 1000000L);\n          synchronized (ConnectionPool.this) {\n            try {\n              ConnectionPool.this.wait(waitMillis, (int) waitNanos);\n            } catch (InterruptedException ignored) {\n            }\n          }\n        }\n      }\n    }\n  };\n```\n\n会专门为连接的清理开一条线程用while true的方式不断检查，当然类似的会使用wait方法等待cleanup返回的时间，减少cpu占用。\n","tags":["技术相关","Android"]},{"title":"Kotlin带接收者的lambda表达式","url":"/2021/05/02/Kotlin带接收者的lambda表达式/","content":"\n在学习kotlin协程原理的时候发现了一个比较有意思的东西:\n\n```kotlin\npublic fun CoroutineScope.launch(\n    context: CoroutineContext = EmptyCoroutineContext,\n    start: CoroutineStart = CoroutineStart.DEFAULT,\n    block: suspend CoroutineScope.() -> Unit\n): Job {\n    ...\n}\n```\n\n这个block参数的类型是:\n\n> suspend CoroutineScope.() -> Unit\n\nsuspend是一个关键字，在协程里面用于声明挂起函数，我们先忽略。看后面的**CoroutineScope.() -> Unit**看起来像是个函数类型，但是比起一般的函数类型又多了前面的”**CoroutineScope.**“前缀。\n\n这玩意学名叫做[带有接收者的函数类型](https://www.kotlincn.net/docs/reference/lambdas.html#%E5%B8%A6%E6%9C%89%E6%8E%A5%E6%94%B6%E8%80%85%E7%9A%84%E5%87%BD%E6%95%B0%E5%AD%97%E9%9D%A2%E5%80%BC)，通过文档我们可以知道它和[扩展函数](https://www.kotlincn.net/docs/reference/extensions.html)类似，允许在函数体内部访问接收者对象的成员。也就是说在lambda内部，传给调用的接收者对象成为隐式的this，我们可以用this去访问它的成员变量。这个时候invoke的第一个参数就是接收者也就是this的值:\n\n```kotlin\ndata class Person(var name: String, var age: Int)\n\nfun with(person: Person, block: Person.() -> R) {\n    return block.invoke(person)\n}\n\nwith(person) {\n    println(\"my name is ${this.name}, ${this.age} years old.\")\n}\n```\n\n然后this也可以省略：\n\n```kotlin\nwith(person) {\n    println(\"my name is ${name}, ${age} years old.\")\n}\n```\n\n# kotlin with方法的原理\n\n通过kotlin的语法糖我们可以将invoke省略，将with方法写成下面的形式:\n\n```kotlin\nfun with(person: Person, block: Person.() -> Unit) {\n    block(person)\n}\n\nwith(person) {\n    println(\"my name is ${name}, ${age} years old.\")\n}\n```\n\n由于block的接收者是Person类型的，通过\"Person.()->Unit\"这个类型声明，其实我们可以将它看成Person的拓展函数，通过person这个传入的对象去调用，也就是说我们可以将with方法再改成这样的形式:\n\n```kotlin\nfun with(person: Person, block: Person.() -> Unit) {\n    person.block()\n}\n```\n\n对kotlin熟悉的同学可能想到了，如果将特定的Person类型改成泛型，然后再将block的返回值返回，就是我们常用的with函数的实现原理:\n\n```kotlin\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    ...\n    return receiver.block()\n}\n```\n\n# kotlin apply方法的原理\n\n如果with方法是Person的成员方法，那么输入的person接收者就是this，可以不用特地在方法参数指定。也就是说可以把它去掉写成下面的形式:\n\n```kotlin\ndata class Person(var name: String, var age: Int) {\n    fun with(block: Person.() -> Unit) {\n        this.block()\n    }\n}\n\nwith(person) {\n    println(\"my name is ${name}, ${age} years old\")\n}\n```\n\n这个时候就更像给Person类创建了一个拓展方法。接收者是this，这个this就是我们传入的person变量。然后this同样可以省略，写成下面的形式:\n\n```kotlin\ndata class Person(var name: String, var age: Int) {\n    fun with(block: Person.() -> Unit) {\n        block()\n    }\n}\n\nwith(person) {\n    println(\"my name is ${name}, ${age} years old\")\n}\n```\n\n如果我们使用泛型去替代这个特定的Person类，然后将this再返回，就是apply方法的实现原理了:\n\n```kotlin\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    ...\n    block()\n    return this\n}\n```\n\n# anko原理\n\n很多的kotlin DSL就是用上面的带有接收者的lambda函数去实现的，例如anko。我们可以先给ViewGroup声明一个拓展方法textView用于创建TextView添加成子view，然后TextView作为接收者去调用lambda方法block:\n\n```kotlin\nfun ViewGroup.textView(block: TextView.() -> Unit) {\n    val textView = TextView(context)\n    addView(textView)\n    block(textView)\n}\n```\n\n然后再声明一个Activity的拓展方法verticalLinearLayout用于创建垂直布局的LinearLayout，然后将这个创建的LinearLayout作为接收者去调用lambda方法block:\n\n```kotlin\nfun Activity.verticalLinearLayout(block: LinearLayout.() -> Unit): LinearLayout {\n    val layout = LinearLayout(this)\n    layout.orientation = LinearLayout.VERTICAL\n    block(layout)\n    return layout\n}\n```\n\n所以就有了下面这样的写法，创建一个垂直布局的LinearLayout里面包含两个TextView:\n\n```\nclass MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        val content = verticalLinearLayout {\n            textView {\n                text = \"aaa\"\n                setBackgroundColor(Color.RED)\n            }\n            textView {\n                text = \"bbb\"\n                setBackgroundColor(Color.GREEN)\n            }\n        }\n        \n        setContentView(content)\n    }\n}\n```\n\n我们对这个dsl进行详细的解析，第一步它调用了Activity的拓展方法verticalLinearLayout，它的接收者是Activity，内部创建了一个LinearLayout返回。并且用它做接收者调用lambda函数，在lambda函数内部调用的textView方法是ViewGroup的拓展函数，它内部创建了一个TextView加入到LinearLayout的子view。并用这个TextView做接收者调再用lambda函数，所以可以直接设置TextView的setText方法和setBackgroundColor方法。\n\n# kotlin DSL设计\n\n除了上面kotlin内置的with、apply方法和anko的实现之外，[官方文档](https://www.kotlincn.net/docs/reference/lambdas.html#%E5%B8%A6%E6%9C%89%E6%8E%A5%E6%94%B6%E8%80%85%E7%9A%84%E5%87%BD%E6%95%B0%E5%AD%97%E9%9D%A2%E5%80%BC)也提供了一个比较典型的例子:\n\n```kotlin\nclass HTML {\n    fun body() { …… }\n}\n\nfun html(init: HTML.() -> Unit): HTML {\n    val html = HTML()  // 创建接收者对象\n    html.init()        // 将该接收者对象传给该 lambda\n    return html\n}\n\nhtml {       // 带接收者的 lambda 由此开始\n    body()   // 调用该接收者对象的一个方法\n}\n```\n\nhtml方法接收一个带HTML类型接收者的lambda函数，它在内部自己创建一个HTML的实例去调用这个lambda函数，于是可以在这个lambda函数里面调用HTML的body方法。\n\n通过上面的几个例子，我们已经了解了带接收者的lambda函数的使用方法，我们可以通过这些典型的用法去设计我们自己的DSL使得我们设计的框架更加易用。\n\n","tags":["技术相关","Android"]},{"title":"Android签名与渠道包制作-V2/V3渠道包原理","url":"/2021/04/09/Android签名与渠道包制作-V2-V3渠道包原理/","content":"系列文章:\n\n- [Android签名与渠道包制作-V1版本](https://blog.islinjw.cn/2021/04/07/Android%E7%AD%BE%E5%90%8D%E4%B8%8E%E6%B8%A0%E9%81%93%E5%8C%85%E5%88%B6%E4%BD%9C-V1%E7%89%88%E6%9C%AC/)\n- [Android签名与渠道包制作-V2/V3签名原理](https://blog.islinjw.cn/2021/04/07/Android%E7%AD%BE%E5%90%8D%E4%B8%8E%E6%B8%A0%E9%81%93%E5%8C%85%E5%88%B6%E4%BD%9C-V2-V3%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86/)\n- [Android签名与渠道包制作-V2/V3渠道包原理](https://blog.islinjw.cn/2021/04/09/Android%E7%AD%BE%E5%90%8D%E4%B8%8E%E6%B8%A0%E9%81%93%E5%8C%85%E5%88%B6%E4%BD%9C-V2-V3%E6%B8%A0%E9%81%93%E5%8C%85%E5%8E%9F%E7%90%86/)\n\n\n[上一篇](https://blog.islinjw.cn/2021/04/07/Android%E7%AD%BE%E5%90%8D%E4%B8%8E%E6%B8%A0%E9%81%93%E5%8C%85%E5%88%B6%E4%BD%9C-V2-V3%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86/)文章我们详细描述了V2/V3签名的原理，大概的原理的就是在APK中插入签名块保存签名信息:\n\n{% img /Android签名与渠道包制作V2V3渠道包原理/1.png %}\n\nAPK签名块的格式如下:\n\n{% img /Android签名与渠道包制作V2V3渠道包原理/2.png %}\n\nV2的签名数据id为0x7109871a,V3的签名数据id为0xf05368c0。由于校验流程里面对APK本身做了校验，所以V1版本的添加zip file comment的方法就失效了。\n\n但是由于V2/V3签名对这个APK签名块是没有做校验的，所以我们可以添加一个自定义的渠道包信息键值对保存渠道信息。这篇文章就通过分析[Demo](https://github.com/bluesky466/ChannelInfoHelper)代码来讲解V2/V3渠道包的原理。\n\n# 渠道信息写入\n\n基本原理就是渠道信息打包成一个id-value键值对放到键值对序列的最后:\n\n{% img /Android签名与渠道包制作V2V3渠道包原理/3.png %}\n\n插入的代码如下:\n\n```java\n\n@Override\npublic boolean addChannelInfo(String srcApk, String outputApk, String channelInfo) {\n    // [APK签名块]插入在[central directory]之前,而[central directory]的起始位置可以在[EOCD]的socdOffset部分读取\n    // 我们在[APK签名块]里面插入渠道信息,会影响到[central directory]的位置,\n    // 所以需要同步修改[EOCD]里面的socdOffset\n    //\n    // [zip包其余内容](不变)          ...\n    //\n    //                              1. APK签名块大小(不包含自己的8个字节)        8字节\n    // [APK签名块](需要插入渠道信息)   2. ID-Value键值对                        大小可变\n    //                              3. APK签名块大小(和第1部分相等)             8字节\n    //                              4. 魔法数(固定为字符串\"APK Sig Block 42\")  16字节\n    //                                      <--------------------------\n    // [central directory](不变)    ...                                |\n    //                                                                 |\n    //                              end of central dir signature       |\n    //                              ...                                |\n    // [EOCD](需要修改socdOffset)    socdOffset  ------------------------\n    //                              ...\n    //\n\n    if (channelInfo == null || channelInfo.isEmpty()) {\n        return true;\n    }\n\n    RandomAccessFile zipFile = null;\n    FileOutputStream fos = null;\n    FileChannel srcChannel = null;\n    FileChannel dstChannel = null;\n    try {\n        zipFile = new RandomAccessFile(new File(srcApk), \"r\");\n        srcChannel = zipFile.getChannel();\n\n        fos = new FileOutputStream(outputApk);\n        dstChannel = fos.getChannel();\n\n        // 查找eocd\n        ByteBuffer eocd = Utils.findEocd(srcChannel);\n        if (eocd == null) {\n            return false;\n        }\n\n        // 获取旧的APK签名块\n        long socdOffset = Utils.getSocdOffset(eocd);\n        Utils.Pair<Long, ByteBuffer> oldSignV2Block = Utils.getSignV2Block(zipFile, socdOffset);\n        if (oldSignV2Block == null) {\n            return false;\n        }\n\n        // 往APK签名块插入渠道信息,得到新的APK签名块\n        ByteBuffer newSignV2Block = addChannelInfo(oldSignV2Block.second, channelInfo);\n\n        // 修改eocd中的socd\n        changeSocdOffset(eocd, channelInfo);\n\n        // APK签名块前的数据是没有改过的,可以直接拷贝\n        srcChannel.position(0);\n        Utils.copyByLength(srcChannel, dstChannel, oldSignV2Block.first);\n\n        // 往后插入新的APK签名块的数据\n        dstChannel.write(newSignV2Block);\n\n        // 往后插入[central directory]的数据,这部分也是没有修改的\n        srcChannel.position(socdOffset);\n        Utils.copyByLength(srcChannel, dstChannel, srcChannel.size() - socdOffset - eocd.capacity());\n\n        // 往后插入修改后的eocd\n        eocd.position(0);\n        dstChannel.write(eocd);\n    } catch (Exception e) {\n        e.printStackTrace();\n        return false;\n    } finally {\n        Utils.safeClose(srcChannel, zipFile, dstChannel, fos);\n    }\n    return true;\n}\n```\n\n基本流程并不复杂，就是:\n\n1. 通过魔数查找eocd\n2. 在eocd中查找central directory的偏移地址socd\n3. socd往前读就是APK签名块\n4. 在APK签名块中插入渠道信息\n5. 由于APK签名块在socd的签名，插入渠道信息后需要将socd往后移\n6. 将修改后的各部分重新写入apk\n\nsocd的修改很简单，读取原来的值加上渠道信息键值对的长度重新写入即可:\n\n```java\nprivate void changeSocdOffset(ByteBuffer eocd, String channelInfo) {\n    // 由于APK签名块在socd offset的前面\n    // 而我们又在APK签名块里面插入了渠道信息\n    // 所以socd offset应该再往后移动插入的渠道信息键值对的大小\n\n\n    // 读取原本的socd offset\n    eocd.position(Utils.EOCD_POSITION_SOCD_OFFSET);\n    int originOffset = eocd.getInt();\n\n\n    // 键值对格式如下:\n    //\n    // 键值对长度(不包含自己的8个字节)   8字节\n    // ID                            4字节\n    // Value                         键值对长度-ID的4字节\n    //\n    // 所以应该加上键值对长度(8字节)、ID长度(4字节)、渠道信息长度\n    eocd.position(Utils.EOCD_POSITION_SOCD_OFFSET);\n    eocd.putInt(originOffset + Long.BYTES + Integer.BYTES + channelInfo.getBytes().length);\n}\n```\n\n往APK签名块中插入渠道信息稍微复杂一点。我们想将渠道信息插入到id-value键值对的最后，但是这里并没有去遍历这个键值对序列，而是用了一种取巧的方式。\n\n由于键值对直接并没有什么指针关系去指定下一个键值对，仅仅只是将将它们排列在一起，所以我们只需要从APK签名块的末尾往前跳过16字节的魔数和8字节的长度信息就能找到插入位置的地址偏移:\n\n{% img /Android签名与渠道包制作V2V3渠道包原理/4.gif %}\n\n由于插入之后APK签名块的长度会增加，所以长度信息需要同步修改，完整的插入代码如下:\n\n```java\nprivate static ByteBuffer addChannelInfo(ByteBuffer oldSignV2BlockSize, String channelInfo) {\n    // ID-Value键值对的格式如下:\n    //\n    // 键值对长度(不包含自己的8个字节)   8字节\n    // ID                            4字节\n    // Value                         键值对长度-ID的4字节\n\n    // 所以整个ID-Value键的长度应该是 Value长度 + ID长度(4字节) + 键值对长度(8字节)\n    long infoLength = channelInfo.getBytes().length;\n    long channelBlockRealSize = Long.BYTES + Integer.BYTES + infoLength;\n\n    ByteBuffer buffer = ByteBuffer.allocate((int) (oldSignV2BlockSize.capacity() + channelBlockRealSize));\n    buffer.order(ByteOrder.LITTLE_ENDIAN);\n\n    // 先将原本的APK完整拷贝出来\n    oldSignV2BlockSize.position(0);\n    buffer.put(oldSignV2BlockSize);\n\n    // 读取原本的APK签名块长度\n    oldSignV2BlockSize.position(0);\n    long originSize = oldSignV2BlockSize.getLong();\n\n    // 该长度要加上插入的渠道信息键值对长度\n    buffer.position(0);\n    buffer.putLong(originSize + channelBlockRealSize);\n\n    // APK签名块结构如下:\n    //\n    // 1. APK签名块大小(不包含自己的8个字节)        8字节\n    // 2. ID-Value键值对                        大小可变\n    // 3. APK签名块大小(和第1部分相等)             8字节\n    // 4. 魔法数(固定为字符串\"APK Sig Block 42\")  16字节\n\n    // 我们把渠道包键值对放到整个APK签名块的最后\n    // 所以从后往前减去魔法数的16字节,减去APK签名块大小的8字节\n    // 定位到渠道包键值的起始位置\n    long magicNumberSize = Utils.SIG_V2_MAGIC_NUMBER.getBytes().length;\n    buffer.position((int) (oldSignV2BlockSize.capacity() - magicNumberSize - Long.BYTES));\n\n    // 插入渠道包键值对数据\n    buffer.putLong(infoLength + Integer.BYTES);\n    buffer.putInt(Utils.CHANNEL_INFO_SIG);\n    buffer.put(channelInfo.getBytes());\n\n    // 插入APK签名块长度\n    buffer.putLong(originSize + channelBlockRealSize);\n\n    // 插入魔法数\n    buffer.put(Utils.SIG_V2_MAGIC_NUMBER.getBytes());\n\n    buffer.flip();\n    return buffer;\n}\n```\n\n# 渠道信息读取\n\n读取部分的逻辑也比较清晰:\n\n1. 通过魔数查找eocd\n2. 在eocd中查找central directory的偏移地址socd\n3. socd往前读就是APK签名块\n4. 跳过APK签名块头8个字节(长度信息)就是第一个id-value键值对\n5. 遍历键值对查找渠道信息键值对的id\n6. 找到渠道信息键值对之后读取value部分返回即可\n\n```java\npublic String getChannelInfo(Context context) {\n    String apkPath = Utils.getApkPath(context);\n    if (apkPath == null) {\n        return null;\n    }\n    RandomAccessFile apk = null;\n    try {\n        apk = new RandomAccessFile(apkPath, \"r\");\n\n        // 查找eocd\n        ByteBuffer eocd = Utils.findEocd(apk.getChannel());\n        if (eocd == null) {\n            return null;\n        }\n\n        // 获取APK签名块\n        Utils.Pair<Long, ByteBuffer> signV2Block = Utils.getSignV2Block(apk, Utils.getSocdOffset(eocd));\n        if (signV2Block == null) {\n            return null;\n        }\n\n\n        // APK签名块结构如下:\n        //\n        // 1. APK签名块大小(不包含自己的8个字节)        8字节\n        // 2. ID-Value键值对(有多个键值对)            大小可变\n        //      2.1 键值对长度(不包含自己的8个字节)     8字节\n        //      2.2 ID                              4字节\n        //      2.3 Value                           键值对长度-ID的4字节\n        // 3. APK签名块大小(和第1部分相等)             8字节\n        // 4. 魔法数(固定为字符串\"APK Sig Block 42\")  16字节\n\n\n        int id;\n        long length,realLength;\n        long positionLimit = signV2Block.second.capacity()\n                - Long.BYTES                                    // APK签名块大小的长度(8字节)\n                - Utils.SIG_V2_MAGIC_NUMBER.getBytes().length;  // 结尾魔数的长度(16字节)\n\n        int position = Long.BYTES; // 跳过开头APK签名块大小的8字节才是第一个ID-Value键值对\n\n        do {\n            signV2Block.second.position(position);\n\n            // 读取键值对长度(不包含自己的8个字节)\n            length = signV2Block.second.getLong();\n\n            // 键值对长度是不包含长度信息的8个字节的,所以要加上这8个字节\n            realLength = Long.BYTES + length;\n\n            // 读取ID\n            id = signV2Block.second.getInt();\n\n            // 移动到下一个键值对\n            position += realLength;\n\n            // 判断是否找到渠道信息键值对的ID,或者已经遍历完整个APK签名块\n        } while (id != Utils.CHANNEL_INFO_SIG && position <= positionLimit);\n\n        if (id == Utils.CHANNEL_INFO_SIG) {\n            // 如果可以找到渠道信息键值对,往后读取就可以读到渠道信息\n            // 键值对长度是包含ID的四个字节的,要减去\n            return Utils.readString(signV2Block.second, (int) (length - Integer.BYTES));\n        }\n        return null;\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        Utils.safeClose(apk);\n    }\n\n    return null;\n}\n```\n\n# 完整代码\n\n由于V2/V3的原理其实是大致相同的，都是在APK签名块里面插入id-value键值对，所以我们这个做法是能够兼容V2/V3版本的签名的。完整的demo已经上传到[Github](https://github.com/bluesky466/ChannelInfoHelper),我将添加渠道信息的操作放到了[单元测试](https://github.com/bluesky466/ChannelInfoHelper/blob/master/app/src/test/java/me/linjw/channelinfohelper/AddChannelInfo.java)里，编译完之后执行插入渠道信息。\n\n","tags":["技术相关","Android"]},{"title":"Android签名与渠道包制作-V2/V3签名原理","url":"/2021/04/07/Android签名与渠道包制作-V2-V3签名原理/","content":"系列文章:\n\n\n- [Android签名与渠道包制作-V1版本](https://blog.islinjw.cn/2021/04/07/Android%E7%AD%BE%E5%90%8D%E4%B8%8E%E6%B8%A0%E9%81%93%E5%8C%85%E5%88%B6%E4%BD%9C-V1%E7%89%88%E6%9C%AC/)\n- [Android签名与渠道包制作-V2/V3签名原理](https://blog.islinjw.cn/2021/04/07/Android%E7%AD%BE%E5%90%8D%E4%B8%8E%E6%B8%A0%E9%81%93%E5%8C%85%E5%88%B6%E4%BD%9C-V2-V3%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86/)\n- [Android签名与渠道包制作-V2/V3渠道包原理](https://blog.islinjw.cn/2021/04/09/Android%E7%AD%BE%E5%90%8D%E4%B8%8E%E6%B8%A0%E9%81%93%E5%8C%85%E5%88%B6%E4%BD%9C-V2-V3%E6%B8%A0%E9%81%93%E5%8C%85%E5%8E%9F%E7%90%86/)\n\n\n\n\n正如[上一篇文章](https://blog.islinjw.cn/2021/04/07/Android%E7%AD%BE%E5%90%8D%E4%B8%8E%E6%B8%A0%E9%81%93%E5%8C%85%E5%88%B6%E4%BD%9C-V1%E7%89%88%E6%9C%AC/)说的,V1版本的签名机制漏洞在于它没有给整个apk包做校验，而且校验的时候需要解压。V2版本的签名机制就是为了解决这两个问题而出现的。\n\n# zip包文件格式\n\n为了了解V2版本的签名原理，我们需要更加深入的了解下zip包的文件格式。由于zip的解析是从后往前的，大体格式如下:\n\n{% img /Android签名与渠道包制作V2V3签名原理/1.png %}\n\neocd的倒数第三部分[offset of start of central directory with respect to the starting disk number]标记了central directory的偏移:\n\n```\nEnd of central directory record:\n\n        end of central dir signature    4 bytes  (0x06054b50)\n        number of this disk             2 bytes\n        number of the disk with the\n        start of the central directory  2 bytes\n        total number of entries in the\n        central directory on this disk  2 bytes\n        total number of entries in\n        the central directory           2 bytes\n        size of the central directory   4 bytes\n        offset of start of central\n        directory with respect to\n        the starting disk number        4 bytes\n        .ZIP file comment length        2 bytes\n        .ZIP file comment       (variable size)\n```\n\n## central directory\n\n我们直接以一个例子来说明:\n\n{% img /Android签名与渠道包制作V2V3签名原理/2.png %}\n\n由于zip包是小端序号,所以实际的值应该是0x00149928，这个地址就代表着central directory的起始地址，我们对比central directory的文件结构:\n\n```\n Central directory structure:\n\n    [file header 1]\n    .\n    .\n    . \n    [file header n]\n    [digital signature] \n\n    File header:\n\n      central file header signature   4 bytes  (0x02014b50)\n      version made by                 2 bytes\n      version needed to extract       2 bytes\n      general purpose bit flag        2 bytes\n      compression method              2 bytes\n      last mod file time              2 bytes\n      last mod file date              2 bytes\n      crc-32                          4 bytes\n      compressed size                 4 bytes\n      uncompressed size               4 bytes\n      file name length                2 bytes\n      extra field length              2 bytes\n      file comment length             2 bytes\n      disk number start               2 bytes\n      internal file attributes        2 bytes\n      external file attributes        4 bytes\n      relative offset of local header 4 bytes\n\n      file name (variable size)\n      extra field (variable size)\n      file comment (variable size)\n\n    Digital signature:\n\n      header signature                4 bytes  (0x05054b50)\n      size of data                    2 bytes\n      signature data (variable size)\n```\n\n一堆的文件头，和一个签名。我们在zip包中找到0x00149928这个位置:\n\n{% img /Android签名与渠道包制作V2V3签名原理/3.png %}\n\n根据上面的格式定义将对应的数据列举出来:\n\n| 地址       | 长度                           | 内容                                      | 值                                                           | 小端序实际值                       |\n| ---------- | ------------------------------ | ----------------------------------------- | ------------------------------------------------------------ | ---------------------------------- |\n| 0x00149928 | 4 bytes                        | central file header signature(0x02014b50) | 0x504B0102                                                   | 0x02014B50                         |\n| 0x0014992C | 2 bytes                        | version made by                           | 0x0000                                                       | 0x0000                             |\n| 0x0014992E | 2 bytes                        | version needed to extract                 | 0x0000                                                       | 0x0000                             |\n| 0x00149930 | 2 bytes                        | general purpose bit flag                  | 0x0000                                                       | 0x0000                             |\n| 0x00149932 | 2 bytes                        | compression method                        | 0x0800                                                       | 0x0008                             |\n| 0x00149934 | 2 bytes                        | last mod file time                        | 0x0000                                                       | 0x0000                             |\n| 0x00149936 | 2 bytes                        | last mod file date                        | 0x0000                                                       | 0x0000                             |\n| 0x00149938 | 4 bytes                        | crc-32                                    | 0x39B6CD57                                                   | 0x57CDB639                         |\n| 0x0014993C | 4 bytes                        | compressed size                           | 0x12030000                                                   | 0x00000312                         |\n| 0x00149940 | 4 bytes                        | uncompressed size                         | 0x98080000                                                   | 0x00000898                         |\n| 0x00149944 | 2 bytes                        | file name length                          | 0x1300                                                       | 0x0013                             |\n| 0x00149946 | 2 bytes                        | extra field length                        | 0x0000                                                       | 0x0000                             |\n| 0x00149948 | 2 bytes                        | file comment length                       | 0x0000                                                       | 0x0000                             |\n| 0x0014994A | 2 bytes                        | disk number start                         | 0x0000                                                       | 0x0000                             |\n| 0x0014994C | 2 bytes                        | internal file attributes                  | 0x0000                                                       | 0x0000                             |\n| 0x0014994E | 4 bytes                        | external file attributes                  | 0x00000000                                                   | 0x00000000                         |\n| 0x00149952 | 4 bytes                        | relative offset of local header           | 0x00000000                                                   | 0x00000000                         |\n| 0x00149956 | variable size<br/>(0x0013==19) | file name                                 | 0x41 0x6E 0x64 0x72 0x6F 0x69 0x64 0x4D 0x61 0x6E 0x69 0x66 0x65 0x73 0x74 0x2E 0x78 0x6D 0x6C | ASCII码的值为：AndroidManifest.xml |\n| -          | variable size(0)               | extra field                               | (空)                                                         | (空)                               |\n| -          | variable size(0)               | file comment                              | (空)                                                         | (空)                               |\n\n所以我们找到第一个文件AndroidManifest.xml的[relative offset of local header]为0x00000000，即local file header 1的地址是0x00000000。\n\n## Local file header\n\n0x00000000的内容如下:\n\n{% img /Android签名与渠道包制作V2V3签名原理/4.png %}\n\nLocal file header的格式如下:\n\n```\nLocal file header:\n\n        local file header signature     4 bytes  (0x04034b50)\n        version needed to extract       2 bytes\n        general purpose bit flag        2 bytes\n        compression method              2 bytes\n        last mod file time              2 bytes\n        last mod file date              2 bytes\n        crc-32                          4 bytes\n        compressed size                 4 bytes\n        uncompressed size               4 bytes\n        file name length                2 bytes\n        extra field length              2 bytes\n\n        file name (variable size)\n        extra field (variable size)\n```\n\n根据上面的格式定义将对应的数据列举出来:\n\n| 地址       | 长度                           | 内容                                    | 值                                                           | 小端序实际值                       |\n| ---------- | ------------------------------ | --------------------------------------- | ------------------------------------------------------------ | ---------------------------------- |\n| 0x00000000 | 4 bytes                        | local file header signature(0x04034b50) | 0x504B0304                                                   | 0x04034B50                         |\n| 0x00000004 | 2 bytes                        | version needed to extract               | 0x0000                                                       | 0x0000                             |\n| 0x00000006 | 2 bytes                        | general purpose bit flag                | 0x0000                                                       | 0x0000                             |\n| 0x00000008 | 2 bytes                        | compression method                      | 0x0800                                                       | 0x0008                             |\n| 0x0000000A | 2 bytes                        | last mod file time                      | 0x0000                                                       | 0x0000                             |\n| 0x0000000C | 2 bytes                        | last mod file date                      | 0x0000                                                       | 0x0000                             |\n| 0x0000001E | 4 bytes                        | crc-32                                  | 0x39B6CD57                                                   | 0x57CDB639                         |\n| 0x00000012 | 4 bytes                        | compressed size                         | 0x12030000                                                   | 0x00000312                         |\n| 0x00000016 | 4 bytes                        | uncompressed size                       | 0x98080000                                                   | 0x00000898                         |\n| 0x0000001A | 2 bytes                        | file name length                        | 0x1300                                                       | 0x0013                             |\n| 0x0000001C | 2 bytes                        | extra field length                      | 0x0000                                                       | 0x0000                             |\n| 0x0000001E | variable size<br/>(0x0013==19) | file name                               | 0x41 0x6E 0x64 0x72 0x6F 0x69 0x64 0x4D 0x61 0x6E 0x69 0x66 0x65 0x73 0x74 0x2E 0x78 0x6D 0x6C | ASCII码的值为：AndroidManifest.xml |\n| -          | variable size(0)               | extra field                             | (空)                                                         | (空)                               |\n\nLocal file header后面跟着的就是压缩后的文件数据，这块我们就不再深入了解了。从上面的解析我们可以了解到，zip包的解析其实是从后往前的。\n\n# V2签名原理\n\n了解完zip包的格式之后，就很容易理解V2签名的原理了。V2签名实际上是在apk的[central directory]前面插入一个apk签名块:\n\n{% img /Android签名与渠道包制作V2V3签名原理/5.png %}\n\n也就是说在eocd读取[offset of start of central directory with respect to the starting disk number]这个地址往前读就是APK签名块了。\n\n我们来看看这个APK签名块的格式:\n\n{% img /Android签名与渠道包制作V2V3签名原理/6.png %}\n\n由于是往前读，所以结尾16字节是一个用于识别的魔数(字符串\"APK Sig Block 42\"),再往前是签名块的长度,继续往前是一系列的带长度前缀的id-value键值对,最前面又是签名块的长度。\n\n我们直接找一个V2签名的apk来分析下:\n\n{% img /Android签名与渠道包制作V2V3签名原理/7.png %}\n\n同样先找到central directory的地址偏移0x00142174:\n\n{% img /Android签名与渠道包制作V2V3签名原理/8.png %}\n\n同样在该地址可以看到0x02014B50这个Central directory的魔数，而往前的16个字节就是字符串”APK Sig Block 42“的ASCII码。继续往前的8个字节则是APK签名块的长度0xFF8。我们用于是我们可以计算出第一个部分的地址:\n\n```\n0x00142174 - 0xFF8 - 0x8 = 0x00141174\n```\n\n再减去8个字节是因为APK签名块长度不包括第一个部分自身的8个字节。然后我们找到这个地址可以看到值是0x00000000 00000FF8:\n\n{% img /Android签名与渠道包制作V2V3签名原理/9.png %}\n\n根据APK签名块的格式我们知道往后便是第一个id-value键值对。他的长度是0x00000000 0000005F3,而id是0x7109871A。这个id的键值对被命名为\"APK 签名方案 v2 分块\"，里面保存的就是签名的校验数据。\n\n## 摘要计算\n\n校验数据的话首先要考虑的就是摘要算法，例如V1版本将每个原始文件用sha算法算出摘要之后用MANIFEST.MF一个个保存起来。而V2版本考虑了整个apk的校验，所以它并不去计算每个原始文件的摘要，而是计算整个apk的摘要。\n\n为了加速运算，首先将apk按1m大小分割成若干块，分别计算这些块的摘要，再将这些摘要组合起来计算一次摘要，就得到了整个apk的摘要。并将其放入id为0x7109871A的\"APK 签名方案 v2 分块\"中:\n\n{% img /Android签名与渠道包制作V2V3签名原理/10.png %}\n\n光讲和看图可能理解还不是特别深入，我们直接干[ApkSignerV2](https://android.googlesource.com/platform/build/+/dd910c5/tools/signapk/src/com/android/signapk/ApkSignerV2.java)的源码:\n\n```java\nprivate static final int CONTENT_DIGESTED_CHUNK_MAX_SIZE_BYTES = 1024 * 1024;\n\nprivate static Map<Integer, byte[]> computeContentDigests(Set<Integer> digestAlgorithms, ByteBuffer[] contents) throws DigestException {\n  // 按1M大小分块,计算分块数量\n  int chunkCount = 0;\n  for (ByteBuffer input : contents) {\n      chunkCount += getChunkCount(input.remaining(), CONTENT_DIGESTED_CHUNK_MAX_SIZE_BYTES);\n  }\n\n  // 可能使用多种算法进行摘要计算\n  // 每种算法都会计算所有分块的摘要然后组合起来,再计算一次摘要\n  // 这里先创建用于组合的buffer\n  final Map<Integer, byte[]> digestsOfChunks = new HashMap<>(digestAlgorithms.size());\n  for (int digestAlgorithm : digestAlgorithms) {\n      // 获取摘要算法计算结果的大小\n      int digestOutputSizeBytes = getContentDigestAlgorithmOutputSizeBytes(digestAlgorithm);\n      // 前5个字节是0x5a和4个字节的块数量,后面是各个块的摘要直接连接组合\n      byte[] concatenationOfChunkCountAndChunkDigests = new byte[5 + chunkCount * digestOutputSizeBytes];\n      // 设置第0个字节为0x5a\n      concatenationOfChunkCountAndChunkDigests[0] = 0x5a;\n      // 设置第1个字节开始的四个字节为块数量\n      setUnsignedInt32LittleEngian(chunkCount, concatenationOfChunkCountAndChunkDigests, 1);\n      // 将buffer放入map中\n      digestsOfChunks.put(digestAlgorithm, concatenationOfChunkCountAndChunkDigests);\n  }\n\n  // 各个分块的摘要计算也是类似的\n  // 需要在摘要前面添加五个字节: 0x5a + 块长度\n  int chunkIndex = 0;\n  byte[] chunkContentPrefix = new byte[5];\n  chunkContentPrefix[0] = (byte) 0xa5;\n\n  for (ByteBuffer input : contents) {\n      while (input.hasRemaining()) {\n          // 读取分块\n          int chunkSize = Math.min(input.remaining(), CONTENT_DIGESTED_CHUNK_MAX_SIZE_BYTES);\n          final ByteBuffer chunk = getByteBuffer(input, chunkSize);\n\n          // 使用各种算法计算分块的摘要\n          for (int digestAlgorithm : digestAlgorithms) {\n              //创建摘要算法实例\n              String jcaAlgorithmName =\n                      getContentDigestAlgorithmJcaDigestAlgorithm(digestAlgorithm);\n              MessageDigest md;\n              try {\n                  md = MessageDigest.getInstance(jcaAlgorithmName);\n              } catch (NoSuchAlgorithmException e) {\n                  throw new DigestException(\n                          jcaAlgorithmName + \" MessageDigest not supported\", e);\n              }\n              // 这个clear并不会将内容清空,仅仅只是是将内部的指针回到position 0\n              chunk.clear();\n\n              //在0x5a后面放入块的大小\n              setUnsignedInt32LittleEngian(chunk.remaining(), chunkContentPrefix, 1);\n\n              //计算块的摘要\n              md.update(chunkContentPrefix);\n              md.update(chunk);\n\n              // 将计算到的分块摘要放入前面为每种算法创建的buffer中组合起来\n              byte[] concatenationOfChunkCountAndChunkDigests =\n                      digestsOfChunks.get(digestAlgorithm);\n              int expectedDigestSizeBytes =\n                      getContentDigestAlgorithmOutputSizeBytes(digestAlgorithm);\n              int actualDigestSizeBytes =\n                      md.digest(\n                              concatenationOfChunkCountAndChunkDigests,\n                              5 + chunkIndex * expectedDigestSizeBytes,\n                              expectedDigestSizeBytes);\n              if (actualDigestSizeBytes != expectedDigestSizeBytes) {\n                  throw new DigestException(\n                          \"Unexpected output size of \" + md.getAlgorithm()\n                                  + \" digest: \" + actualDigestSizeBytes);\n              }\n          }\n          chunkIndex++;\n      }\n  }\n\n  // 遍历算法,计算分块摘要组合起来之后的总摘要\n  Map<Integer, byte[]> result = new HashMap<>(digestAlgorithms.size());\n  for (Map.Entry<Integer, byte[]> entry : digestsOfChunks.entrySet()) {\n      int digestAlgorithm = entry.getKey();\n      byte[] concatenationOfChunkCountAndChunkDigests = entry.getValue();\n      String jcaAlgorithmName = getContentDigestAlgorithmJcaDigestAlgorithm(digestAlgorithm);\n      MessageDigest md;\n      try {\n          md = MessageDigest.getInstance(jcaAlgorithmName);\n      } catch (NoSuchAlgorithmException e) {\n          throw new DigestException(jcaAlgorithmName + \" MessageDigest not supported\", e);\n      }\n      result.put(digestAlgorithm, md.digest(concatenationOfChunkCountAndChunkDigests));\n  }\n  return result;\n}\n```\n\n可以从源码看到计算的流程大概有三步:\n\n1. 将整个apk按1M大小分块\n2. 用多个摘要算法去计算 \"0x5a + 分块长度 + 分块内容\" 的摘要\n3. 用多个摘要算法计算 \"0x5a + 分块数量 + 各个分块摘要\" 的总摘要\n\n虽然在签名的时候没有使用并行计算，但是实际上各个分块的摘要是独立的，在需要的时候完全可以使用并发计算去加速优化。\n\n## 摘要签名\n\n为了防止攻击者在修改apk之后同步修改摘要，V2签名还会使用签名私钥对上面计算出来的摘要进行签名:\n\n```java\nprivate static byte[] generateSignerBlock(\n      SignerConfig signerConfig,\n      Map<Integer, byte[]> contentDigests) throws InvalidKeyException, SignatureException {\n  if (signerConfig.certificates.isEmpty()) {\n      throw new SignatureException(\"No certificates configured for signer\");\n  }\n  // 先将公钥保存下来用于\n  // 1. 签名之后的验证\n  // 2. 写入\"APK 签名方案 v2 分块\"用于安装时候验证签名\n  PublicKey publicKey = signerConfig.certificates.get(0).getPublicKey();\n  byte[] encodedPublicKey = encodePublicKey(publicKey);\n\n  // 初始化签名数据\n  // 主要是创建<摘要算法id,apk摘要>键值对的列表\n  V2SignatureSchemeBlock.SignedData signedData = new V2SignatureSchemeBlock.SignedData();\n  try {\n      signedData.certificates = encodeCertificates(signerConfig.certificates);\n  } catch (CertificateEncodingException e) {\n      throw new SignatureException(\"Failed to encode certificates\", e);\n  }\n  List<Pair<Integer, byte[]>> digests =\n          new ArrayList<>(signerConfig.signatureAlgorithms.size());\n  for (int signatureAlgorithm : signerConfig.signatureAlgorithms) {\n      int contentDigestAlgorithm =\n              getSignatureAlgorithmContentDigestAlgorithm(signatureAlgorithm);\n      byte[] contentDigest = contentDigests.get(contentDigestAlgorithm);\n      if (contentDigest == null) {\n          throw new RuntimeException(\n                  getContentDigestAlgorithmJcaDigestAlgorithm(contentDigestAlgorithm)\n                  + \" content digest for \"\n                  + getSignatureAlgorithmJcaSignatureAlgorithm(signatureAlgorithm)\n                  + \" not computed\");\n      }\n      digests.add(Pair.create(signatureAlgorithm, contentDigest));\n  }\n  signedData.digests = digests;\n\n  // 将上面得到的signedData放入signer中用于计算签名\n  V2SignatureSchemeBlock.Signer signer = new V2SignatureSchemeBlock.Signer();\n  // FORMAT:\n  // * length-prefixed sequence of length-prefixed digests:\n  //   * uint32: signature algorithm ID\n  //   * length-prefixed bytes: digest of contents\n  // * length-prefixed sequence of certificates:\n  //   * length-prefixed bytes: X.509 certificate (ASN.1 DER encoded).\n  // * length-prefixed sequence of length-prefixed additional attributes:\n  //   * uint32: ID\n  //   * (length - 4) bytes: value\n  signer.signedData = encodeAsSequenceOfLengthPrefixedElements(new byte[][] {\n      encodeAsSequenceOfLengthPrefixedPairsOfIntAndLengthPrefixedBytes(signedData.digests),\n      encodeAsSequenceOfLengthPrefixedElements(signedData.certificates),\n      // additional attributes\n      new byte[0],\n  });\n\n  // 保存公钥\n  signer.publicKey = encodedPublicKey;\n\n  // 计算各个摘要算法获取的摘要的签名\n  signer.signatures = new ArrayList<>();\n  for (int signatureAlgorithm : signerConfig.signatureAlgorithms) {\n      Pair<String, ? extends AlgorithmParameterSpec> signatureParams =\n              getSignatureAlgorithmJcaSignatureAlgorithm(signatureAlgorithm);\n      String jcaSignatureAlgorithm = signatureParams.getFirst();\n      AlgorithmParameterSpec jcaSignatureAlgorithmParams = signatureParams.getSecond();\n      byte[] signatureBytes;\n\n      // 获取签名算法使用私钥进行签名\n      try {\n          Signature signature = Signature.getInstance(jcaSignatureAlgorithm);\n          signature.initSign(signerConfig.privateKey);\n          if (jcaSignatureAlgorithmParams != null) {\n              signature.setParameter(jcaSignatureAlgorithmParams);\n          }\n          signature.update(signer.signedData);\n          signatureBytes = signature.sign();\n      } catch (InvalidKeyException e) {\n          throw new InvalidKeyException(\"Failed sign using \" + jcaSignatureAlgorithm, e);\n      } catch (NoSuchAlgorithmException | InvalidAlgorithmParameterException\n              | SignatureException e) {\n          throw new SignatureException(\"Failed sign using \" + jcaSignatureAlgorithm, e);\n      }\n\n      // 使用公钥尝试是否能够正确验证签名\n      try {\n          Signature signature = Signature.getInstance(jcaSignatureAlgorithm);\n          signature.initVerify(publicKey);\n          if (jcaSignatureAlgorithmParams != null) {\n              signature.setParameter(jcaSignatureAlgorithmParams);\n          }\n          signature.update(signer.signedData);\n          if (!signature.verify(signatureBytes)) {\n              throw new SignatureException(\"Signature did not verify\");\n          }\n      } catch (InvalidKeyException e) {\n          throw new InvalidKeyException(\"Failed to verify generated \" + jcaSignatureAlgorithm\n                  + \" signature using public key from certificate\", e);\n      } catch (NoSuchAlgorithmException | InvalidAlgorithmParameterException\n              | SignatureException e) {\n          throw new SignatureException(\"Failed to verify generated \" + jcaSignatureAlgorithm\n                  + \" signature using public key from certificate\", e);\n      }\n\n      // 将签名加入签名数据\n      signer.signatures.add(Pair.create(signatureAlgorithm, signatureBytes));\n  }\n\n  // 生成签名二进制数据\n  // FORMAT:\n  // * length-prefixed signed data\n  // * length-prefixed sequence of length-prefixed signatures:\n  //   * uint32: signature algorithm ID\n  //   * length-prefixed bytes: signature of signed data\n  // * length-prefixed bytes: public key (X.509 SubjectPublicKeyInfo, ASN.1 DER encoded)\n  return encodeAsSequenceOfLengthPrefixedElements(\n          new byte[][] {\n              signer.signedData,\n              encodeAsSequenceOfLengthPrefixedPairsOfIntAndLengthPrefixedBytes(\n                      signer.signatures),\n              signer.publicKey,\n          });\n}\n```\n\n最后会将计算得到的摘要、摘要签名、公钥、算法信息等数据写入刚刚说的的id为0x7109871A的\"APK 签名方案 v2 分块\"中，于是在安装apk的时候就能使用这些数据去检查apk是否被修改了:\n\n{% img /Android签名与渠道包制作V2V3签名原理/11.png %}\n\n## 防回滚保护\n\n由于需要在Android 7.0之后才支持V2版本的签名，为了兼容低版本的安卓机器，一般情况下我们会同时使用V1和V2版本的签名。但由于V2版本插入apk中间的\"APK签名块\"是独立于zip格式存在的，攻击者其实可以直接将其直接删掉，使得apk降级回V1。\n\n而高版本的安卓系统为了兼容旧的apk，也会在找不到Apk签名块的情况下使用V1签名去验证。\n\n谷歌为了防止这种恶意操作规定:\n\n同时包含V1和V2签名的CERT.SF文件会加入这样一个属性:\n\n```\nX-Android-APK-Signed: 2\n```\n\n在Android 7.0之后读取到这个属性的时候就会强制使用V2版本的签名检查机制而不走V1版本的。\n\n# V3签名原理\n\n由于生成签名的时，可以指定一个有效时间，这个时间默认为 25 年，如果过了这个时间可能会出现签名失效不能再安装的情况。\n\n说可能是因为网上[有人](https://blog.fengsq.com/post/ApkSignature.html)实际验证过,有些机器是没有做这个检查的:\n\n> ==但是，我实际测试了下官方模拟器、小米、vivo、华为荣耀，签名已失效依然可以正常安装。== 网上千篇一律都说失效签名无法安装，不知道他们有没有实际测过。咨询了厂商的开发者，目前只收到了vivo的回复，说是因为手机时间可以随意调，所以这个检验没有任何意义，他们废弃掉了，其他厂商不知道是不是也出于这个原因。\n\n但是为了防止的确有公司被收购等这样那样的原因需要更换签名，安卓9.0之后提供了V3版本的签名机制。\n\nV3版本的机制原理是在APK签名块里面新增了一个id为0xF05368C0的键值对，它的格式也和V2版本id为0x7109871A的\"APK 签名方案 v2 分块\"基本相同，只不过增加了attr块，里面保存了多个level的证书信息。(由于它们的id不一样，所以在V2+V3同时签名的情况下，APK签名块会同时有这两个id的键值对)\n\n我从这位博主的[文章](https://blog.csdn.net/bobby_fu/article/details/103843038)中看到了这附两幅图，能够很形象的解释V2和V3签名间的差异:\n\n{% img /Android签名与渠道包制作V2V3签名原理/12.png %}\n\n在安装的时候会使用旧的证书去验证新证书是否有效。如果当前已经安装的apk的证书在level证书链上，就能逐步完后验证更新的证书的有效性\n\n{% img /Android签名与渠道包制作V2V3签名原理/13.png %}\n\n 证书链验证的核心代码如下：\n\n```java\n// frameworks/base/core/java/android/util/apk/ApkSignatureSchemeV3Verifier.java\nprivate static VerifiedProofOfRotation verifyProofOfRotationStruct(\n        ByteBuffer porBuf,\n        CertificateFactory certFactory)\n        throws SecurityException, IOException {\n    int levelCount = 0;\n    int lastSigAlgorithm = -1;\n    X509Certificate lastCert = null;\n    List<X509Certificate> certs = new ArrayList<>();\n    List<Integer> flagsList = new ArrayList<>();\n\n    // Proof-of-rotation struct:\n    // A uint32 version code followed by basically a singly linked list of nodes, called levels\n    // here, each of which have the following structure:\n    // * length-prefix for the entire level\n    //     - length-prefixed signed data (if previous level exists)\n    //         * length-prefixed X509 Certificate\n    //         * uint32 signature algorithm ID describing how this signed data was signed\n    //     - uint32 flags describing how to treat the cert contained in this level\n    //     - uint32 signature algorithm ID to use to verify the signature of the next level. The\n    //         algorithm here must match the one in the signed data section of the next level.\n    //     - length-prefixed signature over the signed data in this level.  The signature here\n    //         is verified using the certificate from the previous level.\n    // The linking is provided by the certificate of each level signing the one of the next.\n\n    try {\n\n        // get the version code, but don't do anything with it: creator knew about all our flags\n        porBuf.getInt();\n        HashSet<X509Certificate> certHistorySet = new HashSet<>();\n        while (porBuf.hasRemaining()) {\n            levelCount++;\n            ByteBuffer level = getLengthPrefixedSlice(porBuf);\n            ByteBuffer signedData = getLengthPrefixedSlice(level); // 获取当前level证书的信息\n            int flags = level.getInt();\n            int sigAlgorithm = level.getInt();\n            byte[] signature = readLengthPrefixedByteArray(level); // 获取上一level证书为当前level证书生成的签名\n\n            // 使用上一个level的证书去验证下一个level的证书\n            if (lastCert != null) {\n                // 获取上一个证书的数据\n                Pair<String, ? extends AlgorithmParameterSpec> sigAlgParams =\n                        getSignatureAlgorithmJcaSignatureAlgorithm(lastSigAlgorithm);\n                // 获取上一个证书的公钥\n                PublicKey publicKey = lastCert.getPublicKey();\n                // 初始化签名信息\n                Signature sig = Signature.getInstance(sigAlgParams.first);\n                sig.initVerify(publicKey);\n                if (sigAlgParams.second != null) {\n                    sig.setParameter(sigAlgParams.second);\n                }\n                // 设置当前level证书的数据\n                sig.update(signedData);\n                // 使用上一level证书为当前level证书生成的签名去验证当前level证书是否有效\n                if (!sig.verify(signature)) {\n                    throw new SecurityException(\"Unable to verify signature of certificate #\"\n                            + levelCount + \" using \" + sigAlgParams.first + \" when verifying\"\n                            + \" Proof-of-rotation record\");\n                }\n            }\n                        \n            // 使用证书信息去创建证书，将其赋值给lastCert并将其丢入certs队列\n            signedData.rewind();\n            byte[] encodedCert = readLengthPrefixedByteArray(signedData);\n            int signedSigAlgorithm = signedData.getInt();\n            if (lastCert != null && lastSigAlgorithm != signedSigAlgorithm) {\n                throw new SecurityException(\"Signing algorithm ID mismatch for certificate #\"\n                        + levelCount + \" when verifying Proof-of-rotation record\");\n            }\n            lastCert = (X509Certificate)\n                    certFactory.generateCertificate(new ByteArrayInputStream(encodedCert));\n            lastCert = new VerbatimX509Certificate(lastCert, encodedCert);\n\n            lastSigAlgorithm = sigAlgorithm;\n            if (certHistorySet.contains(lastCert)) {\n                throw new SecurityException(\"Encountered duplicate entries in \"\n                        + \"Proof-of-rotation record at certificate #\" + levelCount + \".  All \"\n                        + \"signing certificates should be unique\");\n            }\n            certHistorySet.add(lastCert);\n            certs.add(lastCert);\n            flagsList.add(flags);\n        }\n    } catch (IOException | BufferUnderflowException e) {\n        throw new IOException(\"Failed to parse Proof-of-rotation record\", e);\n    } catch (NoSuchAlgorithmException | InvalidKeyException\n            | InvalidAlgorithmParameterException | SignatureException e) {\n        throw new SecurityException(\n                \"Failed to verify signature over signed data for certificate #\"\n                        + levelCount + \" when verifying Proof-of-rotation record\", e);\n    } catch (CertificateException e) {\n        throw new SecurityException(\"Failed to decode certificate #\" + levelCount\n                + \" when verifying Proof-of-rotation record\", e);\n    }\n    return new VerifiedProofOfRotation(certs, flagsList);\n}\n\n```\n\n## V3版本校验流程\n\n实际上校验的时候并不需要从证书链中解析出最后的公钥，因为和V2的格式一样，直接可以在签名块中读取到公钥进行校验。所以他的流程前面的部分其实和v2版本是一致的，只不过在校验完成之后会再去验证证书链:\n\n1. 用PublicKey和Signature验证SignerData\n2. 用SignerData验证apk\n3. 验证当前安装的应用证书是否在证书链中\n4. 继续安装\n\n而证书链最新的证书公钥其实就是APK签名块里的PublicKey:\n\n```java\nprivate static VerifiedSigner verifyAdditionalAttributes(ByteBuffer attrs,\n        List<X509Certificate> certs, CertificateFactory certFactory) throws IOException {\n    X509Certificate[] certChain = certs.toArray(new X509Certificate[certs.size()]);\n    VerifiedProofOfRotation por = null;\n\n    while (attrs.hasRemaining()) {\n        ByteBuffer attr = getLengthPrefixedSlice(attrs);\n        if (attr.remaining() < 4) {\n            throw new IOException(\"Remaining buffer too short to contain additional attribute \"\n                    + \"ID. Remaining: \" + attr.remaining());\n        }\n        int id = attr.getInt();\n        switch(id) {\n            case PROOF_OF_ROTATION_ATTR_ID:\n                if (por != null) {\n                    throw new SecurityException(\"Encountered multiple Proof-of-rotation records\"\n                            + \" when verifying APK Signature Scheme v3 signature\");\n                }\n                por = verifyProofOfRotationStruct(attr, certFactory);\n                // 确认证书链最后一个证书的公钥与APK签名块的公钥相等\n                try {\n                    if (por.certs.size() > 0\n                            && !Arrays.equals(por.certs.get(por.certs.size() - 1).getEncoded(),\n                                    certChain[0].getEncoded())) {\n                        throw new SecurityException(\"Terminal certificate in Proof-of-rotation\"\n                                + \" record does not match APK signing certificate\");\n                    }\n                } catch (CertificateEncodingException e) {\n                    throw new SecurityException(\"Failed to encode certificate when comparing\"\n                            + \" Proof-of-rotation record and signing certificate\", e);\n                }\n\n                break;\n            default:\n                // not the droid we're looking for, move along, move along.\n                break;\n        }\n    }\n    return new VerifiedSigner(certChain, por);\n}\n```\n\n最终用[最新的证书的公钥]+[摘要的签名]去验证[摘要]的有效性，从而验证apk的有效性:\n\n{% img /Android签名与渠道包制作V2V3签名原理/14.png %}\n\n这篇讲述了V2、V3签名机制的原理，由于章节已经很长了，渠道包的制作就放到下一篇。\n\n参考:\n\n[VasDolly实现原理](https://github.com/Tencent/VasDolly/wiki/VasDolly%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86)\n\n[Android V2签名机制以及ApkSignerV2签名源码解析](https://www.jianshu.com/p/dc320629bf9d)\n\n[分析 Android V2 新签名打包机制](https://cloud.tencent.com/developer/article/1006237)\n\n[Android P v3签名新特性](https://blog.csdn.net/bobby_fu/article/details/103843038)\n\n[一次让你搞懂Android应用签名](https://blog.fengsq.com/post/ApkSignature.html)","tags":["技术相关","Android"]},{"title":"Android签名与渠道包制作-V1版本","url":"/2021/04/07/Android签名与渠道包制作-V1版本/","content":"\n系列文章:\n\n- [Android签名与渠道包制作-V1版本](https://blog.islinjw.cn/2021/04/07/Android%E7%AD%BE%E5%90%8D%E4%B8%8E%E6%B8%A0%E9%81%93%E5%8C%85%E5%88%B6%E4%BD%9C-V1%E7%89%88%E6%9C%AC/)\n- [Android签名与渠道包制作-V2/V3签名原理](https://blog.islinjw.cn/2021/04/07/Android%E7%AD%BE%E5%90%8D%E4%B8%8E%E6%B8%A0%E9%81%93%E5%8C%85%E5%88%B6%E4%BD%9C-V2-V3%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86/)\n- [Android签名与渠道包制作-V2/V3渠道包原理](https://blog.islinjw.cn/2021/04/09/Android%E7%AD%BE%E5%90%8D%E4%B8%8E%E6%B8%A0%E9%81%93%E5%8C%85%E5%88%B6%E4%BD%9C-V2-V3%E6%B8%A0%E9%81%93%E5%8C%85%E5%8E%9F%E7%90%86/)\n\n\n\n\n偶然发现安卓的签名V3已经出到了版本，想想自己其实也没有太深入了解过v1、v2。本着查漏补缺的想法把三个版本的原理都过了一遍，并且利用签名的原理手撸了渠道包制作的demo。这系列的文章就带大家深入了解下各个版本的签名和渠道包制作原理。\n\n这篇我们先来看看V1版本的原理。\n\n# V1签名原理\n\n首先我们要知道用v1签名的apk包其实就是一个普通的zip压缩包，我们将后缀改成.zip就可以直接解压。解压出来可以在META-INF目录下看到MANIFEST.MF、CERT.SF、CERT.RSA这三个文件，V1签名就是靠的这三个文件来验证的。\n\n## MANIFEST.MF\n\nMANIFEST.MF长这个样子，它记录了apk所有原始文件的数据摘要的Base64编码:\n\n```\nManifest-Version: 1.0\nBuilt-By: Generated-by-ADT\nCreated-By: Android Gradle 3.5.1\n\nName: AndroidManifest.xml\nSHA-256-Digest: 6gizONW6AQK41R0kXhGh+M60wBxPA06WFrq5KSWrB24=\n\nName: META-INF/androidx.appcompat_appcompat.version\nSHA-256-Digest: n9KGQtOsoZHlx/wjg8/W+rsqrIdD8Cnau4mJrFhOMbw=\n\n...\n```\n\n正如我们所说，apk是个普通的压缩包，我们解压完修改里面的内容(如图片)再压缩回去，它仍然符合apk文件格式可以用于安装。但是V1签名在安装的时候会用MANIFEST.MF去检查原始文件是否被修改，如果被修改就拒绝安装。\n\n## CERT.SF\n\n当然我们也可以将MANIFEST.MF一起修改了，但是安卓还会通过CERT.SF去检查MANIFEST.MF是否被修改。\n\nCERT.SF长这样:\n\n```\nSignature-Version: 1.0\nCreated-By: 1.0 (Android)\nSHA-256-Digest-Manifest: aed+nGnbmO5m79Dy1aNQ68aTFC9N5EyZj8kOeE56yyU=\n\nName: AndroidManifest.xml\nSHA-256-Digest: QA9D/hXYs4aCJcZ4nZ8kLP2RnPn/kw15girRaw7xdng=\n\nName: META-INF/androidx.appcompat_appcompat.version\nSHA-256-Digest: ABbgKP0s08CVeuJ5ZMlIZx/AvJtb1QhNA0ffeXfCaHk=\n\nName: META-INF/androidx.arch.core_core-runtime.version\nSHA-256-Digest: PjygIQMN5T6nIKT/hi5PFaxVcEB+W20fr4f0g2n7jrg=\n\n...\n```\n\n它将MANIFEST.MF整个文件和里面的每一项的摘要信息又做一次SHA摘要和Base64编码记录起来。例如CERT.SF第一个AndroidManifest.xml的SHA-256-Digest代表的其实是下面内容SHA摘要的Base64编码:\n\n```\nName: AndroidManifest.xml\nSHA-256-Digest: 6gizONW6AQK41R0kXhGh+M60wBxPA06WFrq5KSWrB24=\n\\r\\n\n```\n\nPS: 最后一行的\\r\\n也是要参与计算的。\n\n## CERT.RSA\n\n同样的道理在修改apk的时候我们也可以将MANIFEST.MF和CERT.SF一并修改了。这个时候就轮到CERT.RSA出马了。\n\n进行V1签名的时候会先计算CERT.SF的摘要，然后用开发者的私钥计算数字签名，然后将数字签名、开发者公钥等信息保存到CERT.RSA，在安装的时候就能进行验证。如果没有私钥，修改完CERT.SF就没有办法同步修改CERT.RSA。\n\n## 签名与校验流程\n\n通过上面的介绍我们能总结出V1版本的签名和校验流程:\n\n签名流程:\n\n1. 计算每个原始文件的SHA摘要，用Base64编码保存到MANIFEST.MF\n2. 对MANIFEST.MF的整个文件和里面的每一项信息再进行SHA摘要，用Base64编码保存到CERT.SF\n3. 计算CERT.SF的摘要并使用开发者的私钥加密计算出数字签名，将该数字签名和开发者公钥等信息保存到CERT.RSA\n\n验证流程:\n\n1. 在CERT.RSA读取公钥和CERT.SF的数字签名，计算CERT.SF的摘要\n2. 验证CERT.SF是否被修改\n3. 通过CERT.SF验证MANIFEST.MF是否被修改\n4. 通过MANIFEST.MF验证原始文件是否被修改\n\n# 渠道包原理\n\n由于国内的应用市场众多，一般需要打多个渠道包上传，这些渠道包会保存该渠道的一些信息。虽然我们可以通过gradle的productFlavors去编译多个包，但是由于这种机制没生成一个渠道包都要走一遍编译流程，耗时比较多。而且一般会生成不同的BuildConfig.java类导致dex不同，如果使用Tinker需要对不同的渠道包都单独做差异包去热修复。\n\n所以一般都不会用这种方式去打渠道包，而是在编译完之后在apk里面插入渠道信息。\n\n刚刚我们也有讲到V1签名会对apk里面的文件进行校验，但是这里有个漏洞就是它是对原始文件进行校验，对整个apk包没有做校验。所以我们可以在apk包中插入渠道信息。\n\n## zip包格式\n\n使用将数据直接插入apk文件的方式，我们先要了解下apk(也就是zip包)的[文件格式](https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.2.0.txt):\n\n{% img /Android签名与渠道包制作V1版本/1.png %}\n\n它主要分成了上面的三个部分，而我们的突破口就在最后一部分，我们来看看这部分的详细格式:\n\n| 内容                                                         | 大小            |\n| ------------------------------------------------------------ | --------------- |\n| end of central dir signature (0x06054b50)                    | 4 bytes         |\n| number of this disk                                          | 2 bytes         |\n| number of the disk with the start of the central directory   | 2 bytes         |\n| total number of entries in the central directory on this disk | 2 bytes         |\n| total number of entries in the central directory             | 2 bytes         |\n| size of the central directory                                | 4 bytes         |\n| offset of start of central directory with respect to the starting disk number | 4 bytes         |\n| .ZIP file comment length                                     | 2 bytes         |\n| .ZIP file comment                                            | (variable size) |\n\n这部分我们简称eocd，它以一个魔数0x06054b50打头，后面带了一些zip包的描述。其中对我们最重要的是最后的.ZIP file comment length和.ZIP file comment。\n\nzip包是可以在末尾携带描述信息的。描述信息的长度在.ZIP file comment length字段中获取。所以我们可以将渠道信息写到.ZIP file comment里。我这里参考[VasDolly]([https://github.com/Tencent/VasDolly/wiki/VasDolly%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86](https://github.com/Tencent/VasDolly/wiki/VasDolly实现原理))的实现原理将渠道信息格式定义成下面的样子插入到apk包的最末尾:\n\n{% img /Android签名与渠道包制作V1版本/2.png %}\n\n于是我们在运行的时候就能通过读取apk包的结尾4个字节看看是否能读到我们定义的魔数判断有无渠道信息，如果有的话往前两个字节读渠道信息的长度，最后根据长度再往前读取渠道信息。\n\n## 渠道信息的写入\n\n这边实现了个Demo，我们直接来看看代码:\n\n```java\npublic boolean addChannelInfo(String srcApk, String outputApk, String channelInfo) {\n    RandomAccessFile zipFile = null;\n    FileOutputStream fos = null;\n    FileChannel srcChannel = null;\n    FileChannel dstChannel = null;\n    try {\n        zipFile = new RandomAccessFile(new File(srcApk), \"r\");\n        srcChannel = zipFile.getChannel();\n\n        fos = new FileOutputStream(outputApk);\n        dstChannel = fos.getChannel();\n\n        // 查找eocd\n        ByteBuffer originEocd = Utils.findEocd(srcChannel);\n        if (originEocd == null) {\n            return false;\n        }\n\n        // 往eocd插入渠道信息得到新的eocd\n        ByteBuffer newEocd = addChannelInfo(originEocd, channelInfo);\n\n        // eocd前面的数据是没有改到的,直接拷贝就好\n        Utils.copyByLength(srcChannel, dstChannel, zipFile.length() - originEocd.capacity());\n\n        // 往后插入新的eocd\n        dstChannel.write(newEocd);\n    } catch (Exception e) {\n        e.printStackTrace();\n        return false;\n    } finally {\n        Utils.safeClose(srcChannel, zipFile, dstChannel, fos);\n    }\n    return true;\n}\n```\n\neocd的读取很简单，从后往前查找eocd魔数即可:\n\n```java\npublic static ByteBuffer findEocd(FileChannel zipFile) throws IOException {\n    // end of central directory record 是整个zip包的结尾\n    // 而且它以0x06054b50这个魔数做起始,所以只需从后往前遍历找到这个魔数,即可截取整个EOCD\n    //\n    // [zip包其余内容]      ...\n    //\n    // [EOCD]              end of central dir signature (0x06054b50)\n    //                     eocd其余部分\n\n    try {\n        if (zipFile.size() < Utils.EOCD_MIN_LENGTH) {\n            return null;\n        }\n\n        int length = (int) Math.min(Utils.EOCD_MAX_LENGTH, zipFile.size());\n        ByteBuffer buffer = ByteBuffer.allocate(length);\n        buffer.order(ByteOrder.LITTLE_ENDIAN);\n\n        zipFile.read(buffer, zipFile.size() - length);\n\n        for (int i = length - Utils.EOCD_MIN_LENGTH; i >= 0; i--) {\n            if (buffer.getInt(i) == Utils.EOCD_SIG) {\n                buffer.position(i);\n                return buffer.slice().order(ByteOrder.LITTLE_ENDIAN);\n            }\n        }\n        System.out.println(\"return null\");\n        return null;\n    } finally {\n        zipFile.position(0);\n    }\n}\n```\n\n如果apk本身没有带描述，我们主需要直接读最后的22个字节就好，但是为了兼容带描述的情况，我们还是通过查找魔数的方式定位eocd。\n\n.ZIP file comment length只有2字节,所以描述长度最多有0xffff,然后加上eocd前固定的22个字节就得到eocd可能的最大长度\n\n```java\npublic static final int EOCD_MAX_LENGTH = 0xffff + 22;\n```\n\n所以我们直接从apk最后读取这么多个字节去遍历就好。\n\n查到到eocd之后我们在最后插入渠道信息，然后同步修改.ZIP file comment length字段:\n\n```java\nprivate static ByteBuffer addChannelInfo(ByteBuffer eocd, String channelInfo) {\n    // end of central directory record 的格式如下:\n    //\n    // end of central dir signature                                                    4 bytes  (0x06054b50)\n    // number of this disk                                                             2 bytes\n    // number of the disk with the start of the central directory                      2 bytes\n    // total number of entries in the central directory on this disk                   2 bytes\n    // total number of entries in the central directory                                2 bytes\n    // size of the central directory                                                   4 bytes\n    // offset of start of central directory with respect to the starting disk number   4 bytes\n    // .ZIP file comment length                                                        2 bytes\n    // .ZIP file comment                                                               (variable size)\n    //\n    // 我们可以在.ZIP file comment里面插入渠道信息块:\n    //\n    // 渠道信息      大小记录在[渠道信息长度]中\n    // 渠道信息长度  2字节\n    // 魔数         4字节\n    //\n    // 魔数放在最后面方便我们读取判断是否有渠道信息\n\n    short infoLength = (short) channelInfo.getBytes().length;\n    short channelBlockSize = (short) (infoLength // 渠道信息\n            + Short.BYTES      // 渠道信息长度\n            + Integer.BYTES);  // 渠道信息魔数\n    ByteBuffer buffer = ByteBuffer.allocate(eocd.capacity() + channelBlockSize);\n    buffer.order(ByteOrder.LITTLE_ENDIAN);\n\n    // eocd前面部分的数据我们没有改动,直接拷贝就好\n    byte[] bytes = new byte[Utils.EOCD_MIN_LENGTH - Utils.EOCD_SIZE_OF_COMMENT_LENGTH];\n    eocd.get(bytes);\n    buffer.put(bytes);\n\n    // 由于插入了渠道信息块,zip包的注释长度需要相应的增加\n    buffer.putShort((short) (eocd.getShort() + channelBlockSize));\n\n    // 拷贝原本的zip包注释\n    eocd.position(Utils.EOCD_MIN_LENGTH);\n    buffer.put(eocd);\n\n    // 插入渠道包信息块\n    buffer.put(channelInfo.getBytes());     // 渠道信息\n    buffer.putShort(infoLength);            // 渠道信息长度\n    buffer.putInt(Utils.CHANNEL_INFO_SIG);  // 魔数\n\n    buffer.flip();\n    return buffer;\n}\n```\n\n## 渠道信息的读取\n\n讲完渠道信息的写入，我们再来看看运行的时候怎么去读取渠道信息:\n\n```java\npublic String getChannelInfo(Context context) {\n    String apkPath = Utils.getApkPath(context);\n    if (apkPath == null) {\n        return null;\n    }\n    RandomAccessFile apk = null;\n    try {\n        apk = new RandomAccessFile(apkPath, \"r\");\n\n        // 读取apk的结尾4字节看看是否为渠道信息魔数判断是否有渠道信息\n        long sigPosition = apk.length() - Integer.BYTES;\n        int sig = Utils.readInt(apk, sigPosition);\n        if (sig != Utils.CHANNEL_INFO_SIG) {\n            return null;\n        }\n\n        // 再往前读两个字节获取渠道信息的长度\n        long lengthPosition = sigPosition - Short.BYTES;\n        short length = Utils.readShort(apk, lengthPosition);\n        if (length <= 0) {\n            return null;\n        }\n\n        // 根据长度读取渠道信息\n        long infoPosition = lengthPosition - length;\n        return Utils.readString(apk, infoPosition, length);\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        Utils.safeClose(apk);\n    }\n\n    return null;\n}\n```\n\n流程很简单:\n\n1. 判断apk结尾4个字节是否为渠道信息魔数\n2. 获取渠道信息长度\n3. 读取渠道信息\n\n# 完整代码\n\n完整的demo已经上传到[Github](https://github.com/bluesky466/ChannelInfoHelper),我将添加渠道信息的操作放到了[单元测试](https://github.com/bluesky466/ChannelInfoHelper/blob/master/app/src/test/java/me/linjw/channelinfohelper/AddChannelInfo.java)里，编译完之后执行插入渠道信息。\n\n","tags":["技术相关","Android"]},{"title":"Glide源码探究(四) - Bitmap复用机制","url":"/2021/03/27/Glide源码探究-四-Bitmap复用机制/","content":"\n系列文章:\n\n- [Glide源码探究(一) - 生命周期绑定与Request创建](https://blog.islinjw.cn/2021/02/05/Glide%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6-%E4%B8%80-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%91%E5%AE%9A%E4%B8%8ERequest%E5%88%9B%E5%BB%BA/)\n\n- [Glide源码探究(二) - 内存缓存](https://blog.islinjw.cn/2021/02/08/Glide%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6-%E4%BA%8C-%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98/)\n\n- [Glide源码探究(三) - 网络资源加载](https://blog.islinjw.cn/2021/02/10/Glide%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6-%E4%B8%89-%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/)\n\n- [Glide源码探究(四) - Bitmap复用机制](https://blog.islinjw.cn/2021/03/27/Glide%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6-%E5%9B%9B-Bitmap%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6/)\n\n现在的app界面越做越复杂，图片也越来越多，每次切换或者滑动页面就会有旧图片的释放与新图片的加载。如果我们不做特殊的优化，只是简单的释放和创建bitmap，那么除了内存资源申请的耗时，由于内存的不断申请与释放造成的内存抖动会很容易引发GC耗时。卡上加卡，越来越卡......\n\n其实内存抖动问题已经有非常常规的解决策略了，那就是复用池技术。直接的做法就是我们可以拿旧图片的bitmap给新图片去循环利用。\n\n你说巧不巧，Glide里面就是这么做的......\n\n{% img /Glide源码探究四/1.jpeg %}\n\nGlide的Bitmap复用是通过BitmapPool实现的，它在Glide在初始化的时候创建:\n\n```java\nGlide build(@NonNull Context context) {\n  ...\n  if (bitmapPool == null) {\n    int size = memorySizeCalculator.getBitmapPoolSize();\n    if (size > 0) {\n      bitmapPool = new LruBitmapPool(size);\n    } else {\n      bitmapPool = new BitmapPoolAdapter();\n    }\n  }\n  ...\n}\n```\n\nGlide会通过安卓版本、内存大小、屏幕尺寸等参数计算复用池的大小去创建复用池。如果大小是0的话代表不是用复用池，Glide就会用BitmapPoolAdapter去做一个简单的适配。\n\n# BitmapPoolAdapter\n\n简单到基本啥也不做，就只是普通的创建和销毁Bitmap，完全没有复用:\n\n```java\npublic class BitmapPoolAdapter implements BitmapPool {\n  @Override\n  public long getMaxSize() {\n    return 0;\n  }\n\n  @Override\n  public void setSizeMultiplier(float sizeMultiplier) {\n    // Do nothing.\n  }\n\n  @Override\n  public void put(Bitmap bitmap) {\n    bitmap.recycle();\n  }\n\n  @NonNull\n  @Override\n  public Bitmap get(int width, int height, Bitmap.Config config) {\n    return Bitmap.createBitmap(width, height, config);\n  }\n\n  @NonNull\n  @Override\n  public Bitmap getDirty(int width, int height, Bitmap.Config config) {\n    return get(width, height, config);\n  }\n\n  @Override\n  public void clearMemory() {\n    // Do nothing.\n  }\n\n  @Override\n  public void trimMemory(int level) {\n    // Do nothing.\n  }\n}\n```\n\n# LruBitmapPool\n\n所以我们的这篇博客的重点就在LruBitmapPool了。我们在[Glide源码探究(二) - 内存缓存](https://blog.islinjw.cn/2021/02/08/Glide源码探究-二-内存缓存/)里面讲过图片资源引用计数被清零的时候就会从弱引用缓存中删除，加入lru cache中。而如果这个时候lru cache满了的话就会对最近最久未使用的图片资源进行回收。简单来讲就是使用BitmapPool.put方法将它丢到复用池:\n\n```java\npublic class BitmapResource implements Resource<Bitmap>, Initializable {\n  ...\n  @Override\n  public void recycle() {\n    bitmapPool.put(bitmap);\n  }\n  ...\n}\n```\n\n而我们的LruBitmapPool就会将它放到strategy中:\n\n```java\nprivate static LruPoolStrategy getDefaultStrategy() {\n  final LruPoolStrategy strategy;\n  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {\n    strategy = new SizeConfigStrategy();\n  } else {\n    strategy = new AttributeStrategy();\n  }\n  return strategy;\n}\n\n@Override\npublic synchronized void put(Bitmap bitmap) {\n  ... // 判断该bitmap是否可被回收\n  strategy.put(bitmap);\n  ...\n}\n```\n\n从源码可以看出这个strategy在KITKAT以下的版本使用的是AttributeStrategy，在KITKAT以上的版本使用的是SizeConfigStrategy，它们两者同样都是LRU Cache。\n\n## AttributeStrategy\n\n这样区分的原因是安卓4.4对Bitmap的复用做了优化，在4.4以前只有宽高和Config一致的时候才能复用一个bitmap:\n\n```java\nclass AttributeStrategy implements LruPoolStrategy {\n  private final KeyPool keyPool = new KeyPool();\n  private final GroupedLinkedMap<Key, Bitmap> groupedMap = new GroupedLinkedMap<>();\n\n  @Override\n  public void put(Bitmap bitmap) {\n    final Key key = keyPool.get(bitmap.getWidth(), bitmap.getHeight(), bitmap.getConfig());\n\n    groupedMap.put(key, bitmap);\n  }\n\n  @Override\n  public Bitmap get(int width, int height, Bitmap.Config config) {\n    final Key key = keyPool.get(width, height, config);\n\n    return groupedMap.get(key);\n  }\n  ...\n}\n```\n\n## KeyPool\n\n这里的Key是通过图片的大小和config去创建的，由于查询的频率比较高，为了防止这个Key的多次创建，这里也用了池化技术:\n\n```java\nstatic class KeyPool extends BaseKeyPool<Key> {\n\n  public Key get(int size, Bitmap.Config config) {\n    Key result = get();\n    result.init(size, config);\n    return result;\n  }\n\n  @Override\n  protected Key create() {\n    return new Key(this);\n  }\n}\n\nabstract class BaseKeyPool<T extends Poolable> {\n  private static final int MAX_SIZE = 20;\n  private final Queue<T> keyPool = Util.createQueue(MAX_SIZE);\n\n  T get() {\n    T result = keyPool.poll();\n    if (result == null) {\n      result = create();\n    }\n    return result;\n  }\n\n  public void offer(T key) {\n    if (keyPool.size() < MAX_SIZE) {\n      keyPool.offer(key);\n    }\n  }\n\n  abstract T create();\n}\n```\n\n## SizeConfigStrategy\n\n而由于实际开发的时候两张图片资源尺寸完全一样的情况不多(尤其在不同页面)，会导致复用的命中率比较低。而安卓4.4之后如果config相同只需要旧图片Bitmap的内存大小大于新图片需要的内存大小就能拿来复用了，这样就能提高复用的命中率:\n\n```java\npublic class SizeConfigStrategy implements LruPoolStrategy {\n  ...\n  private final GroupedLinkedMap<Key, Bitmap> groupedMap = new GroupedLinkedMap<>();\n  private final Map<Bitmap.Config, NavigableMap<Integer, Integer>> sortedSizes = new HashMap<>();\n  ...\n  @Override\n  public void put(Bitmap bitmap) {\n    int size = Util.getBitmapByteSize(bitmap);\n    Key key = keyPool.get(size, bitmap.getConfig());\n\n    groupedMap.put(key, bitmap); // 缓存bitmap\n\n    NavigableMap<Integer, Integer> sizes = getSizesForConfig(bitmap.getConfig());\n    Integer current = sizes.get(key.size);\n    sizes.put(key.size, current == null ? 1 : current + 1); // size这个大小的bitmap数量加一\n  }\n  ...\n  private NavigableMap<Integer, Integer> getSizesForConfig(Bitmap.Config config) {\n    NavigableMap<Integer, Integer> sizes = sortedSizes.get(config);\n    if (sizes == null) {\n      sizes = new TreeMap<>();\n      sortedSizes.put(config, sizes);\n    }\n    return sizes;\n  }\n  ...\n}\n```\n\n可以看到SizeConfigStrategy在回收的时候除了将bitmap放到groupedMap之外，还会用sortedSizes记录每种config的不同尺寸缓存bitmap缓存的数量。\n\n于是在get的时候只需要在缓存的bitmap里面找到能够满足新的图片内存需求的去复用即可:\n\n```java\npublic Bitmap get(int width, int height, Bitmap.Config config) {\n  int size = Util.getBitmapByteSize(width, height, config);\n  Key bestKey = findBestKey(size, config); // 从缓存的bitmap中找到内存比新图片需要的内存大的\n\n  Bitmap result = groupedMap.get(bestKey);\n  if (result != null) {\n    decrementBitmapOfSize(bestKey.size, result); // 减少sortedSizes中可以复用的bitmap\n    result.reconfigure(width, height, config); // 修改尺寸实现复用\n  }\n  return result;\n}\n```\n\n查找的核心代码在findBestKey:\n\n```java\nprivate Key findBestKey(int size, Bitmap.Config config) {\n  Key result = keyPool.get(size, config);\n  for (Bitmap.Config possibleConfig : getInConfigs(config)) {\n    NavigableMap<Integer, Integer> sizesForPossibleConfig = getSizesForConfig(possibleConfig); // 通过config获取可用的bitmap尺寸\n    Integer possibleSize = sizesForPossibleConfig.ceilingKey(size); // 找到大于size的最小可用尺寸\n    if (possibleSize != null && possibleSize <= size * MAX_SIZE_MULTIPLE) {\n      if (possibleSize != size\n          || (possibleConfig == null ? config != null : !possibleConfig.equals(config))) {\n        // 如果满足复用条件，就将原本的key回收，通过复用的bitmap尺寸创建复用的key\n        keyPool.offer(result);\n        result = keyPool.get(possibleSize, possibleConfig);\n      }\n      break;\n    }\n  }\n  return result;\n}\n```\n\n这里是先通过config获取到缓存的bitmap尺寸，然后通过NavigableMap.ceilingKey方法查找到大于需要尺寸的最小可用尺寸。如果可以找到就能用这个尺寸去groupedMap里面查找Bitmap复用了。\n\n","tags":["技术相关","Android"]},{"title":"源码阅读计划 - LiveData","url":"/2021/03/23/源码阅读计划-LiveData/","content":"\nLiveData是Jetpack里一个十分常用的组件，它是一个可以被观察的数据源。能够感知 Activity等的生命周期，在onStart或者onResume的时候才会回调监听。\n\n这里举个简单的例子，我们在Activity中可以使用DataSource的observe方法去监听内部数据的改变，直接修改TextView，因为这个方法是回调在主线程的。而且可以看到DataSource里面是没有解注册的方法的，原因是LiveData会帮我们自动在LifecycleOwner的onDestory的时候解注册:\n\n```kotlin\nclass DataSource {\n    private val liveData = MutableLiveData<Int>()\n\n    fun observe(owner: LifecycleOwner, observer: Observer<Int>) {\n        liveData.observe(owner, observer)\n    }\n\n    fun loadData() {\n        Thread(Runnable {\n            // 加载数据\n            //liveData.value = 123 // 主线程中\n            liveData.postValue(123) // 子线程中\n        }).start()\n    }\n}\n\n// Activity中监听\ndataSource.observe(this, Observer {data->\n    textView.text = \"data = ${data}\"\n})\n```\n\n知道用法之后我们来看看原理，瞧一瞧它是如何实现的。\n\n# 注册监听\n\n```java\nprivate SafeIterableMap<Observer<? super T>, ObserverWrapper> mObservers =\n            new SafeIterableMap<>();\n\n@MainThread\npublic void observe(@NonNull LifecycleOwner owner, @NonNull Observer<? super T> observer) {\n    // 判断主线程  \n    assertMainThread(\"observe\");\n\n    // 判断是否已经DESTROYED\n    if (owner.getLifecycle().getCurrentState() == DESTROYED) {\n        return;\n    }\n\n    // 创建LifecycleBoundObserver\n    LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);\n  \n\n    // 判断是否已经添加过监听,如果没有就丢入mObservers这个map中保存\n    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);\n    if (existing != null && !existing.isAttachedTo(owner)) {\n        throw new IllegalArgumentException(\"Cannot add the same observer\"\n                + \" with different lifecycles\");\n    }\n    if (existing != null) {\n        return;\n    }\n\n    // 向Lifecycle注册监听\n    owner.getLifecycle().addObserver(wrapper);\n}   \n```\n\n首先是注册监听，这个代码十分简单，具体可以看我写的注释。它最核心的功能就是最后的向Lifecycle注册监听。\n\n# 数据更新与通知\n\n注册完监听之后我们看看数据的更新部分，如果在主线程的话直接调用LiveData的setValue方法即可更新数据:\n\n```java\nprotected void setValue(T value) {\n    assertMainThread(\"setValue\");\n    mVersion++;\n    mData = value;\n    dispatchingValue(null);\n}\n```\n\n这个方法逻辑也很清晰，总共四行就做了四件事情: \n\n1. 判断主线程\n2. 更新数据版本\n3. 更新数据\n4. 分发更新事件\n\ndispatchingValue里面判断传入的initiator是否为空，如果不为空则只通知该observer，否则通知所有的observer:\n\n```java\nvoid dispatchingValue(@Nullable ObserverWrapper initiator) {\n    ...\n\n    if (initiator != null) {\n        considerNotify(initiator);\n        initiator = null;\n    } else {\n        for (Iterator<Map.Entry<Observer<? super T>, ObserverWrapper>> iterator =\n                mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {\n            considerNotify(iterator.next().getValue());\n            ...\n        }\n    }\n    ...\n}\n```\n\nconsiderNotify方法也比较易懂，就是判断Observer是否已经激活，如果没有激活就返回。如果激活了再判断observer是否已经接收到最后一次修改数据的事件(反正Activity反复切换的时候重复通知)，如果没有就调用onChanged方法通知。\n\n```java\nprivate void considerNotify(ObserverWrapper observer) {\n    if (!observer.mActive) {\n        return;\n    }\n    \n    if (!observer.shouldBeActive()) {\n        observer.activeStateChanged(false);\n        return;\n    }\n    if (observer.mLastVersion >= mVersion) {\n        return;\n    }\n    observer.mLastVersion = mVersion;\n    observer.mObserver.onChanged((T) mData);\n}\n```\n\n这里的Active判断其实判断的observer的owner的是否至少是onStart的:\n\n```java\n@Override\nboolean shouldBeActive() {\n    return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);\n}\n```\n\n## 生命周期感知\n\n也就是说如果Activity是在后台的，那么setValue的时候就不会去通知observer，这就是LiveData的生命周期感知机制。那么这个消息是否就丢失了呢？当然不是。\n\n还记得observe方法里面向Lifecycle注册了监听吗:\n\n```java\npublic void observe(@NonNull LifecycleOwner owner, @NonNull Observer<? super T> observer) {\n    ...\n    LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);\n    ...\n    owner.getLifecycle().addObserver(wrapper);\n}   \n```\n\n在Activity走到各个生命周期的时候LifeCycle就会回调LifecycleBoundObserver的onStateChanged方法:\n\n```java\npublic void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) {\n    if (mOwner.getLifecycle().getCurrentState() == DESTROYED) {\n        removeObserver(mObserver);\n        return;\n    }\n    activeStateChanged(shouldBeActive());\n}\n```\n\n在这里面做两件事情:\n\n1. 判断owner是否已经destroy了，如果是就自动解除监听\n2. 如果没有destroy就修改激活状态\n\n如果是start或者resume的activeStateChanged里面就会进行事件方法:\n\n```java\nvoid activeStateChanged(boolean newActive) {\n    ...\n    mActive = newActive;\n    ...\n    if (mActive) {\n        dispatchingValue(this);\n    }\n}\n```\n\ndispatchingValue方法上面讲过，在这里会调用considerNotify去单独分发给initiator。:\n\n```java\nvoid dispatchingValue(@Nullable ObserverWrapper initiator) {\n    ...\n\n    if (initiator != null) {\n        considerNotify(initiator);\n        initiator = null;\n    } else {\n        for (Iterator<Map.Entry<Observer<? super T>, ObserverWrapper>> iterator =\n                mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {\n            considerNotify(iterator.next().getValue());\n            ...\n        }\n    }\n    ...\n}\n```\n\n于是observer就能监听到onStart之前发送的消息了。\n\n# 粘性事件\n\nLiveData的事件都是粘性事件，什么是粘性事件呢？简单来讲就是注册的监听可以接收到注册之前的事件:\n\n```kotlin\nclass DataSource {\n    private val liveData = MutableLiveData<Int>()\n\n    fun observe(owner: LifecycleOwner, observer: Observer<Int>) {\n        liveData.observe(owner, observer)\n    }\n\n    fun loadData() {\n        liveData.value = 123\n    }\n}\n\n// Activity\noverride fun onResume() {\n    super.onResume()\n        // 先发送\n    dataSource.loadData()\n        // 再注册\n    dataSource.observe(this, Observer { data ->\n        Log.d(\"testtest\", \"data = ${data}\")\n    })\n}\n```\n\n这个其实结合上面的更新流程，去到considerNotify里面只要mLastVersion小于LiverData.mVersion就会被通知\n\n```java\nprivate void considerNotify(ObserverWrapper observer) {\n    ...\n    if (observer.mLastVersion >= mVersion) {\n        return;\n    }\n    observer.mLastVersion = mVersion;\n    observer.mObserver.onChanged((T) mData);\n}\n```\n\n而在创建ObserverWrapper的时候mLastVersion初始化是-1:\n\n```java\npublic abstract class LiveData<T> {\n    ...\n    static final int START_VERSION = -1;\n    ...\n    private abstract class ObserverWrapper {\n        ...\n        int mLastVersion = START_VERSION;\n        ...\n    }\n    ...\n}\n```\n\n于是注册的时候就会直接通知到LiveData之前设置的数据了。\n\n## 实现非粘性事件\n\n如果我们不想要这个粘性事件要怎么做呢？从根本原因上来讲是因为observe创建ObserverWrapper的时候mLastVersion直接设置成了-1，所以在分发的时候肯定会被分发一次。也就是说只要我们在创建的时候将mLastVersion设置成当前LiveData的mVersion就能避免了。\n\n但是无论mLastVersion还是mVersion都是没有对外公开的，所以很容易想到继承LiveData在observe的时候反射去修改mLastVersion。但是反射的代码比较恶心，我就不贴出来了。我这里再提供另外一种思路:\n\n```kotlin\nclass MyLiveData<T> : LiveData<T>() {\n    var version = -1\n\n    public override fun setValue(value: T) {\n        version++\n        super.setValue(value)\n    }\n\n    override fun observe(owner: LifecycleOwner, observer: Observer<in T>) {\n        super.observe(owner, ObserverWrapper(observer, version))\n    }\n\n    private inner class ObserverWrapper<T>(\n        private val observer: Observer<in T>,\n        private var version: Int\n    ) :\n        Observer<T> {\n        override fun onChanged(t: T) {\n            if (this.version < this@MyLiveData.version) {\n                observer.onChanged(t)\n            }\n\n            this.version = this@MyLiveData.version\n        }\n    }\n}\n```\n\n代码很简单，我们自己使用装饰器模式再包装了一层维护了LiveData的version和Observer的version进行判断。\n\n# postValue\n\n在上面我们看到setValue是会判断主线程的:\n\n```java\nprotected void setValue(T value) {\n    assertMainThread(\"setValue\");\n    ...\n}\n```\n\n如果我们在子线程里面想要修改数据需要使用postValue:\n\n```java\nprotected void postValue(T value) {\n    boolean postTask;\n    synchronized (mDataLock) {\n        postTask = mPendingData == NOT_SET;\n        mPendingData = value;\n    }\n    if (!postTask) {\n        return;\n    }\n    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);\n}\n\nprivate final Runnable mPostValueRunnable = new Runnable() {\n    public void run() {\n        Object newValue;\n        synchronized (mDataLock) {\n            newValue = mPendingData;\n            mPendingData = NOT_SET;\n        }\n        setValue((T) newValue);\n    }\n};\n```\n\n它的原理其实很简单，将value保存到mPendingData，然后用postToMainThread(最底层其实是Handler.post)将mPostValueRunnable丢到主线程执行setValue(mPendingData)方法.\n\n而且在postValue会判断之前是否有设置过mPendingData，如果有代表已经post过Runnable，于是就不再post第二个，也就是说最多只有一个Runnable会被post。\n\n于是这就有个问题了，就是在子线程中多次postValue，只有最后一个value会在主线程中最终设置。\n\n但其实这个也并不是什么问题，大多数情况下主线程其实并不关心数据是如何一步步更新的，只关心最终的结果。\n\n# observeForever\n\nobserve注册的观察者都是生命周期感知的，如果不是start活着resume状态的话是不能立马接收到消息的。如果我们需要非生命周期感知的话可以使用observeForever方法，里面创建的是AlwaysActiveObserver而不是observe里看到的LifecycleBoundObserver:\n\n```java\npublic void observeForever(@NonNull Observer<? super T> observer) {\n    ...\n    AlwaysActiveObserver wrapper = new AlwaysActiveObserver(observer);\n    ...\n}\n```\n\n它的特点在于shouldBeActive永远是true:\n\n```java\nprivate class AlwaysActiveObserver extends ObserverWrapper {\n    ...\n    @Override\n    boolean shouldBeActive() {\n        return true;\n    }\n}\n```\n\n这就意味着considerNotify里面肯定会继续往下走到version判断那里，不会因为生命周期而提前结束:\n\n```java\nprivate void considerNotify(ObserverWrapper observer) {\n    if (!observer.mActive) {\n        return;\n    }\n    if (!observer.shouldBeActive()) { // AlwaysActiveObserver永远为true\n        observer.activeStateChanged(false);\n        return;\n    }\n    if (observer.mLastVersion >= mVersion) {\n        return;\n    }\n    observer.mLastVersion = mVersion;\n    observer.mObserver.onChanged((T) mData);\n}\n```\n\n","tags":["技术相关","Android"]},{"title":"源码阅读计划 - ARouter","url":"/2021/03/18/源码阅读计划_ARouter/","content":"\n# 初始化\n\nARouter的源码相对来讲还是比较简单易懂的，我们先从初始化部分的逻辑开始看。它的初始化代码只有一行，一般放在Application.onCreate()中:\n\n```java\nARouter.init(this)\n```\n\n我们最追进去可以看到它将实际的初始化逻辑委托给\\_ARouter这个类去处理:\n\n```java\npublic static void init(Application application) {\n    if (!hasInit) {\n        ...\n        hasInit = _ARouter.init(application);\n\n        if (hasInit) {\n            _ARouter.afterInit();\n        }\n        ...\n    }\n}\n```\n\n继续看\\_ARouter.init又会发现它又将初始化的逻辑放到LogisticsCenter.init:\n\n```java\nprotected static synchronized boolean init(Application application) {\n        mContext = application;\n        LogisticsCenter.init(mContext, executor);\n        logger.info(Consts.TAG, \"ARouter init success!\");\n        hasInit = true;\n        mHandler = new Handler(Looper.getMainLooper());\n\n        return true;\n}\n```\n\n最后来的LogisticsCenter.init就能看的真正的初始化逻辑:\n\n```java\npublic synchronized static void init(Context context, ThreadPoolExecutor tpe) throws HandlerException {\n    ...\n    loadRouterMap();\n    if (registerByPlugin) {\n        logger.info(TAG, \"Load router map by arouter-auto-register plugin.\");\n    } else {\n        // 从dex中加载路由表,耗时操作\n    }\n    ...\n}\n```\n\n一般情况下我们都会使用gradle插件去生成注册代码以加快启动速度，loadRouterMap()方法里面就是这些生成的代码，注册完成之后registerByPlugin被设置成true，不会跑到下面的耗时操作中。这里我想先讲讲这个耗时操作到底有多耗时:\n\n```java\nSet<String> routerMap;\n\nif (ARouter.debuggable() || PackageUtils.isNewVersion(context)) {\n    routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);\n    if (!routerMap.isEmpty()) {\n        context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE)\n                .edit()\n                .putStringSet(AROUTER_SP_KEY_MAP, routerMap)\n                .apply();\n    }\n\n    PackageUtils.updateVersion(context);\n} else {\n    routerMap = new HashSet<>(context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE)\n                        .getStringSet(AROUTER_SP_KEY_MAP, new HashSet<String>()));\n}\n\nfor (String className : routerMap) {\n    if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) {\n        ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex);\n    } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) {\n        ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex);\n    } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) {\n        ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex);\n    }\n}\n```\n\n上面是我删除多余注释之后的代码，可以看到其实它的流程并不复杂。先判断是否为debug模式或者版本是否有更新，如果是就使用ClassUtils.getFileNameByPackageName查找下面这些类:\n\n- com.alibaba.android.arouter.routes.ARouter\\$\\$Root\\$\\$XXX\n- com.alibaba.android.arouter.routes.ARouter\\$\\$Interceptors\\$\\$XXX\n- com.alibaba.android.arouter.routes.ARouter\\$\\$Providers\\$\\$XXX\n\n查找到的话将他们保存搭配sp中，避免每次启动都需要查找，下一次直接从sp中读取即可。\n\n然后就会利用反射机制创建这些类的实例并且调用loadInto方法，将路由加载到Warehouse的对应map中。\n\nClassUtils.getFileNameByPackageName很暴力，直接开启线程去读取dex文件进行类的遍历:\n\n```java\npublic static Set<String> getFileNameByPackageName(Context context, final String packageName) throws PackageManager.NameNotFoundException, IOException, InterruptedException {\n    final Set<String> classNames = new HashSet<>();\n\n    List<String> paths = getSourcePaths(context);\n    final CountDownLatch parserCtl = new CountDownLatch(paths.size());\n\n    for (final String path : paths) {\n        DefaultPoolExecutor.getInstance().execute(new Runnable() {\n            @Override\n            public void run() {\n                ...\n                if (path.endsWith(EXTRACTED_SUFFIX)) {\n                    dexfile = DexFile.loadDex(path, path + \".tmp\", 0);\n                } else {\n                    dexfile = new DexFile(path);\n                }\n\n                Enumeration<String> dexEntries = dexfile.entries();\n                while (dexEntries.hasMoreElements()) {\n                    String className = dexEntries.nextElement();\n                    if (className.startsWith(packageName)) {\n                        classNames.add(className);\n                    }\n                }\n                ...\n                parserCtl.countDown();\n                \n            }\n        });\n    }\n\n    parserCtl.await();\n    return classNames;\n}\n```\n\ngetSourcePaths方法是查找这个app的所有dex文件的路径，我就不展开了。可以看出来这个流程需要遍历该app的所有dex的所有类去匹配类名，的确十分耗时。\n\n## arouter-register\n\n于是乎arouter提供了arouter-register用于优化初始化速度:\n\n1. 在根目录的build.gradle加上插件的classpath\n\n```groovy\nbuildscript {\n    dependencies {\n        classpath \"com.alibaba:arouter-register:1.0.2\"\n    }\n}\n```\n\n2. 在app目录下的build.gradle使用插件\n\n```groovy\napply plugin: 'com.alibaba.arouter'\n```\n\n这个插件会在编译的时候使用用ASM向loadRouterMap方法插入注册代码:\n\n```java\nprivate static void loadRouterMap() {\n  registerByPlugin = false;\n  //auto generate register code by gradle plugin: arouter-auto-register\n  // looks like below:\n  // registerRouteRoot(new ARouter..Root..modulejava());\n  // registerRouteRoot(new ARouter..Root..modulekotlin());\n}\n```\n\n我们可以使用jadx反编译生成的apk看到插入的代码:\n\n{% img /源码阅读计划_ARouter/1.png %}\n\nregister方法会根据类型调用不同的注册方法，但是它们都会使用markRegisteredByPlugin方法将registerByPlugin设置成true，以跳过dex的遍历:\n\n```java\nprivate static void register(String className) {\n    ...\n    Class<?> clazz = Class.forName(className);\n    Object obj = clazz.getConstructor().newInstance();\n    if (obj instanceof IRouteRoot) {\n        registerRouteRoot((IRouteRoot) obj);\n    } else if (obj instanceof IProviderGroup) {\n        registerProvider((IProviderGroup) obj);\n    } else if (obj instanceof IInterceptorGroup) {\n        registerInterceptor((IInterceptorGroup) obj);\n    } \n    ...\n}\nprivate static void registerRouteRoot(IRouteRoot routeRoot) {\n    markRegisteredByPlugin();\n    if (routeRoot != null) {\n        routeRoot.loadInto(Warehouse.groupsIndex);\n    }\n}\nprivate static void registerProvider(IProviderGroup providerGroup) {\n    markRegisteredByPlugin();\n    if (providerGroup != null) {\n        providerGroup.loadInto(Warehouse.providersIndex);\n    }\n}\nprivate static void registerInterceptor(IInterceptorGroup interceptorGroup) {\n    markRegisteredByPlugin();\n    if (interceptorGroup != null) {\n        interceptorGroup.loadInto(Warehouse.interceptorsIndex);\n    }\n}\nprivate static void markRegisteredByPlugin() {\n    if (!registerByPlugin) {\n        registerByPlugin = true;\n    }\n}\n```\n\n## 路由的注册\n\n在上面的代码中我们知道ARouter在初始化的时候会调用IRouteRoot、IProviderGroup、IInterceptorGroup的loadInto方法将路由加载到Warehouse中。那这些类又是怎么知道我们代码里面用@Router注册的路径的?例如下面的MainActivity:\n\n```kotlin\n@Route(path = \"/activity/home\")\nclass MainActivity : BaseActivity() {\n    ...\n}\n```\n\n其实这些类都是由ARouter在编译的时候生成的:\n\n{% img /源码阅读计划_ARouter/2.png %}\n\n像ARouter\\$\\$Root\\$\\$app这个分组类就注册了我们的页面路由，而ARouter\\$\\$Root\\$\\$provider这个分组类就注册了我们的provider路由:\n\n```java\npublic class ARouter$$Root$$app implements IRouteRoot {\n  @Override\n  public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {\n    routes.put(\"activity\", ARouter$$Group$$activity.class);\n    routes.put(\"provider\", ARouter$$Group$$provider.class);\n  }\n}\n\npublic class ARouter$$Group$$activity implements IRouteGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> atlas) {\n    atlas.put(\"/activity/date\", RouteMeta.build(RouteType.ACTIVITY, DateActivity.class, \"/activity/date\", \"activity\", null, -1, -2147483648));\n    atlas.put(\"/activity/edit\", RouteMeta.build(RouteType.ACTIVITY, EditActivity.class, \"/activity/edit\", \"activity\", new java.util.HashMap<String, Integer>(){{put(\"taskGroupId\", 4); }}, -1, -2147483648));\n    atlas.put(\"/activity/home\", RouteMeta.build(RouteType.ACTIVITY, MainActivity.class, \"/activity/home\", \"activity\", null, -1, -2147483648));\n    atlas.put(\"/activity/login\", RouteMeta.build(RouteType.ACTIVITY, LoginActivity.class, \"/activity/login\", \"activity\", null, -1, -2147483648));\n    atlas.put(\"/activity/register\", RouteMeta.build(RouteType.ACTIVITY, RegisterActivity.class, \"/activity/register\", \"activity\", null, -1, -2147483648));\n    atlas.put(\"/activity/welcome\", RouteMeta.build(RouteType.ACTIVITY, WelcomeActivity.class, \"/activity/welcome\", \"activity\", null, -1, -2147483648));\n  }\n}\n\npublic class ARouter$$Group$$provider implements IRouteGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> atlas) {\n    atlas.put(\"/provider/demoProvider\", RouteMeta.build(RouteType.PROVIDER, DemoProvider.class, \"/provider/demoprovider\", \"provider\", null, -1, -2147483648));\n  }\n}\n```\n\nARouter\\$\\$Root\\$\\$app的后缀\"app\"字符串是由gradle里面配置的AROUTER\\_MODULE\\_NAME决定的,一般我们设置成module的名字，这样不同module生成的类就不会重名:\n\n```groovy\njavaCompileOptions {\n    annotationProcessorOptions {\n        arguments = [\n                AROUTER_MODULE_NAME  : project.getName(),\n        ]\n    }\n}\n```\n\n从上面可以看到IRouteRoot并不会直接将所有的路由信息直接加载进去，而是加载分组信息IRouteGroup。IRouteGroup会在navigation查找的时候再去加载对应分组的路由表。\n\n## 路由分组\n\n我们从上面的截图可以看到ARouter\\$\\$Group\\$\\$activity、ARouter\\$\\$Group\\$\\$provider这样的类，它就是activity和provider这两个分组的路由表注册逻辑。由于路由表可能会比较大，一次全部加载可能影响启动耗时，所以ARouter设计了路由分组的概念，在需要的时候才去加载。默认path的第一级就是分组，例如下面的activity:\n\n```kotlin\n@Route(path = \"/activity/home\")\nclass MainActivity : BaseActivity() {\n    ...\n}\n```\n\n当然你也可以主动指定分组:\n\n```kotlin\n@Route(path = Router.ActivityHome.PATH, group = \"xxx\")\nclass MainActivity : BaseActivity() {\n    ...\n}\n```\n\n于是@Router注解就会生成ARouter\\$\\$Group\\$\\$xxx这样的类去管理该分组下的路由表的加载。\n\n## 拦截器初始化\n\n由于拦截器不需要我们等主动去获取，在navigation的时候就会自动调用，所以ARouter在初始化的时候就会顺便将拦截器给初始化了。在ARouter.init的后面会调用\\_ARouter.afterInit去初始化拦截器\n\n```java\n//ARouter.java\npublic static void init(Application application) {\n    if (!hasInit) {\n        ...\n        hasInit = _ARouter.init(application);\n\n        if (hasInit) {\n            _ARouter.afterInit();\n        }\n        ...\n    }\n}\n\n//_ARouter.java\nstatic void afterInit() {\n    interceptorService = (InterceptorService) ARouter.getInstance().build(\"/arouter/service/interceptor\").navigation();\n}\n```\n\n在afterInit里面会去创建InterceptorServiceImpl，它是一个IProvider，会在它的init方法里实例化拦截器并且添加到Warehouse.interceptors列表里面提供页面路由的时候调用:\n\n```java\n@Route(path = \"/arouter/service/interceptor\")\npublic class InterceptorServiceImpl implements InterceptorService {\n    //...\n    @Override\n    public void init(final Context context) {\n        LogisticsCenter.executor.execute(new Runnable() {\n            @Override\n            public void run() {\n                //...\n                for (Map.Entry<Integer, Class<? extends IInterceptor>> entry : Warehouse.interceptorsIndex.entrySet()) {\n                    Class<? extends IInterceptor> interceptorClass = entry.getValue();\n                    try {\n                        IInterceptor iInterceptor = interceptorClass.getConstructor().newInstance();\n                        iInterceptor.init(context);\n                        Warehouse.interceptors.add(iInterceptor);\n                    } catch (Exception ex) {\n                        throw new HandlerException(TAG + \"ARouter init interceptor error! name = [\" + interceptorClass.getName() + \"], reason = [\" + ex.getMessage() + \"]\");\n                    }\n                }\n                //...\n            }\n        });\n    }\n    //...\n}\n```\n\nWarehouse.interceptorsIndex是一个UniqueKeyTreeMap，它在前面被扫描dex或者生成代码注册。key为拦截器的优先级，所以拦截器的优先级是不能有相同的:\n\n```java\n// Warehouse.java\nstatic Map<Integer, Class<? extends IInterceptor>> interceptorsIndex = new UniqueKeyTreeMap<>(\"More than one interceptors use same priority [%s]\");\n\n//UniqueKeyTreeMap.java\npublic class UniqueKeyTreeMap<K, V> extends TreeMap<K, V> {\n    private String tipText;\n\n    public UniqueKeyTreeMap(String exceptionText) {\n        super();\n\n        tipText = exceptionText;\n    }\n\n    @Override\n    public V put(K key, V value) {\n        if (containsKey(key)) {\n            throw new RuntimeException(String.format(tipText, key));\n        } else {\n            return super.put(key, value);\n        }\n    }\n}\n```\n\n# navigation\n\n使用ARouter进行页面跳转只需要下面的简单代码，build方法会分析路径，查找分组信息创建Postcard对象，然后使用Postcard对象的navigation进行跳转:\n\n```java\nARouter.getInstance()\n      .build(\"/activity/home\")\n      .navigation()\n```\n\n当然navigation不一定是跳转页面，也可能直接返回查找到的IProvider等组件，下面我们就来看看具体的实现逻辑。由于navigation最后面是跑到\\_ARouter.navigation里面的，我们直接从这个方法开始分析:\n\n```java\nprotected Object navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) {\n    ...\n    LogisticsCenter.completion(postcard);\n    ...\n    if (!postcard.isGreenChannel()) {\n        interceptorService.doInterceptions(postcard, new InterceptorCallback() {\n            @Override\n            public void onContinue(Postcard postcard) {\n                _navigation(context, postcard, requestCode, callback);\n            }\n\n            @Override\n            public void onInterrupt(Throwable exception) {\n                if (null != callback) {\n                    callback.onInterrupt(postcard);\n                }\n            }\n        });\n    } else {\n        return _navigation(context, postcard, requestCode, callback);\n    }\n\n    return null;\n}\n```\n\n这里面的逻辑分三部分:\n\n1. 使用LogisticsCenter.completion去查找路由表，将查找到的信息填充到postcard里面\n2. 如果postcard不走绿色通道，就调用拦截器逻辑\n3. 走绿色通道或者拦截器处理完成之后调用\\_navigation进行实际的页面跳转或者返回查找到的组件\n\n## 路由表查找\n\n我们先看看completion查找路由表的逻辑:\n\n```java\npublic synchronized static void completion(Postcard postcard) {\n    ...\n    RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());\n    if (null == routeMeta) {    // Maybe its does't exist, or didn't load.\n        Class<? extends IRouteGroup> groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  // Load route meta.\n        if (null == groupMeta) {\n            throw new NoRouteFoundException(TAG + \"There is no route match the path [\" + postcard.getPath() + \"], in group [\" + postcard.getGroup() + \"]\");\n        } else {\n            ...\n            IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();\n            iGroupInstance.loadInto(Warehouse.routes);\n            Warehouse.groupsIndex.remove(postcard.getGroup());\n            ...\n            completion(postcard);   // Reload\n        }\n    } else {\n        postcard.setDestination(routeMeta.getDestination());\n        postcard.setType(routeMeta.getType());\n        postcard.setPriority(routeMeta.getPriority());\n        postcard.setExtra(routeMeta.getExtra());\n\n        Uri rawUri = postcard.getUri();\n        if (null != rawUri) {   // Try to set params into bundle.\n            ...\n        }\n\n        switch (routeMeta.getType()) {\n            case PROVIDER:\n                Class<? extends IProvider> providerMeta = (Class<? extends IProvider>) routeMeta.getDestination();\n                IProvider instance = Warehouse.providers.get(providerMeta);\n                if (null == instance) { // There's no instance of this provider\n                    ...\n                    provider = providerMeta.getConstructor().newInstance();\n                    provider.init(mContext);\n                    Warehouse.providers.put(providerMeta, provider);\n                    instance = provider;\n                    ...\n                }\n                postcard.setProvider(instance);\n                postcard.greenChannel();    // Provider should skip all of interceptors\n                break;\n            case FRAGMENT:\n                postcard.greenChannel();    // Fragment needn't interceptors\n            default:\n                break;\n        }\n    }\n}\n```\n\n它会先查找Warehouse.routes这个缓存，如果找不到就先去查找分组并加载该分组的路由表到Warehouse.routes，然后递归调用自己重新查找Warehouse.routes。这次就能查找到路由信息了，于是将该path对应的组件的信息填充到postcard。\n\n而且我们可以看到如果是Provider或者Fragment，就会走绿色通道，因为它们是不会被拦截器拦截的。\n\n整体流程如下:\n\n{% img /源码阅读计划_ARouter/3.png %}\n\n## 拦截器调用原理\n\n查找路由表成功填充信息之后如果不走绿色通道的话就会先去调用interceptorService.doInterceptions走拦截器的流程:\n\n```java\n@Override\npublic void doInterceptions(final Postcard postcard, final InterceptorCallback callback) {\n    ...\n    LogisticsCenter.executor.execute(new Runnable() {\n        @Override\n        public void run() {\n            CancelableCountDownLatch interceptorCounter = new CancelableCountDownLatch(Warehouse.interceptors.size());\n            try {\n                _execute(0, interceptorCounter, postcard);\n                interceptorCounter.await(postcard.getTimeout(), TimeUnit.SECONDS);\n                if (interceptorCounter.getCount() > 0) {    // Cancel the navigation this time, if it hasn't return anythings.\n                    callback.onInterrupt(new HandlerException(\"The interceptor processing timed out.\"));\n                } else if (null != postcard.getTag()) {    // Maybe some exception in the tag.\n                    callback.onInterrupt(new HandlerException(postcard.getTag().toString()));\n                } else {\n                    callback.onContinue(postcard);\n                }\n            } catch (Exception e) {\n                callback.onInterrupt(e);\n            }\n        }\n    });\n    ...\n}\n```\n\n首先看doInterceptions的逻辑我们可以知道它创建了一个子线程去使用\\_execute方法调用拦截器，并且使用CancelableCountDownLatch等待所有拦截器执行完毕。也就是说\\_execute里面可能也是存在子线程的:\n\n```java\nprivate static void _execute(final int index, final CancelableCountDownLatch counter, final Postcard postcard) {\n    if (index < Warehouse.interceptors.size()) {\n        IInterceptor iInterceptor = Warehouse.interceptors.get(index);\n        iInterceptor.process(postcard, new InterceptorCallback() {\n            @Override\n            public void onContinue(Postcard postcard) {\n                counter.countDown();\n                _execute(index + 1, counter, postcard);  \n            }\n\n            @Override\n            public void onInterrupt(Throwable exception) {\n                postcard.setTag(null == exception ? new HandlerException(\"No message.\") : exception.getMessage());    \n                counter.cancel();\n                ...\n            }\n        });\n    }\n}\n```\n\n\\_execute里面的逻辑也比较容易看懂，根据传入的index参数从拦截器数组获取拦截器，并且调用拦截器的process方法，这个方法就是我们使用拦截器需要实现的接口，在内部可能会开子线程或者去到主线程弹出对话框让用户选择。当拦截逻辑处理完之后就必现要回调callback的onContinue方法或者onInterrupt，让它去到下一个拦截器或者取消整个路由流程。__所以我们这自定义拦截器的时候不要忘了调用onContinue或者onInterrupt。__\n\n整个拦截器的流程如下:\n\n{% img /源码阅读计划_ARouter/4.png %}\n\n总结下就是doInterceptions里面开启子线程，设置CancelableCountDownLatch为拦截器数组大小，然后调用第一个拦截器，接着线程等待CountDown取消或者为0。拦截器调用onContinue让CountDown减一和继续调用下一个拦截器直到遍历完所有拦截器或者有拦截器调用onInterrupt。\n\n所以我们在navigation的时候如果不是绿色通道，需要走到拦截器的话并不会立马跳转，而是会开启子线程等待拦截器处理，也就是说__拦截器是运行在子线程里面的。__\n\n## \\_navigation\n\n走完拦截器就去到了\\_navigation方法。这个方法比较简单，就是判断类型进行页面跳转或者创建返回:\n\n```java\n    private Object _navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) {\n        final Context currentContext = null == context ? mContext : context;\n\n        switch (postcard.getType()) {\n            case ACTIVITY:\n                final Intent intent = new Intent(currentContext, postcard.getDestination());\n                intent.putExtras(postcard.getExtras());\n                int flags = postcard.getFlags();\n                if (-1 != flags) {\n                    intent.setFlags(flags);\n                } else if (!(currentContext instanceof Activity)) {    // Non activity, need less one flag.\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                }\n                String action = postcard.getAction();\n                if (!TextUtils.isEmpty(action)) {\n                    intent.setAction(action);\n                }\n                runInMainThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        startActivity(requestCode, currentContext, intent, postcard, callback);\n                    }\n                });\n                break;\n            case PROVIDER:\n                return postcard.getProvider();\n            case BOARDCAST:\n            case CONTENT_PROVIDER:\n            case FRAGMENT:\n                Class fragmentMeta = postcard.getDestination();\n                try {\n                    Object instance = fragmentMeta.getConstructor().newInstance();\n                    if (instance instanceof Fragment) {\n                        ((Fragment) instance).setArguments(postcard.getExtras());\n                    } else if (instance instanceof android.support.v4.app.Fragment) {\n                        ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras());\n                    }\n\n                    return instance;\n                } catch (Exception ex) {\n                    logger.error(Consts.TAG, \"Fetch fragment instance error, \" + TextUtils.formatStackTrace(ex.getStackTrace()));\n                }\n            case METHOD:\n            case SERVICE:\n            default:\n                return null;\n        }\n\n        return null;\n    }\n```\n\n## Provider类型查找\n\n除了使用路径去查找Provider之外，我们还可以用Provider的类型去查找:\n\n```kotlin\nval provider = ARouter.getInstance().navigation(DemoProvider::class.java)\n```\n\n这里是通过类的Name或者SimpleName从providersIndex去查找的:\n\n```java\nprotected <T> T navigation(Class<? extends T> service) {\n    try {\n        Postcard postcard = LogisticsCenter.buildProvider(service.getName());\n        if (null == postcard) {\n            postcard = LogisticsCenter.buildProvider(service.getSimpleName());\n        }\n        if (null == postcard) {\n            return null;\n        }\n        LogisticsCenter.completion(postcard);\n        return (T) postcard.getProvider();\n    } catch (NoRouteFoundException ex) {\n        return null;\n    }\n}\n\npublic static Postcard buildProvider(String serviceName) {\n    RouteMeta meta = Warehouse.providersIndex.get(serviceName);\n\n    if (null == meta) {\n        return null;\n    } else {\n        return new Postcard(meta.getPath(), meta.getGroup());\n    }\n}\n```\n\n是我们在ARouter\\$\\$Provider\\$\\$xxx里面注册的:\n\n{% img /源码阅读计划_ARouter/5.png %}\n\n```java\npublic class ARouter$$Providers$$app implements IProviderGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> providers) {\n    providers.put(\"me.linjw.checklist.DemoProvider\", RouteMeta.build(RouteType.PROVIDER, DemoProvider.class, \"/provider/demoProvider\", \"provider\", null, -1, -2147483648));\n  }\n}\n```\n\n# @Autowired自动注入原理\n\n最后我们来讲讲@Autowired自动注入。它的使用也很方便，使用@Autowired修饰想要注入的数据，然后再使用ARouter.getInstance().inject(this)进行自动注入将intent携带的数据注入:\n\n```kotlin\n@Route(path = Router.ActivityHome.PATH)\nclass MainActivity : BaseActivity() {\n    @Autowired\n    lateinit var data : String\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        ARouter.getInstance().inject(this)\n        ...\n    }\n}\n```\n\ninject最后会根据类名查找到对应的ISyringe，并且调用它的inject实现注入:\n\n```java\n// _Arouter.java\nstatic void inject(Object thiz) {\n    AutowiredService autowiredService = ((AutowiredService) ARouter.getInstance().build(\"/arouter/service/autowired\").navigation());\n    if (null != autowiredService) {\n        autowiredService.autowire(thiz);\n    }\n}\n\n\n// AutowiredServiceImpl.java\n@Override\npublic void autowire(Object instance) {\n    doInject(instance, null);\n}\n\nprivate void doInject(Object instance, Class<?> parent) {\n    Class<?> clazz = null == parent ? instance.getClass() : parent;\n\n    ISyringe syringe = getSyringe(clazz);\n    if (null != syringe) {\n        syringe.inject(instance);\n    }\n    ...\n}\n```\n\n这个ISyringe也是ARouter自动生成的，它不需要使用反射而是直接设置，所以__@Autowired修饰的数据不能是private的__:\n\n```java\npublic class MainActivity$$ARouter$$Autowired implements ISyringe {\n  private SerializationService serializationService;\n\n  @Override\n  public void inject(Object target) {\n    serializationService = ARouter.getInstance().navigation(SerializationService.class);\n    MainActivity substitute = (MainActivity)target;\n    substitute.data = substitute.getIntent().getStringExtra(\"data\");\n  }\n}\n```\n\n","tags":["技术相关","Android"]},{"title":"stm32 can总线学习笔记","url":"/2021/02/26/stm32-can总线学习笔记/","content":"\n这段时间折腾stm32与树莓派之间的can总线通讯遇到了不少问题,树莓派那端的已经写在[树莓派外挂MCP2515模块爬坑记录](https://blog.islinjw.cn/2021/02/09/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%A4%96%E6%8C%82MCP2515%E6%A8%A1%E5%9D%97%E7%88%AC%E5%9D%91%E8%AE%B0%E5%BD%95/)里面了。这次来总结下CAN总线协议和讲讲stm32如何使用CAN总线。\n\n# can总线协议基础\n\n首先我们来大概看看CAN总线协议是怎样的。\n\n完整的CAN电路是由CAN控制器和CAN收发器组成的。协议相关的内容由CAN控制器完成。CAN 控制器和CAN收发器用CAN TX和CAN RX两根线传输TTL电平信号。低电平代表二进制的0,高电平代表二进制的1。\n\nCAN H 和CAN L就是CAN总线,所有设备的CAN 收发器都会挂在这两根线上。数据通过差分信号在这两个线间传输:\n\n- CAN H - CAN L < 0.5V 表示二进制的1\n- CAN H - CAN L > 0.9V 表示二进制的0\n\n为了避免信号的反射和干扰，还需要在CAN H和CAN L之间接上120欧姆的终端电阻。\n\n{% img /stm32can学习笔记/1.png %}\n\nCAN收发器将CAN控制器通过CAN TX线传来的二进制码流转换为差分信号用CAN H、CAN L两根线发送出去。同时接收端设备的CAN接收器会监听CAN H、CAN L两根线的差分信号，转换成二进制码流通过CAN RX线传给CAN控制器\n\n## 位时序\n\ncan总线并没有主从之分,当can总线上的一个设备发送数据时,它以广播的形式在can总线上发送报文给所有的设备。其他设备通过过滤报文的id,处理自己感兴趣的报文。\n\n由于CAN通讯协议并没有时钟信号线,所以要求发送端与接收端的波特率是一致的,而can总线的数据发送效率需要我们去自定义。\n\n要设置设置速率，我先要了解CAN的位时序概念。CAN协议把每个bit分成了四个时间段。我们可以用示波器在CAN TX或者CAN RX上量到下面的10101的波形,把每个bit的波形放大其实会有四段时间:\n\n{% img /stm32can学习笔记/2.png %}\n\n- ss : 同步段（Synchronization Segment）固定为1Tq\n- pts : 传播段（Propagation Time Segment）1~8Tq\n- pbs1 : 相位缓冲段1（Phase Buffer Segment 1）1~8Tq\n- pbs2 : 相位缓冲段2（Phase Buffer Segment 2）2~8Tq\n\n每个段的时长单位是Tq(Time Quantum),这个Tq可以由我们去设置,例如设置为1000ns。\n\n# stm32 位时序配置\n\n上面的是标准的CAN总线位时序,具体每一段的意义我没有深入去了解,但是对于使用来讲并不重要。而stm32里面将pts和pbs1合并了,所以它剩下了三段:\n\n- ss : Synchronization Segment固定为1Tq\n- ts1 : Time segment 1, 即 pts + pbs1\n- ts2 : Time segment 2, 即pbs2\n\n由于ss固定为1Tq，所以我们在STM32CubeMX里面可以设置的是Tq、ts1和ts2:\n\n{% img /stm32can学习笔记/3.png %}\n\nTq并不能直接设置,要通过Prescaler设置分频去设置。\n\n例如我们将can的时钟频率设置为36MHz:\n\n{% img /stm32can学习笔记/4.png %}\n\n所以Prescaler设置成36的时候Tq可以这样计算:\n1Tq = 36 MHz / 36 = 1 MHz = 1000 ns\n\n这个时候我们就能去计算一个bit的时间了,如上图我们把ts1设置为4,ts2设置为5,再加上ss固定的1Tq:\n\n1Tq + 4Tq + 5Tq = 10 Tq = 10000 ns = 10 us\n\n波特率为 1 s / 10 us = 100k\n\n于是我们可以在树莓派中设置CAN的波特率为100k:\n\n```\nsudo ip link set can0 up type can bitrate 100000\n```\n\n当然也可以设置每一段的时间:\n\n```\nsudo ip link set can0 up type can tq 1000 prop-seg 3 phase-seg1 1 phase-seg2 5 sjw 4\n```\n\nprop-seg和phase-seg1加起来等于ts1即可。当然有同学会看到还有另外一个sjw(ReSynchronization Jump Width)的参数,这个时间是用于同步的不影响波特率,范围是1~4Tq,我这里设置成4Tq。\n\n# 标准帧与拓展帧\n\n如此配置之后树莓派就能接收到stm32通过CAN总线发送的数据了,发送的代码如下:\n\n```\nHAL_StatusTypeDef Can_TxMessage(uint8_t ide,uint32_t id,uint8_t len,uint8_t *data)\n{\n    uint32_t   TxMailbox;\n    CAN_TxHeaderTypeDef CAN_TxHeader;\n    HAL_StatusTypeDef   HAL_RetVal;\n    uint16_t i=0;\n    if(ide == 0)\n    {\n        CAN_TxHeader.IDE = CAN_ID_STD;\n        CAN_TxHeader.StdId = id;\n    }\n    else\n    {\n        CAN_TxHeader.IDE = CAN_ID_EXT;\n        CAN_TxHeader.ExtId = id;\n    }\n    CAN_TxHeader.DLC = len;\n    CAN_TxHeader.RTR = CAN_RTR_DATA;\n    CAN_TxHeader.TransmitGlobalTime = DISABLE;\n    while(HAL_CAN_GetTxMailboxesFreeLevel(&hcan) == 0)\n    {\n        i++;\n        if(i>0xfffe)\n        {\n            return HAL_ERROR;\n        }\n    }\n    HAL_Delay(500);\n    HAL_RetVal = HAL_CAN_AddTxMessage(&hcan,&CAN_TxHeader,data,&TxMailbox);\n    if(HAL_RetVal != HAL_OK)\n    {\n        return HAL_ERROR;\n    }\n    return HAL_OK;\n}\n\n// 发送数据\nuint8_t data[8]={170,170,170,170,170,170,170,170};\nCan_TxMessage(0,0x222,8,data);\n```\n\nCan_TxMessage的第一个参数可以配置CAN报文是标准帧还是拓展帧。它们其实基本只有id的长度不一样而已。这个id就是上面我们提到的用于过滤CAN广播的标识符。\n标准帧的id有11位,这11位被命名为STDID。拓展帧在标准帧的基础上增加了18位所以有29位,这个拓展的18位被命名为EXID。\n\n\n\n# stm32 CAN id过滤器\n\nstm32 提供了一组过滤器,可以用于过滤CAN报文,只要符合某一个过滤器的规则,该报文即被接收。\n\n过滤器过滤报文有两种模式: 列表模式与掩码模式\n\n## 掩码模式\n\n掩码模式下我们需要配置屏蔽寄存器和标识符寄存器，屏蔽寄存器用于配置需要匹配的CAN id的比特位。屏蔽码寄存器某位为1表示接收到的CAN ID对应的位必须和标识符寄存器对应的位相同。\n\n例如我们将屏蔽码寄存器配置为0xF,意味着我们只关心CAN ID二进制的后4位,此时再将标识符寄存器配置为0xa,意味着所有二进制后四位为1010的CAN ID都能能被接收(例如0xa/0xaa/0xffa等)。\n\n```\n0000 0000 ffff  # 掩码寄存器\n0000 0000 1010  # 标识符寄存器\n--------------\n0000 0000 1010  # 0xa\n0000 1010 1010  # 0xaa\n1111 1111 1010  # 0xffa\n```\n\n原理是这个原理,但是是stm32的配置还是需要了解一下的。虽然CAN报文的id长度只有标准帧的11位或者拓展帧的29位，但是stm32中却是用了16位宽或者32位宽的寄存器去保存掩码和标识符。所以会有除了id和mask之外还会有其他的位需要配置。\n\n### 32位宽的掩码模式\n\n我们先来看下面这附图，它说明了32位宽的掩码模式的寄存器每一位的作用:\n\n{% img /stm32can学习笔记/5.jpg %}\n\nid和mask皆由4个字节组成,第一个字节存放了STDID的10\\~3bit，第二个字节放了STDID的2\\~0bit还有EXID的17\\~13bit，第三个字节放了EXID的12\\~5bit，第四个字节放了EXID的4\\~0bit、IDE（扩展帧标识）、RTR（远程帧标志）和一个预留的0。\n\n我们在代码中通过FilterMaskIdHigh、FilterIdLow、FilterMaskIdHigh、FilterMaskIdLow去设置掩码和标识符:\n\n```\nuint32_t ext_id =0xa;\nuint32_t mask =0xf;\n\nCAN_FilterTypeDef CAN_FilterType;\n\n// 过滤器的id,STM32F072RBTx提供了14个过滤器所以id可以配置成0~13\nCAN_FilterType.FilterBank=0;\n\n// 设置位宽为32位\nCAN_FilterType.FilterScale=CAN_FILTERSCALE_32BIT;\n\n// 设置为掩码模式\nCAN_FilterType.FilterMode=CAN_FILTERMODE_IDMASK;\n\n// 设置前两个字节的STDID[10:3]、STDID[2:0]、EXID[17:13]\nCAN_FilterType.FilterIdHigh=((ext_id<<3) >>16) &0xffff;\n\n// 设置后两个字节的EXID[12:5]、EXID[4:0]、IDE、RTR、预留的一个0\nCAN_FilterType.FilterIdLow=(ext_id<<3) | CAN_ID_EXT;\n\n// 设置掩码前两个字节,左移3位再或CAN_ID_EXT是因为最后的三位并不是ID，而是IDE、RTR和预留的0\nCAN_FilterType.FilterMaskIdHigh=((mask<<3|CAN_ID_EXT)>>16)&0xffff;\n\n// 设置掩码后两个字节,左移3位再或CAN_ID_EXT是因为最后的三位并不是ID，而是IDE、RTR和预留的0\nCAN_FilterType.FilterMaskIdLow=(mask<<3|CAN_ID_EXT)&0xffff;\n\n// 将消息放到FIFO0这个队列里\nCAN_FilterType.FilterFIFOAssignment=CAN_RX_FIFO0;\n\n// 激活过滤器\nCAN_FilterType.FilterActivation=ENABLE;\n\n// 设置过滤器\nif(HAL_CAN_ConfigFilter(&hcan,&CAN_FilterType)!=HAL_OK)\n{\n  Error_Handler();\n}\n```\n\n### 16位宽的掩码模式\n\n16位宽的寄存器示意图如下:\n\n{% img /stm32can学习笔记/6.jpg %}\n\nid和mask都是两个字节，但是真正使得标准id起作用的只有第一个字节和第二个自己的前3位。这里各只用了两个字节，也就是说一个过滤器可以设置两组id和mask,FilterMaskIdHigh和FilterMaskIdHigh一组FilterIdLow和FilterMaskIdLow一组:\n\n```\nuint32_t std_id1 =0xa;\nuint32_t mask1 = 0xf;\nuint32_t std_id2 =0xbb;\nuint32_t mask2 = 0xff;\n\nCAN_FilterTypeDef CAN_FilterType;\n\n// 过滤器的id,STM32F072RBTx提供了14个过滤器所以id可以配置成0~13\nCAN_FilterType.FilterBank=0;\n\n// 设置位宽为16位\nCAN_FilterType.FilterScale=CAN_FILTERSCALE_16BIT;\n\n// 设置为掩码模式\nCAN_FilterType.FilterMode=CAN_FILTERMODE_IDMASK;\n\n// 设置第一组的id,左移5位是因为最后的5bit是RTR、IDE和EXID[17:15]\nCAN_FilterType.FilterIdHigh=(std_id1<<5) | CAN_ID_STD;\n\n// 设置第一组的mask,左移5位是因为最后的5bit是RTR、IDE和EXID[17:15]\nCAN_FilterType.FilterMaskIdHigh= ((mask1<<5)|CAN_ID_STD)\n\n// 设置第二组的id,左移5位是因为最后的5bit是RTR、IDE和EXID[17:15]\nCAN_FilterType.FilterIdLow=(std_id2<<5)|CAN_ID_STD;\n\n// 设置第二组的mask,左移5位是因为最后的5bit是RTR、IDE和EXID[17:15]\nCAN_FilterType.FilterMaskIdLow=(mask2<<5|CAN_ID_STD);\n\n// 将消息放到FIFO0这个队列里\nCAN_FilterType.FilterFIFOAssignment=CAN_RX_FIFO0;\n\n// 激活过滤器\nCAN_FilterType.FilterActivation=ENABLE;\n\n// 设置过滤器\nif(HAL_CAN_ConfigFilter(&hcan,&CAN_FilterType)!=HAL_OK)\n{\n  Error_Handler();\n}\n```\n\n## 列表模式\n\n列表模式意味着我们将想要接收的CAN id直接配置到过滤器。\n\n### 32位宽的列表模式\n\n{% img /stm32can学习笔记/7.jpg %}\n\n32位宽的列表模式下,可以设置两个id,FilterMaskIdHigh和FilterMaskIdHigh一个，FilterIdLow和FilterMaskIdLow一个:\n\n```\nuint32_t ext_id1 =0xa;\nuint32_t ext_id2 =0xbb;\n\nCAN_FilterTypeDef CAN_FilterType;\n\n// 过滤器的id,STM32F072RBTx提供了14个过滤器所以id可以配置成0~13\nCAN_FilterType.FilterBank=0;\n\n// 设置位宽为32位\nCAN_FilterType.FilterScale=CAN_FILTERSCALE_32BIT;\n\n// 设置为列表模式\nCAN_FilterType.FilterMode=CAN_FILTERMODE_IDLIST;\n\n// 设置第一个id的高字节,左移三位是因为最后的三位是IDE、RTR和预留的0\nCAN_FilterType.FilterIdHigh=((ext_id1<<3)>>16)&0xffff;\n\n// 设置第一个id的低字节,左移三位是因为最后的三位是IDE、RTR和预留的0\nCAN_FilterType.FilterIdLow=((ext_id1<<3)&0xffff)|CAN_ID_EXT;\n\n// 设置第二个id的高字节,左移三位是因为最后的三位是IDE、RTR和预留的0\nCAN_FilterType.FilterMaskIdHigh=((ext_id2<<3)>>16)&0xffff;\n\n// 设置第二个id的低字节,左移三位是因为最后的三位是IDE、RTR和预留的0\nCAN_FilterType.FilterMaskIdLow=((ext_id2<<3)&0xffff)|CAN_ID_EXT;\n\n// 将消息放到FIFO0这个队列里\nCAN_FilterType.FilterFIFOAssignment=CAN_RX_FIFO0;\n\n// 激活过滤器\nCAN_FilterType.FilterActivation=ENABLE;\n\n// 设置过滤器\nif(HAL_CAN_ConfigFilter(&hcan,&CAN_FilterType)!=HAL_OK)\n{\n  Error_Handler();\n}\n```\n\n### 16位宽的列表模式\n\n{% img /stm32can学习笔记/8.png %}\n\n16位宽的列表模式下,可以设置四个id,FilterMaskIdHigh、FilterMaskIdHigh、FilterIdLow和FilterMaskIdLow各一个:\n\n```\nuint16_t ext_id1 =0xa;\nuint16_t ext_id2 =0xb;\nuint16_t ext_id3 =0xc;\nuint16_t ext_id4 =0xd;\n\nCAN_FilterTypeDef CAN_FilterType;\n\n// 过滤器的id,STM32F072RBTx提供了14个过滤器所以id可以配置成0~13\nCAN_FilterType.FilterBank=0;\n\n// 设置位宽为16位\nCAN_FilterType.FilterScale=CAN_FILTERSCALE_16BIT;\n\n// 设置为列表模式\nCAN_FilterType.FilterMode=CAN_FILTERMODE_IDLIST;\n\n// 设置第一个id,左移五位是因为最后的五位是RTR、IDE和EXID[17:15]\nCAN_FilterType.FilterIdHigh=(ext_id1<<5)|CAN_ID_STD;\n\n// 设置第二个id,左移五位是因为最后的五位是RTR、IDE和EXID[17:15]\nCAN_FilterType.FilterIdLow=(ext_id2<<5)|CAN_ID_STD;\n\n// 设置第三个id,左移五位是因为最后的五位是RTR、IDE和EXID[17:15]\nCAN_FilterType.FilterMaskIdHigh=(ext_id3<<5)|CAN_ID_STD;\n\n// 设置第四个id,左移五位是因为最后的五位是RTR、IDE和EXID[17:15]\nCAN_FilterType.FilterMaskIdLow=(ext_id4<<5)|CAN_ID_STD;\n\n// 将消息放到FIFO0这个队列里\nCAN_FilterType.FilterFIFOAssignment=CAN_RX_FIFO0;\n\n// 激活过滤器\nCAN_FilterType.FilterActivation=ENABLE;\n\n// 设置过滤器\nif(HAL_CAN_ConfigFilter(&hcan,&CAN_FilterType)!=HAL_OK)\n{\n  Error_Handler();\n}\n```\n\n# 接收数据\n\n我们可以看到设置过滤器的时候,会配置将过滤出来的数据放到FIFO0这个队里里面:\n\n```\n// 将消息放到FIFO0这个队列里\nCAN_FilterType.FilterFIFOAssignment=CAN_RX_FIFO0;\n```\n\n然后我们还有两步需要操作:\n\n1. 激活这个队列的通知\n\n```\nif(HAL_CAN_ActivateNotification(&hcan,CAN_IT_RX_FIFO0_MSG_PENDING)!=HAL_OK)\n{\n    Error_Handler();\n}\n```\n\n2. 在STM32CubeMX中使能CAN的接收中断:\n\n{% img /stm32can学习笔记/9.png %}\n\n然后就能重写HAL_CAN_RxFifo0MsgPendingCallback函数去处理接收的数据了:\n\n```\nvoid HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)\n{\n    printf(\"HAL_CAN_RxFifo0MsgPendingCallback\\r\\n\");\n    CAN_RxHeaderTypeDef CAN_RxHeader;\n    HAL_StatusTypeDef HAL_Retval;\n    uint8_t Rx_Data[8];\n    uint8_t Data_Len = 0;\n    uint32_t ID = 0;\n    uint8_t i;\n    HAL_Retval = HAL_CAN_GetRxMessage(hcan,CAN_RX_FIFO0,&CAN_RxHeader,Rx_Data);\n    if(HAL_Retval == HAL_OK)\n    {\n        Data_Len = CAN_RxHeader.DLC;\n        if(CAN_RxHeader.IDE)\n        {\n            ID = CAN_RxHeader.ExtId;\n        }\n        else\n        {\n            ID = CAN_RxHeader.StdId;\n        }\n        printf(\"id:%x\\r\\n\",ID);\n        printf(\"Data_Len:%d\\r\\n\",Data_Len);\n        for(i=0;i<8;i++)\n        {\n            printf(\"Rx_Data[%d]=%x\\r\\n\",i,Rx_Data[i]);  \n        }\n    }\n}\n```\n\n\n\n# NORMAL和LOOPBACK模式\n\n正常模式下设备是收不到自己发送的报文的，我们可以设置LOOPBACK模式实现自发自收,但是注意该模式只用于调试,此时报文其实不会在总线上传播,所以其他设备是收不到发送的报文的:\n\n```\n//hcan.Init.Mode = CAN_MODE_NORMAL;\nhcan.Init.Mode = CAN_MODE_LOOPBACK;\n```\n\n# NORMAL模式下收不到数据\n\n我在调CAN总线的最后遇到了这样一个问题:LOOPBACK模式下能收到自己发的数据,但NORMAL模式下收不到树莓派发送的数据。\n\n通过示波器测量: stm32的CAN RX可以量到树莓派发送的数据波形了，波特率是100k，甚至CAN TX都量到有stm32响应的波形。\n\n而且有个奇怪的现象，stm32在loopback下发数据，CAN TX可以量到完整的数据波形，但是如果改成NORMAL模式，就只能量到一个bit的数据。\n\n于是我怀疑是收发器哪里出问题了,导致发送失败,在接收到数据的时候由于发送响应失败,导致接收的流程也断掉了,没有去到回调函数那里。\n\n最终定位到收发器TJA1042T的STB脚没有拉低,导致收发器处于Standby模式:\n\n{% img /stm32can学习笔记/10.png %}\n\n除了这个原因之外在[网上](http://www.cnblogs.com/whitetiger/p/3811872.html)也有看到这种情况的其他可能原因:\n\n1. 回环下应该与GPIO无关\n\n2. GPIO是否初始化正确，时钟启用\n\n3. 是否复用，AFIO时钟是否启用\n\n4. 回环下是否有CAN_Tx应该有输出\n\n5. 终端电阻是否有\n\n6. CAN收发器电路电压是否正常\n\n7. 波特率是否标准\n\n8. 换块板试一下\n","tags":["技术相关","嵌入式"]},{"title":"Glide源码探究(三) - 网络资源加载","url":"/2021/02/10/Glide源码探究-三-网络资源加载/","content":"\n系列文章:\n\n- [Glide源码探究(一) - 生命周期绑定与Request创建](https://blog.islinjw.cn/2021/02/05/Glide%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6-%E4%B8%80-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%91%E5%AE%9A%E4%B8%8ERequest%E5%88%9B%E5%BB%BA/)\n\n- [Glide源码探究(二) - 内存缓存](https://blog.islinjw.cn/2021/02/08/Glide%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6-%E4%BA%8C-%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98/)\n\n- [Glide源码探究(三) - 网络资源加载](https://blog.islinjw.cn/2021/02/10/Glide%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6-%E4%B8%89-%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/)\n\n- [Glide源码探究(四) - Bitmap复用机制](https://blog.islinjw.cn/2021/03/27/Glide%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6-%E5%9B%9B-Bitmap%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6/)\n\n\n\n接着[上篇笔记](https://www.jianshu.com/p/79cc0dab40c3)，按照Glide的流程查询完内存缓存之后应该算是查询磁盘缓存，但是由于磁盘缓存的数据依赖第一次请求的时候从网络下载，再写入磁盘缓存。所以我这篇先讲网络请求部分的流程。\n\n这部分的代码坦白讲比较多也比较绕，我在看的时候也看的头晕。这里就不去把代码都列出来了，感兴趣的同学可以跟着下面的时序图去追踪一下:\n\n{% img /Glide源码探究三/1.jpg %}\n\nEngineJob的功能比较简单，就是管理加载和回调:\n\n```java\n/**\n * A class that manages a load by adding and removing callbacks for for the load and notifying\n * callbacks when the load completes.\n */\nclass EngineJob<R> implements DecodeJob.Callback<R>, Poolable {\n    ...\n}\n```\n\n它最重要的功能是启动了DecodeJob去加载资源，DecodeJob是一个运行在子线程的Runnable。它会使用Generator去从缓存或者数据源加载数据，我们这次只看从数据源加载的SourceGenerator。\n\nSourceGenerator在启动的时候会使用DecodeHelper去获取一个叫LoadData的东西，这一步比较有意思我们展开讲，先看看DecodeHelper.getLoadData的代码:\n\n```java\nList<LoadData<?>> getLoadData() {\n    if (!isLoadDataSet) {\n        isLoadDataSet = true;\n        loadData.clear();\n        List<ModelLoader<Object, ?>> modelLoaders = glideContext.getRegistry().getModelLoaders(model);\n\n        for (int i = 0, size = modelLoaders.size(); i < size; i++) {\n            ModelLoader<Object, ?> modelLoader = modelLoaders.get(i);\n            LoadData<?> current = modelLoader.buildLoadData(model, width, height, options);\n            if (current != null) {\n                loadData.add(current);\n            }\n        }\n    }\n    return loadData;\n}\n```\n\nloadData是个List，而且DecodeHelper内部做了缓存。它的加载逻辑是先用model(就是我们load传入的url)从glideContext里面查询ModelLoader列表，然后遍历它去buildLoadData丢到loadData这个列表里面。\n\n# ModelLoader的查询与注册\n\ngetModelLoaders的逻辑很简单，就用modelLoaderRegistry去getModelLoaders:\n\n```java\n@NonNull\npublic <Model> List<ModelLoader<Model, ?>> getModelLoaders(@NonNull Model model) {\n    return modelLoaderRegistry.getModelLoaders(model);\n}\n```\n\nmodelLoaderRegistry里面会根据model的class查询modelLoaders列表，然后遍历它去使用ModelLoader.handles方法判断这个ModelLoader是否支持这个model，如果是的再放到filteredLoaders里面一起返回。\n\n```java\npublic <A> List<ModelLoader<A, ?>> getModelLoaders(@NonNull A model) {\n    List<ModelLoader<A, ?>> modelLoaders = getModelLoadersForClass(getClass(model));\n    ...\n    int size = modelLoaders.size();\n    boolean isEmpty = true;\n    List<ModelLoader<A, ?>> filteredLoaders = Collections.emptyList();\n    for (int i = 0; i < size; i++) {\n      ModelLoader<A, ?> loader = modelLoaders.get(i);\n      if (loader.handles(model)) {\n        if (isEmpty) {\n          filteredLoaders = new ArrayList<>(size - i);\n          isEmpty = false;\n        }\n        filteredLoaders.add(loader);\n      }\n    }\n    ...\n    return filteredLoaders;\n}\n```\n\n这个逻辑要怎么理解呢？举个例子，就是假设model是一个Uri，那么getModelLoadersForClass查出来的ModelLoader列表里面可能有加载本地图片的也可能有加载网络图片的。然后分别调用ModelLoader.handles方法去过滤。如果是个本地请求的Uri，网络请求的ModelLoader就会被过滤掉，因为它只支持http和https的scheme:\n\n```java\npublic class UrlUriLoader<Data> implements ModelLoader<Uri, Data> {\n  private static final Set<String> SCHEMES =\n      Collections.unmodifiableSet(new HashSet<>(Arrays.asList(\"http\", \"https\")));\n  ...\n  @Override\n  public boolean handles(@NonNull Uri uri) {\n    return SCHEMES.contains(uri.getScheme());\n  }\n  ...\n}\n```\n\ngetModelLoadersForClass方法里面也比较绕，我就不展开代码了，只要知道它是根据model的class去查询即可。\n\n有了查询就肯定有注册，它的注册在Glide的构造函数里面有很长的一坨，第一个参数就是用于对比model class的，第二个参数是DataFetcher的数据类型，最后一个参数是ModelLoader的工厂:\n\n```java\nregistry\n  ...\n  .append(String.class, InputStream.class, new StringLoader.StreamFactory())\n    ...\n    .append(Uri.class, InputStream.class, new UriLoader.StreamFactory(contentResolver))\n    .append(Uri.class,ParcelFileDescriptor.class,new UriLoader.FileDescriptorFactory(contentResolver))\n    .append(Uri.class,AssetFileDescriptor.class,new UriLoader.AssetFileDescriptorFactory(contentResolver))\n    .append(Uri.class, InputStream.class, new UrlUriLoader.StreamFactory())\n    .append(URL.class, InputStream.class, new UrlLoader.StreamFactory())\n    ...\n```\n\n光看这个流程其实还比较好理解，但是由于我们使用的是String类型的url，当我第一次追踪代码的时候还是有被绕晕。原因是String.class注册的StringLoader自己并不干活，而是将String转换成Uri再去registry里面找人干活:\n\n```java\npublic class StringLoader<Data> implements ModelLoader<String, Data> {\n    public StringLoader(ModelLoader<Uri, Data> uriLoader) {\n        this.uriLoader = uriLoader;\n    }\n\n    @Override\n    public LoadData<Data> buildLoadData(@NonNull String model, int width, int height, @NonNull Options options) {\n        Uri uri = parseUri(model);\n        if (uri == null || !uriLoader.handles(uri)) {\n            return null;\n        }\n        return uriLoader.buildLoadData(uri, width, height, options);\n    }\n\n    @Override\n    public boolean handles(@NonNull String model) {\n        return true;\n    }\n    ...\n    public static class StreamFactory implements ModelLoaderFactory<String, InputStream> {\n        public ModelLoader<String, InputStream> build(@NonNull MultiModelLoaderFactory multiFactory) {\n          return new StringLoader<>(multiFactory.build(Uri.class, InputStream.class));\n        }\n        ...\n    }\n    ...\n}\n```\n\n可以看到StreamFactory创建StringLoader的时候调用了multiFactory.build(Uri.class, InputStream.class)方法创建了一个ModelLoader传给StringLoader。这个build出来的是一个MultiModelLoader，具体细节我也不讲了。它从registry查询了append时候第一个参数为Uri.class，第二个参数为InputStream.class的ModelLoader。\n\nStringLoader.handles直接返回true，然后buildLoadData的时候在从这堆ModelLoader使用handles然后build出来。\n\n也就是相当于将String.class的model转换成了Uri.class类型。但是这样还没有完，Uri.class最终又被转换成了GlideUrl.class，这个我就不展开代码了...\n\n# DataFetcher\n\n得到的ModelLoader回到到DecodeHelper.getLoadData去buildLoadData创建LoadData，就得到了一个LoadData列表。\n\n然后SourceGenerator.startNext里面就会遍历这个列表去找到一个能加载资源的LoadData，其中主要干活的是DataFetcher:\n\n```java\npublic boolean startNext() {\n    ...\n    while (!started && hasNextModelLoader()) {\n      loadData = helper.getLoadData().get(loadDataListIndex++);\n      if (loadData != null\n          && (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())\n              || helper.hasLoadPath(loadData.fetcher.getDataClass()))) {\n        started = true;\n        startNextLoad(loadData);\n      }\n    }\n    return started;\n}\n```\n\nstartNextLoad里面使用loadData.fetcher启动资源的加载，完成后回调onDataReadyInternal:\n\n```java\nprivate void startNextLoad(final LoadData<?> toStart) {\n    loadData.fetcher.loadData(\n        helper.getPriority(),\n        new DataCallback<Object>() {\n          @Override\n          public void onDataReady(@Nullable Object data) {\n            if (isCurrentRequest(toStart)) {\n              onDataReadyInternal(toStart, data);\n            }\n          }\n        ...);\n}\n```\n\n但是值得注意的是Fetcher的加载完成并不是把图片文件下载完成，只是打开了文件流而已，需要等待后面的流程从里面读取:\n\n```java\npublic class HttpUrlFetcher implements DataFetcher<InputStream> {\n    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super InputStream> callback) {\n        ...\n        InputStream result = loadDataWithRedirects(glideUrl.toURL(), 0, null, glideUrl.getHeaders());\n        callback.onDataReady(result);\n        ...\n    }\n}\n```\n\n# LoadPath\n\n看回时序图可以知道，DataFetcher的数据是被LoadPath读取去解码的。这里面也很复杂，但是我们并不需要全部了解，我这只讲个比较重要的东西。\n\nLoadPath.load方法最终会调用到LoadPath.decodeResourceWithList方法。顾名思义它是遍历解码器列表查找一个解码器去解码文件:\n\n```java\nprivate Resource<ResourceType> decodeResourceWithList(...) throws GlideException {\n    Resource<ResourceType> result = null;\n    \n    for (int i = 0, size = decoders.size(); i < size; i++) {\n        ResourceDecoder<DataType, ResourceType> decoder = decoders.get(i);\n        ...\n        DataType data = rewinder.rewindAndGet();\n        if (decoder.handles(data, options)) {\n            data = rewinder.rewindAndGet();\n            result = decoder.decode(data, width, height, options);\n        }\n        ...\n\n        if (result != null) {\n            break;\n        }\n    }\n    ...\n    return result;\n  }\n```\n\n这些解码器是哪里注册的呢？答案还是Glide的构造函数里面那坨很长的append，没错那坨append不仅注册了ModelLoader还注册了解码器:\n\n```java\nregistry\n        .append(ByteBuffer.class, new ByteBufferEncoder())\n        .append(InputStream.class, new StreamEncoder(arrayPool))\n        .append(Registry.BUCKET_BITMAP, ByteBuffer.class, Bitmap.class, byteBufferBitmapDecoder)\n        .append(Registry.BUCKET_BITMAP, InputStream.class, Bitmap.class, streamBitmapDecoder)\n            ...\n```\n\n# 总结\n\n之后的流程就是不断回到到Engine去放到弱引用缓存里面的。到这里整个网络资源的下载解码流程也就讲完了，我们来看看简化之后的时序图:\n\n{% img /Glide源码探究三/2.png %}\n","tags":["技术相关","Android"]},{"title":"树莓派外挂MCP2515模块爬坑记录","url":"/2021/02/09/树莓派外挂MCP2515模块爬坑记录/","content":"\n最近由于接近放假，协调不到调板哥，于是兼职下调板的工作。虽然之前也业余玩过树莓派和arduino，但是由于没有stm32的开发经验和硬件知识的匮乏，还是遇到了很多坑。\n\n这个can总线模块就卡了我两三天，由于涉及到树莓派的配置知识，觉得有必要记录一下。\n\n# can驱动配置\n\n目前的这个项目涉及到了树莓派和stm32的通信，使用的是can总线。由于树莓派本身不提供can总线功能，需要外挂一个MCP2515芯片。\n\n网上搜索树莓派的can总线配置，可以找到不少的资料，其中感觉最详细的是[这一篇](https://zhuanlan.zhihu.com/p/173648955)。但是里面有个小bug，我等下再说。\n\n首先网上的接线多数都是这样的:\n\n```\nRPi Pin    RPi Label     CAN Module\n02---------5V------------VCC\n06---------GND-----------GND\n19---------GPIO10--------MOSI (SI)\n21---------GPIO9---------MISO (SO)\n22---------GPIO25--------INT\n23---------GPIO11--------SCK\n24---------GPIO8---------CS\n```\n\n然后修改文件**/boot/config.txt**激活MCP2515驱动:\n\n```\n# 打开spi总线，树莓派与MCP2515之前通过spi通信，然后再转成can协议\ndtparam=spi=on\n\n# 在spi0.0上配置MCP2515 CAN控制器,CAN控制器的晶振频率是16MHz,INT脚接到了gpio25\ndtoverlay=mcp2515-can0,oscillator=16000000,interrupt=25 \n\n# SPI0只使用一个CS引脚，把spi0.0的cs脚配置到gpio8。实际上不配置这个也没有影响\ndtoverlay=spi0-1cs,cs0_pin=8\n```\n\n这些dtoverlay配置项的说明可以查看**/boot/overlays/README**:\n\n```\n...\nName:   mcp2515-can0\nInfo:   Configures the MCP2515 CAN controller on spi0.0\nLoad:   dtoverlay=mcp2515-can0,<param>=<val>\nParams: oscillator              Clock frequency for the CAN controller (Hz)\n\n        spimaxfrequency         Maximum SPI frequence (Hz)\n\n        interrupt               GPIO for interrupt signal\n        \nName:   mcp2515-can1\nInfo:   Configures the MCP2515 CAN controller on spi0.1\nLoad:   dtoverlay=mcp2515-can1,<param>=<val>\nParams: oscillator              Clock frequency for the CAN controller (Hz)\n\n        spimaxfrequency         Maximum SPI frequence (Hz)\n\n        interrupt               GPIO for interrupt signal\n...\n\nName:   spi0-1cs\nInfo:   Only use one CS pin for SPI0\nLoad:   dtoverlay=spi0-1cs,<param>=<val>\nParams: cs0_pin                 GPIO pin for CS0 (default 8)\n        no_miso                 Don't claim and use the MISO pin (9), freeing\n                                it for other uses.\n\nName:   spi0-2cs\nInfo:   Change the CS pins for SPI0\nLoad:   dtoverlay=spi0-2cs,<param>=<val>\nParams: cs0_pin                 GPIO pin for CS0 (default 8)\n        cs1_pin                 GPIO pin for CS1 (default 7)\n        no_miso                 Don't claim and use the MISO pin (9), freeing\n                                it for other uses.\n...\n```\n\n**所以以后需要打开什么功能，都可以到这文档里面查看配置方法**。\n\n首先由于我们把MCP2515 CAN控制器配到了spi0.0，所以我们需要配置spi0.0的cs脚(当然如果你也可以配置mcp2515-can1将它配置到spi0.1，这样的话就需要改spi0.1的cs脚)。\n\n这个cs脚使是用来选择设备的，当有多个设备挂到spi总线上的时候可以用这个脚去选择指定设备。由于我们只有一个设备，所以可以使用spi0-1cs指定spi0只有一个cs脚，当然你也可以配置两个cs脚(spi0-2cs)留空一个不用。然后无论是spi0-1cs还是spi0-2cs，cs0默认都是gpio8，所以我们配不配都没有关系，下面几种配置方法都是对的:\n\n1. dtoverlay=spi0-1cs,cs0_pin=8\n2. dtoverlay=spi0-1cs\n3. dtoverlay=spi0-2cs,cs0_pin=8\n4. dtoverlay=spi0-2cs\n5. \\# 不配置，留空\n\n之前我说的[这一篇](https://zhuanlan.zhihu.com/p/173648955)博客的小bug就是它配了dtoverlay=spi1-1cs，实际上是配置了spi1的cs脚，对我们的配置在spi0的can控制器没有影响\n\n我们的接法和网上的不一样，INT脚接gpio17，CS脚接gpio22。根据文档修改下配置就好:\n\n```\ndtoverlay=mcp2515-can0,oscillator=16000000,interrupt=17\ndtoverlay=spi0-1cs,cs0_pin=22\n```\n\n# can驱动启动失败\n\n事情到这里其实还算一帆风顺，我也没有花多少时间。但是当重启树莓派发现并没有/sys/bus/spi/devices/spi0.0/net/can0这个设备，使用dmesg命令查看开机日志会发现这样的一个错误，mcp2515驱动启动失败了:\n\n```\n[    7.653601] mcp251x spi0.0: MCP251x didn't enter in conf mode after reset\n[    7.653654] mcp251x spi0.0: Probe failed, err=16\n[    7.653738] mcp251x: probe of spi0.0 failed with error -16\n```\n\n然后我就懵逼了，网上搜索这个错误找到了很多遇到这种情况的人，但是他们的回答都是加上dtoverlay=spi0-1cs配置，让我一度怀疑自己的英语阅读水平以为自己文档看劈叉了(虽然水平的确也不怎样)。\n\n由于我们的接线和网上的不一样，所以试了很多种配置都没有用。然后我们只能不断做尝试\n\n1. 让硬件帮忙跳线，跳到和网上的一样，然后用网上的配置 --- 失败。\n\n2. 由于网上的例子都是用4.x的树莓派内核，而我们用的是5.x的内核。所以又猜测是系统版本原因，网上找了个旧的树莓派镜像验证 --- 失败。\n\n3. 见到[这篇博客](https://blog.csdn.net/qq_33440634/article/details/109111384)说是电压问题，但是我用万用表量电压是5.17V，接近他所说的5.2伏 --- 无用\n4. 找来示波器测量，发现cs脚在开机的时候的确有被拉低又拉高 -- 排除树莓派gpio引脚的硬件问题\n\n# 解决措施\n\n就这样卡了两天，没有办法了在某宝上买了个[用到mcp2515的模块](https://item.taobao.com/item.htm?id=586333809106)回来验证(我们的板子是自己做的)，发现买回来的是成功的。\n\n那基本定位是硬件问题，于是交给硬件对比差异。经过修改引脚、晶振、最后定位到的确是电压问题，但是我们这边需要将电压改到3.3v才能用...\n\n最后感慨几句。这段时间虽然遇到的大部分问题最终都定位到是硬件的问题。但是由于芯片都是买的，相当于一个黑盒，硬件修改也比较麻烦，所以需要软件先调试分析给出大概的定位。由于嵌入式经验不足，i2c、spi、can、i2s等各种硬件协议都只能现学现卖。嵌入式的api又由于需要考虑性能问题和应用层api侧重易用性的思路不一样，一堆配置和前置条件比较难用。每天都处于对自己能力的怀疑当中，不确定是否能做好，但所幸大部分问题都找到解决或者规避措施。也算去计算机的硬件底层瞄了几眼，开了不少眼界，算是给不平凡的鼠年画上了个特别的句号。希望明年还能继续保持对学习热情，有趣的东西那么多，为什么不去学呢？","tags":["技术相关","嵌入式","树莓派"]},{"title":"Glide源码探究(二) - 内存缓存","url":"/2021/02/08/Glide源码探究-二-内存缓存/","content":"\n系列文章:\n\n- [Glide源码探究(一) - 生命周期绑定与Request创建](https://blog.islinjw.cn/2021/02/05/Glide%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6-%E4%B8%80-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%91%E5%AE%9A%E4%B8%8ERequest%E5%88%9B%E5%BB%BA/)\n\n- [Glide源码探究(二) - 内存缓存](https://blog.islinjw.cn/2021/02/08/Glide%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6-%E4%BA%8C-%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98/)\n\n- [Glide源码探究(三) - 网络资源加载](https://blog.islinjw.cn/2021/02/10/Glide%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6-%E4%B8%89-%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/)\n\n- [Glide源码探究(四) - Bitmap复用机制](https://blog.islinjw.cn/2021/03/27/Glide%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6-%E5%9B%9B-Bitmap%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6/)\n\n\n让我们接着[上一篇笔记](https://blog.islinjw.cn/2021/02/05/Glide%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6-%E4%B8%80-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%91%E5%AE%9A%E4%B8%8ERequest%E5%88%9B%E5%BB%BA/)继续讲Engine的load方法，这里面就是Glide的资源加载流程。\n\n```java\npublic <R> LoadStatus load(...) {\n    long startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : 0;\n\n    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations, resourceClass, transcodeClass, options);\n\n    EngineResource<?> memoryResource;\n    synchronized (this) {\n      memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);\n\n      if (memoryResource == null) {\n        return waitForExistingOrStartNewJob(...);\n      }\n    }\n    \n    cb.onResourceReady(memoryResource, DataSource.MEMORY_CACHE, false);\n    return null;\n}\n```\n\n这个方法的流程其实也挺清晰的:\n\n1. 创建缓存的key，这个key由一系列的参数组成，其中最重要的参数model在我们的例子中就是传进去的url。\n2. 使用这个key从内存缓存中查询资源\n3. 如果内存缓存中查不到资源就开启线程去加载资源\n4. 如果内存缓存中可以查到资源就调用cb.onResourceReady回调\n\n流程图如下:\n\n{% img /Glide源码探究二/1.png %}\n\n# 内存缓存\n\n内存缓存的流程也比较清晰从代码上看，如果开启了内存缓存的话会先从ActiveResources中查询，查不到的话再从Cache里面查询:\n\n```java\nprivate EngineResource<?> loadFromMemory( EngineKey key, boolean isMemoryCacheable, long startTime) {\n    if (!isMemoryCacheable) {\n      return null;\n    }\n\n    EngineResource<?> active = loadFromActiveResources(key);\n    if (active != null) {\n      ...\n      return active;\n    }\n\n    EngineResource<?> cached = loadFromCache(key);\n    if (cached != null) {\n      ...\n      return cached;\n    }\n\n    return null;\n}\n```\n\n这两个东西同样是内存缓存，那有啥区别呢？我们先看ActiveResources:\n\n```java\n// Engine\nprivate EngineResource<?> loadFromActiveResources(Key key) {\n    EngineResource<?> active = activeResources.get(key);\n    if (active != null) {\n      active.acquire();\n    }\n\n    return active;\n}\n\n// ActiveResources\nfinal class ActiveResources {\n  ...\n  final Map<Key, ResourceWeakReference> activeEngineResources = new HashMap<>();\n  ...\n  synchronized EngineResource<?> get(Key key) {\n    ResourceWeakReference activeRef = activeEngineResources.get(key);\n    if (activeRef == null) {\n      return null;\n    }\n\n    EngineResource<?> active = activeRef.get();\n    if (active == null) {\n      cleanupActiveReference(activeRef);\n    }\n    return active;\n  }\n  ...\n  static final class ResourceWeakReference extends WeakReference<EngineResource<?>> {\n    ...\n  }\n  ...\n}\n```\n\nloadFromActiveResources实际上是从弱引用缓存里面查询资源。既然是缓存当然就要讲讲它的添加和删除。\n\n## 弱引用缓存的添加\n\n首先是添加，弱引用缓存的添加基本有两个时机。\n\n1. 从Cache里面查询到的时候如果能查到，会将查到的资源放入弱引用缓存:\n\n```java\nprivate EngineResource<?> loadFromCache(Key key) {\n    EngineResource<?> cached = getEngineResourceFromCache(key);\n    if (cached != null) {\n      cached.acquire();\n      activeResources.activate(key, cached);\n    }\n    return cached;\n}\n```\n\n2. 子线程加载完资源后会将资源放入弱引用缓存:\n\n```java\npublic synchronized void onEngineJobComplete(EngineJob<?> engineJob, Key key, EngineResource<?> resource) {\n    if (resource != null && resource.isMemoryCacheable()) {\n      activeResources.activate(key, resource);\n    }\n    ...\n}\n```\n\n## 弱引用缓存的删除\n\n细心的同学可能会看到cached.acquire()这个操作，我们来看看它的代码:\n\n```java\nsynchronized void acquire() {\n    ...\n    ++acquired;\n}\n```\n\n有没有想到些啥?没错，引用计数!\n\nEngineResource是通过引用计数来管理的。有引用计数增加那就有引用计数减少。减少的操作在release方法里面:\n\n```java\nvoid release() {\n  boolean release = false;\n  synchronized (this) {\n    if (acquired <= 0) {\n      throw new IllegalStateException(\"Cannot release a recycled or not yet acquired resource\");\n    }\n    if (--acquired == 0) {\n      release = true;\n    }\n  }\n  if (release) {\n    listener.onResourceReleased(key, this);\n  }\n}\n```\n\n如果引用计数降到了0就会调用listener的onResourceReleased回调回去，在onResourceReleased里面Engine会将资源从弱引用缓存删除然后移到cache里:\n\n```java\n// Engine\npublic void onResourceReleased(Key cacheKey, EngineResource<?> resource) {\n    activeResources.deactivate(cacheKey);\n    if (resource.isMemoryCacheable()) {\n      cache.put(cacheKey, resource);\n    } else {\n      resourceRecycler.recycle(resource, /*forceNextFrame=*/ false);\n    }\n}\n\n// ActiveResources\nsynchronized void deactivate(Key key) {\n    ResourceWeakReference removed = activeEngineResources.remove(key);\n    if (removed != null) {\n      removed.reset();\n    }\n}\n```\n\nEngineResource.release又是什么时候被调用的呢?其实调用的地方有好几处，但是最重要的两处是\n\n1. 我们手动调Glide的clear清理资源的时候:\n\n```kotlin\n// 手动清理资源\nGlide.with(context)\n    .clear(img)\n```\n\n2. 绑定的生命LifecycleListener.onDestroy的时候:\n\n```java\n// RequestManager\npublic synchronized void onDestroy() {\n  ...\n  for (Target<?> target : targetTracker.getAll()) {\n    clear(target);\n  }\n  ...\n}\n\npublic void clear(@Nullable final Target<?> target) {\n  ...\n  untrackOrDelegate(target);\n}\n\nprivate void untrackOrDelegate(@NonNull Target<?> target) {\n  ...\n  Request request = target.getRequest();\n  if (!isOwnedByUs && !glide.removeFromManagers(target) && request != null) {\n    target.setRequest(null);\n    request.clear();\n  }\n}\n\n// SingleRequest\npublic void clear() {\n  ...\n  engine.release(toRelease);\n  ...\n}\n\n// Engine\npublic void release(Resource<?> resource) {\n  if (resource instanceof EngineResource) {\n    ((EngineResource<?>) resource).release();\n  }\n  ...\n}\n```\n\n简单来讲就是加载资源的时候会把资源放入弱引用缓存，但资源不需要的时候会从弱引用缓存里面拿出移到另一个内存缓存里面。所以这些资源都是正在使用的，这个弱引用缓存Glide把它叫做ActiveResources也是比较准确的。\n\n**这个缓存使用弱引用的意义在于: 资源是保存在request里面的，而根据我们[上篇笔记](https://www.jianshu.com/p/85da220d8442)的知识，request是以setTag的方式保存在view里面的。所以当view被回收之后，resource也就没有别的强引用可以连接到gc root，可以被java垃圾回收机制回收**\n\n# LRUCache\n\nEngine.load会先从ActiveResources中查询，查不到的话再从Cache里面查询，这个Cache其实是一个LruResourceCache:\n\n```java\npublic class LruResourceCache extends LruCache<Key, Resource<?>> implements MemoryCache {\n    ...\n}\n```\n\n从这个lru cache里面加载资源意味着把资源从lru cache里面移出，放到弱引用缓存中:\n\n```java\nprivate EngineResource<?> loadFromCache(Key key) {\n  EngineResource<?> cached = getEngineResourceFromCache(key);\n  if (cached != null) {\n    cached.acquire();\n    activeResources.activate(key, cached);\n  }\n  return cached;\n}\n\nprivate EngineResource<?> getEngineResourceFromCache(Key key) {\n  Resource<?> cached = cache.remove(key);\n\n  final EngineResource<?> result;\n  if (cached == null) {\n    result = null;\n  } else if (cached instanceof EngineResource) {\n    result = (EngineResource<?>) cached;\n  } else {\n    result = new EngineResource<>(cached, /*isMemoryCacheable=*/ true, /*isRecyclable=*/ true, key, /*listener=*/ this);\n  }\n  return result;\n}\n```\n\n而正如上节我们讲的资源的引用计数被清零的时候就会从弱引用缓存中删除，加入lru cache中:\n\n```java\n// Engine\npublic void onResourceReleased(Key cacheKey, EngineResource<?> resource) {\n    activeResources.deactivate(cacheKey);\n    if (resource.isMemoryCacheable()) {\n      cache.put(cacheKey, resource);\n    } else {\n      resourceRecycler.recycle(resource, /*forceNextFrame=*/ false);\n    }\n}\n\n// ActiveResources\nsynchronized void deactivate(Key key) {\n    ResourceWeakReference removed = activeEngineResources.remove(key);\n    if (removed != null) {\n      removed.reset();\n    }\n}\n```\n\n# 内存缓存整体流程\n\n至此整个内存缓存的架构就大体完整了，当资源被使用的时候会被放到弱引用缓存，当资源不再被使用的时候就会被放入LRU Cache(注意这里放的是强引用，因为是从view里面getTage拿到Resource强引用进行release的):\n\n{% img /Glide源码探究二/2.png %}\n\n# 补充: 内存缓存的查询顺序\n\n先查弱引用缓存再查lru cache这个顺序并不是一开始就这样的，我刚看glide源码的时候看的是比较旧的版本，那个时候是先查lru cahe，查不到再查弱引用缓存。\n\n这个顺序在2017年11月[这个commit](https://github.com/bumptech/glide/commit/02096625b38f5c5fd6c820752a2fc4f0ae2b07ea)之后修改的:\n\n{% img /Glide源码探究二/3.png %}\n\n这个修改是为了修复资源被重复加载的bug，但实际上我看这部分修改的时候，感觉交换查询顺序应该和解这个bug没有直接关系，它更像是作者在重构之后觉得先查lru cache再查弱引用缓存的顺序怪怪的(我那个时候也有这种感觉)，顺手改了下:\n\n{% img /Glide源码探究二/4.png %}\n\n这里它将原本写在Engine的弱引用Map封装成了ActiveResources。\n\n那为啥顺序不是一开始就是先查弱引用缓存呢?原因可能是[一开始的代码](https://github.com/bumptech/glide/blob/fe7154fc88d47c779aec395af7020a69d61f6392/library/src/com/bumptech/glide/load/engine/Engine.java)内存缓存就没有弱引用缓存:\n\n```\npublic <T, Z> LoadStatus load(String id, int width, int height, ResourceDecoder<InputStream, Z> cacheDecoder,\n        ResourceFetcher<T> fetcher, ResourceDecoder<T, Z> decoder,  Transformation<Z> transformation,\n        ResourceEncoder<Z> encoder, Priority priority, ResourceCallback cb) {\n\n    Key key = keyFactory.buildKey(id, width, height, cacheDecoder, decoder, transformation, encoder);\n\n    Resource cached = cache.get(key);\n    if (cached != null) {\n        cached.acquire(1);\n        cb.onResourceReady(cached);\n        return null;\n    }\n\n    ResourceRunner current = runners.get(key);\n    if (current != null) {\n        EngineJob job = current.getJob();\n        job.addCallback(cb);\n        return new LoadStatus(cb, job);\n    }\n\n    ResourceRunner<Z> runner = factory.build(key, width, height, cacheDecoder, fetcher, decoder, transformation,\n            encoder, priority, this);\n    runner.getJob().addCallback(cb);\n    runners.put(key, runner);\n    runner.queue();\n    return new LoadStatus(cb, runner.getJob());\n}\n```\n可能是作者在后面优化添加这个弱引用缓存的时候就顺手放到了原有逻辑的后面。\n\n其实仔细想想内存缓存的架构，我觉得这个顺序其实并不重要，谁先谁后都不会有什么问题，无非是说流程是从lru cache拿出来放到弱引用缓存的，查询的时候先查弱引用缓存会比较符合一般人的思路。\n\n我们回想下两个缓存存放的资源，简化到Activity的场景。弱引用缓存放的都是当前activity正在使用的图片，lru cache是activity退出之后回收的图片。如果先查弱引用缓存，意味着当上下不停滑动recyclerview的时候效率高一丢丢。如果先查lru cahe，意味着反复进出同一个activity的时候效率高一丢丢。很难说哪个顺序性能比较高。而且这一丢丢性能在现代设备中的确真的是毫无影响，所以让人好理解是最重要的，先查弱引用缓存没毛病。","tags":["技术相关","Android"]},{"title":"Glide源码探究(一) - 生命周期绑定与Request创建","url":"/2021/02/05/Glide源码探究-一-生命周期绑定与Request创建/","content":"\n系列文章:\n\n- [Glide源码探究(一) - 生命周期绑定与Request创建](https://blog.islinjw.cn/2021/02/05/Glide%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6-%E4%B8%80-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%91%E5%AE%9A%E4%B8%8ERequest%E5%88%9B%E5%BB%BA/)\n\n- [Glide源码探究(二) - 内存缓存](https://blog.islinjw.cn/2021/02/08/Glide%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6-%E4%BA%8C-%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98/)\n\n- [Glide源码探究(三) - 网络资源加载](https://blog.islinjw.cn/2021/02/10/Glide%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6-%E4%B8%89-%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/)\n\n- [Glide源码探究(四) - Bitmap复用机制](https://blog.islinjw.cn/2021/03/27/Glide%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6-%E5%9B%9B-Bitmap%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6/)\n\n\n蛮久之前囫囵吞枣地瞄过Glide部分源码，最近由于某个契机又心血来潮比较系统的过了一遍它的源码，发现它的蛮多设计还是比较有意思的(该系列笔记基于Glide 4.12.0这个版本进行分析)。\n\n首先Glide的使用十分简单，只需要三行代码就能完成图片的下载、缓存和显示:\n\n```kotlin\nGlide.with(this)\n    .load(url)\n    .into(img)\n```\n\n但为了我们可以方便的使用，实际上每一行代码的背后都帮我们做了不少脏活累活。\n\n# Glide.with\n\n我们一行行来看，首先看Glide.with方法，它其实有一系列的重载:\n\n```java\npublic static RequestManager with(@NonNull Context context) {\n  return getRetriever(context).get(context);\n}\n\npublic static RequestManager with(@NonNull Activity activity) {\n  return getRetriever(activity).get(activity);\n}\n\npublic static RequestManager with(@NonNull FragmentActivity activity) {\n  return getRetriever(activity).get(activity);\n}\n\npublic static RequestManager with(@NonNull Fragment fragment) {\n  return getRetriever(fragment.getContext()).get(fragment);\n}\n\npublic static RequestManager with(@NonNull android.app.Fragment fragment) {\n  return getRetriever(fragment.getActivity()).get(fragment);\n}\n\npublic static RequestManager with(@NonNull View view) {\n  return getRetriever(view.getContext()).get(view);\n}\n```\n\n内容大同小异，都是用getRetriever方法获取RequestManagerRetriever，然后从里面get出RequestManager。\n\n## Glide 单例模式实现\n\n追踪getRetriever方法，可以比较容易看出来实际上是从Glide单例里面获取RequestManagerRetriever，而且我们还能看到Glide使用的是单例模式的双重校验锁方式:\n\n```java\nprivate static RequestManagerRetriever getRetriever(@Nullable Context context) {\n        ...\n    return Glide.get(context).getRequestManagerRetriever();\n}\n\npublic static Glide get(@NonNull Context context) {\n    if (glide == null) {\n      ...\n      synchronized (Glide.class) {\n        if (glide == null) {\n          checkAndInitializeGlide(context, annotationGeneratedModule);\n        }\n      }\n    }\n\n    return glide;\n}\n```\n\n## Glide生命周期绑定\n\nglide其实已经帮我们对activty生命周期进行了绑定：在onStop的时候停止加载，在onStart的时候继续加载，在onDestory清除任务和进行缓存的回收。它的原理是通过在Activity里面添加一个不可见的fragment，在里面监听生命周期。\n\n我们可以看到在RequestManagerRetriever.get方法最终会add一个SupportRequestManagerFragment到Activity里面:\n\n```java\npublic RequestManager get(@NonNull FragmentActivity activity) {\n    ...\n    FragmentManager fm = activity.getSupportFragmentManager();\n    return supportFragmentGet(activity, fm, /*parentHint=*/ null, isActivityVisible(activity));\n    ...\n}\n\n@NonNull\nprivate RequestManager supportFragmentGet(Context context, FragmentManager fm, Fragment parentHint, boolean isParentVisible) {\n    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);\n    RequestManager requestManager = current.getRequestManager();\n    ...\n    return requestManager;\n}\n\n@NonNull\nprivate SupportRequestManagerFragment getSupportRequestManagerFragment(final FragmentManager fm, Fragment parentHint) {\n    SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);\n    if (current == null) {\n        ...\n        current = new SupportRequestManagerFragment();\n        ...\n        fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();\n        ...\n    }\n    return current;\n}\n```\n\nSupportRequestManagerFragment里面有个lifecycle成员，我们可以向它注册监听，RequestManager也正是这么干的:\n\n```java\npublic class SupportRequestManagerFragment extends Fragment {\n    ...\n  private final ActivityFragmentLifecycle lifecycle;\n  ...\n  public SupportRequestManagerFragment(@NonNull ActivityFragmentLifecycle lifecycle) {\n    this.lifecycle = lifecycle;\n  }\n  ...\n  @Override\n  public void onStart() {\n    super.onStart();\n    lifecycle.onStart();\n  }\n  @Override\n  public void onStop() {\n    super.onStop();\n    lifecycle.onStop();\n  }\n  @Override\n  public void onDestroy() {\n    super.onDestroy();\n    lifecycle.onDestroy();\n    unregisterFragmentWithRoot();\n  }\n  ...\n}\n```\n\n```java\n//RequestManager\nRequestManager(\n      Glide glide,\n      Lifecycle lifecycle,\n      RequestManagerTreeNode treeNode,\n      RequestTracker requestTracker,\n      ConnectivityMonitorFactory factory,\n      Context context) {\n    ...\n    lifecycle.addListener(connectivityMonitor);\n    ...\n}\n\npublic synchronized void onStart() {\n    resumeRequests();\n    targetTracker.onStart();\n}\n\n@Override\npublic synchronized void onStop() {\n    pauseRequests();\n    targetTracker.onStop();\n}\n\n@Override\npublic synchronized void onDestroy() {\n    targetTracker.onDestroy();\n    for (Target<?> target : targetTracker.getAll()) {\n      clear(target);\n    }\n    targetTracker.clear();\n    requestTracker.clearRequests();\n    ...\n}\n```\n\n这种添加不可见Fragment监听生命周期的技巧还是挺实用的。RxPermissions里面也用了这种技巧去监听onActivityResult回调\n\n# RequestManager.load\n\n第二行的load方法，虽然只有一行但是实际上它做了两件事情:\n\n```java\npublic RequestBuilder<Drawable> load(@Nullable String string) {\n    return asDrawable().load(string);\n}\n```\n\n1. new了一个请求Drawable的RequestBuilder:\n\n```java\npublic RequestBuilder<Drawable> asDrawable() {\n    return as(Drawable.class);\n}\n\npublic <ResourceType> RequestBuilder<ResourceType> as(\n      @NonNull Class<ResourceType> resourceClass) {\n    return new RequestBuilder<>(glide, this, resourceClass, context);\n}\n```\n\n2. 往builder里设置了model:\n\n```java\npublic RequestBuilder<TranscodeType> load(@Nullable String string) {\n    return loadGeneric(string);\n}\nprivate RequestBuilder<TranscodeType> loadGeneric(@Nullable Object model) {\n    ...\n    this.model = model;\n    ...\n}\n```\n\n没错这里使用的是Builder模式。\n\n# RequestManager.into\n\ninto实际上也是干了两件事情，build了一个Request出来，然后runRequest执行它:\n\n```java\n// RequestBuilder\npublic ViewTarget<ImageView, TranscodeType> into(@NonNull ImageView view) {\n    ...\n    return into(\n        glideContext.buildImageViewTarget(view, transcodeClass),\n        /*targetListener=*/ null,\n        requestOptions,\n        Executors.mainThreadExecutor());\n}\n\nprivate <Y extends Target<TranscodeType>> Y into(\n  @NonNull Y target,\n  @Nullable RequestListener<TranscodeType> targetListener,\n  BaseRequestOptions<?> options,\n  Executor callbackExecutor) {\n    ...\n    Request request = buildRequest(target, targetListener, options, callbackExecutor);\n    ...\n  target.setRequest(request);\n    requestManager.track(target, request);\n    return target;\n}\n\n// RequestManager\nsynchronized void track(@NonNull Target<?> target, @NonNull Request request) {\n    targetTracker.track(target);\n    requestTracker.runRequest(request);\n}\n```\n\n这里其实还有个细节，我们展开讲讲。如果我们中途想取消对该view的图片加载，可以用下面两行代码进行取消:\n\n```java\nGlide.with(this)\n    .clear(img)\n```\n\n这样就要求我们要记录view和request的关联，可能有些同学会想到用map<View,Request>这样的形式去保存，但是这样的话需要我们额外做出一些手段去防止view的内存泄露(如弱引用等)。其实安卓里比较常用的手段是将需要关联的东西用setTag方法保存到view里面:\n\n```java\n// ViewTarget\npublic void setRequest(@Nullable Request request) {\n    setTag(request);\n}\n\nprivate void setTag(@Nullable Object tag) {\n    isTagUsedAtLeastOnce = true;\n    view.setTag(tagId, tag);\n}\n```\n\n于是clear的时候只需要用View.getTag把request再拿出来就好:\n\n```java\npublic void clear(@NonNull View view) {\n    clear(new ClearTarget(view));\n}\n\npublic void clear(@Nullable final Target<?> target) {\n    if (target == null) {\n      return;\n    }\n    untrackOrDelegate(target);\n}\n\nprivate void untrackOrDelegate(@NonNull Target<?> target) {\n    boolean isOwnedByUs = untrack(target);\n  Request request = target.getRequest();\n  if (!isOwnedByUs && !glide.removeFromManagers(target) && request != null) {\n      target.setRequest(null);\n      request.clear();\n  }\n}\n```\n\n# request的执行\n\nrunRequest的逻辑其实也比较简单，如果没有pause就begin request，如果不是就放到pendingRequests列表里面等待后面再begin:\n\n```java\npublic void runRequest(@NonNull Request request) {\n    requests.add(request);\n    if (!isPaused) {\n        request.begin();\n    } else {\n        request.clear();\n        ...\n        pendingRequests.add(request);\n    }\n}\n```\n\n而request的begin方法的核心流程就是先获取图片的尺寸，然后使用engine.load去启动真正的加载逻辑:\n\n```java\npublic void begin() {\n    ...\n    if (Util.isValidDimensions(overrideWidth, overrideHeight)) {\n        onSizeReady(overrideWidth, overrideHeight);\n    } else {\n        target.getSize(this);\n    }\n    ...\n}\n\npublic void onSizeReady(int width, int height) {\n    ...\n    loadStatus =\n      engine.load(\n          glideContext,\n          model,\n          requestOptions.getSignature(),\n          this.width,\n          this.height,\n          requestOptions.getResourceClass(),\n          transcodeClass,\n          priority,\n          requestOptions.getDiskCacheStrategy(),\n          requestOptions.getTransformations(),\n          requestOptions.isTransformationRequired(),\n          requestOptions.isScaleOnlyOrNoTransform(),\n          requestOptions.getOptions(),\n          requestOptions.isMemoryCacheable(),\n          requestOptions.getUseUnlimitedSourceGeneratorsPool(),\n          requestOptions.getUseAnimationPool(),\n          requestOptions.getOnlyRetrieveFromCache(),\n          this,\n          callbackExecutor);\n    ...\n}\n```\n\n到这里其实一切都比较好理解，下一步就到了Engine这个Glide的核心模块，Glide的实际加载和多级缓存都是由它去调度的，由于该模块比较复杂，我们留到下一篇单独来聊。\n\n","tags":["技术相关","Android"]},{"title":"Dagger2 AndroidInjector原理探究","url":"/2021/01/17/Dagger2AndroidInjector原理探究/","content":"\n\nAndroidInjector在实际的项目中已经频繁使用了，但是其底层的原理一直没有关注，只是简单的使用。这篇笔记就来探究下它的实现原理。\n\n我们要先从Component的依赖开始讲起，然后一步一步往AndroidInjector的原理靠近。\n\n在Dagger2里面@Component.dependencies和@Subcomponent都可以实现Component依赖，而@Subcomponent又可以分成使用和不使用@Module.subcomponents去声明依赖两种。所以算下来应该是三种实现依赖的方式。今天主要想介绍的是@Module.subcomponents的方式，但是其他两种我也先过一下。\n\n# @Component.dependencies实现依赖\n\n@Component.dependencies是一种比较简单的方式，举个简单的例子，MainActivityComponent是子Component，它需要给MainActivity注入AppCommonData和MainActivityData。\n\n但MainActivityModule只提供了MainActivityData，AppCommonData由dependencies指定的AppComponent提供注入:\n\n```kotlin\n@Component(modules = [MainActivityModule::class], dependencies = [AppComponent::class])\ninterface MainActivityComponent {\n    fun inject(activity: MainActivity)\n}\n\n@Module\nclass MainActivityModule {\n    @Provides\n    fun providerMainActivityData(): MainActivityData {\n        return MainActivityData()\n    }\n}\n\nclass MainActivity : AppCompatActivity() {\n    @Inject\n    lateinit var appCommonData: AppCommonData\n    @Inject\n    lateinit var mainActivityData: MainActivityData\n    ...\n}\n```\n\n由于使用了dependencies的方式，AppComponent需要将AppCommonData暴露出来给MainActivityComponent使用，如果不去暴露的话MainActivityComponent是拿不到的:\n\n```kotlin\n@Component(modules = [AppModule::class])\ninterface AppComponent {\n    fun provideAppCommonData(): AppCommonData\n}\n\n@Module\nclass AppModule {\n    @Provides\n    fun provideAppCommonData(): AppCommonData {\n        return AppCommonData()\n    }\n}\n```\n\n当使用dependencies方式的适合会生成DaggerMainActivityComponent，我们需要先创建父Component，然后在创建MainActivityComponent的时候将父Component传入实现依赖的注册:\n\n```kotlin\nclass DemoApplication : Application() {\n    private lateinit var appComponent: AppComponent\n\n    lateinit var mainActivityComponent: MainActivityComponent\n        private set\n\n    override fun onCreate() {\n        super.onCreate()\n\n        appComponent = DaggerAppComponent.builder().build()\n\n        mainActivityComponent = DaggerMainActivityComponent.builder()\n            .appComponent(appComponent)\n            .build()\n    }\n}\n```\n\n注入的时候需要找到MainActivityComponent去注入:\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    ...\n    override fun onCreate(savedInstanceState: Bundle?) {\n        ...\n        (applicationContext as DemoApplication)\n            .mainActivityComponent\n            .inject(this)\n        ...\n    }\n}\n```\n\n这种方式的优点是父Component不需要知道子Component的存在，缺点是父Component需要显示提供子Component需要注入的对象，一旦需要提供的注入对象比较多的时候写起来就很啰嗦。\n\n[Demo代码](https://github.com/bluesky466/DaggerSubcomponentDemo/tree/feature_dependencies)\n\n# @Subcomponent实现依赖\n\n我们可以使用@Subcomponent去实现依赖，将子Component的注解改成@Subcomponent，dependencies去掉其他不变:\n\n```kotlin\n@Subcomponent(modules = [MainActivityModule::class])\ninterface MainActivityComponent {\n    fun inject(activity: MainActivity)\n}\n\n@Module\nclass MainActivityModule {\n    @Provides\n    fun providerMainActivityData(): MainActivityData {\n        return MainActivityData()\n    }\n}\n\nclass MainActivity : AppCompatActivity() {\n    @Inject\n    lateinit var appCommonData: AppCommonData\n    @Inject\n    lateinit var mainActivityData: MainActivityData\n    ...\n}\n```\n\nAppComponent不需要直接提供AppCommonData，但是由于使用了Subcomponent之后是不会生成DaggerMainActivityComponent的，它需要AppCommonData去负责创建，所以AppCommonData需要添加DaggerMainActivityComponent的创建方法。这里的主要目的是为了明确依赖关系，因为dagger2不可能知道你想要的依赖关系是怎样的:\n\n```kotlin\n@Component(modules = [AppModule::class])\ninterface AppComponent {\n    fun addMainActivityComponent(): MainActivityComponent\n}\n\n@Module\nclass AppModule {\n    @Provides\n    fun provideAppCommonData(): AppCommonData {\n        return AppCommonData()\n    }\n}\n\nclass DemoApplication : Application() {\n    private lateinit var appComponent: AppComponent\n\n    lateinit var mainActivityComponent: MainActivityComponent\n        private set\n\n    override fun onCreate() {\n        super.onCreate()\n\n        appComponent = DaggerAppComponent.builder().build()\n        mainActivityComponent = appComponent.addMainActivityComponent()\n    }\n}\n```\n\nMainActivity在使用注入的时候代码是一样的，我这里就不贴了。这种方式的好处是Subcomponent可以直接使用父类提供的所有注入对象，但是每增加一个Subcomponent，父Component都需要新增一个创建方法。\n\n[Demo代码](https://github.com/bluesky466/DaggerSubcomponentDemo/tree/feature_subcomponent)\n\n# @Module.subcomponents实现依赖\n\n除了在父Component添加Subcomponent的创建方法之外，我们还可以在父Component的Module里面去声明依赖关系:\n\n```kotlin\n@Module(subcomponents = [MainActivityComponent::class])\nclass AppModule {\n    @Provides\n    fun provideAppCommonData(): AppCommonData {\n        return AppCommonData()\n    }\n}\n```\n\n这里的@Module.subcomponents相当于Module添加了Subcomponent.Builder的注入能力，我们可以将Subcomponent.Builder注入到任意对象。这里我们注入到DemoApplication，所以AppComponent如下:\n\n```kotlin\n@Component(modules = [AppModule::class])\ninterface AppComponent {\n    fun inject(app: DemoApplication)\n}\n```\n\n既然是注入Subcomponent.Builder，那么就要求我们的Subcomponent要声明Builder:\n\n```kotlin\n@Subcomponent(modules = [MainActivityModule::class])\ninterface MainActivityComponent {\n    fun inject(activity: MainActivity)\n\n    @Subcomponent.Builder\n    interface Builder {\n        fun build(): MainActivityComponent\n    }\n}\n\n@Module\nclass MainActivityModule {\n    @Provides\n    fun providerMainActivityData(): MainActivityData {\n        return MainActivityData()\n    }\n}\n```\n\n这个时候创建MainActivityComponent就分成了两步，先创建MainActivityComponent.Builder，再创建MainActivityComponent:\n\n```kotlin\nclass DemoApplication : Application() {\n    @Inject\n    lateinit var mainActivityComponentBuilder: MainActivityComponent.Builder\n\n    lateinit var mainActivityComponent: MainActivityComponent\n\n    override fun onCreate() {\n        super.onCreate()\n\n        DaggerAppComponent.builder()\n            .build()\n            .inject(this)\n        mainActivityComponent = mainActivityComponentBuilder.builder()\n    }\n}\n```\n\n当然__上面的Subcomponent.Builder改成Subcomponent.Factory__也是可以的。\n\n[Demo代码](https://github.com/bluesky466/DaggerSubcomponentDemo/tree/feature_module_subcomponents)\n\n# @Module.subcomponents实现多绑定\n\n这种方式看上去是麻烦了一些，但是由于Subcomponent.Builder也是dagger2注入的，所以可以用这个特性去让我们的依赖注入做的更加彻底一点。\n\n我们可以看到目前我们的MainActivity实际上是需要知道自己是用哪个Component去注入的，也就是说我们破坏了\"一个对象不应该知道它是如何被注入的\"这个原则:\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    @Inject\n    lateinit var appCommonData: AppCommonData\n\n    @Inject\n    lateinit var mainActivityData: MainActivityData\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        ...\n        (applicationContext as DemoApplication)\n            .mainActivityComponent\n            .inject(this)\n        ...\n    }\n}\n```\n\n当然我们使用重载的方式将Component的选择挪到Application中，但是这样依然是在Dagger2框架之外去决定依赖关系。那可不可以做的更彻底些，将MainActivity和Component的依赖关系也使用Dagger2框架去决定呢?当然是可以的，就是使用@Module.subcomponents。\n\n首先我们定义一个BaseComponent作为基类，然后MainActivityComponent和SecondActivityComponent都继承它\n\n```kotlin\ninterface BaseComponent<T> {\n    fun inject(target: T)\n\n    interface Builder<T> {\n        fun build(): BaseComponent<T>\n    }\n}\n\n@Subcomponent(modules = [MainActivityModule::class])\ninterface MainActivityComponent : BaseComponent<MainActivity> {\n    @Subcomponent.Builder\n    interface Builder : BaseComponent.Builder<MainActivity>\n}\n\n@Subcomponent(modules = [SecondActivityModule::class])\ninterface SecondActivityComponent : BaseComponent<SecondActivity> {\n    @Subcomponent.Builder\n    interface Builder : BaseComponent.Builder<SecondActivity>\n}\n```\n\n然后定义Activity与Subcomponent.Builder之间的关联:\n\n```kotlin\n@Module(subcomponents = [MainActivityComponent::class, SecondActivityComponent::class])\ninterface ComponentBindingModule {\n    @Binds\n    @IntoMap\n    @ClassKey(MainActivity::class)\n    fun mainActivityComponentBuilder(builder: MainActivityComponent.Builder): BaseComponent.Builder<*>\n\n\n    @Binds\n    @IntoMap\n    @ClassKey(SecondActivity::class)\n    fun secondActivityComponentBuilder(builder: SecondActivityComponent.Builder): BaseComponent.Builder<*>\n}\n\n@Component(modules = [AppModule::class, ComponentBindingModule::class])\ninterface AppComponent {\n    fun inject(app: DemoApplication)\n}\n```\n\nComponentBindingModule将MainActivityComponent.Builder和SecondActivityComponent.Builder用对应的Activity的class为key放入Map中，所以Activity在需要注入的时候可以用自己的class为key获取到Subcomponent.Builder然后进行注入:\n\n```kotlin\nclass DemoApplication : Application() {\n    @Inject\n    lateinit var componentMap: MutableMap<Class<*>, BaseComponent.Builder<*>>\n\n    @Inject\n    lateinit var secondActivityComponentBuilder: SecondActivityComponent.Builder\n\n    override fun onCreate() {\n        super.onCreate()\n        DaggerAppComponent.builder()\n            .build()\n            .inject(this)\n    }\n\n    fun <T : Any> inject(target: T) {\n        (componentMap[target.javaClass]?.build() as BaseComponent<T>).inject(target)\n    }\n}\n```\n\n于是乎Activity的注入就变得很简单了:\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    @Inject\n    lateinit var appCommonData: AppCommonData\n    @Inject\n    lateinit var mainActivityData: MainActivityData\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        ...\n        (applicationContext as DemoApplication).inject(this)\n        ...\n    }\n}\n\nclass SecondActivity : AppCompatActivity() {\n    @Inject\n    lateinit var appCommonData: AppCommonData\n    @Inject\n    lateinit var secondActivityData: SecondActivityData\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        ...\n        (applicationContext as DemoApplication).inject(this)\n        ...\n    }\n}\n```\n\n我们还可以为其编写BaseActivity去进行注入。\n\n[Demo代码](https://github.com/bluesky466/DaggerSubcomponentDemo/tree/master)\n\n# AndroidInjector的原理\n\n[AndroidInjector](https://dagger.dev/dev-guide/android)的就是基于上面的技术实现的。我们可以看到DaggerApplication里面注入了一个DispatchingAndroidInjector\\<Object\\>，Activity在onCreate的时候就可以拿到这个东西去进行注入:\n\n```kotlin\npublic abstract class DaggerApplication extends Application implements HasAndroidInjector {\n  @Inject volatile DispatchingAndroidInjector<Object> androidInjector;\n  ...\n  @Override\n  public AndroidInjector<Object> androidInjector() {\n    ...\n    return androidInjector;\n  }\n  ...\n}\n```\n\n那我们来看看DispatchingAndroidInjector其实内部类似的也有两个Map用于获取不同的类对应的AndroidInjector.Factory:\n\n```kotlin\npublic final class DispatchingAndroidInjector<T> implements AndroidInjector<T> {\n    ...\n    private final Map<String, Provider<AndroidInjector.Factory<?>>> injectorFactories;\n    ...\n    @Inject\n    DispatchingAndroidInjector(\n        Map<Class<?>, Provider<AndroidInjector.Factory<?>>> injectorFactoriesWithClassKeys,\n        Map<String, Provider<AndroidInjector.Factory<?>>> injectorFactoriesWithStringKeys) {\n      this.injectorFactories = merge(injectorFactoriesWithClassKeys, injectorFactoriesWithStringKeys);\n    }\n    ...\n    @Override\n    public void inject(T instance) {\n        boolean wasInjected = maybeInject(instance);\n        ...\n    }\n    ...\n    public boolean maybeInject(T instance) {\n        Provider<AndroidInjector.Factory<?>> factoryProvider = injectorFactories.get(instance.getClass().getName());\n        ...\n        AndroidInjector.Factory<T> factory = (AndroidInjector.Factory<T>) factoryProvider.get();\n        try {\n              AndroidInjector<T> injector = checkNotNull(factory.create(instance), \"%s.create(I) should not return null.\", factory.getClass());\n              injector.inject(instance);\n              return true;\n        } \n        ...\n  }\n}\n```\n\n于是乎在inject的时候就能通过类名找到这个AndroidInjector.Factory进而创建AndroidInjector去进行注入。\n\n Map\\<Class\\<?\\>, Provider\\<AndroidInjector.Factory\\<?\\>\\>\\> 和Map\\<String, Provider\\<AndroidInjector.Factory\\<?\\>\\>\\>是通过AndroidInjectionModule注入的:\n\n```java\n@Module\npublic abstract class AndroidInjectionModule {\n  @Multibinds\n  abstract Map<Class<?>, AndroidInjector.Factory<?>> classKeyedInjectorFactories();\n\n  @Multibinds\n  abstract Map<String, AndroidInjector.Factory<?>> stringKeyedInjectorFactories();\n\n  private AndroidInjectionModule() {}\n}\n```\n\n所以AppComponent里面需要添加这个module依赖:\n\n```kotlin\n@Component(modules = [AndroidInjectionModule::class, AppModule::class, ComponentBindingModule::class])\ninterface AppComponent : AndroidInjector<DemoApplication>\n```\n\n而Map里面找到的都是AndroidInjector.Factory，所以我们的Subcomponent也应该继承AndroidInjector:\n\n```kotlin\n@Subcomponent(modules = [MainActivityModule::class])\ninterface MainActivityComponent : AndroidInjector<MainActivity> {\n    @Subcomponent.Factory\n    interface Factory : AndroidInjector.Factory<MainActivity>\n}\n\n@Subcomponent(modules = [SecondActivityModule::class])\ninterface SecondActivityComponent : AndroidInjector<SecondActivity> {\n    @Subcomponent.Factory\n    interface Factory : AndroidInjector.Factory<SecondActivity>\n}\n\n```\n\nComponentBindingModule里面依然是将AndroidInjector.Factory用对应的Activity的class为key放入Map中:\n\n```kotlin\n@Module(subcomponents = [MainActivityComponent::class, SecondActivityComponent::class])\ninterface ComponentBindingModule {\n    @Binds\n    @IntoMap\n    @ClassKey(MainActivity::class)\n    fun mainActivityComponentFactory(factory: MainActivityComponent.Factory): AndroidInjector.Factory<*>\n\n\n    @Binds\n    @IntoMap\n    @ClassKey(SecondActivity::class)\n    fun secondActivityComponentFactory(factory: SecondActivityComponent.Factory): AndroidInjector.Factory<*>\n}\n```\n\nActivity在注入的时候只需要使用AndroidInjection.inject(this)即可:\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    @Inject\n    lateinit var appCommonData: AppCommonData\n    @Inject\n    lateinit var mainActivityData: MainActivityData\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        AndroidInjection.inject(this)\n        super.onCreate(savedInstanceState)\n        ...\n    }\n}\n```\n\n[Demo代码](https://github.com/bluesky466/DaggerSubcomponentDemo/tree/feature_android_injection_principle)\n\n## ContributesAndroidInjector\n\n上面的MainActivityComponent、SecondActivityComponent的代码还有IntoMap的代码其实比较呆板，我们可以通过ContributesAndroidInjector去优化。所以ComponentBindingModule可以改成下面这个样子,然后:\n\n```kotlin\n@Module\nabstract class ComponentBindingModule {\n    @ContributesAndroidInjector(modules = [MainActivityModule::class])\n    abstract fun contributesMainActivity(): MainActivity\n    ...\n}\n```\n\n它会帮我们生成Subcomponent、IntoMap代码:\n\n```kotlin\n//下面的代码可以省略，被ContributesAndroidInjector代替了\n@Module\nclass MainActivityModule {\n    @Provides\n    fun providerMainActivityData(): MainActivityData {\n        return MainActivityData()\n    }\n}\n\n@Binds\n@IntoMap\n@ClassKey(MainActivity::class)\nfun mainActivityComponentFactory(factory: MainActivityComponent.Factory): AndroidInjector.Factory<*>\n```\n\n[Demo代码](https://github.com/bluesky466/DaggerSubcomponentDemo/tree/feature_android_injection)\n\n# 参考文章\n\n[Dagger & Android](https://dagger.dev/dev-guide/android)\n\n[Multibindings](https://dagger.dev/dev-guide/multibindings)\n\n[在Dagger 2中Activities和Subcomponents的多绑定](https://www.cnblogs.com/tiantianbyconan/p/6266442.html )\n\n","tags":["技术相关","Android"]},{"title":"JNI运行错误-符号未定义","url":"/2020/11/24/JNI运行错误-符号未定义/","content":"\n最近在弄ndk的时候遇到了个比较坑的问题，虽然最后发现原因挺低级的，但是的确花了我不少时间去查找，中间的分析手法可能不熟悉c/c++的同学会比较陌生，如果遇到的同样问题的话会无从下手。这里把整个分析的流程记录下来，希望有用。\n\n背景项目分两个部分，自己编写的c库工程，和安卓工程，将它们分离的原因是这个c库的功能可能在其他的地方也能使用到。\n\n由于项目只是初始阶段，为了验证流程，我先搭了个简单的demo框架，用c库工程编译出so之后导入到安卓工程。虽然整个代码比较简单，但是运行的时候直接就崩溃了，报找不到符号的异常。\n\n# 问题还原\n\n这里用个简单的demo还原下问题，JNI部分调用c库里面的getString函数返回字符串:\n\n```c++\nconst char *getString(); // 这个函数的定义在c库工程编译出来的so库里面\n\nextern \"C\" JNIEXPORT jstring JNICALL\nJava_com_cvte_tv_ndkdemo_MainActivity_stringFromJNI(\n        JNIEnv *env,\n        jobject /* this */) {\n    return env->NewStringUTF(getString());\n}\n```\n\nc库的代码也很简单，就返回字符串，我们会将它编译成libdemo.so:\n\n```c++\nconst char* getString() {\n    return \"Hello world!\\n\";\n}\n```\n\ncmake配置也很简单，我们的jni编译了一个libnative-lib.so依赖libdemo.so，java层通过这个libnative-lib.so去调用到libdemo.so里面的getString:\n\n```cmake\ncmake_minimum_required(VERSION 3.4.1)\n\nadd_library(native-lib SHARED native-lib.cpp)\n\nadd_library(demo SHARED IMPORTED)\n\nset_target_properties(demo PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/jniLibs/${ANDROID_ABI}/libdemo.so)\n\ntarget_link_libraries(native-lib  demo)\n```\n\n运行之后报的问题看起来也很简单:\n\n```shell\njava.lang.UnsatisfiedLinkError: dlopen failed: cannot locate symbol \"_Z9getStringv\" referenced by \"/data/app/com.cvte.tv.ndkdemo-xD9KLsO5Wmh_YGDKRKL5lA==/lib/arm64/libnative-lib.so\"...\n```\n\n这样奔溃其实挺常见的，因为编译的时候已经通过了，证明编译的时候是可以找到这个符号的，但是运行的时候没有找到，无非是so没有导入到apk里面，解压apk发现的确如此:\n\n```shell\n~/workspace/NDKDemo/app/build/outputs/apk/debug/app-debug/lib  tree\n.\n└── arm64-v8a\n    └── libnative-lib.so\n\n1 directory, 1 file\n```\n\n这种问题的原因在于jniLibs.srcDirs没有配置，我的so是放在app/src/main/cpp/jniLibs目录里面的，所以在build.gradle里面添加下面配置即可:\n\n```groovy\n\nandroid {\n    ...\n    sourceSets {\n        main {\n            jniLibs.srcDirs = ['src/main/cpp/jniLibs']\n        }\n    }\n}\n```\n\n修改完之后满心欢喜的重新编译运行，立马啪啪打脸，依然找不到\\_Z9getStringv\n\n# 问题分析\n\n## 疑点一: so仍未导入apk\n\n难道是gradle配置没有起作用?解压apk之后发现libdemo.so是有导入的:\n\n```shell\n~/workspace/NDKDemo/app/build/outputs/apk/debug/app-debug/lib  tree .\n.\n└── arm64-v8a\n    ├── libdemo.so\n    └── libnative-lib.so\n\n1 directory, 2 files\n```\n\n## 疑点二: so里面没有这个符号\n\n难道是libdemo.so里面的确没有这个符号?我们可以用nm工具去查看so里面的符号。这个nm命令可以在ndk里面找到，最好找到对应cpu架构的目录下的工具。我编译的是arm64-v8a的so，可以用aarch64-linux-android下面的nm工具:\n\n```shell\n~/Library/Android/sdk/ndk/20.0.5594570  ./toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/aarch64-linux-android/bin/nm  ~/workspace/NDKDemo/app/src/main/cpp/jniLibs/arm64-v8a/libdemo.so | grep getString\n0000000000000538 T _Z9getStringv\n```\n\n输出显示没毛病，so里面的确是有_Z9getStringv这个符号的。\n\n## 疑点三: 诡异的so依赖\n\n其实之后我就在这里卡了很久，感觉哪里都对就结果不对。后面到处搜索也没有找到有人遇到类似的情况。后面是在用readelf分析发现它的依赖有些诡异:\n\n```shell\n~/Library/Android/sdk/ndk/20.0.5594570  ./toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/aarch64-linux-android/bin/readelf -d ~/workspace/NDKDemo/app/build/outputs/apk/debug/app-debug/lib/arm64-v8a/libnative-lib.so\n\nDynamic section at offset 0xdd8 contains 26 entries:\n  Tag        Type                         Name/Value\n 0x0000000000000001 (NEEDED)             Shared library: [libnative-lib.so]\n 0x0000000000000001 (NEEDED)             Shared library: [libm.so]\n 0x0000000000000001 (NEEDED)             Shared library: [libdl.so]\n 0x0000000000000001 (NEEDED)             Shared library: [libc.so]\n 0x000000000000000e (SONAME)             Library soname: [libnative-lib.so]\n ...\n```\n\n我们可以看到libnative-lib.so这个库它不但没有依赖libdemo.so，而且还依赖了它自己。\n\n当时我就震惊了，还能有这种操作？\n\n反复查看cmake配置的依赖配置，没有发现问题:\n\n```cmake\ncmake_minimum_required(VERSION 3.4.1)\n\nadd_library(native-lib SHARED native-lib.cpp)\n\nadd_library(demo SHARED IMPORTED)\n\nset_target_properties(demo PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/jniLibs/${ANDROID_ABI}/libdemo.so)\n\ntarget_link_libraries(native-lib  demo)\n```\n\n## 疑点四: 诡异的SONAME\n\n我也卡了很久一直在cmake里面找原因，以为是编译libnative-lib.so的时候出了问题。后面实在没有头绪，无意中用readelf看了下libdemo.so:\n\n```shell\n~/Library/Android/sdk/ndk/20.0.5594570  ./toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/aarch64-linux-android/bin/readelf -d ~/workspace/NDKDemo/app/build/outputs/apk/debug/app-debug/lib/arm64-v8a/libdemo.so\n\nDynamic section at offset 0xdf8 contains 25 entries:\n  Tag        Type                         Name/Value\n 0x0000000000000001 (NEEDED)             Shared library: [libm.so]\n 0x0000000000000001 (NEEDED)             Shared library: [libdl.so]\n 0x0000000000000001 (NEEDED)             Shared library: [libc.so]\n 0x000000000000000e (SONAME)             Library soname: [libnative-lib.so]\n...\n```\n\n它的SONAME居然是libnative-lib.so，问题肯定就是出在这里了...\n\n# so的几个名字\n\n到了这一步，我们已经找到了问题的原因所在。但是要去解决它的话，我们还需要了解一些基础知识，这里也顺便普及下。so库的名字其实分三种realname、linkname和soname。\n\n## realname\n\nrealname实际上就是so的文件名，一般格式为lib$(name).so.$(major).$(minor).$(revision)例如libcurl.so.4.5.0，我们可以在编译的时候用-o参数指定:\n\n> gcc -shared -o $(realname) ...\n\n## linkname\n\nlinkname是在链接时使用的,用-l参数指定例如下面的foo就是linkname。我们在这里不需要填so文件的名字，gcc会自动为linkname补上lib和.so，去链接lib$(name).so\n\n> gcc main.c -L. -lfoo\n\n## soname\n\nsoname顾名思义就是so的名字，它可以在编译的时候用−Wl,−soname,$(soname)指定，-Wl,表示后面的参数将传给link程序ld。如果不指定的话soname默认为realname:\n\n```shell\ngcc -shared -fPIC -Wl,-soname,libfoo.so.0 -o libfoo.so.0.0.0 foo.c\n```\n\nSoname会被记录在so的二进制数据中，我们可以用readelf命令查看:\n\n```shell\nreadelf  -d libfoo.so.0.0.0\n\nDynamic section at offset 0xf18 contains 25 entries:\n  标记        类型                         名称/值\n 0x00000001 (NEEDED)                     共享库：[libc.so.6]\n 0x0000000e (SONAME)                     Library soname: [libfoo.so.0]\n ...\n```\n\n那它有什么作用呢，我们可以做个试验:\n\n```shell\n$ gcc -shared -fPIC -Wl,-soname,libfoo.so.0 -o libfoo.so.0.0.0 foo.c\n$ ln -s libfoo.so.0.0.0 libfoo.so\n$ gcc main.c -L. -lfoo -o demo\n$ ldd demo\n        linux-vdso.so.1 (0xbece4000)\n        /usr/lib/arm-linux-gnueabihf/libarmmem-${PLATFORM}.so => /usr/lib/arm-linux-gnueabihf/libarmmem-v7l.so (0xb6ef5000)\n        libfoo.so.0 => not found\n        libc.so.6 => /lib/arm-linux-gnueabihf/libc.so.6 (0xb6d8f000)\n        /lib/ld-linux-armhf.so.3 (0xb6f0a000)\n\n```\n\n我们先编译了一个realname为libfoo.so.0.0.0，soname为libfoo.so.0的so库，然后创建一个软连接libfoo.so指向它，接着用foo这个linkname指定这个软链接去编译demo。\n\n最后使用ldd查看demo的依赖，发现它依赖的是libfoo.so.0这个soname而不是编译的时候使用的libfoo.so。用readelf查看demo也能看到:\n\n```shell\n$ readelf -d demo\n\nDynamic section at offset 0xf10 contains 25 entries:\n  标记        类型                         名称/值\n 0x00000001 (NEEDED)                     共享库：[libfoo.so.0]\n 0x00000001 (NEEDED)                     共享库：[libc.so.6]\n...\n```\n\n也就是说在编译demo这个程序的时候，会通过linkname找到libfoo.so，它是个软链接实际指向libfoo.so.0.0.0，然后gcc会从libfoo.so.0.0.0里面读取soname写入demo的二进制信息。于是如果这个时候执行demo的话就会报找不到libfoo.so.0的问题:\n\n```shell\n$ ./demo\n./demo: error while loading shared libraries: libfoo.so.0: cannot open shared object file: No such file or directory\n```\n\n# 问题原因\n\n好了，现在回到我们的问题。最后我们分析到libdemo.so的soname居然是libnative-lib.so，那么原因很容易猜到就是−Wl,−soname指定错了。\n\n查看编译记录的确是这个问题：由于新版本的ndk已经放弃gcc转向clang，我前段时间刚好换了电脑下载的是比较新的ndk，里面找不到熟悉的gcc了而我之前又没有用过clang。所以编译的指令是从android studio编译libnative-lib.so的日志里面拷贝修改的。它有很大一坨，又由于粗心，只改了-o 参数和.c文件，没有修改soname，然后问题就出现了。\n\n然后这里还有一个坑，我一开始是直接报−Wl,−soname,libnative-lib.so这段给删掉了，因为使用gcc的时候如果没有指定，会自动把realname当做soname，但是clang不会。这个时候编译出来的so里面没有SONAME字段:\n\n```shell\n$ readelf -d libdemo.so\n\nDynamic section at offset 0xe08 contains 24 entries:\n  Tag        Type                         Name/Value\n 0x0000000000000001 (NEEDED)             Shared library: [libm.so]\n 0x0000000000000001 (NEEDED)             Shared library: [libdl.so]\n 0x0000000000000001 (NEEDED)             Shared library: [libc.so]\n 0x000000000000001a (FINI_ARRAY)         0x10df8\n```\n\n于是在运行的时候又会报找不到libdemo.so。也就是说在运行的时候查找依赖的原理是:从libnative-lib.so读到依赖libdemo.so，找到libdemo.so之后还会验证它的soname对不对，如果你只是realname为libdemo.so，soname不匹配也是不会去链接的。\n\n最后将−Wl,−soname,libdemo.so加回上去问题解决。\n\n事后回想了下，其实这种问题遇到的几率还是比较小的。因为如果c部分是我们自己写的，一般也就放到android stduio里面合成一个so。而如果需要导入外部的so一般也是用的第三方的，他们也很难出这种低级问题。就算像我这样的需求自己写个外部的so导入，干这活的一般也是个成熟的c/c++的程序员。也就我这种半桶水还啥都要自己干的苦逼会遇到。\n\n","tags":["技术相关","Android","C/C++"]},{"title":"python与c/c++相互调用","url":"/2020/10/30/python与c-c-相互调用/","content":"\n最近的项目使用python语言，其中一个功能需要对接c++的sdk。于是学习了下python与c/c++的相互调用方法，这里做下笔记，方便以后查找。\n\npython里面调用c/c++代码基本上有三种方式: ctypes库、cffi库和c/c++拓展模块。这篇笔记主要讲的是拓展模块，不过ctypes和cffi也会稍微介绍一下:\n\n# ctypes\n\n使用ctypes模块十分简单，这里直接上demo。我们的c代码如下:\n\n```c\n// demo.c\nint add(int a, int b) {\n    return a + b;\n}\n```\n\n使用下面命令编译demo.so\n\n> gcc demo.c -shared -fPIC -o demo.so\n\n然后python里面只需要用ctypes.cdll.LoadLibrary方法加载so库，就可以通过方法名去调用c的函数了:\n\n```python\nimport ctypes\nlib = ctypes.cdll.LoadLibrary(\"./demo.so\")\nprint(lib.add(1, 3))\n```\n\n基本上不需要过多的介绍，不过有个坑是如果写的是c++，那么需要用extern \"C\"包裹下给python调用的函数:\n\n```c++\nclass Utils {\npublic:\n        static int add(int a, int b) {\n                return a + b;\n        }\n};\n\nextern \"C\" {\n\nint add(int a, int b) {\n        return Utils::add(a, b);\n}\n\n}\n```\n\n这么做的原因在于c++编译之后会修改函数的名字，add函数在编译之后变成了__ZN5Utils3addEii，而且不同编译器的修改规则还不一样，所以在python里面用add找不到对应的函数。\n\n加上extern \"C\"包裹之后能让编译器按照c的方式去编译这个函数，不对函数名做额外的修改，这样python里面才能通过函数名去调用它。\n\n# cffi\n\ncffi和ctypes类似，但是稍微复杂一些。\n\ncffi的功能其实是在python里面写c代码，我们可以通过python里面写的c代码去调用第三库的c代码。\n\n这么说可能有点抽象，我举个例子大家可能就好理解了:\n\n我们在c里面实现了一个foo方法，它的作用是打印传入的字符串，并且返回字符串的长度:\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint foo(char* str) {\n    printf(\"%s\\n\", str);\n    return strlen(str);\n}\n```\n\n我们将上面的c代码编译成ffidemo.so，然后用下面的python代码去调用这个foo方法:\n\n```python\nfrom cffi import FFI\n\nffi = FFI()\nlib = ffi.dlopen(\"./ffidemo.so\")           # 导入so\nffi.cdef(\"int foo(char* str);\")            # 声明foo方法\nparam = ffi.new(\"char[]\", b\"hello world!\") # 创建char数组\nprint(lib.foo(param))                      # 调用之前声明的foo方法,它的实现在ffidemo.so\n```\n\n\n\n# c/c++拓展模块\n\n使用ctypes的方式虽然简便，但是在使用上能明显的感觉出来是在调用so库的代码。\n\n更不用说使用cffi会在python代码里面嵌入c的语句，总有种莫名的不协调感。\n\n而且c/c++编码规范里一般方法名会用驼峰，但是python编码规范里建议方法名用下划线分割单词，上面的两种方法都会造成python里面调用so和python脚本的方法有两种命名规范，逼死强迫症。\n\n有没有一种方法可能让python无感调用c/c++代码，就像调用普通的python代码一样呢？\n\n答案就是使用c/c++为Python编写扩展模块。虽然有[官方文档](https://docs.python.org/zh-cn/3/extending/extending.html)可以参考，但这个文档其实讲的不是很全，当初也遇到了不少问题，这里也整理下。\n\n我们希望Python里面像这样去调用c/c++:\n\n```python\nimport demo\ndemo.foo()\n```\n\nc/c++的完整代码如下:\n\n```c++\n#define PY_SSIZE_T_CLEAN\n#include <Python.h>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nPyObject* Foo(PyObject* self, PyObject* args) {\n    cout<<\"Foo\"<<endl;\n    return Py_BuildValue(\"\");\n}\n\nstatic PyMethodDef g_moduleMethods[] = {\n        {\"foo\", Foo, METH_NOARGS, \"function Foo\"},\n        {NULL, NULL, 0, NULL}\n};\n\nstatic PyModuleDef g_moduleDef = {\n        PyModuleDef_HEAD_INIT,\n        \"ExtendedDemo\",                /* name of module */\n        \"C/C++ Python extension demo\", /* module documentation, may be NULL */\n        -1,                            /* size of per-interpreter state of the module, or -1 \n                                          if the module keeps state in global variables. */\n        g_moduleMethods\n};\n\nPyMODINIT_FUNC PyInit_demo(void) {\n        return PyModule_Create(&g_moduleDef);\n}\n\n```\n\n我们用下面命令将这个代码编译成demo.so (mac系统下):\n\n```shell\ng++ demo.cpp -shared -fPIC -o demo.so -I /usr/local/Frameworks/Python.framework/Versions/3.7/include/python3.7m -L /usr/local/Frameworks/Python.framework/Versions/3.7/lib -lpython3.7m\n```\n\npython的import demo语句就会去动态链接这个demo.so，并且调用PyInit_demo方法。也就是说**so的名字要和PyInit_XXX这个方法名对应**，要不然python里面会报找不到init方法的异常。\n\n这个init方法很简单，就是创建了一个module。这个module的定义在g\\_moduleDef这个全局变量里面，它定义了module的name、documentation等，这里的name可以和so的名字不一样，它在python里module的\\_\\_name\\_\\_、\\_\\_doc\\_\\_里面体现:\n\n```python\nimport demo\nprint(demo.__name__)  # ExtendedDemo\nprint(demo.__doc__)   # C/C++ Python extension demo\n```\n\ng\\_moduleDef里面最重要的是最后一个成员g\\_moduleMethods，它定义的module里面的方法。这货是个PyMethodDef结构体数组，定义了方法名字，方法的指针，参数类型，和文档描述：\n\n```c++\nstruct PyMethodDef {\n    const char  *ml_name;   /* The name of the built-in function/method */\n    PyCFunction ml_meth;    /* The C function that implements it */\n    int         ml_flags;   /* Combination of METH_xxx flags, which mostly\n                               describe the args expected by the C func */\n    const char  *ml_doc;    /* The __doc__ attribute, or NULL */\n};\ntypedef struct PyMethodDef PyMethodDef;\n```\n\nml\\_name、ml\\_meth和ml\\_doc都很好理解，ml\\_flags有点小坑。它可以是下面几种类型:\n\n- METH\\_NOARGS 没有参数\n- METH_VARARGS 可变参数\n- METH_VARARGS | METH\\_KEYWORDS 可变参数+关键字参数\n\n## METH\\_NOARGS\n\n我们上面的demo里foo方法就是没有参数的，这里可能有同学会说怎么就没有参数了？明明它有两个参数:\n\n```C++\nPyObject* Foo(PyObject* self, PyObject* args) {\n    cout<<\"Foo\"<<endl;\n    return Py_BuildValue(\"\");\n}\n```\n\n是的，虽然在c/c++这里的声明它是有两个参数的，但是由于我们在g\\_moduleMethods里面给它的声明是METH\\_NOARGS，在python里面如果给它传参就会出现异常:\n\n```python\nimport demo\ndemo.foo(1)\n\n# 出现异常\n# Traceback (most recent call last):\n#   File \"test.py\", line 2, in <module>\n#     demo.foo(1)\n#  TypeError: foo() takes no arguments (1 given)\n```\n\n所以对于METH\\_NOARGS类型的方法来说，c/c++里面的args参数其实是没有意义的，它总是NULL。\n\n而 *self* 参数，对模块级函数指向模块对象，对于对象实例则指向方法。\n\n\n## METH_VARARGS\n\n当我们将一个方法声明成METH_VARARGS，这个函数的args就会变成一个元组，我们可以通过PyArg\\_Parse方法解析出里面的值，例如下面的add方法:\n\n```c++\nPyObject* Add(PyObject* self, PyObject* args) {\n    int a,b;\n    PyArg_Parse(args, \"(ii)\", &a, &b);\n    return Py_BuildValue(\"i\", a+b);\n}\n\nstatic PyMethodDef g_moduleMethods[] = {\n        ...\n        {\"add\", Add, METH_VARARGS, \"function Add\"},\n        ...\n}\n```\n\n这个方法接收两个int的参数，然后返回a+b的值:\n\n```python\nimport demo\nprint(demo.add(1,2)) # 3\n```\n\n我们看到PyArg\\_Parse和Py\\_BuildValue都有个字符串去配置数据类型，它们很相似，只不过一个是解析PyObejct\\*一个是生成PyObejct\\*，这里用Py\\_BuildValue举例(左侧是调用，右侧是Python值结果):\n\n```c++\nPy_BuildValue(\"\")                        None\nPy_BuildValue(\"i\", 123)                  123\nPy_BuildValue(\"iii\", 123, 456, 789)      (123, 456, 789)\nPy_BuildValue(\"s\", \"hello\")              'hello'\nPy_BuildValue(\"y\", \"hello\")              b'hello'\nPy_BuildValue(\"ss\", \"hello\", \"world\")    ('hello', 'world')\nPy_BuildValue(\"s#\", \"hello\", 4)          'hell'\nPy_BuildValue(\"y#\", \"hello\", 4)          b'hell'\nPy_BuildValue(\"()\")                      ()\nPy_BuildValue(\"(i)\", 123)                (123,)\nPy_BuildValue(\"(ii)\", 123, 456)          (123, 456)\nPy_BuildValue(\"(i,i)\", 123, 456)         (123, 456)\nPy_BuildValue(\"[i,i]\", 123, 456)         [123, 456]\nPy_BuildValue(\"{s:i,s:i}\",\n              \"abc\", 123, \"def\", 456)    {'abc': 123, 'def': 456}\nPy_BuildValue(\"((ii)(ii)) (ii)\",\n              1, 2, 3, 4, 5, 6)          (((1, 2), (3, 4)), (5, 6))\n```\n\n不过需要注意的是，**虽然Py\\_BuildValue不用加括号也能自动解析成元组，但是如果要用PyArg\\_Parse解析元组的话必须加上括号**,当然你也可以直接用PyArg\\_ParseTuple去元组，这样的话就不需要带括号。\n\n## METH\\_KEYWORDS\n\n关于METH\\_KEYWORDS，文档里面有这样一句话(好像漏了METH\\_NOARGS，我测试验证这个也是可以用的):\n\n> 这个标志指定会使用C的调用惯例。可选值有 `METH_VARARGS` 、 `METH_VARARGS | METH_KEYWORDS` \n\n也就是说METH\\_KEYWORDS是不能单独使用的，必须要和METH\\_VARARGS一起。我一开始没有注意，单独使用之后一直报错。\n\n这样配置的方法参数类似python里面的func(*args, **kwargs)，而c/c++里面的函数声明和METH\\_NOARGS、METH\\_VARARGS不一样，有三个参数。可以看下下面的demo:\n\n```c++\nPyObject* Subtract(PyObject* self, PyObject* args, PyObject* keywds) {\n    int a,b;\n    char *kwlist[] = {\"a\", \"b\", NULL};\n    PyArg_ParseTupleAndKeywords(args, keywds, \"ii\", kwlist, &a, &b);\n    return Py_BuildValue(\"i\", a-b);\n}\nstatic PyMethodDef g_moduleMethods[] = {\n        ...\n        {\"subtract\", (PyCFunction)(void(*)(void))Subtract, METH_VARARGS|METH_KEYWORDS, \"function Subtract\"},\n        ...\n};\n```\n\npython里面就能用可变参数和关键字参数的方式传参:\n\n```python\nimport demo\nprint(demo.subtract(1, 2))     # -1\nprint(demo.subtract(1, b=2))   # -1\nprint(demo.subtract(b=1, a=2)) # 1\n```\n\n## c/c++回调python\n\n通过上面的讲解我们可以轻松实现python对c/c++函数的调用。但是我们的项目还出现了python往c/c++里面设置回调函数的需求，我们接下来就来看看这个需求要怎么实现。\n\n下面是c++部分的代码，它注册了个方法，参数是一个PyObject\\*，实际上它是个回调函数，我把可以用PyEval\\_CallObject去调用它计算两个字符串的字符总数，得到一个PyObject\\*的返回值。我们可以用PyLong\\_AsLong将它解析成c的long类型:\n\n```c++\nPyObject* SetCountCallback(PyObject* self, PyObject* args) {\n    PyObject* callback;\n    PyArg_Parse(args, \"(O)\", &callback);\n\n    PyGILState_STATE state = PyGILState_Ensure();\n    PyObject* callbackArgs = Py_BuildValue(\"(ss)\", \"hello \", \"world\");\n    PyObject* result = PyEval_CallObject(callback, callbackArgs);\n    cout<<\"count result : \"<<PyLong_AsLong(result)<<endl;\n\n    Py_DECREF(callbackArgs);\n    PyGILState_Release(state);\n\n    return Py_BuildValue(\"\");\n}\n\nstatic PyMethodDef g_moduleMethods[] = {\n        ...\n        {\"setCountCallback\", SetCountCallback, METH_VARARGS, \"function SetCountCallback\"},\n        ...\n};\n\n```\n\npython的代码如下:\n\n```python\nimport demo\ndef count(str1, str2):\n    return len(str1) + len(str2)\ndemo.setCountCallback(count) # c++会打印count result : 11\n```\n\n类似的我们可以用PyFloat\\_AsDouble从PyObject\\*解析出double类型的数据。但是如果是字符串类型的话解析比较麻烦需要先转换成bytes类型的数据再转成char\\*，可以用下面这个方法转换:\n\n```c++\nstring GetStringFromPyObject(PyObject* pObject) {\n    PyObject* bytes = PyUnicode_AsUTF8String(pObject);\n    string str = PyBytes_AsString(bytes);\n    Py_DECREF(bytes);\n    return str;\n}\n```\n\n如果是返回的元组的话可以用遍历的方法去读取，用PyTuple\\_Size读取数量然后用PyTuple\\_GetItem读取item，然后再用上面的转换方法转换:\n\n```c++\nPyObject* SetSplicingAndCountCallback(PyObject* self, PyObject* args) {\n    PyObject* callback;\n    PyArg_Parse(args, \"(O)\", &callback);\n\n    PyGILState_STATE state = PyGILState_Ensure();\n    PyObject* callbackArgs = Py_BuildValue(\"(ss)\", \"hello \", \"world\");\n    PyObject* result = PyEval_CallObject(callback, callbackArgs);\n    cout<<\"result size : \"<<PyTuple_Size(result)<<endl;\n    cout<<\"item0 : \"<<GetStringFromPyObject(PyTuple_GetItem(result, 0))<<endl;\n    cout<<\"item1 : \"<<PyLong_AsLong(PyTuple_GetItem(result, 1))<<endl;\n    Py_DECREF(callbackArgs);\n    PyGILState_Release(state);\n\n    return Py_BuildValue(\"\");\n}\n```\n\nPython里面这么调用:\n\n```python\nimport demo\n\ndef splicing_and_count(str1, str2):\n    return str1+str2, len(str1)+len(str2)\n    \ndemo.setSplicingAndCountCallback(splicing_and_count)\n```\n\n不过实际调试的时候使用PyArg\\_Parse也能解析出返回值元组的数据，但是这个方法的名字用在解析返回值这里总感觉怪怪的，说不好有什么坑，这块文档里面也没有讲。\n\n```c\nchar* s;\nint i;\nPyArg_Parse(result, \"(si)\", &s, &i);\n```\n\n# 完整demo\n\n```c++\n#define PY_SSIZE_T_CLEAN\n#include <Python.h>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nPyObject* Foo(PyObject* self, PyObject* args) {\n    cout<<self<<endl;\n    cout<<args<<endl;\n    cout<<\"Foo\"<<endl;\n    return Py_BuildValue(\"\");\n}\n\nPyObject* Add(PyObject* self, PyObject* args) {\n    int a,b;\n    PyArg_Parse(args, \"(ii)\", &a, &b);\n    return Py_BuildValue(\"i\", a+b);\n}\n\nPyObject* Subtract(PyObject* self, PyObject* args, PyObject* keywds) {\n    int a,b;\n    char *kwlist[] = {\"a\", \"b\", NULL};\n    PyArg_ParseTupleAndKeywords(args, keywds, \"ii\", kwlist, &a, &b);\n    return Py_BuildValue(\"i\", a-b);\n}\n\nPyObject* SetCountCallback(PyObject* self, PyObject* args) {\n    PyObject* callback;\n    PyArg_Parse(args, \"(O)\", &callback);\n\n    PyGILState_STATE state = PyGILState_Ensure();\n    PyObject* callbackArgs = Py_BuildValue(\"(ss)\", \"hello \", \"world\");\n    PyObject* result = PyEval_CallObject(callback, callbackArgs);\n    cout<<\"count result : \"<<PyLong_AsLong(result)<<endl;\n\n    Py_DECREF(callbackArgs);\n    PyGILState_Release(state);\n\n    return Py_BuildValue(\"\");\n}\n\nstring GetStringFromPyObject(PyObject* pObject) {\n    PyObject* bytes = PyUnicode_AsUTF8String(pObject);\n    string str = PyBytes_AsString(bytes);\n    Py_DECREF(bytes);\n    return str;\n}\n\nPyObject* SetSplicingCallback(PyObject* self, PyObject* args) {\n    PyObject* callback;\n    PyArg_Parse(args, \"(O)\", &callback);\n\n    PyGILState_STATE state = PyGILState_Ensure();\n    PyObject* callbackArgs = Py_BuildValue(\"(ss)\", \"hello \", \"world\");\n    PyObject* result = PyEval_CallObject(callback, callbackArgs);\n    cout<<\"splicing result : \"<<GetStringFromPyObject(result)<<endl;\n\n    Py_DECREF(callbackArgs);\n    PyGILState_Release(state);\n\n    return Py_BuildValue(\"\");\n}\n\nPyObject* SetSplicingAndCountCallback(PyObject* self, PyObject* args) {\n    PyObject* callback;\n    PyArg_Parse(args, \"(O)\", &callback);\n\n    PyGILState_STATE state = PyGILState_Ensure();\n    PyObject* callbackArgs = Py_BuildValue(\"(ss)\", \"hello \", \"world\");\n    PyObject* result = PyEval_CallObject(callback, callbackArgs);\n    cout<<\"result size : \"<<PyTuple_Size(result)<<endl;\n    cout<<\"item0 : \"<<GetStringFromPyObject(PyTuple_GetItem(result, 0))<<endl;\n    cout<<\"item1 : \"<<PyLong_AsLong(PyTuple_GetItem(result, 1))<<endl;\n\n    char* s;\n    int i;\n    PyArg_Parse(result, \"(si)\", &s, &i);\n    cout<<\"s=\"<<s<<endl;\n    cout<<\"i=\"<<i<<endl;\n\n    Py_DECREF(callbackArgs);\n    PyGILState_Release(state);\n\n    return Py_BuildValue(\"\");\n}\n\nstatic PyMethodDef g_moduleMethods[] = {\n        {\"foo\", Foo, METH_NOARGS, \"function Foo\"},\n        {\"add\", Add, METH_VARARGS, \"function Add\"},\n        {\"subtract\", (PyCFunction)(void(*)(void))Subtract, METH_VARARGS|METH_KEYWORDS, \"function Subtract\"},\n        {\"setCountCallback\", SetCountCallback, METH_VARARGS, \"function SetCountCallback\"},\n        {\"setSplicingCallback\", SetSplicingCallback, METH_VARARGS, \"function SetSplicingCallback\"},\n        {\"setSplicingAndCountCallback\", SetSplicingAndCountCallback, METH_VARARGS, \"function SetSplicingAndCountCallback\"},\n        {NULL, NULL, 0, NULL}\n};\n\nstatic PyModuleDef g_moduleDef = {\n        PyModuleDef_HEAD_INIT,\n        \"ExtendedDemo\",\n        \"C/C++ Python extension demo\",\n        -1,\n        g_moduleMethods\n};\n\nPyMODINIT_FUNC PyInit_demo(void) {\n        return PyModule_Create(&g_moduleDef);\n}\n```\n\n```python\nimport demo\n\nprint(demo.__name__)\nprint(demo.__doc__)\n\n\nprint(demo.add.__name__)\nprint(demo.add.__doc__)\n\ndef splicing(str1, str2):\n    return str1+str2\n\ndef count(str1, str2):\n    return len(str1) + len(str2)\n\ndef splicing_and_count(str1, str2):\n    return splicing(str1, str2), count(str1, str2)\n\ndemo.foo()\nprint(demo.add(1,2))\nprint(demo.subtract(1, 2))\nprint(demo.subtract(1, b=2))\nprint(demo.subtract(b=1, a=2))\n\ndemo.setCountCallback(count)\ndemo.setSplicingCallback(splicing)\ndemo.setSplicingAndCountCallback(splicing_and_count)\n\ndef foo(a,b):\n    return a-b\n```","tags":["技术相关","C/C++","python"]},{"title":"JNI编译错误-符号未定义","url":"/2020/09/27/JNI编译错误-符号未定义/","content":"这篇笔记记录了一次编译问题的排查过程，还简单介绍了一些C/C++编译的知识，希望对jni编译错误的排查能有点帮助。\n\n没有接触过C/C++的安卓程序员可能在遇到so库出现编译问题的时候会有点束手无措，如果这个库是公司内部开发的还能丢给负责的同事分析，如果是第三方的开源库可能就需要我们自己去分析了。\n\n# Alexa rapidjson符号未定义\n\n我司基于亚马逊开源的Alexa应用分为两个工程，一个是[avs-device-sdk](https://github.com/alexa/avs-device-sdk)用于打包出相关的动态链接库(当然我们对这个开源项目做了一些定制化修改)。另外一个是安卓应用工程，包含java层的ui展现、jni接口和部分c++的alexa初始化逻辑。\n\n在更新Alexa sdk版本打包apk的过程中出现了这样一个编译错误:\n\n```c++\nerror: undefined reference to 'alexaClientSDK::avsCommon::utils::json::jsonUtils::findNode(rapidjson::GenericValue<rapidjson::UTF8<char>, rapidjson::MemoryPoolAllocator<rapidjson::CrtAllocator> > const&, std::__ndk1::basic_string<char, std::__ndk1::char_traits<char>, std::__ndk1::allocator<char> > const&, rapidjson::GenericMemberIterator<true, rapidjson::UTF8<char>, rapidjson::MemoryPoolAllocator<rapidjson::CrtAllocator> >*)'\n```\n\n这个错误的意思是找不到findNode这个方法的定义。\n\n# c/c++编译基础\n\n在这里要大概的介绍下c/c++的编译流程，C/C++的编译可以分为下面几个步骤:\n\n{% img /JNI编译错误-符号未定义/1.png %}\n\n代码通过前面的预处理、编译、汇编之后就生成了包含机器指令的.o文件，一个.c或者.cpp文件就会生成一个.o文件。每个.o文件都只有自己那部分的代码，需要将他们合并到一起才能组成一个可执行程序，这个合并的过程叫做链接。\n\n{% img /JNI编译错误-符号未定义/2.png %}\n\n而且.o文件之间是有依赖关系的，a.o可能调用到b.o的代码，如果调用的代码的实现找不到了，就会出现上面所说的undefined reference错误。\n\n实际上链接过程中除了.o文件之外还有有动态链接库、静态链接库参与进来。链接库是一些可复用的代码，\n\n动态链接库、静态链接库windows上对应的是.lib、.dll linux上对应的是.a、.so它们的区别在于静态链接库在链接的时候会和.o文件一起打包到可执行文件中，而动态链接库不会被打包进可执行文件，而是在运行过程中被加载。\n\n.o文件依赖的代码除了在其他.o文件中，还有可能在静态链接库或者动态链接库中。(关于c/c++的编译我之前有写一篇博客[写给安卓程序员的C/C++编译入门](https://blog.islinjw.cn/2018/07/29/写给安卓程序员的cc-编译入门/),感兴趣的同学可以去看看)\n\n# nm命令使用\n\n出现了上面的错误，我的第一反应是so库没有链接进来。该函数的定义在libAVSCommon.so，查看CMakeLists.txt之后发现该库是有正常链接的:\n\n```cmake\ntarget_link_libraries( AlexaJni AVSCommon)\n```\n\n而且如果将这行代码注释掉，不去链接它，会出现更多其他的符号未定义，所以这个库肯定是正常链接的。\n\n这种情况下可能考虑是不是出现了宏没有打开的情况，例如下面这样的代码:\n\n```c++\n#ifdef EN_XXX\n// code\n#endif\n```\n\n如果这个EN_XXX的宏没有定义，中间的代码就会在预编译的时候被清除。\n\n这样的情况我们有两种方法去判断，第一种是看代码看看能不能找到这样的宏，并且看看它是否真的没有打开。另一种方法是通过nm命令列举so文件中的符号:\n\n> nm libAVSCommon.so\n\n我们在里面是可以找到findNode符号的:\n\n{% img /JNI编译错误-符号未定义/3.png %}\n\n```shell\n0013f768 T _ZN14alexaClientSDK9avsCommon5utils4json9jsonUtils8findNodeERKN9rapidjson12GenericValueINS4_4UTF8IcEENS4_12CrtAllocatorEEERKNSt6__ndk112basic_stringIcNSC_11char_traitsIcEENSC_9allocatorIcEEEEPNS4_21GenericMemberIteratorILb1ES7_S8_EE\n```\n\n我们首先可以看到的是方法的名字好像和之前不一样了，感觉多了很多内容。\n\n## 编译后C++函数名会被修改\n\n其实C/C++在编译之后函数的名字就会被修改，改成编译器内部的名字，每个编译器都有一套自己内部的名字，这里就看看g++编译器的实现:\n\n```c++\nnamespace mytest {\n  void foo(int a) {\n  }\n  void foo(int a, int b) {\n  }\n}\n```\n\nnamespace 关键字顾名思义是定义一个命名空间。编程的时候一个很令人头大的问题是起名字，很多的库可能都会有个叫做Utils的类，也有可能有些比较常见的函数如PrintLog，当导入多个不同的第三方库的时候很容易出现命名冲突的问题，namespace的作用就在于将这些同名的类或者函数区分开来，一般的第三方库都会以库的名字起一个命名空间，这样就能尽可能的减少命名冲突。\n\nc++编译器实现命名空间的方式也很简单，就在将命名空间的名字拼到函数名前面，可以看到编译之后foo的前面多了mytest这个命名空间:\n\n```shell\n0000000100000f60 T __ZN6mytest3fooEi\n0000000100000f70 T __ZN6mytest3fooEii\n```\n\n然后我们可以在上面的例子看到有两个名字一样的函数，但是他们的参数数量不一样，像这种函数名字一样但是参数数量或者类型不一样的情况叫做函数重载，其实C语言不支持函数重载，但是C++支持的。C++支持重载的原理就是在函数的后面拼接参数类型:\n\n例如void foo(int a)有一个int类型的参数，于是就在后面加了一个i:\n\n```shell\n__ZN6mytest3fooEi\n```\n\n而void foo(int a, int b)又两个int类型的参数，于是就在后面加了两个i:\n\n```shell\n__ZN6mytest3fooEii\n```\n\n同理的如果有泛型参数也是会拼接在函数名字后面。\n\n像我们在使用JNI的时候经常能看到这样的代码\n\n```\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n...\n\n#ifdef __cplusplus\n}\n#endif\n\n```\n\n就是为了在c++编译器声明C代码防止函数名被修改，因为在静态注册的情况下，java层的natvie方法名和c的函数名是有对应关系的，一旦函数名被修改了就对应不上了。\n\n## nm符号类型\n\n我们可以看到上面nm命令的打印，在函数名签名都会有一个 T，这个T指的是该符号的类型。符号类型有很多种，它和C/C++的内存模型有很大关系，作为安卓程序员我们只需要大概了解就够了，对于每一个符号来说，其类型如果是小写的，则表明该符号是local的；大写则表明该符号是global(external)的。下面这张表我是在网上摘抄的别人的[博客](https://www.cnblogs.com/LiuYanYGZ/p/5536607.html):\n\n| **符号 类型** | **说明**                                                     |\n| ------------- | ------------------------------------------------------------ |\n| A             | 该符号的值是绝对的，在以后的链接过程中，不允许进行改变。这样的符号值，常常出现在中断向量表中，例如用符号来表示各个中断向量函数在中断向量表中的位置。 |\n| B             | 该符号的值出现在非初始化数据段(bss)中。例如，在一个文件中定义全局static int test。则该符号test的类型为b，位于bss section中。其值表示该符号在bss段中的偏移。一般而言，bss段分配于RAM中 |\n| C             | 该符号为common。common symbol是未初始话数据段。该符号没有包含于一个普通section中。只有在链接过程中才进行分配。符号的值表示该符号需要的字节数。例如在一个c文件中，定义int test，并且该符号在别的地方会被引用，则该符号类型即为C。否则其类型为B。 |\n| D             | 该符号位于初始话数据段中。一般来说，分配到data section中。例如定义全局int baud_table[5] = {9600, 19200, 38400, 57600, 115200}，则会分配于初始化数据段中。 |\n| G             | 该符号也位于初始化数据段中。主要用于small object提高访问small data object的一种方式。 |\n| I             | 该符号是对另一个符号的间接引用。                             |\n| N             | 该符号是一个debugging符号。                                  |\n| R             | 该符号位于只读数据区。例如定义全局const int test[] = {123, 123};则test就是一个只读数据区的符号。注意在cygwin下如果使用gcc直接编译成MZ格式时，源文件中的test对应_test，并且其符号类型为D，即初始化数据段中。但是如果使用m6812-elf-gcc这样的交叉编译工具，源文件中的test对应目标文件的test,即没有添加下划线，并且其符号类型为R。一般而言，位于rodata section。值得注意的是，如果在一个函数中定义const char *test = “abc”, const char test_int = 3。使用nm都不会得到符号信息，但是字符串“abc”分配于只读存储器中，test在rodata section中，大小为4。 |\n| S             | 符号位于非初始化数据区，用于small object。                   |\n| T             | 该符号位于代码区text section。                               |\n| U             | 该符号在当前文件中是未定义的，即该符号的定义在别的文件中。例如，当前文件调用另一个文件中定义的函数，在这个被调用的函数在当前就是未定义的；但是在定义它的文件中类型是T。但是对于全局变量来说，在定义它的文件中，其符号类型为C，在使用它的文件中，其类型为U。 |\n| V             | 该符号是一个weak object。                                    |\n| W             | The symbol is a weak symbol that has not been specifically tagged as a weak object symbol. |\n| -             | 该符号是a.out格式文件中的stabs symbol。                      |\n| ?             | 该符号类型没有定义                                           |\n\n函数的符号类型是T或者小写的t，当然如果这个函数是在其他动态链接库里面定义的，它的类型就是U。\n\n那local和global有什么区别吗？什么样的函数是local的，什么样的函数是global的？\n\n一般情况下函数默认都是global的，这意味着so库里面的函数可以被外部使用，但是如果有些函数只想so库内部使用不暴露给外部，就可以添加static关键字:\n\n```c++\nstatic void foo() {\n}\n```\n\n它的符号类型就是t，在so外部是看不到这个函数不能使用的:\n\n```\n0000000100000fb0 t __ZL3foov\n```\n\n## rapidjson编译配置\n\n我们使用nm命令打印libAVSCommon.so的符号表可以看到，alexaClientSDK::avsCommon::utils::json::jsonUtils::findNode这个函数在so里面是存在的，而且是有定义的(符号类型是T不是U):\n\n```shell\n0013f768 T _ZN14alexaClientSDK9avsCommon5utils4json9jsonUtils8findNodeERKN9rapidjson12GenericValueINS4_4UTF8IcEENS4_12CrtAllocatorEEERKNSt6__ndk112basic_stringIcNSC_11char_traitsIcEENSC_9allocatorIcEEEEPNS4_21GenericMemberIteratorILb1ES7_S8_EE\n```\n\n一开始看到这里我是懵逼的，很不科学。于是我用了一个方法，修改了findNode函数的名字，重新编译libAVSCommon.so，这样的话在其他so库使用它的地方就出现了找不到符号的错误:\n\n```c++\nerror: undefined reference to 'alexaClientSDK::avsCommon::utils::json::jsonUtils::findNode(rapidjson::GenericValue<rapidjson::UTF8<char>, rapidjson::CrtAllocator> const&, std::__ndk1::basic_string<char, std::__ndk1::char_traits<char>, std::__ndk1::allocator<char> > const&, rapidjson::GenericMemberIterator<true, rapidjson::UTF8<char>, rapidjson::CrtAllocator>*)'\n```\n\n而这里的打印和我们在编译apk的时候的打印好像不太一样，编译apk的时候的打印如下:\n\n```c++\nerror: undefined reference to 'alexaClientSDK::avsCommon::utils::json::jsonUtils::findNode(rapidjson::GenericValue<rapidjson::UTF8<char>, rapidjson::MemoryPoolAllocator<rapidjson::CrtAllocator> > const&, std::__ndk1::basic_string<char, std::__ndk1::char_traits<char>, std::__ndk1::allocator<char> > const&, rapidjson::GenericMemberIterator<true, rapidjson::UTF8<char>, rapidjson::MemoryPoolAllocator<rapidjson::CrtAllocator> >*)'\n```\n\n它们的参数类型不一样,这个时候我们再去看看它的函数定义:\n\n```c++\nbool findNode(\n    const rapidjson::Value& jsonNode,\n    const std::string& key,\n    rapidjson::Value::ConstMemberIterator* iteratorPtr);\n```\n\nrapidjson::Value的定义如下:\n\n```c++\n\ntemplate <typename Encoding, typename Allocator = RAPIDJSON_DEFAULT_ALLOCATOR >\nclass GenericValue {\n    ...\n  typedef typename GenericMemberIterator<true,Encoding,Allocator>::Iterator ConstMemberIterator;  //!< Constant member iterator for iterating in object.\n  ...\n};\n\n//! GenericValue with UTF8 encoding\ntypedef GenericValue<UTF8<> > Value;\n```\n\n这里我们可以看到，泛型参数Allocator由RAPIDJSON\\_DEFAULT\\_ALLOCATOR这个宏决定，默认情况下是:\n\n```c++\n#ifndef RAPIDJSON_DEFAULT_ALLOCATOR\n#define RAPIDJSON_DEFAULT_ALLOCATOR MemoryPoolAllocator<CrtAllocator>\n#endif\n```\n\n也就是我们在编译apk的时候出现的类型。问题到这里实际就已经找到原因了，编译so库的时候和编译apk的时候RAPIDJSON\\_DEFAULT\\_ALLOCATOR这个宏的定义不一致，导致findNode参数类型不一致。那肯定是编译配置导致的,于是在工程下grep搜索一下RAPIDJSON\\_DEFAULT\\_ALLOCATOR可以发现编译so的cmake配置里有这几条:\n\n```cmake\nif(RAPIDJSON_MEM_OPTIMIZATION STREQUAL \"OFF\")\n    ...\nelseif(RAPIDJSON_MEM_OPTIMIZATION STREQUAL \"CUSTOM\")\n    ...\nelse()\n    # Use Memory Optimization\n    message(STATUS \"rapidjson memory optimization used\")\n    add_definitions(-DRAPIDJSON_DEFAULT_ALLOCATOR=CrtAllocator)\n    add_definitions(-DRAPIDJSON_VALUE_DEFAULT_OBJECT_CAPACITY=1)\n    add_definitions(-DRAPIDJSON_VALUE_DEFAULT_ARRAY_CAPACITY=1)\n    add_definitions(-DRAPIDJSON_DEFAULT_STACK_ALLOCATOR=CrtAllocator)\nendif()\n~\n```\n\n而RAPIDJSON\\_MEM\\_OPTIMIZATION这个配置再grep搜索下发现没有地方配置，所以默认使用了rapidjson内存优化选项。\n\n所以只需要把这几行配置拷贝到apk工程的CMakeList.txt就好:\n\n```cmake\nadd_definitions(-DRAPIDJSON_DEFAULT_ALLOCATOR=CrtAllocator)\nadd_definitions(-DRAPIDJSON_VALUE_DEFAULT_OBJECT_CAPACITY=1)\nadd_definitions(-DRAPIDJSON_VALUE_DEFAULT_ARRAY_CAPACITY=1)\nadd_definitions(-DRAPIDJSON_DEFAULT_STACK_ALLOCATOR=CrtAllocator)\n```\n\n","tags":["技术相关","Android","C/C++"]},{"title":"Git是怎么工作的","url":"/2020/08/21/Git是怎么工作的/","content":"\n相信大部分的程序员都会使用Git，可能使用IDE集成的可视化界面，也可能是直接用的命令行。但是可能很多人对Git的一些原理性的概念并没有什么了解，这篇博客就从Git的原理出发，讲解Git的一些命令操作的底层意义，可能会让大家使用Git的时候更加得心应手。\n\nPS: 这篇博客是对部门技术分享的整理，绝大多数知识点可以在[*Pro* *Git*](https://www.progit.cn/)这本书里面找到，也有部分篇幅摘抄自这本书，我也强推大家去通读一遍这本书。\n\n\n# Git与其它版本控制系统的差异\n\nGit 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方法。 概念上来区分，其它大部分系统以文件变更列表的方式存储信息。 这类系统（CVS、Subversion、Perforce、Bazaar 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。\n\n{% img /Git是怎么工作的/deltas.png %}\n\nGit 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 **快照流**\n\n{% img /Git是怎么工作的/snapshots.png %}\n\n也就是说Git实际是实现了一个小型的文件系统，把需要托管的文件的所有版本都备份到了这个系统里面，然后在需要的时候找到对应的版本拿出来使用。\n\n大家都知道Git是Linus开发的，写操作系统内核的人思路的确就是和其他人的不一样，直接搞了个文件系统，而且还继承了Linux一切皆文件的思想。\n\n# object(对象)\n\n这个文件系统其实就在.git/objects目录里面，git把所有的提交文件、提交历史等都保存成一个object保存到这个目录里面。\n\n当clone了一个空的项目的时候.git/objects目录里面会有几个子目录，但是并没有实际的文件:\n\n```shell\ntree .git/objects\n.git/objects\n├── info\n└── pack\n```\n\n当我们做了添加了一些目录和文件:\n\n```shell\ntree .\n.\n├── dir_a\n│   └── file_1\n└── dir_b\n    └── file_2\n```\n\n然后将它们提交到Git之后，Git就会对这些目录和文件原内容加上特定头部信息一起做SHA-1散列得到一个校验和，并且将它们保存到objects目录。散列值前两字符用于命名子目录，余下的38个字符则用作文件名，这个文件就是Git的存储对象(obejct):\n\n```shell\ntree .git/objects\n.git/objects\n├── 26\n│   └── f76fe87ba045f5a6b40d93598ca96e5a1fab39\n├── 31\n│   └── 2f01ad223d5eb1e959122ac2829744b59fd7f2\n├── 75\n│   └── 8902e9f92ad80673cb0f1da4b8d34fbfe47544\n├── 8a\n│   └── 776b73f34c3b546a66fe6173dfa0a53a142b9b\n├── b8\n│   └── 947b77094228836f18792dc5fac15dfa9de11e\n├── c5\n│   └── 0a174948973a2dbe8a43fd9282d24a7a6074c4\n├── info\n└── pack\n```\n\n这些文件都是压缩过的，我们可以用`git cat-file`名去查看内容，由于这些文件都是有不同类型区分的，所以可以用-p参数自动识别文件类型，例如我们查看26f76fe87ba045f5a6b40d93598ca96e5a1fab39这个object:\n\n```shell\ngit cat-file -p 26f76fe87ba045f5a6b40d93598ca96e5a1fab39\n040000 tree 758902e9f92ad80673cb0f1da4b8d34fbfe47544    dir_a\n040000 tree 8a776b73f34c3b546a66fe6173dfa0a53a142b9b    dir_b\n```\n\n它是就是我们的根目录，可以看到有两个tree类型的object，分别对应子目录dir_a和dir_b，我们进去dir_a看看:\n\n```shell\ngit cat-file -p 758902e9f92ad80673cb0f1da4b8d34fbfe47544\n100644 blob c50a174948973a2dbe8a43fd9282d24a7a6074c4    file_1\n```\n\n这里有个blob类型的object file_1，blob类型的object就用来文件快照，可以看到它保存了file\\_1的所有内容:\n\n```shell\ngit cat-file -p c50a174948973a2dbe8a43fd9282d24a7a6074c4\nfile 1 content\n```\n\n除了这些目录、文件的object之外我们的commit也是会被保存成一个obejct:\n\n```shell\ngit cat-file -p 312f01ad223d5eb1e959122ac2829744b59fd7f2\ntree 26f76fe87ba045f5a6b40d93598ca96e5a1fab39\nauthor linjw <bluesky466@qq.com> 1597981085 +0800\ncommitter linjw <bluesky466@qq.com> 1597981085 +0800\n\nfirst commit\n```\n\n可以看到它有个tree字段指向了根目录的object(26f76fe87ba045f5a6b40d93598ca96e5a1fab39)\n\n这个commit的object的校验和其实就是commit id:\n\n```shell\ncommit 312f01ad223d5eb1e959122ac2829744b59fd7f2 (HEAD -> master)\nAuthor: linjw <bluesky466@qq.com>\nDate:   Fri Aug 21 11:38:05 2020 +0800\n\n    first commit\n```\n\n所以通过这个commit我们就能构建起整个目录:\n\n{% img /Git是怎么工作的/1.png %}\n\n## 对象树\n\n然后我们再修改下file\\_1，提交个commit，commit id 是da64cc3756675914aab6df4c01b81539ae6ef39f，我们查看它的内容，发现它对比第一个commit多了个parent指向第一个commit:\n\n```shell\ngit cat-file -p da64cc3756675914aab6df4c01b81539ae6ef39f\ntree 8cbab3b672a04bc8bf5fa63af6e06b0d92bd4126\nparent 312f01ad223d5eb1e959122ac2829744b59fd7f2\nauthor linjw <bluesky466@qq.com> 1597982034 +0800\ncommitter linjw <bluesky466@qq.com> 1597982034 +0800\n\nmodifying file_1\n```\n\n然后现在整个objects目录是这样的:\n\n```shell\ntree .git/objects\n.git/objects\n├── 1e\n│   └── a40765c24dc3a9109c06d2e2c1408ea40568be\n├── 26\n│   └── f76fe87ba045f5a6b40d93598ca96e5a1fab39\n├── 31\n│   └── 2f01ad223d5eb1e959122ac2829744b59fd7f2\n├── 70\n│   └── d733623d440ad95d53272528ae900295855665\n├── 75\n│   └── 8902e9f92ad80673cb0f1da4b8d34fbfe47544\n├── 8a\n│   └── 776b73f34c3b546a66fe6173dfa0a53a142b9b\n├── 8c\n│   └── bab3b672a04bc8bf5fa63af6e06b0d92bd4126\n├── b8\n│   └── 947b77094228836f18792dc5fac15dfa9de11e\n├── c5\n│   └── 0a174948973a2dbe8a43fd9282d24a7a6074c4\n├── da\n│   └── 64cc3756675914aab6df4c01b81539ae6ef39f\n├── info\n└── pack\n```\n\n我们用下面这张图表示各个object 的关系:\n\n{% img /Git是怎么工作的/2.png %}\n\n这些object是以树形结构组织起来的，而且每个commit都能遍历找到那个版本的所有文件，所以当使用reset命令的时候只需要找到commit的object然后遍历对象树将object里面的内容解压出来替换工作区的文件就可以了。\n\n\n\n# 引用\n\n在理解了commit本质上其实是一个object之后，我们就能很容易理解引用这个概念了。\n\n引用在Git里面其实本质也是一个文件，它们存放在.git/refs/下的子目录里面，例如本地引用的路径在.git/refs/heads目录里面:\n\n```shell\ntree .git/refs/heads\n.git/refs/heads\n└── master\n```\n\n我们可以看到现在里面只有个master文件，原因是我们只有一个master分支。让我们打印一下这个master文件的内容:\n\n```shell\ncat .git/refs/heads/master\nda64cc3756675914aab6df4c01b81539ae6ef39f\n```\n\n它的内容其实就是object的检验和。让我们创建多一个develop分支，可以看到这个目录就多了个develop文件\n\n```shell\ntree .git/refs/heads\n.git/refs/heads\n├── develop\n└── master\n```\n\n它的内容和master的一样:\n\n```shell\ncat .git/refs/heads/develop\nda64cc3756675914aab6df4c01b81539ae6ef39f\n```\n\n让我们回滚这个分支到第一个提交，可以发现它的内容就变成了第一个commit的校验和:\n\n```shell\ncat .git/refs/heads/develop\n312f01ad223d5eb1e959122ac2829744b59fd7f2\n```\n\n其实除了分支之外，我们打的tag也是一样的原理，例如我们此时在develop上一个v1.0的tag，就会发现.git/refs/tags/目录下多了一个v1.0的文件：\n\n```shell\ntree .git/refs/tags\n.git/refs/tags\n└── v1.0\n```\n\n它的内容也是第一个commit:\n\n```shell\ncat .git/refs/tags/v1.0\n312f01ad223d5eb1e959122ac2829744b59fd7f2\n```\n\n现在引用的情况如下图:\n\n{% img /Git是怎么工作的/3.png %}\n\n所以我们的分支也好，tag也好，其实都是一个引用，它们本质上是一个文件，里面的内容就是指向的object的校验和，而我们的回滚代码，其实就是将各个分支的引用指向了不同的commit而已，如果我们在master分支将代码reset到commit 312f01，就会发现master的引用指向了这个commit。\n\n\n\n## HEAD引用\n\n那Git又是如何知道我们当前是在哪个分支的呢？\n\n其实在Git里面还有个特殊的引用HEAD引用，它就在.git目录下面。我们可以打印下它的内容:\n\n```shell\ncat HEAD\nref: refs/heads/develop\n```\n\n可以发现它指向了我们的develop引用， 这就表示我们当前正在develop分支。\n\nGit就是靠这个HEAD引用找到我们当前位于哪个commit:\n\n{% img /Git是怎么工作的/4.png %}\n\n当然HEAD的内容也可能直接指向某个commit号，例如我们checkout到某个tag的时候:\n\n```shell\ncat .git/HEAD\n312f01ad223d5eb1e959122ac2829744b59fd7f2\n```\n\n{% img /Git是怎么工作的/5.png %}\n\n这是因为tag是固定的，我们并不能直接修改tag指向的commit。\n\n## reflog\n\n我们都知道可以用`git log`去查看commit的日志，其实类似的我们可以用`git reflog`去查看引用的操作日志，它会的打印如下:\n\n```shell\n3cb383a (HEAD -> develop) HEAD@{0}: commit: difying file_2\n312f01a (tag: v1.0) HEAD@{1}: checkout: moving from 312f01ad223d5eb1e959122ac2829744b59fd7f2 to develop\n312f01a (tag: v1.0) HEAD@{2}: checkout: moving from develop to v1.0\n312f01a (tag: v1.0) HEAD@{3}: reset: moving to 312f01ad223d5eb1e959122ac2829744b59fd7f2\nda64cc3 (master) HEAD@{4}: checkout: moving from master to develop\nda64cc3 (master) HEAD@{5}: commit: modifying file_1\n312f01a (tag: v1.0) HEAD@{6}: commit (initial): first commit\n```\n\n这个东西有什么用呢？举个例子，假设我现在在develop修改了file_2提交了一个commit，没有推到服务器上，然后就reset --hard回到了上一个commit。这个时候突然反悔了想找到之前那个commit要怎么办？\n\n对的，就是用reflog:\n\n```shell\n312f01a (HEAD -> develop, tag: v1.0) HEAD@{0}: reset: moving to 312f01ad223d5eb1e959122ac2829744b59fd7f2\n3cb383a HEAD@{1}: commit: difying file_2\n312f01a (HEAD -> develop, tag: v1.0) HEAD@{2}: checkout: moving from 312f01ad223d5eb1e959122ac2829744b59fd7f2 to develop\n312f01a (HEAD -> develop, tag: v1.0) HEAD@{3}: checkout: moving from develop to v1.0\n312f01a (HEAD -> develop, tag: v1.0) HEAD@{4}: reset: moving to 312f01ad223d5eb1e959122ac2829744b59fd7f2\nda64cc3 (master) HEAD@{5}: checkout: moving from master to develop\nda64cc3 (master) HEAD@{6}: commit: modifying file_1\n312f01a (HEAD -> develop, tag: v1.0) HEAD@{7}: commit (initial): first commit\n```\n\n从下往上,可以看到HEAD引用的操作历史:\n\n提交了第一个commit(312f01a) \n\n---> 提交了第二个commit(da64cc3) \n\n---> 从master切换到了develop分支，当前所处的commit号依然是da64cc3 \n\n---> 移动回了commit 312f01a  \n\n---> 从develop分支切换 到了v1.0这个tag，当前所处的commit号依然是312f01a\n\n---> 切换回了develop分支，当前所处的commit号依然是312f01a\n\n--->  修改了file_2提交了commit 3cb383a\n\n----> reset 回到了commit 312f01a\n\n所以我们就能找到丢失了的commit 3cb383a，此时只需要用reset --hard 3cb383a就能回到那个commit了。\n\n\n\n# 远程分支\n\n远程引用是对远程仓库的引用。我们从服务器拉取代码的时候就会将服务器的分支引用拉到本地，它们的文件在.git/refs/remotes/目录下的远程仓库对应的子目录里。例如我们在`git clone`的时候，Git会默认帮我们将远程仓库命名为origin，所以它的分支引用文件就在.git/refs/remotes/origin/目录下面。\n\n这些远程分支以\\<remote\\>/\\<branch\\>的形式命名，例如origin仓库的master分支的名字就叫origin/master，所以我们可以用checkout命令直接切到远程分支:\n\n```shell\ngit checkout origin/master\n```\n\n当有其他人往服务器推代码之后，我们需要用`git fetch`命令来抓取远程仓库有，而本地没有的数据:\n\n```shell\ngit fetch origin\n```\n\n抓取完之后远程分支就更新了:\n\n{% img /Git是怎么工作的/remote-branches-3.png %}\n\n这个时候就可以用`git merge`命令将远程分支的代码合并到本地:\n\n```shell\ngit merge origin/master\n```\n\n而我们工作中常用的`git pull` 在大多数情况下它的含义是一个 `git fetch` 紧接着一个 `git merge` 命令\n\n顺便一讲，之前我们讲到commit是有parent概念的，而第一个commit由于之前已经没有提交了，所以它没有parent，普通的commit会有一个parent。\n\n而`git merge`命令由于需要合并两个分支的修改，所以它会生成一个新的commit，它有两个parent:\n\n{% img /Git是怎么工作的/6.png %}\n\n例如我们上面的C6这commit就有两个parent C4和从C5\n\n# pack机制\n\n从上面我们可以看到Git向磁盘中存储对象使用松散对象格式，一个文件、目录、commit等对应一个文件，这样的操作可能会比较简单，但是其实是比较浪费磁盘空间的。而且在需要推送到远程仓库的时候需要一个个文件上传效率也比较低。所以Git会时不时将这些文件打包在一起以节省空间提高网络传输效率。\n\n我们可以收到调用`git gc`命令让Git进行打包并清理一些不需要的对象。打包完成之后.git/objects里面的文件就会变小，并且在.git/objects/pack下面多出打包文件:\n\n```shell\ntree .git/objects/pack\n.git/objects/pack\n├── pack-20f597c6ab0c05f5c907023edf4e282be00ad6fe.idx\n└── pack-20f597c6ab0c05f5c907023edf4e282be00ad6fe.pack\n```\n\n.idx文件是索引文件，而.pack就是将object对象打包成的二进制包，我们可以用`git verify-pack -v`命令查看包里的信息:\n\n```shell\ngit verify-pack -v .git/objects/pack/pack-20f597c6ab0c05f5c907023edf4e282be00ad6fe.idx\n1dcac3d26ede1fe64eddd3511a74d99a96ef97e2 commit 202 144 12\n3fbc341a1b669518f3ef7aa038d71f2f7d68a5f0 commit 207 150 156\n34ffe485561f71337d0b64fca8dc9c8d57d86027 commit 78 88 306 1 3fbc341a1b669518f3ef7aa038d71f2f7d68a5f0\n58d65a51d2e0288b577c73a660f467bd548033f8 commit 231 166 394\nace7ce09e72571eb0474221f8e52b1767cebb0db commit 269 190 560\nfeafba560a569ff272319bb98dba0869aa2b242c commit 48 59 750 1 ace7ce09e72571eb0474221f8e52b1767cebb0db\n9aaa265d2221fd96e5d3dd420fe9d93e7b99726f commit 13 24 809 1 58d65a51d2e0288b577c73a660f467bd548033f8\n2cb88bd69545620211e77a7865b9e9990d9a0c20 commit 212 150 833\n9750080a17990f284f5045e4eef885605f2eb6d8 commit 80 91 983 1 2cb88bd69545620211e77a7865b9e9990d9a0c20\n69f9a2ec2f55ceed476a68190d32f543d89c2f78 commit 70 82 1074 1 3fbc341a1b669518f3ef7aa038d71f2f7d68a5f0\nda5e1a12ab4c5fdca2a808e4b85c1c54dc780642 commit 81 91 1156 1 3fbc341a1b669518f3ef7aa038d71f2f7d68a5f0\nc756597a8071fbf0b26fda95f0cd99edb68f7759 commit 79 90 1247 1 2cb88bd69545620211e77a7865b9e9990d9a0c20\n3cb383a390cbd7cbf4872412b828987e0cdc1b13 commit 213 153 1337\nda64cc3756675914aab6df4c01b81539ae6ef39f commit 64 76 1490 1 58d65a51d2e0288b577c73a660f467bd548033f8\n312f01ad223d5eb1e959122ac2829744b59fd7f2 commit 163 119 1566\ne4e3854198486f045f95c16d886a7ecec076799d tree   64 67 1685\n758902e9f92ad80673cb0f1da4b8d34fbfe47544 tree   34 45 1752\n593e3181013a603a1f273034ad4d2b30ebed201a tree   34 45 1797\n70d733623d440ad95d53272528ae900295855665 tree   34 45 1842\ncfb98c1ce98de4290f310e81cf0b9128749df334 tree   130 129 1887\n08df14d61d050a7235a5bab256e63432d422ab61 tree   64 67 2016\n67ed7f289e73c67217c5bcdbe18f8f55c2d3699f tree   34 45 2083\n8205fc9052e9544796e762459e48909f661145dc tree   64 67 2128\n4c1ae63f5abfcb9107241f03a86df80aafbc6780 tree   34 45 2195\na8c1a9640eb8e53987cd5684535769a9f86622cf tree   64 67 2240\nb7391b72f9c25ce53cf9a3679f9157d19897fd5c tree   34 45 2307\n022d4f657214d39e3d540d214aa7affdd44cf489 tree   96 100 2352\n69f3e7095dc70df5693bb6c213bdc77d3665be3d tree   96 100 2452\n8a776b73f34c3b546a66fe6173dfa0a53a142b9b tree   34 45 2552\n26f76fe87ba045f5a6b40d93598ca96e5a1fab39 tree   64 67 2597\nc50a174948973a2dbe8a43fd9282d24a7a6074c4 blob   15 24 2664\n9d791ce077105e227ffae01975a81e980a06a9a2 blob   24 34 2688\n6d1f7671b90551cb98157a48a7b26b1183dfb821 tree   27 40 2722 1 cfb98c1ce98de4290f310e81cf0b9128749df334\n1ea40765c24dc3a9109c06d2e2c1408ea40568be blob   25 35 2762\ne69de29bb2d1d6434b8b29ae775ad8c2e48c5391 blob   0 9 2797\nd00491fd7e5bb6fa28c517a0bb32b8b506539d4d blob   2 11 2806\n41ba6a00583e910f220ecd34021d4d29de0feeda blob   3 12 2817\n896691a3909edace46e4b587e1f1496af22f36d7 tree   4 15 2829 1 022d4f657214d39e3d540d214aa7affdd44cf489\nce7499ae1967bd055f42c5458a60be5131f85da2 blob   21 31 2844\n258be8efcad31cc0c6c8dc6bc7d15a2c6910cd1a blob   22 32 2875\n840bbdd49116cbffa896bb7f5ab011f2ddf8d446 blob   19 29 2907\nb8947b77094228836f18792dc5fac15dfa9de11e blob   15 24 2936\n8cbab3b672a04bc8bf5fa63af6e06b0d92bd4126 tree   4 15 2960 1 69f3e7095dc70df5693bb6c213bdc77d3665be3d\n非 delta：32 个对象\n链长 = 1: 11 对象\n.git/objects/pack/pack-20f597c6ab0c05f5c907023edf4e282be00ad6fe.pack: ok\n```\n\n同样的.git/refs/下面的引用文件也会被打包，这里可以看到该目录已经清空了:\n\n```\ntree .git/refs/heads\n.git/refs/heads\n\n0 directories, 0 files\n```\n\n它们会被打包到.git/packed-refs文件中,可以直接用`cat`命令查看:\n\n```shell\ncat .git/packed-refs\n# pack-refs with: peeled fully-peeled sorted\n3cb383a390cbd7cbf4872412b828987e0cdc1b13 refs/heads/develop\n3cb383a390cbd7cbf4872412b828987e0cdc1b13 refs/heads/master\n312f01ad223d5eb1e959122ac2829744b59fd7f2 refs/tags/v1.0\n```","tags":["技术相关","Git"]},{"title":"深挖view绘制流程(二)","url":"/2020/07/22/深挖view绘制流程-二/","content":"# Choreographer\n\nChoreographer的中文翻译是编舞者、舞蹈编导的意思，为什么起这个名字呢？因为view的刷新和舞蹈一样是需要按着节拍来的，Choreographer就是根据VSync信号这个节拍来安排view的刷新动作。\n\n它使用ThreadLocal单例模式，每个线程都有自己的Choreographer，靠Looper去同步：\n\n```java\npublic final class Choreographer {\n    ...\n    private static final ThreadLocal<Choreographer> sThreadInstance = new ThreadLocal<Choreographer>() {\n        @Override\n        protected Choreographer initialValue() {\n            Looper looper = Looper.myLooper();\n            if (looper == null) {\n                throw new IllegalStateException(\"The current thread must have a looper!\");\n            }\n            return new Choreographer(looper, VSYNC_SOURCE_APP);\n        }\n    };\n    ..\n    public static Choreographer getInstance() {\n        return sThreadInstance.get();\n    }\n}\n```\n\n而且Choreographer实际上不仅仅是控制view刷新，作为一个舞蹈编导需要编排多个人的动作，它也需要控制多种类型的事件的处理。\n\n它内部有4条CallbackQueue,分别控制input、animation、traversal和commit:\n\n```java\npublic static final int CALLBACK_INPUT = 0;\npublic static final int CALLBACK_ANIMATION = 1;\npublic static final int CALLBACK_TRAVERSAL = 2;\npublic static final int CALLBACK_COMMIT = 3;\nprivate static final int CALLBACK_LAST = CALLBACK_COMMIT;\n\nprivate Choreographer(Looper looper, int vsyncSource) {\n    ...\n    mCallbackQueues = new CallbackQueue[CALLBACK_LAST + 1];\n    for (int i = 0; i <= CALLBACK_LAST; i++) {\n        mCallbackQueues[i] = new CallbackQueue();\n    }\n}\n```\n\nViewRootImpl在requestLayout的时候就是丢到了CALLBACK\\_TRAVERSAL类型的CallbackQueue里面:\n\n```java\n@Override\npublic void requestLayout() {\n    ...\n    scheduleTraversals();\n    ..\n}\n\nvoid scheduleTraversals() {\n    if (!mTraversalScheduled) {\n        mTraversalScheduled = true;\n        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();\n        mChoreographer.postCallback(\n                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);\n        ...\n    }\n}\n```\n\nChoreographer会找到对应的CallbackQueue然后使用addCallbackLocked将他们按时间顺序插入:\n\n```java\npublic void postCallback(int callbackType, Runnable action, Object token) {\n    postCallbackDelayed(callbackType, action, token, 0);\n}\n\npublic void postCallbackDelayed(int callbackType,\n        Runnable action, Object token, long delayMillis) {\n    ...\n    postCallbackDelayedInternal(callbackType, action, token, delayMillis);\n}\n\nprivate void postCallbackDelayedInternal(int callbackType,\n        Object action, Object token, long delayMillis) {\n    ...\n    final long now = SystemClock.uptimeMillis();\n    final long dueTime = now + delayMillis;\n    mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);\n    ...\n}\n\nprivate final class CallbackQueue {\n    ...\n    public void addCallbackLocked(long dueTime, Object action, Object token) {\n        CallbackRecord callback = obtainCallbackLocked(dueTime, action, token);\n        CallbackRecord entry = mHead;\n        if (entry == null) {\n            mHead = callback;\n            return;\n        }\n        if (dueTime < entry.dueTime) {\n            callback.next = entry;\n            mHead = callback;\n            return;\n        }\n        while (entry.next != null) {\n            if (dueTime < entry.next.dueTime) {\n                callback.next = entry.next;\n                break;\n            }\n            entry = entry.next;\n        }\n        entry.next = callback;\n    }\n    ...\n}\n```\n\n从上面代码我们可以看出来CallbackQueue是个单链表，而Choreographer里维护了四条CallbackQueue用于不同类的回调:\n\n{% img /深挖view绘制流程二/1.png %}\n\n\n插入CallbackQueue之后Choreographer就会向DisplayEventReceiver请求一个Vsync信号的监听:\n\n```java\nprivate void postCallbackDelayedInternal(int callbackType,\n        Object action, Object token, long delayMillis) {\n    ...\n    scheduleFrameLocked(now);\n    ...\n}\n\nprivate void scheduleFrameLocked(long now) {\n    ...\n        scheduleVsyncLocked();\n    ...\n}\n\nprivate void scheduleVsyncLocked() {\n    mDisplayEventReceiver.scheduleVsync();\n}\n```\n\nDisplayEventReceiver的监听原理我们等下再看，总之调用scheduleVsync之后DisplayEventReceiver会监听一次Vsync信号，然后在接收到信号的时候回调onVsync，而Choreographer有个FrameDisplayEventReceiver内部类继承了DisplayEventReceiver并且实现了Runnable接口，它在onVsync里面就会通过Handler机制将自己同步到Looper线程去执行run方法，去调用Choreographer.doFrame:\n\n```java\nprivate final class FrameDisplayEventReceiver extends DisplayEventReceiver\n            implements Runnable {\n    ...\n    @Override\n    public void onVsync(long timestampNanos, int builtInDisplayId, int frame) {\n        ...\n        mFrame = frame;\n        Message msg = Message.obtain(mHandler, this);\n        msg.setAsynchronous(true);\n        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);\n    }\n\n    @Override\n    public void run() {\n        mHavePendingVsync = false;\n        doFrame(mTimestampNanos, mFrame);\n    }\n}\n```\n\n而Choreographer.doFrame里面就会去回调之前post的callback了:\n\n```java\nvoid doFrame(long frameTimeNanos, int frame) {\n    ...\n    try {\n        Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"Choreographer#doFrame\");\n        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);\n\n        mFrameInfo.markInputHandlingStart();\n        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);\n\n        mFrameInfo.markAnimationsStart();\n        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);\n\n        mFrameInfo.markPerformTraversalsStart();\n        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);\n\n        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);\n    } finally {\n        AnimationUtils.unlockAnimationClock();\n        Trace.traceEnd(Trace.TRACE_TAG_VIEW);\n    }\n    ...\n}\n```\n\n# DisplayEventReceiver\n\njava层的DisplayEventReceiver基本就是个壳，都是通过jni调到native层，由native层c++的NativeDisplayEventReceiver去干活:\n\n```java\npublic DisplayEventReceiver(Looper looper, int vsyncSource) {\n    ...\n    mReceiverPtr = nativeInit(new WeakReference<DisplayEventReceiver>(this), mMessageQueue,\n            vsyncSource);\n    ...\n}\n\nprivate void dispose(boolean finalized) {\n    ...\n    nativeDispose(mReceiverPtr);\n    mReceiverPtr = 0;\n    ...\n}\n\n public void scheduleVsync() {\n    ...\n    nativeScheduleVsync(mReceiverPtr);\n    ...\n}\n```\n\njni层是这样的，沟通了java层的DisplayEventReceiver和native层的NativeDisplayEventReceiver:\n\n```c++\n// 动态注册JNI回调\nstatic const JNINativeMethod gMethods[] = {\n    { \"nativeInit\",\n            \"(Ljava/lang/ref/WeakReference;Landroid/os/MessageQueue;I)J\",\n            (void*)nativeInit },\n    { \"nativeDispose\",\n            \"(J)V\",\n            (void*)nativeDispose },\n    { \"nativeScheduleVsync\", \"(J)V\",\n            (void*)nativeScheduleVsync }\n};\n\nstatic jlong nativeInit(JNIEnv* env, jclass clazz, jobject receiverWeak,\n        jobject messageQueueObj, jint vsyncSource) {\n    ...\n\n    sp<NativeDisplayEventReceiver> receiver = new NativeDisplayEventReceiver(env,\n            receiverWeak, messageQueue, vsyncSource);\n    ...\n    return reinterpret_cast<jlong>(receiver.get());\n}\n\nstatic void nativeDispose(JNIEnv* env, jclass clazz, jlong receiverPtr) {\n    NativeDisplayEventReceiver* receiver =\n            reinterpret_cast<NativeDisplayEventReceiver*>(receiverPtr);\n    receiver->dispose();\n    ..\n}\n\nstatic void nativeScheduleVsync(JNIEnv* env, jclass clazz, jlong receiverPtr) {\n    sp<NativeDisplayEventReceiver> receiver =\n            reinterpret_cast<NativeDisplayEventReceiver*>(receiverPtr);\n    status_t status = receiver->scheduleVsync();\n    ...\n}\n```\n\n我们现在开始看看scheduleVsync里面具体干了些啥，由于NativeDisplayEventReceiver是继承了DisplayEventDispatcher，而且没有重写该方法，所以我们要实际应该去看DisplayEventDispatcher::scheduleVsync。\n\n```c++\nclass NativeDisplayEventReceiver : public DisplayEventDispatcher {\npublic:\n    NativeDisplayEventReceiver(JNIEnv* env,\n            jobject receiverWeak, const sp<MessageQueue>& messageQueue, jint vsyncSource);\n\n    void dispose();\n\nprotected:\n    virtual ~NativeDisplayEventReceiver();\n\nprivate:\n    jobject mReceiverWeakGlobal;\n    sp<MessageQueue> mMessageQueue;\n    DisplayEventReceiver mReceiver;\n\n    virtual void dispatchVsync(nsecs_t timestamp, int32_t id, uint32_t count);\n    virtual void dispatchHotplug(nsecs_t timestamp, int32_t id, bool connected);\n};\n```\n\n```c++\nstatus_t DisplayEventDispatcher::scheduleVsync() {\n    if (!mWaitingForVsync) {\n        ...\n        status_t status = mReceiver.requestNextVsync();\n        ...\n\n        mWaitingForVsync = true;\n    }\n    return OK;\n}\n```\n\n可以看到DisplayEventDispatcher::scheduleVsync又是调用mReceiver.requestNextVsync请求下一个VSync信号，这个mReceiver是DisplayEventReceiver:\n\n```c++\nDisplayEventReceiver mReceiver;\n```\n\n所以我们就继续追踪:\n\n```c++\nstatus_t DisplayEventReceiver::requestNextVsync() {\n    if (mEventConnection != NULL) {\n        mEventConnection->requestNextVsync();\n        return NO_ERROR;\n    }\n    return NO_INIT;\n}\n\nDisplayEventReceiver::DisplayEventReceiver(ISurfaceComposer::VsyncSource vsyncSource) {\n    sp<ISurfaceComposer> sf(ComposerService::getComposerService());\n    if (sf != NULL) {\n        mEventConnection = sf->createDisplayEventConnection(vsyncSource);\n        if (mEventConnection != NULL) {\n            mDataChannel = std::make_unique<gui::BitTube>();\n            mEventConnection->stealReceiveChannel(mDataChannel.get());\n        }\n    }\n}\n```\n\n这里打开了一个ComposerService连接，然后实际是向这个服务请求VSync信号。Composer是作曲家的意思，实际上和之前java层的编舞者是对应的。作曲家作曲，谱写节奏，编舞者根据节奏指挥舞蹈。\n\n上面讲的DisplayEventReceiver感觉就是个套娃架构，一层套一层。而且类的名字又很接近，所以直接追踪代码的确比较晕，看下面的时序图的话会好一些:\n\n{% img /深挖view绘制流程二/2.png %}\n\n\n# VSync信号的读取\n\nComposerService实际上是指的SurfaceFlinger服务的client端包装类:\n\n```c++\n/*static*/ sp<ISurfaceComposer> ComposerService::getComposerService() {\n    ComposerService& instance = ComposerService::getInstance();\n    ...\n    if (instance.mComposerService == NULL) {\n        ComposerService::getInstance().connectLocked();\n        ...\n    }\n    return instance.mComposerService;\n}\n\nvoid ComposerService::connectLocked() {\n    const String16 name(\"SurfaceFlinger\");\n    while (getService(name, &mComposerService) != NO_ERROR) {\n        usleep(250000);\n    }\n    ...\n}\n```\n\n所以createDisplayEventConnection最终调用到SurfaceFlinger::createDisplayEventConnection，在这个方法用mEventThread去createEventConnection，最终创建一个Connection:\n\n```c++\nsp<IDisplayEventConnection> SurfaceFlinger::createDisplayEventConnection(\n        ISurfaceComposer::VsyncSource vsyncSource) {\n    ...\n    return mEventThread->createEventConnection();\n    ...\n}\n\nsp<EventThread::Connection> EventThread::createEventConnection() const {\n    return new Connection(const_cast<EventThread*>(this));\n}\n```\n\n然后Connection是个安卓里面的只能指针类型(RefBase)它在第一次引用计数的时候会调用onFirstRef，在这里Connection会将自己注册到EventThread的mDisplayEventConnections列表里:\n\n```c++\nvoid EventThread::Connection::onFirstRef() {\n    // NOTE: mEventThread doesn't hold a strong reference on us\n    mEventThread->registerDisplayEventConnection(this);\n}\n\nstatus_t EventThread::registerDisplayEventConnection(\n        const sp<EventThread::Connection>& connection) {\n    ...\n    mDisplayEventConnections.add(connection);\n    ...\n    return NO_ERROR;\n}\n```\n\nrequestNextVsync最终是会调用到Connection::requestNextVsync，而这里除了会调用到SurfaceFlinger::resyncWithRateLimit去请求VSync信号之外还会将设置Connection的count:\n\n```c++\nvoid EventThread::Connection::requestNextVsync() {\n    mEventThread->requestNextVsync(this);\n}\n\nvoid EventThread::requestNextVsync(\n        const sp<EventThread::Connection>& connection) {\n    Mutex::Autolock _l(mLock);\n\n    mFlinger.resyncWithRateLimit();\n\n    if (connection->count < 0) {\n        connection->count = 0;\n        mCondition.broadcast();\n    }\n}\n```\n\n从注释可以看出来这个count是用来标志这次应用进程VSync信号的请求是一次性的，还是多次的:\n\n```c++\n// count >= 1 : continuous event. count is the vsync rate\n// count == 0 : one-shot event that has not fired\n// count ==-1 : one-shot event that fired this round / disabled\nint32_t count;\n```\n\n然后mCondition.broadcast()就会唤醒EventThread的waitForEvent流程，这个流程相对比较复杂，我先将删除注释之后的完整代码贴出来，然后再详细解释:\n\n```c++\n001 Vector< sp<EventThread::Connection> > EventThread::waitForEvent(\n002        DisplayEventReceiver::Event* event)\n003 {\n004    Mutex::Autolock _l(mLock);\n005    Vector< sp<EventThread::Connection> > signalConnections;\n006\n007    do {\n008        bool eventPending = false;\n009        bool waitForVSync = false;\n010\n011        size_t vsyncCount = 0;\n012        nsecs_t timestamp = 0;\n013        for (int32_t i=0 ; i<DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) {\n014            timestamp = mVSyncEvent[i].header.timestamp;\n015            if (timestamp) {\n016                if (mInterceptVSyncs) {\n017                    mFlinger.mInterceptor.saveVSyncEvent(timestamp);\n018                }\n019                *event = mVSyncEvent[i];\n020                mVSyncEvent[i].header.timestamp = 0;\n021                vsyncCount = mVSyncEvent[i].vsync.count;\n022                break;\n023            }\n024        }\n025\n026        if (!timestamp) {\n027            eventPending = !mPendingEvents.isEmpty();\n028            if (eventPending) {\n029                *event = mPendingEvents[0];\n030                mPendingEvents.removeAt(0);\n031            }\n032        }\n033\n034        size_t count = mDisplayEventConnections.size();\n035        for (size_t i=0 ; i<count ; i++) {\n036            sp<Connection> connection(mDisplayEventConnections[i].promote());\n037            if (connection != NULL) {\n038                bool added = false;\n039                if (connection->count >= 0) {\n040                    waitForVSync = true;\n041                    if (timestamp) {\n042                        if (connection->count == 0) {\n043                            connection->count = -1;\n044                            signalConnections.add(connection);\n045                            added = true;\n046                        } else if (connection->count == 1 ||\n047                                (vsyncCount % connection->count) == 0) {\n048                            signalConnections.add(connection);\n049                            added = true;\n050                        }\n051                    }\n052                }\n053\n054                if (eventPending && !timestamp && !added) {\n055                    signalConnections.add(connection);\n056                }\n057            } else {\n058                mDisplayEventConnections.removeAt(i);\n059                --i; --count;\n060            }\n061        }\n062\n063        if (timestamp && !waitForVSync) {\n064            disableVSyncLocked();\n065        } else if (!timestamp && waitForVSync) {\n066            enableVSyncLocked();\n067        }\n068\n069        if (!timestamp && !eventPending) {\n070            if (waitForVSync) {\n071                bool softwareSync = mUseSoftwareVSync;\n072                nsecs_t timeout = softwareSync ? ms2ns(16) : ms2ns(1000);\n073                if (mCondition.waitRelative(mLock, timeout) == TIMED_OUT) {\n074                    if (!softwareSync) {\n075                        ALOGW(\"Timed out waiting for hw vsync; faking it\");\n076                    }\n077                    mVSyncEvent[0].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;\n078                    mVSyncEvent[0].header.id = DisplayDevice::DISPLAY_PRIMARY;\n079                    mVSyncEvent[0].header.timestamp = systemTime(SYSTEM_TIME_MONOTONIC);\n080                    mVSyncEvent[0].vsync.count++;\n081                }\n082            } else {\n083                mCondition.wait(mLock);\n084            }\n085        }\n086    } while (signalConnections.isEmpty());\n087\n088    return signalConnections;\n089 }\n```\n\n首先一开始waitForEvent是阻塞在083行的mCondition.wait(mLock)这里等待，EventThread::requestNextVsync会将它唤醒，然后在013~024检查唤醒之前是否已经有VSync信号，我们先假设没有，那么timestamp就一直是0。\n\n然后继续跑到039行，这个的count在EventThread::requestNextVsync已经被设置>=0了，所以会进去将waitForVSync设置成true。而041行由于timestamp是0所以不会进去。\n\n我们假设mPendingEvents也是空的，于是eventPending也是false， 接着就继续跑到073等待VSync信号了。\n\n这里用mCondition.waitRelative等待一段时间，其实是在等待之前调用SurfaceFlinger::resyncWithRateLimit请求的屏幕硬件VSync信号，如果信号到来的话EventThread::onVSyncEvent会被调用，然后唤醒线程:\n\n```c++\nvoid EventThread::onVSyncEvent(nsecs_t timestamp) {\n    Mutex::Autolock _l(mLock);\n    mVSyncEvent[0].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;\n    mVSyncEvent[0].header.id = 0;\n    mVSyncEvent[0].header.timestamp = timestamp;\n    mVSyncEvent[0].vsync.count++;\n    mCondition.broadcast();\n}\n```\n\n如果一直没有到来的话，等待时间结束，返回TIMED\\_OUT的话也会用软件模拟一个VSync信号。\n\n然后就会继续do-while循环跑到013~024将timestamp和参数出参event的内容给设置了，接着在041行的timestamp判断不为0，于是就会将Connection放到signalConnections，最后在while里面判断到signalConnections不为空退出循环。\n\n# VSync信号的发送\n\n于是乎threadLoop就能拿到event和Connection列表，将事件分发出去:\n\n```c++\nbool EventThread::threadLoop() {\n    DisplayEventReceiver::Event event;\n    Vector< sp<EventThread::Connection> > signalConnections;\n    signalConnections = waitForEvent(&event);\n\n    // dispatch events to listeners...\n    const size_t count = signalConnections.size();\n    for (size_t i=0 ; i<count ; i++) {\n        const sp<Connection>& conn(signalConnections[i]);\n        // now see if we still need to report this event\n        status_t err = conn->postEvent(event);\n        ...\n    }\n    return true;\n}\n```\n\nConnection::postEvent实际是调用DisplayEventReceiver::sendEvents往Channel里面发送消息:\n\n```c++\nstatus_t EventThread::Connection::postEvent(\n        const DisplayEventReceiver::Event& event) {\n    ssize_t size = DisplayEventReceiver::sendEvents(&mChannel, &event, 1);\n    return size < 0 ? status_t(size) : status_t(NO_ERROR);\n}\n```\n\n还记得在app端createDisplayEventConnection的代码吗？我们得到Connection之后调用了stealReceiveChannel方法，它就将c/s两端的通信链路打通了:\n\n```c++\nDisplayEventReceiver::DisplayEventReceiver(ISurfaceComposer::VsyncSource vsyncSource) {\n    sp<ISurfaceComposer> sf(ComposerService::getComposerService());\n    if (sf != NULL) {\n        mEventConnection = sf->createDisplayEventConnection(vsyncSource);\n        if (mEventConnection != NULL) {\n            mDataChannel = std::make_unique<gui::BitTube>();\n            mEventConnection->stealReceiveChannel(mDataChannel.get());\n        }\n    }\n}\n\nstatus_t EventThread::Connection::stealReceiveChannel(gui::BitTube* outChannel) {\n    outChannel->setReceiveFd(mChannel.moveReceiveFd());\n    return NO_ERROR;\n}\n```\n\n所以s端写入event之后c端就能读取到。这个fd的监听是在DisplayEventDispatcher::initialize里面写入的,它往mLooper里面add了DataChannel的Fd:\n\n```c++\nstatus_t DisplayEventDispatcher::initialize() {\n    ...\n    int rc = mLooper->addFd(mReceiver.getFd(), 0, Looper::EVENT_INPUT,\n            this, NULL);\n    ...\n}\n\nint DisplayEventReceiver::getFd() const {\n    if (mDataChannel == NULL)\n        return NO_INIT;\n\n    return mDataChannel->getFd();\n}\n```\n\n所以当消息到来之后DisplayEventDispatcher::handleEvent就会被调用然后再使用dispatchVsync去发送VSync事件\n\n```c++\nint DisplayEventDispatcher::handleEvent(int, int events, void*) {\n    ...\n    nsecs_t vsyncTimestamp;\n    int32_t vsyncDisplayId;\n    uint32_t vsyncCount;\n    if (processPendingEvents(&vsyncTimestamp, &vsyncDisplayId, &vsyncCount)) {\n        ...\n        dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount);\n    }\n\n    return 1; // keep the callback\n}\n```\n\n这个在dispatchVsync子类NativeDisplayEventReceiver中实现，它会使用jni回调java层的DisplayEventReceiver.dispatchVsync:\n\n```c++\ngDisplayEventReceiverClassInfo.dispatchVsync = GetMethodIDOrDie(env,\n            gDisplayEventReceiverClassInfo.clazz, \"dispatchVsync\", \"(JII)V\");\n\n\nvoid NativeDisplayEventReceiver::dispatchVsync(nsecs_t timestamp, int32_t id, uint32_t count) {\n    JNIEnv* env = AndroidRuntime::getJNIEnv();\n  ...\n    env->CallVoidMethod(receiverObj.get(),\n                        gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, id, count);\n  ...\n}\n```\n\n而java层的dispatchVsync再调onVsync方法\n\n```java\n@SuppressWarnings(\"unused\")\nprivate void dispatchVsync(long timestampNanos, int builtInDisplayId, int frame) {\n    onVsync(timestampNanos, builtInDisplayId, frame);\n}\n```\n\n而这个onVsync在我们在第一节Choreographer流程里面有讲到，它会调到Choreographer.doFrame去回调注册的Callback:\n\n```java\nprivate final class FrameDisplayEventReceiver extends DisplayEventReceiver\n            implements Runnable {\n    ...\n    @Override\n    public void onVsync(long timestampNanos, int builtInDisplayId, int frame) {\n        ...\n        mFrame = frame;\n        Message msg = Message.obtain(mHandler, this);\n        msg.setAsynchronous(true);\n        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);\n    }\n\n    @Override\n    public void run() {\n        mHavePendingVsync = false;\n        doFrame(mTimestampNanos, mFrame);\n    }\n}\n```\n\n# 总结\n\n所以整个调用关系如下图:\n\n{% img /深挖view绘制流程二/3.png %}\n\nViewRootImpl将Callback丢到Choreographer之后，通过FrameDisplayEventReceiver调到Native层的NativeDisplayEventReceiver。\n\n然后通过Connect调用到SurfaceFlinger进程的EventThread，在这里向SurfaceFlinger请求一次VSync信号并且等待信号到来之后通过DataChannel回调到应用进程的NativeDisplayEventReceiver。\n\n之后再通过jni调回java层FrameDisplayEventReceiver和Choreographer去执行post的Callback去执行view的布局绘制。","tags":["技术相关","Android"]},{"title":"深挖view绘制流程(一)","url":"/2020/07/16/深挖view绘制流程-一/","content":"\nview的绘制流程是安卓应用开发的基础,但是可能很多人对它的理解可能仅限于onMeasure、onLayout、onDraw这三个方法。\n\n我们本着刨根问底的思想,从应用层到native层,对view的绘制流程是如何调用的一探到底。\n\n大家都知道可以用View.requestLayout触发view的重新布局和绘制,我们就从这个方法开始挖。这个方法会一直往上调用父布局的requestLayout:\n\n```java\npublic void requestLayout() {\n    ...\n    // 添加重新布局和绘制的标志位\n    mPrivateFlags |= PFLAG_FORCE_LAYOUT;\n    mPrivateFlags |= PFLAG_INVALIDATED;\n\n    if (mParent != null && !mParent.isLayoutRequested()) {\n        mParent.requestLayout();\n    }\n    ...\n}\n```\n\n那到什么时候才是个头呢？答案是会一直调用到ViewRootImpl.requestLayout。\n\n# View树的结构\n\n大家可能没有太注意过，View.getParent的返回值其实不是View也不是ViewGroup而是ViewParent。这就是为了将ViewRootImpl挂到整棵view树的根:\n\n```java\npublic class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource {\n  ...\n\tprotected ViewParent mParent;\n\t...\n\tpublic final ViewParent getParent() {\n\t    return mParent;\n\t}\n\t...\n}\n\npublic abstract class ViewGroup extends View implements ViewParent, ViewManager {\n\t...\n}\n\npublic final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks {\n\t...\n}\n```\n\n这里就遇到了第一个问题,ViewRootImpl是如何成为View树的根节点的?让我们先跳出绘制流程看看这个问题。\n\n一般设置activity布局都是调用Activity.setContentView方法,所以我们从这里开始看:\n\n```java\npublic void setContentView(View view) {\n    getWindow().setContentView(view);\n    initWindowDecorActionBar();\n}\n```\n\n这个getWindow拿到的实际是PhoneWindow,所以我们从它的setContentView继续往下追:\n\n```java\n@Override\npublic void setContentView(View view) {\n    setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));\n}\n\n@Override\npublic void setContentView(View view, ViewGroup.LayoutParams params) {\n    if (mContentParent == null) {\n        installDecor();\n    }\n    ...\n    mContentParent.addView(view, params);\n    ...\n}\n\nprivate void installDecor() {\n    ...\n    if (mDecor == null) {\n        mDecor = generateDecor(-1);\n        ...\n    }\n    ...\n    if (mContentParent == null) {\n        mContentParent = generateLayout(mDecor);\n        ...\n    }\n}\n\nprotected DecorView generateDecor(int featureId) {\n    ...\n    return new DecorView(context, featureId, this, getAttributes());\n}\n\nprotected ViewGroup generateLayout(DecorView decor) {\n\t...\n\tViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);\n\t...\n\treturn contentParent;\n}\n\n// Window.java\n@Nullable\npublic <T extends View> T findViewById(@IdRes int id) {\n    return getDecorView().findViewById(id);\n}\n```\n\n经过上面的代码我们知道PhoneWindow里面有个DecorView,然后会用DecorView.findViewById(ID\\_ANDROID\\_CONTENT)得到一个mContentParent，而我们setContentView实际上就是将它addView成为这个mContentParent的子view。整个View树如下图:\n\n{% img /view绘制流程一探到底一/1.png %}\n\n然后在ActivityThread.handleResumeActivity里面会将这个DecorView add 到ViewManager\n\n```java\nfinal void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) {\n  ...\n  //performResumeActivity方法会调用Activity.onResume\n  ActivityClientRecord r = performResumeActivity(token, clearHide);\n  ...\n  r.window = r.activity.getWindow();\n  View decor = r.window.getDecorView();\n  ...\n  ViewManager wm = a.getWindowManager();\n  ...\n  wm.addView(decor, l);\n  ...\n}\n```\n\n在ViewManager里面就会创建ViewRootImpl并且将它设置成DecorView的Parent:\n\n```java\npublic final class WindowManagerImpl implements WindowManager {\n  private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();\n  ...\n  public void addView(View view, ViewGroup.LayoutParams params) {\n      mGlobal.addView(view, params, mDisplay, mParentWindow);\n  }\n  ...\n}\n\npublic final class WindowManagerGlobal {\n  public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) {\n    ...\n    ViewRootImpl root;\n    ...\n    root = new ViewRootImpl(view.getContext(), display);\n    ...\n    root.setView(view, wparams, panelParentView);\n    ...\n  }    \n}\n\npublic final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks {\n\tpublic void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {\n    ...\n    mView = view;\n\t\t...\n\t\tview.assignParent(this);\n\t\t...\n\t}\n}\n\npublic class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource {\n\tvoid assignParent(ViewParent parent) {\n\t    ...\n\t    mParent = parent;\n\t    ...\n\t}\n}\n```\n\n现在View树长这样（当然DecorView下面可能不只有ID\\_ANDROID\\_CONTENT一个子view,还会有些view用来装ActionBar之类的,这里将它们省略了）:\n\n{% img /view绘制流程一探到底一/2.png %}\n\n所以到这里我们能确定View.requestLayout会一直调用mParent的requestLayout方法,最终调用到ViewRootImpl.requestLayout。\n\n# ViewRootImpl布局流程\n\nViewRootImpl.requestLayout里面将mTraversalRunnable丢到了mChoreographer里面,Choreographer是编舞者、舞蹈编导的意思,它的作用是在接收到屏幕垂直同步信号(VSync)的时候使用handler机制将这个Runnable同步到主线程执行。这块我们之后再详细展开。\n\n```java\n@Override\npublic void requestLayout() {\n    ...\n    scheduleTraversals();\n    ..\n}\n\nvoid scheduleTraversals() {\n    if (!mTraversalScheduled) {\n        mTraversalScheduled = true;\n        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();\n        mChoreographer.postCallback(\n                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);\n        ...\n    }\n}\n```\n\n而这个mTraversalRunnable在run方法里面会调用ViewRootImpl.doTraversal,最后调到performMeasure、performLayout、performDraw，这三个方法就会调用到DecorView的measure、layout、draw方法，然后最终调用到我们熟悉的onMeasure、onLayout、onDraw。\n\n```java\nfinal class TraversalRunnable implements Runnable {\n    @Override\n    public void run() {\n        doTraversal();\n    }\n}\n\nfinal TraversalRunnable mTraversalRunnable = new TraversalRunnable();\n\nvoid doTraversal() {\n    if (mTraversalScheduled) {\n        mTraversalScheduled = false;\n        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);\n        ...\n        performTraversals();\n        ...\n    }\n}\n\nprivate void performTraversals() {\n\t  ...\n    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);\n    ...\n    performLayout(lp, mWidth, mHeight);\n    ...\n    performDraw();\n    ...\n}\n```\n\n我们还能看到这里用一个mTraversalScheduled变量保存绘制请求的状态,它在scheduleTraversals里面被设置成true，下一次再进入scheduleTraversals方法判断到为true的话就会跳过。它在下次实际的绘制调用doTraversal里面才会被还原成false。\n\n这就保证了我们连续调用多次requestLayout，只会触发一次重新布局绘制。\n\n# VSync\n\n上面的源码中我们看到ViewRootImpl使用Choreographer.postCallback将绘制流程调用的Runnable丢给Choreographer。\n\n而Choreographer会在接收到VSync信号的时候去调用这个Runnable执行实际的布局绘制,那VSync是什么东东呢？我们现在就来讲一讲。\n\n我们也许都听说过,安卓的屏幕刷新率是60Hz，即屏幕每秒刷新60次。\n\n但实际上每次屏幕刷新并不是整个屏幕的像素同时刷新的，它的刷新过程其实是从左到右一行行像素刷新的:\n\n{% img /view绘制流程一探到底一/3.png %}\n\n当整个屏幕刷新完毕一个刷新周期完成就完成了，此时屏幕就会发出VSync信号通知系统。然后之后会有一个短暂的空白期等待下一次刷新。\n\n所以我们的Choreographer就是等待VSync信号利用这个短暂的空白去计算布局和渲染绘制。\n\n# 双缓冲\n\n双缓冲也是一个比较成熟的方案了，想象下如果我们只用一个buffer用于保存屏幕数据，如果计算量比较大，在下次屏幕刷新之前不能完成，那就可能出现屏幕边读取像素，GPU边写入数据的情况，导致上半部分屏幕显示的是前一帧画面下半部分是后一帧画面的尴尬场景。\n\n而双缓冲指的就是使用两个buffer，一个用于GPU写入数据，另一个用于屏幕读取数据，当GPU写入完成之后交换两个buffer，屏幕就能读取到最新的画面了。\n\n如果当屏幕刷新周期开始，而GPU还没有或者正在写入数据的话，屏幕读取的也是上一帧的画面不会有冲突:\n\n{% img /view绘制流程一探到底一/4.png %}\n\n这个Jank指的就是同一个画面在屏幕上多次出现。\n\n当然现在还出现了三缓存机制来减少Jank的出现，有兴趣的同学可以自行搜索，这里就不展开了。\n\n\n\n# SyncBarrier机制\n\n由于这段空白的时间特别的短暂，所以我们需要尽快的完成布局和绘制来减少Jank的发生。这里有两个方向:一个是减少计算的时间，另外一个是将计算开始的时间提前。\n\n减少计算时间好理解，但是将计算开始的时间提前又是怎么一回事呢？由于我们的view操作都是在主线程进行的，也就是往主线程的MessageQueue里面丢入message，而MessageQueue里面的message是一般情况按顺序执行的。\n\n我们调用Choreographer.postCallback之后并不是立刻将消息丢到MessageQueue，而是要等VSync到来之后才会丢进去，中间的时间差就可能有消息插入了，于是就会导致执行布局绘制的message可能排在后面执行:\n\n{% img /view绘制流程一探到底一/5.png %}\n\n所以我们如果能将布局绘制的message优先级提高，就能在下次VSync到来之前完成绘制，这里使用的就是SyncBarrier机制:\n\n```java\nvoid scheduleTraversals() {\n    if (!mTraversalScheduled) {\n        mTraversalScheduled = true;\n        // 开始前先往MessageQueue post 一个SyncBarrier\n        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();\n        mChoreographer.postCallback(\n                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);\n        ...\n    }\n}\n\nvoid doTraversal() {\n    if (mTraversalScheduled) {\n        mTraversalScheduled = false;\n        // 执行布局绘制的时候才将SyncBarrier删除\n        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);\n        ...\n        performTraversals();\n        ...\n    }\n}\n```\n\npostSyncBarrier其实是往MessageQueue里面丢了一个没有target的Message:\n\n```java\npublic int postSyncBarrier() {\n    return postSyncBarrier(SystemClock.uptimeMillis());\n}\n\nprivate int postSyncBarrier(long when) {\n    // Enqueue a new sync barrier token.\n    // We don't need to wake the queue because the purpose of a barrier is to stall it.\n    synchronized (this) {\n        final int token = mNextBarrierToken++;\n        final Message msg = Message.obtain();\n        msg.markInUse();\n        msg.when = when;\n        msg.arg1 = token;\n\n        Message prev = null;\n        Message p = mMessages;\n        if (when != 0) {\n            while (p != null && p.when <= when) {\n                prev = p;\n                p = p.next;\n            }\n        }\n        if (prev != null) { // invariant: p == prev.next\n            msg.next = p;\n            prev.next = msg;\n        } else {\n            msg.next = p;\n            mMessages = msg;\n        }\n        return token;\n    }\n}\n```\n\n然后在next方法取消息的时候如果拿到了SyncBarrier，则会跳过所有不是Asynchronous的消息:\n\n```java\nMessage next() {\n    ...\n    for (;;) {\n        ...\n        nativePollOnce(ptr, nextPollTimeoutMillis);\n\n        synchronized (this) {\n            ..\n            Message msg = mMessages;\n            if (msg != null && msg.target == null) {  // target为null的是SyncBarrier\n                do {\n                    prevMsg = msg;\n                    msg = msg.next;\n                } while (msg != null && !msg.isAsynchronous());\n            }\n            ...\n        }\n        ...\n    }\n}\n```\n\n所以在VSync信号到来的时候只要往MessageQueue里面丢一个Asynchronous的Message就能保证它会优先执行了。\n\n# 整体流程\n\n上面讲的整个流程可以用下面这张图来大概表示:\n\n{% img /view绘制流程一探到底一/6.png %}\n","tags":["技术相关","Android"]},{"title":"Android NDK Crash定位分析","url":"/2020/06/05/Android-NDK-Crash定位分析/","content":"\n当拿到应用的crash日志,如果是在java层出现了异常,相信大家都知道通过堆栈信息查找到奔溃的代码,但是如果是在native层出现了问题,面对下面的一堆内存地址,有些小伙伴可能就会觉得无从下手了:\n\n```shell\n30597 30597 F DEBUG   : *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***\n30597 30597 F DEBUG   : Build fingerprint: 'Xiaomi/chiron/chiron:8.0.0/OPR1.170623.027/V10.3.1.0.ODECNXM:user/release-keys'                \n30597 30597 F DEBUG   : Revision: '0'\n30597 30597 F DEBUG   : ABI: 'arm64'\n30597 30597 F DEBUG   : pid: 30535, tid: 30535, name: me.linjw.ndkdemo  >>> com.me.linjw.ndkdemo <<<\n30597 30597 F DEBUG   : signal 6 (SIGABRT), code -6 (SI_TKILL), fault addr --------\n30597 30597 F DEBUG   : Abort message: 'Invalid address 0x7ffd3cfac0 passed to free: value not allocated'\n30597 30597 F DEBUG   :     x0   0000000000000000  x1   0000000000007747  x2   0000000000000006  x3   0000000000000008\n30597 30597 F DEBUG   :     x4   8000000000808080  x5   8000000000808080  x6   8000000000808080  x7   0000000000000008\n30597 30597 F DEBUG   :     x8   0000000000000083  x9   d6a0828f4d3c1493  x10  0000000000000000  x11  0000000000000001\n30597 30597 F DEBUG   :     x12  ffffffffffffffff  x13  0000000000000001  x14  003275d83bd3efb5  x15  0000c345d3d41566\n30597 30597 F DEBUG   :     x16  0000007b582112e8  x17  0000007b581b2d2c  x18  0000007ffd3ce5c8  x19  0000000000007747\n30597 30597 F DEBUG   :     x20  0000000000007747  x21  0000007b5520d000  x22  0000000000000000  x23  0000007b5821c878\n30597 30597 F DEBUG   :     x24  0000000000000004  x25  0000007b55214c98  x26  0000000000000000  x27  0000000000000001\n30597 30597 F DEBUG   :     x28  0000000000000001  x29  0000007ffd3cf8c0  x30  0000007b58166e54                                      \n30597 30597 F DEBUG   :     sp   0000007ffd3cf880  pc   0000007b581b2d34  pstate 0000000060000000\n30597 30597 F DEBUG   :\n30597 30597 F DEBUG   : backtrace:\n30597 30597 F DEBUG   :     #00 pc 0000000000069d34  /system/lib64/libc.so (tgkill+8)\n30597 30597 F DEBUG   :     #01 pc 000000000001de50  /system/lib64/libc.so (abort+88)\n30597 30597 F DEBUG   :     #02 pc 0000000000025644  /system/lib64/libc.so (__libc_fatal+116)\n30597 30597 F DEBUG   :     #03 pc 0000000000091204  /system/lib64/libc.so (ifree+812)\n30597 30597 F DEBUG   :     #04 pc 0000000000091484  /system/lib64/libc.so (je_free+120)\n30597 30597 F DEBUG   :     #05 pc 000000000000f60c  /data/app/com.me.linjw.ndkdemo-qgq0-FTl7SRsBBdmCeMAdg==/lib/arm64/libnative-lib.so (_Z9willCrashv+80)\n30597 30597 F DEBUG   :     #06 pc 000000000000f728  /data/app/com.me.linjw.ndkdemo-qgq0-FTl7SRsBBdmCeMAdg==/lib/arm64/libnative-lib.so (Java_com_me_linjw_ndkdemo_MainActivity_callNative+20)\n30597 30597 F DEBUG   :     #07 pc 000000000000909c  /data/app/com.me.linjw.ndkdemo-qgq0-FTl7SRsBBdmCeMAdg==/oat/arm64/base.odex (offset 0x9000)\n```\n\n莫慌,这篇博客就来讲讲怎么分析这份崩溃日志。\n\n{% img /AndroidNDK定位分析/0.jpg %}\n\n\n# 信号\n\n首先第一个知识点就是信号(signal)机制,它其实是进程间通信的一种方式。在处理ndk crash日志的时候可以大概理解为错误码,它描述了错误的大概原因。例如上面的log,可以看到这个程序是因为SIGABRT这个信号奔溃的,它的码字是6:\n\n```shell\n06-04 19:05:38.910 30597 30597 F DEBUG   : signal 6 (SIGABRT), code -6 (SI_TKILL), fault addr --------\n```\n\n我们常见的信号有下面这些:\n\n| **信号** | **码值** | **描述**                                   |\n| -------- | -------- | ------------------------------------------ |\n| SIGILL   | 4        | 非法指令，例如损坏的可执行文件或代码区损坏 |\n| SIGABRT  | 6        | 通过C函数abort()发送；为assert()使用       |\n| SIGBUS   | 7        | 不存在的物理地址，更多为硬件或系统引起     |\n| SIGFPE   | 8        | 浮点数运算错误，如除0操作                  |\n| SIGKILL  | 9        | 迅速完全终止进程；不能被捕获               |\n| SIGSEGV  | 11       | 段地址错误，例如空指针、野指针、数组越界等 |\n\n从表里面我们知道SIGABRT信号的触发原因是通过C函数abort()发送为assert()使用,也就是说它是个断言失败,从日志里面我们还能看到abort的信息:\n\n```shell\nAbort message: 'Invalid address 0x7ffd3cfac0 passed to free: value not allocated'\n```\n\n# 堆栈分析\n\n但是光知道SIGABRT信号我们是很难定位到问题的。所以我们还需要分析下面的堆栈信息,找到对应的代码:\n\n```shell\n30597 30597 F DEBUG   : backtrace:\n30597 30597 F DEBUG   :     #00 pc 0000000000069d34  /system/lib64/libc.so (tgkill+8)\n30597 30597 F DEBUG   :     #01 pc 000000000001de50  /system/lib64/libc.so (abort+88)\n30597 30597 F DEBUG   :     #02 pc 0000000000025644  /system/lib64/libc.so (__libc_fatal+116)\n30597 30597 F DEBUG   :     #03 pc 0000000000091204  /system/lib64/libc.so (ifree+812)\n30597 30597 F DEBUG   :     #04 pc 0000000000091484  /system/lib64/libc.so (je_free+120)\n30597 30597 F DEBUG   :     #05 pc 000000000000f60c  /data/app/com.me.linjw.ndkdemo-qgq0-FTl7SRsBBdmCeMAdg==/lib/arm64/libnative-lib.so (_Z9willCrashv+80)\n30597 30597 F DEBUG   :     #06 pc 000000000000f728  /data/app/com.me.linjw.ndkdemo-qgq0-FTl7SRsBBdmCeMAdg==/lib/arm64/libnative-lib.so (Java_com_me_linjw_ndkdemo_MainActivity_callNative+20)\n30597 30597 F DEBUG   :     #07 pc 000000000000909c  /data/app/com.me.linjw.ndkdemo-qgq0-FTl7SRsBBdmCeMAdg==/oat/arm64/base.odex (offset 0x9000)\n```\n\n从这里我们可以分析到libnative-lib.so里面的Java\\_com\\_me\\_linjw\\_ndkdemo\\_MainActivity\\_callNative调用了willCrash函数,然后在willCrash函数里面触发了异常:\n\n```shell\n30597 30597 F DEBUG   :     #05 pc 000000000000f60c  /data/app/com.me.linjw.ndkdemo-qgq0-FTl7SRsBBdmCeMAdg==/lib/arm64/libnative-lib.so (_Z9willCrashv+80)\n30597 30597 F DEBUG   :     #06 pc 000000000000f728  /data/app/com.me.linjw.ndkdemo-qgq0-FTl7SRsBBdmCeMAdg==/lib/arm64/libnative-lib.so (Java_com_me_linjw_ndkdemo_MainActivity_callNative+20)\n```\n\n# C++ 编译器的函数名修饰\n\n细心的同学可能会有疑问,函数名明明是显示的\\_Z9willCrashv,为啥我会说是willCrash？它和下面的Java\\_com\\_me\\_linjw\\_ndkdemo\\_MainActivity\\_callNative有什么区别？\n\n我们可以先来看看源代码确认下我没有骗你:\n\n{% img /AndroidNDK定位分析/1.jpeg %}\n\n那为什么willCrash在编译之后so里面会变成\\_Z9willCrashv?这主要是C++编译器的函数名修饰功能在作怪。由于c++是支持重载的,也就是只要参数不一样,函数的名字可以相同。\n\n这个重载其实在编译期就能确定，所以编译器实现重载的原理是给函数加上修饰符，例如在函数后面拼接上参数类型简写，这里\\_Z9willCrashv最后拼接的v就代表void,说明该函数没有参数。\n\n也就是说虽然你在代码里面写的是同样的函数名，但是在编译之后，重载的函数其实就变成了不同名字的不同函数。\n\n解释完了\\_Z9willCrashv我们再来说说Java\\_com\\_me\\_linjw\\_ndkdemo\\_MainActivity\\_callNative，为什么它又没有被修饰呢？原因就在于函数上面的extern \"C\"，它告诉编译器将这个函数当做c语言的函数来处理。而c语言是没有重载这一说的，所以也就不会改变它原本的函数名。\n\n# 指令偏移地址\n\n然后方法名+号后面的数字是指的什么？方法行数吗?实际去代码里面看Java\\_com\\_me\\_linjw\\_ndkdemo\\_MainActivity\\_callNative只有一行代码,找不到20行，同样willCrash也没有80行:\n\n{% img /AndroidNDK定位分析/1.jpeg %}\n\n这里我们来解释下+号后面的值的意义。我们都知道c/c++代码都是需要编译成二进制文件之后才能运行,而实际上程序就是通过执行二进制文件中的一条条指令来运行的。上面日志中的#06 pc 000000000000f728指的就是出现问题的时候Java\\_com\\_me\\_linjw\\_ndkdemo\\_MainActivity\\_callNative执行到了0x000000000000f728这个地址的指令,而后面的+20指的是这个地址相对方法起始地址的偏移。\n\n说起来可能比较难以理解,这里我们直接通过反汇编libnative-lib.so来帮助理解。ndk提供了objdump工具用于反汇编,由于不同cpu架构的反编译工具也是不一样的,大家可以根据需要找到对应的程序进行反汇编:\n\n```shell\n LinJW@LinJWdeMacBook-Pro  ~/Library/Android/sdk/ndk  find . -name \"*objdump\"\n./20.0.5594570/toolchains/x86-4.9/prebuilt/darwin-x86_64/bin/i686-linux-android-objdump\n./20.0.5594570/toolchains/x86-4.9/prebuilt/darwin-x86_64/i686-linux-android/bin/objdump\n./20.0.5594570/toolchains/llvm/prebuilt/darwin-x86_64/aarch64-linux-android/bin/objdump\n./20.0.5594570/toolchains/llvm/prebuilt/darwin-x86_64/bin/x86_64-linux-android-objdump\n./20.0.5594570/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android-objdump\n./20.0.5594570/toolchains/llvm/prebuilt/darwin-x86_64/bin/i686-linux-android-objdump\n./20.0.5594570/toolchains/llvm/prebuilt/darwin-x86_64/bin/arm-linux-androideabi-objdump\n./20.0.5594570/toolchains/llvm/prebuilt/darwin-x86_64/arm-linux-androideabi/bin/objdump\n./20.0.5594570/toolchains/llvm/prebuilt/darwin-x86_64/x86_64-linux-android/bin/objdump\n./20.0.5594570/toolchains/llvm/prebuilt/darwin-x86_64/i686-linux-android/bin/objdump\n./20.0.5594570/toolchains/x86_64-4.9/prebuilt/darwin-x86_64/bin/x86_64-linux-android-objdump\n./20.0.5594570/toolchains/x86_64-4.9/prebuilt/darwin-x86_64/x86_64-linux-android/bin/objdump\n./20.0.5594570/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-androideabi-objdump\n./20.0.5594570/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/arm-linux-androideabi/bin/objdump\n./20.0.5594570/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/aarch64-linux-android/bin/objdump\n./20.0.5594570/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin/aarch64-linux-android-objdump\n```\n\n我这边使用的是aarch64-linux-android-objdump,命令如下:\n\n```\naarch64-linux-android-objdump -S ./libnative-lib.so\n```\n\n然后我们搜索Java\\_com\\_me\\_linjw\\_ndkdemo\\_MainActivity\\_callNative找到这个方法的定义:\n\n```asm\n000000000000f714 <Java_com_me_linjw_ndkdemo_MainActivity_callNative@@Base>:\n    f714:   d10083ff    sub sp, sp, #0x20\n    f718:   a9017bfd    stp x29, x30, [sp,#16]\n    f71c:   910043fd    add x29, sp, #0x10\n    f720:   f90007e0    str x0, [sp,#8]\n    f724:   f90003e1    str x1, [sp]\n    f728:   97ffff0a    bl  f350 <_Z9willCrashv@plt>\n    f72c:   a9417bfd    ldp x29, x30, [sp,#16]\n    f730:   910083ff    add sp, sp, #0x20\n    f734:   d65f03c0    ret\n    f738:   d100c3ff    sub sp, sp, #0x30\n    f73c:   a9027bfd    stp x29, x30, [sp,#32]\n    ...\n```\n\n然后我们上面看到的pc 000000000000f728其实指的就是f728这个地址的指令,也就是bl指令,这个指令用于调用子程序,于是我们可以容易猜出这行指令的作用是跳转到willCrash方法:\n\n```asm\nf728:   97ffff0a    bl  f350 <_Z9willCrashv@plt>\n```\n\n而Java\\_com\\_me\\_linjw\\_ndkdemo\\_MainActivity\\_callNative的起始地址为000000000000f714，于是可以计算出000000000000f728相对函数起始地址的偏移为0xf728-0xf714=0x14，而0x14在十进制里面就是20。\n\n# addr2line\n\n如果对这些汇编指令比较熟悉的话当然可以分析定位问题,但是一般的安卓程序员可能对这块比较陌生。所以我们可以用addr2line工具直接定位到源代码。\n\n我们从下面log可以得到两个地址000000000000f728、000000000000f60c\n\n```shell\n30597 30597 F DEBUG   :     #05 pc 000000000000f60c  /data/app/com.me.linjw.ndkdemo-qgq0-FTl7SRsBBdmCeMAdg==/lib/arm64/libnative-lib.so (_Z9willCrashv+80)\n30597 30597 F DEBUG   :     #06 pc 000000000000f728  /data/app/com.me.linjw.ndkdemo-qgq0-FTl7SRsBBdmCeMAdg==/lib/arm64/libnative-lib.so (Java_com_me_linjw_ndkdemo_MainActivity_callNative+20)\n```\n\n\n\n使用这个命令的前提是我们要有带符号的so库,因为一般情况下打包到apk里面的so都是不带符号的(可以大概理解成java层的混淆,去掉了符号信息),所以如果直接从apk里面解压出so,然后使用addr2line会得到下面结果，全是问号:\n\n```shell\n??:?\n```\n\n带符号的so一般会在编译的过程中生成,所以可以在app/build目录里面递归搜索下,而且不同cpu架构也需要用不同的addr2line,命令如下:\n\n```shell\naarch64-linux-android-addr2line -e ./app/build/intermediates/cmake/debug/obj/arm64-v8a/libnative-lib.so 000000000000f728 000000000000f60c\n```\n\n得到结果:\n\n```shell\n/Users/LinJW/workspace/NdkDemo/app/src/main/cpp/native-lib.cpp:19\n/Users/LinJW/workspace/NdkDemo/app/src/main/cpp/native-lib.cpp:13\n```\n\n我们来对比下源码就能找到崩溃的原因是delete了字符串常量的内存:\n\n{% img /AndroidNDK定位分析/2.jpeg %}\n\n# ndk-stack\n\n作为认真看到这里的同学,我必须要奖励好学的你一个福利,那就是ndk-stack,他也在ndk里面:\n\n```shell\nNDK目录/prebuilt/darwin-x86_64/bin/ndk-stack\n```\n\n首先我们将含有native crash的log保存到crash_log.txt用-dump参数出入,然后将所有带符号的so放到某个目录下,用-sym参数传入:\n\n```shell\nndk-stack -sym ./app/build/intermediates/cmake/debug/obj/arm64-v8a/ -dump ~/Downloads/crash_log.txt\n```\n\n然后它就会对native堆栈使用addr2line和目录下的so去转换,最终输出带符号的堆栈信息:\n\n```shell\n********* Crash dump: **********\nBuild fingerprint: 'Xiaomi/chiron/chiron:8.0.0/OPR1.170623.027/V10.3.1.0.ODECNXM:user/release-keys'\nAbort message: 'Invalid address 0x7ffd3cfac0 passed to free: value not allocated'\n#00 0x0000000000069d34 /system/lib64/libc.so (tgkill+8)\n#01 0x000000000001de50 /system/lib64/libc.so (abort+88)\n#02 0x0000000000025644 /system/lib64/libc.so (__libc_fatal+116)\n#03 0x0000000000091204 /system/lib64/libc.so (ifree+812)\n#04 0x0000000000091484 /system/lib64/libc.so (je_free+120)\n#05 0x000000000000f60c /data/app/com.me.linjw.ndkdemo-qgq0-FTl7SRsBBdmCeMAdg==/lib/arm64/libnative-lib.so (_Z9willCrashv+80)\n                                                                                                           willCrash()\n                                                                                                           /Users/LinJW/workspace/NdkDemo/app/src/main/cpp/native-lib.cpp:13:5\n#06 0x000000000000f728 /data/app/com.me.linjw.ndkdemo-qgq0-FTl7SRsBBdmCeMAdg==/lib/arm64/libnative-lib.so (Java_com_me_linjw_ndkdemo_MainActivity_callNative+2\n0)\n                                                                                                           Java_com_cvte_tv_ndkdemo_MainActivity_callNative\n                                                                                                           /Users/LinJW/workspace/NdkDemo/app/src/main/cpp/native-lib.cpp:19:5\n#07 0x000000000000909c /data/app/com.me.linjw.ndkdemo-qgq0-FTl7SRsBBdmCeMAdg==/oat/arm64/base.odex (offset 0x9000)\n```\n\nndk-stack在开始解析 logcat 输出时将查找第一行星号,所以拷贝的时候记得这行不能缺少:\n\n```shell\n*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***\n```\n\n当然通常情况下我们直接将logcat出来的所有日志传给它就好，它会自动根据星号行识别出native堆栈:\n\n```shell\nadb logcat | ndk-stack路径 -sym 存放带符号so库目录的路径\n```\n\n","tags":["技术相关","Android"]},{"title":"JNI内存管理","url":"/2020/04/08/JNI内存管理/","content":"\n面试的时候遇到一些候选人的简历上写着熟悉jni,但是问的时候才发现对jni的了解仅仅是停留在java和c的方法是如何相互调用上。其实这远远称不上熟悉,这篇博客就来讲讲jni面试中经常还会问到的内存管理问题。\n\n首先我们知道java和c的对象是不能直接共用的,例如字符串我们不能直接返回char*,而需要创建一个jstring对象:\n\n```\nstd::string hello = \"hello world\";\njstring jstr = env->NewStringUTF(hello.c_str());\n```\n那问题就来了,这个jstr是我们用env去new出来的。那我们需要手动去delete吗,不delete会不会造成内存泄露?\n\n如果需要的话,当我们需要将这个jstr返回给java层使用的时候又要怎么办呢?不delete就内存泄露,delete就野指针:\n\n```\nextern \"C\" JNIEXPORT jstring JNICALL\nJava_me_linjw_ndkdemo_MainActivity_stringFromJNI(\n        JNIEnv *env,\n        jobject thiz/* this */) {\n    std::string hello = \"hello world\";\n    jstring jstr = env->NewStringUTF(hello.c_str());\n    return jstr;\n}\n```\n\n其实jni为了解决这个问题,设计了三种引用类型:\n\n- 局部引用\n- 全局引用\n- 弱全局引用\n\n# 局部引用\n\n我们先从局部引用讲起,其实我们这里通过NewStringUTF创建的jstring就是局部引用,那它有什么特点呢?\n\n我们在c层大多数调用jni方法创建的引用都是局部引用,它会别存放在一张局部引用表里。它的内存有四种释放方式:\n\n1. 程序员可以手动调用DeleteLocalRef去释放\n2. c层方法执行完成返回java层的时候,jvm会遍历局部引用表去释放\n3. 使用PushLocalFrame/PopLocalFrame创建/销毁局部引用栈帧的时候,在PopLocalFrame里会释放帧内创建的引用\n4. 如果使用AttachCurrentThread附加原生线程,在调用DetachCurrentThread的时候会释放该线程创建的局部引用\n\n所以上面的问题我们就能回答了, jstr可以不用手动delete,可以等方法结束的时候jvm自己去释放(当然如果返回之后在java层将这个引用保存了起来,那也是不会立马释放内存的)\n\n但是这样是否就意味着我们可以任性的去new对象,不用考虑任何东西呢?其实也不是,局部引用表是有大小限制的,如果new的内存太多的话可能造成局部引用表的内存溢出,例如我们在for循环里面不断创建对象:\n\n```\nstd::string hello = \"hello world\";\nfor(int i = 0 ; i < 9999999 ; i ++) {\n    env->NewStringUTF(hello.c_str());\n}\n```\n\n这就会引起local reference table overflow:\n\n{% img /JNI内存管理/1.png %}\n\n所以在使用完之后一定记得调用DeleteLocalRef去释放它。\n\n有些同学可能会说,怎么可能会有人真的直接就在循环里不断创建对象呢。其实这种溢出大多数情况发生在被循环调用的方法里面:\n\n```\nvoid func(JNIEnv *env) {\n    std::string hello = \"hello world\";\n    env->NewStringUTF(hello.c_str());\n}\n\n...\n\nfor(int i = 0 ; i < 9999999 ; i ++) {\n    func(env);\n}\n```\n\n作为一个安全的程序员,在对象不再使用的时候,立马使用DeleteLocalRef去将其释放是一个很好的习惯。\n\n## 局部引用栈帧\n\n如上面所说我们可能在某个函数中创建了局部引用,然后这个函数在循环中被调用,就容易出现溢出。\n\n但是如果方法里面创建了多个局部引用,在return之前一个个去释放会显得十分繁琐:\n\n```\nvoid func(JNIEnv *env) {\n    ...\n    jstring jstr1 = env->NewStringUTF(str1.c_str());\n    jstring jstr2 = env->NewStringUTF(str2.c_str());\n    jstring jstr3 = env->NewStringUTF(str3.c_str());\n    jstring jstr4 = env->NewStringUTF(str4.c_str());\n    ...\n    env->DeleteLocalRef(jstr1);\n    env->DeleteLocalRef(jstr2);\n    env->DeleteLocalRef(jstr3);\n    env->DeleteLocalRef(jstr4);\n}\n```\n\n这个时候可以考虑使用局部引用栈帧:\n\n```\nvoid func(JNIEnv *env) {\n    env->PushLocalFrame(4);\n    ...\n    jstring jstr1 = env->NewStringUTF(str1.c_str());\n    jstring jstr2 = env->NewStringUTF(str2.c_str());\n    jstring jstr3 = env->NewStringUTF(str3.c_str());\n    jstring jstr4 = env->NewStringUTF(str4.c_str());\n\t...\n    env->PopLocalFrame(NULL);\n}\n```\n\n我们在方法开头PushLocalFrame,结尾PopLocalFrame,这样整个方法就在一个局部引用帧里面,而在PopLocalFrame就会将该帧里面创建的局部引用全部释放。\n\n有的同学可能会想到一种场景,如果需要将某个局部引用当初返回值返回怎么办?用局部引用帧会不会造成野指针?\n\n其实jni也考虑到了这中情况,所以PopLocalFrame有一个参数:\n\n```\njobject PopLocalFrame(jobject result)\n```\n\n这个result参数可以传入你的返回值引用,这样的话这个局部引用就会在去到父帧里面,这样就能直接返回了:\n\n```\njstring func(JNIEnv *env) {\n    env->PushLocalFrame(4);\n    ...\n    jstring jstr1 = env->NewStringUTF(str1.c_str());\n    jstring jstr2 = env->NewStringUTF(str2.c_str());\n    jstring jstr3 = env->NewStringUTF(str3.c_str());\n    jstring jstr4 = env->NewStringUTF(str4.c_str());\n\t...\n    return (jstring)env->PopLocalFrame(jstr4);\n}\n```\n\nPS: 就算使用了result参数,局部引用帧里面的引用也是会失效的,所以不能直接将它返回,而是需要用PopLocalFrame为它创建的新引用,这个引用才在父帧里面。\n\n## 多线程下的局部引用\n\n前面三种情况我们好理解,但是第四种情况又是什么意思呢?\n\n> 3.如果使用AttachCurrentThread附加原生线程,在调用DetachCurrentThread的时候会释放该线程创建的局部引用\n\n我们使用JNIEnv这个数据结构去调用jni的方法创建局部引用,但是JNIEnv将用于线程本地存储,所以我们不能在线程之间共享它。\n\n如果是java层创建的线程,那调到c层会自然传入一个JNIEnv指针,但是如果是我们在c层自己新建的线程,我们要怎么拿的这个线程的JNIEnv呢?\n\n在讲解之前还有一个知识点要先交代,除了JNIEnv其实jni还有个很重要的数据结构JavaVM,理论上每个进程可以有多个JavaVM,但Android只允许有一个,所以JavaVM是可以在多线程间共享的。\n\n我们在java层使用System.loadLibrary方法加载so的时候,c层的JNI_OnLoad方法会被调用,我们可以在拿到JavaVM指针并将它保存起来:\n\n```\nJavaVM* g_Vm;\n\nJNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) {\n    g_Vm = vm;\n    return JNI_VERSION_1_4;\n}\n```\n\n之后可以在线程中使用它的AttachCurrentThread方法附加原生线程,然后在线程结束的时候使用DetachCurrentThread去解除附加:\n\n```\npthread_t g_pthread;\nJavaVM* g_vm;\n\nvoid* ThreadRun(void *data) {\n    JNIEnv* env;\n    g_vm->AttachCurrentThread(&env, nullptr);\n    ...\n    g_vm->DetachCurrentThread();\n}\n\nJNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) {\n    g_vm = vm;\n    return JNI_VERSION_1_4;\n}\n\n...\n\npthread_create(&g_pthread, NULL, ThreadRun, (void *) 1);\n```\n\n所以在AttachCurrentThread和DetachCurrentThread之间JNIEnv都是有效的,我们可以使用它去创建局部引用,而在DetachCurrentThread之后JNIEnv就失效了,同时我们用它创建的局部引用也会被回收。\n\n# 全局引用\n\n假设我们需要使用监听者模式在c层保存java对象的引用,并启动线程执行操作,在适当的时候通知java层。我们需要怎么做,一种<font color='red'>__错误__</font>的做法是直接将传入的jobject保存到全局变量:\n\n```\njobject g_listener;\n\nextern \"C\" JNIEXPORT void JNICALL\nJava_me_linjw_ndkdemo_MainActivity_registerListener(\n        JNIEnv *env,\n        jobject thiz,\n        jobject listener) {\n    g_listener = listener; // 错误的做法!!!\n}\n```\n\n原因是这里传进来的jobject其实也是局部引用,而局部引用是不能跨线程使用的。我们应该将它转换成全局引用去保存:\n\n```\njobject g_listener;\n\nextern \"C\" JNIEXPORT void JNICALL\nJava_me_linjw_ndkdemo_MainActivity_registerListener(\n        JNIEnv *env,\n        jobject thiz,\n        jobject listener) {\n    g_listener = env->NewGlobalRef(listener);\n}\n```\n\n顾名思义,全局引用就是全局存在的引用,只有在我们调用DeleteGlobalRef之后它才会失效。\n\n然后这样又出现了个问题,按道理这个g_listener和listener应该指向的是同一个java对象,但是如果我们这样去判断的话是错误的:\n\n```\nif(g_listener == listener) {\n\t...\n}\n```\n\n它们的值是不会相等的,如果要判断两个jobject是否指向同一个java对象要需要用IsSameObject去判断:\n\n```\nif(env->IsSameObject(g_listener, listener)) {\n\t...   \n}\n```\n\n# 弱全局引用\n\n弱全局引用和全局引用类似,可以在跨线程使用,它使用NewGlobalWeakRef创建,使用DeleteGlobalWeakRef释放。\n\n但是弱全局引用是会被gc回收的,所以在使用的时候我们需要先判断它是否已经被回收:\n\n```\nif(!env->IsSameObject(g_listener, NULL)) {\n\t...   \n}\n```\n\nJNI中的NULL引用指向JVM中的null对象。","tags":["技术相关","Android"]},{"title":"Android Input系统(二) 事件的分发流程","url":"/2020/02/06/Android-Input系统-二-事件的分发流程/","content":"\n[上篇笔记](http://blog.islinjw.cn/2020/01/23/Android-Input%E7%B3%BB%E7%BB%9F-%E4%B8%80-%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%8E%B7%E5%8F%96%E6%B5%81%E7%A8%8B/)说到InputReader将事件传到InputDispatcher:: mInboundQueue里面并且唤醒了InputDispatcherThread。现在我们来继续看看InputDispatcherThread被唤醒之后干了什么:\n\n首先会用haveCommandsLocked判断是否有Command,如果没有的话才去分发事件,如果有的话不分发,而是在下面的runCommandsLockedInterruptible里面执行Command:\n\n```\nvoid InputDispatcher::dispatchOnce() {\n    nsecs_t nextWakeupTime = LONG_LONG_MAX;\n    {\n        AutoMutex _l(mLock);\n        mDispatcherIsAliveCondition.broadcast();\n\n        if (!haveCommandsLocked()) {\n            dispatchOnceInnerLocked(&nextWakeupTime);\n        }\n\n        if (runCommandsLockedInterruptible()) {\n            nextWakeupTime = LONG_LONG_MIN;\n        }\n    }\n    ...\n}\n```\n\n也就是说在dispatchOnce里面其实主要是做两件事情,执行指令或者分发事件,而且指令的优先级会比较高。由于上一篇笔记里面讲到的时候事件唤醒了InputDispatcherThread,所以我们这里先讲事件的分发:\n\n```\nvoid InputDispatcher::dispatchOnceInnerLocked(nsecs_t* nextWakeupTime) {\n    if (! mPendingEvent) {\n        if (mInboundQueue.isEmpty()) {\n            ...\n        } else {\n            mPendingEvent = mInboundQueue.dequeueAtHead();\n            ...\n        }\n        ...\n    }\n\n    switch (mPendingEvent->type) {\n        ...\n\n    case EventEntry::TYPE_KEY: {\n        KeyEntry* typedEntry = static_cast<KeyEntry*>(mPendingEvent);\n        ...\n        done = dispatchKeyLocked(currentTime, typedEntry, &dropReason, nextWakeupTime);\n        break;\n    }\n\n    case EventEntry::TYPE_MOTION: {\n        MotionEntry* typedEntry = static_cast<MotionEntry*>(mPendingEvent);\n        ...\n        done = dispatchMotionLocked(currentTime, typedEntry,\n                &dropReason, nextWakeupTime);\n        break;\n    }\n    ...\n    }\n\n    if (done) {\n        ...\n        releasePendingEventLocked();\n        ...\n    }\n}\n\nvoid InputDispatcher::releasePendingEventLocked() {\n    if (mPendingEvent) {\n\t\t...\n\t\treleaseInboundEventLocked(mPendingEvent);\n\t\tmPendingEvent = NULL;\n    }\n}\n```\n\n从这里可以看到如果mPendingEvent是正在处理的事件,如果是null的话就会从mInboundQueue里面拿队列头的事件,然后在后面判断事件类型,如果是按键事件就调用dispatchKeyLocked,如果是触摸事件就调用dispatchMotionLocked,然后如果完成了的话就会在releasePendingEventLocked里面将mPendingEvent设置回null。\n\n这里我们只拿按键事件处理来分析,触摸事件的原理大同小异:\n\n```\n\nbool InputDispatcher::dispatchKeyLocked(nsecs_t currentTime, KeyEntry* entry,\n        DropReason* dropReason, nsecs_t* nextWakeupTime) {\n          ...\n          Vector<InputTarget> inputTargets;\n          int32_t injectionResult = findFocusedWindowTargetsLocked(currentTime,\n                  entry, inputTargets, nextWakeupTime);\n          ...\n\n          addMonitoringTargetsLocked(inputTargets);\n\n          dispatchEventLocked(currentTime, entry, inputTargets);\n}\n```\n\ndispatchKeyLocked里面最主要是两个步骤,一是找到焦点窗口,将它放到inputTargets里面:\n\n```\nint32_t InputDispatcher::findFocusedWindowTargetsLocked(nsecs_t currentTime,\n        const EventEntry* entry, Vector<InputTarget>& inputTargets, nsecs_t* nextWakeupTime) {\n    ...\n\n    injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;\n    addWindowTargetLocked(mFocusedWindowHandle,\n            InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS, BitSet32(0),\n            inputTargets);\n    ...\n    return injectionResult;\n}\n\nvoid InputDispatcher::addWindowTargetLocked(const sp<InputWindowHandle>& windowHandle,\n        int32_t targetFlags, BitSet32 pointerIds, Vector<InputTarget>& inputTargets) {\n    inputTargets.push();\n\n    const InputWindowInfo* windowInfo = windowHandle->getInfo();\n    InputTarget& target = inputTargets.editTop();\n    target.inputChannel = windowInfo->inputChannel;\n    target.flags = targetFlags;\n    target.xOffset = - windowInfo->frameLeft;\n    target.yOffset = - windowInfo->frameTop;\n    target.scaleFactor = windowInfo->scaleFactor;\n    target.pointerIds = pointerIds;\n}\n```\n\n然后去dispatchEventLocked里面会将事件进行分发,这块我们之后详细聊。这里可以看到dispatchEventLocked并不是只将消息分发给当前焦点窗口,而是会分发给inputTargets里面的所有监听者,另外的一些特殊需求需要监听事件的时候就能把自己注册到mMonitoringChannels里面,分发事件的时候会把mMonitoringChannels里面的channel放到inputTargets里面:\n\n```\nvoid InputDispatcher::addMonitoringTargetsLocked(Vector<InputTarget>& inputTargets) {\n    for (size_t i = 0; i < mMonitoringChannels.size(); i++) {\n        inputTargets.push();\n\n        InputTarget& target = inputTargets.editTop();\n        target.inputChannel = mMonitoringChannels[i];\n        target.flags = InputTarget::FLAG_DISPATCH_AS_IS;\n        target.xOffset = 0;\n        target.yOffset = 0;\n        target.pointerIds.clear();\n        target.scaleFactor = 1.0f;\n    }\n}\n```\n\n# InputChannel通信\n\n在继续讲事件分发之前我们先来看看InputDispatcher是怎么和窗口通信的。\n\n在应用层新的顶层窗口需要被注册到WMS中是在ViewRootImpl.setView实现的,我们从这里开始一路往下追,可以看到最后会调用到InputDispatcher::registerInputChannel注册通信的channel__放到InputDispatcher::mConnectionsByFd__这个KeyedVector里面:\n\n```\n// frameworks/base/core/java/android/view/ViewRootImpl.java\npublic void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {\n\t...\n\tmInputChannel = new InputChannel();\n\t...\n\tres = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,\n                            getHostVisibility(), mDisplay.getDisplayId(),\n                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,\n                            mAttachInfo.mOutsets, mInputChannel);\n\t...\n\tmInputEventReceiver = new WindowInputEventReceiver(mInputChannel,\n                            Looper.myLooper());\n\t...\n}\n\n// frameworks/base/services/core/java/com/android/server/wm/Session.java\npublic class Session extends IWindowSession.Stub\n        implements IBinder.DeathRecipient {\n    ...\n\t@Override\n\tpublic int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs,\n\t        int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets,\n\t        Rect outOutsets, InputChannel outInputChannel) {\n\t    return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId,\n\t            outContentInsets, outStableInsets, outOutsets, outInputChannel);\n\t}\n\t...\n}\n\n// frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java\npublic int addWindow(Session session, IWindow client, int seq,\n        WindowManager.LayoutParams attrs, int viewVisibility, int displayId,\n        Rect outContentInsets, Rect outStableInsets, Rect outOutsets,\n        InputChannel outInputChannel) {\n\t...\n\tfinal WindowState win = new WindowState(this, session, client, token, parentWindow,\n\t        appOp[0], seq, attrs, viewVisibility, session.mUid,\n\t        session.mCanAddInternalSystemWindow);\n\t...\n    win.openInputChannel(outInputChannel);\n\t...\n}\n\n// frameworks/base/services/core/java/com/android/server/wm/WindowState.java\nvoid openInputChannel(InputChannel outInputChannel) {\n    ...\n    String name = getName();\n    InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);\n    mInputChannel = inputChannels[0];\n    mClientChannel = inputChannels[1];\n    mInputWindowHandle.inputChannel = inputChannels[0];\n    if (outInputChannel != null) {\n        mClientChannel.transferTo(outInputChannel);\n        mClientChannel.dispose();\n        mClientChannel = null;\n    } else {\n        ...\n    }\n    mService.mInputManager.registerInputChannel(mInputChannel, mInputWindowHandle);\n}\n\n// frameworks/base/services/core/java/com/android/server/input/InputManagerService.java\npublic void registerInputChannel(InputChannel inputChannel,\n        InputWindowHandle inputWindowHandle) {\n    ...\n    nativeRegisterInputChannel(mPtr, inputChannel, inputWindowHandle, false);\n}\n\n// frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp\nstatic void nativeRegisterInputChannel(JNIEnv* env, jclass /* clazz */,\n        jlong ptr, jobject inputChannelObj, jobject inputWindowHandleObj, jboolean monitor) {\n    NativeInputManager* im = reinterpret_cast<NativeInputManager*>(ptr);\n\n    sp<InputChannel> inputChannel = android_view_InputChannel_getInputChannel(env,\n            inputChannelObj);\n    ...\n    status_t status = im->registerInputChannel(\n            env, inputChannel, inputWindowHandle, monitor);\n    ...\n}\n\n// frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp\nstatus_t NativeInputManager::registerInputChannel(JNIEnv* /* env */,\n        const sp<InputChannel>& inputChannel,\n        const sp<InputWindowHandle>& inputWindowHandle, bool monitor) {\n    return mInputManager->getDispatcher()->registerInputChannel(\n            inputChannel, inputWindowHandle, monitor);\n}\n\n// frameworks/native/services/inputflinger/InputDispatcher.cpp\nstatus_t InputDispatcher::registerInputChannel(const sp<InputChannel>& inputChannel,\n        const sp<InputWindowHandle>& inputWindowHandle, bool monitor) {\n\t\t...\n        sp<Connection> connection = new Connection(inputChannel, inputWindowHandle, monitor);\n\n        int fd = inputChannel->getFd();\n        mConnectionsByFd.add(fd, connection);\n        ...\n\n        // registerInputChannel里面传入的monitor是false --> nativeRegisterInputChannel(mPtr, inputChannel, inputWindowHandle, false);\n        // 所以这个流程不会将窗口的channel放到mMonitoringChannels里面\n        if (monitor) {\n            mMonitoringChannels.push(inputChannel);\n        }\n        ...\n}\n```\n\n时序图如下:\n\n{% img /AndroidInput系统二/1.png %}\n\n值得注意的是这个流程里InputDispatcher::registerInputChannel的monitor是false(原因看注释),所以不会将channel放到mMonitoringChannels,要不然分发消息的时候就不止会分发到焦点窗口而是分发到所有窗口了。\n\n细心的同学可能会发现ViewRootImpl.setView里面new的InputChannel到了WindowState.openInputChannel里面就不再继续往下传了,而是保存到mClientChannel。而继续往下传的其实是mInputChannel:\n\n```\n// frameworks/base/services/core/java/com/android/server/wm/WindowState.java\nvoid openInputChannel(InputChannel outInputChannel) {\n    ...\n    String name = getName();\n    InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);\n    mInputChannel = inputChannels[0];\n    mClientChannel = inputChannels[1];\n    mInputWindowHandle.inputChannel = inputChannels[0];\n    if (outInputChannel != null) {\n        mClientChannel.transferTo(outInputChannel);\n        mClientChannel.dispose();\n        mClientChannel = null;\n    } else {\n        ...\n    }\n    mService.mInputManager.registerInputChannel(mInputChannel, mInputWindowHandle);\n}\n```\n\n这两个都是是啥?我们直接来看看InputChannel.openInputChannelPair的代码:\n\n```\n// frameworks/base/core/java/android/view/InputChannel.java\npublic static InputChannel[] openInputChannelPair(String name) {\n    ...\n    return nativeOpenInputChannelPair(name);\n}\n\n// frameworks/base/core/jni/android_view_InputChannel.cpp\nstatic jobjectArray android_view_InputChannel_nativeOpenInputChannelPair(JNIEnv* env,\n        jclass clazz, jstring nameObj) {\n    ...\n    sp<InputChannel> serverChannel;\n    sp<InputChannel> clientChannel;\n    status_t result = InputChannel::openInputChannelPair(name, serverChannel, clientChannel);\n\t...\n    env->SetObjectArrayElement(channelPair, 0, serverChannelObj);\n    env->SetObjectArrayElement(channelPair, 1, clientChannelObj);\n    return channelPair;\n}\n\n// frameworks/native/libs/input/InputTransport.cpp\nstatus_t InputChannel::openInputChannelPair(const String8& name,\n        sp<InputChannel>& outServerChannel, sp<InputChannel>& outClientChannel) {\n    int sockets[2];\n    if (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets)) {\n        ...\n    }\n\n    int bufferSize = SOCKET_BUFFER_SIZE;\n    setsockopt(sockets[0], SOL_SOCKET, SO_SNDBUF, &bufferSize, sizeof(bufferSize));\n    setsockopt(sockets[0], SOL_SOCKET, SO_RCVBUF, &bufferSize, sizeof(bufferSize));\n    setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF, &bufferSize, sizeof(bufferSize));\n    setsockopt(sockets[1], SOL_SOCKET, SO_RCVBUF, &bufferSize, sizeof(bufferSize));\n\n    String8 serverChannelName = name;\n    serverChannelName.append(\" (server)\");\n    outServerChannel = new InputChannel(serverChannelName, sockets[0]);\n\n    String8 clientChannelName = name;\n    clientChannelName.append(\" (client)\");\n    outClientChannel = new InputChannel(clientChannelName, sockets[1]);\n    return OK;\n}\n```\n\n最后追下来,它们其实是两个socket,0是服务端,1是客户端。然后再让我们品味一下这个代码:\n\n```\n// frameworks/base/services/core/java/com/android/server/wm/WindowState.java\nvoid openInputChannel(InputChannel outInputChannel) {\n    ...\n    String name = getName();\n    InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);\n    mInputChannel = inputChannels[0];\n    mClientChannel = inputChannels[1];\n    mInputWindowHandle.inputChannel = inputChannels[0];\n    if (outInputChannel != null) {\n        mClientChannel.transferTo(outInputChannel);\n        mClientChannel.dispose();\n        mClientChannel = null;\n    } else {\n        ...\n    }\n    mService.mInputManager.registerInputChannel(mInputChannel, mInputWindowHandle);\n}\n```\n\n它将服务端socket注册给InputDispatcher,于是InputDispatcher就可以往服务端写入数据传给WindowState。而客户端的socket和ViewRootImpl传下来的outInputChannel绑定,也就是说可以往客户端socket里面写入数据通知ViewRootImpl。没错,事件机制的消息传输靠的是socket!\n\n大概的原理是这样的:\n\n{% img /AndroidInput系统二/2.png %}\n\n# 焦点窗口确定机制\n\n好了,上一小节里面我们知道了应用启动的时候最终会调用InputDispatcher::registerInputChannel往mConnectionsByFd添加一个socket连接,那InputDispatcher又是怎样确定事件分发的时候要分发给谁的呢?\n\n应该有同学记得事件分发时findFocusedWindowTargetsLocked里面这个mFocusedWindowHandle:\n\n```\nbool InputDispatcher::dispatchKeyLocked(nsecs_t currentTime, KeyEntry* entry,\n        DropReason* dropReason, nsecs_t* nextWakeupTime) {\n          ...\n          Vector<InputTarget> inputTargets;\n          int32_t injectionResult = findFocusedWindowTargetsLocked(currentTime,\n                  entry, inputTargets, nextWakeupTime);\n          ...\n\n          addMonitoringTargetsLocked(inputTargets);\n\n          dispatchEventLocked(currentTime, entry, inputTargets);\n}\n\nint32_t InputDispatcher::findFocusedWindowTargetsLocked(nsecs_t currentTime,\n        const EventEntry* entry, Vector<InputTarget>& inputTargets, nsecs_t* nextWakeupTime) {\n    ...\n\n    injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;\n    addWindowTargetLocked(mFocusedWindowHandle,\n            InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS, BitSet32(0),\n            inputTargets);\n    ...\n    return injectionResult;\n}\n\nvoid InputDispatcher::addWindowTargetLocked(const sp<InputWindowHandle>& windowHandle,\n        int32_t targetFlags, BitSet32 pointerIds, Vector<InputTarget>& inputTargets) {\n    inputTargets.push();\n\n    const InputWindowInfo* windowInfo = windowHandle->getInfo();\n    InputTarget& target = inputTargets.editTop();\n    target.inputChannel = windowInfo->inputChannel;\n    target.flags = targetFlags;\n    target.xOffset = - windowInfo->frameLeft;\n    target.yOffset = - windowInfo->frameTop;\n    target.scaleFactor = windowInfo->scaleFactor;\n    target.pointerIds = pointerIds;\n}\n```\n\n我们来看看它是怎么被赋值的,当焦点窗口改变的时候WindowManagerService.mInputMonitor的setInputFocusL和updateInputWindowsLw会被调用,我们从这里开始追踪:\n\n```\n// frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java\n@Override\npublic int addWindow(Session session, IWindow client, int seq,\n            WindowManager.LayoutParams attrs, int viewVisibility, int displayId,\n            Rect outContentInsets, Rect outStableInsets, Rect outOutsets,\n            InputChannel outInputChannel) {\n\t...\n\tif (focusChanged) {\n        mInputMonitor.setInputFocusLw(mCurrentFocus, false /*updateInputWindows*/);\n    }\n    mInputMonitor.updateInputWindowsLw(false /*force*/);\n\t...\n}\n\n// frameworks/base/services/core/java/com/android/server/wm/InputMonitor.java\nvoid updateInputWindowsLw(boolean force) {\n\t...\n    mUpdateInputForAllWindowsConsumer.updateInputWindows(inDrag);\n\t...\n}\n\n// frameworks/base/services/core/java/com/android/server/wm/InputMonitor.java\nprivate void updateInputWindows(boolean inDrag) {\n\t...\n\tmService.mInputManager.setInputWindows(mInputWindowHandles, mFocusedInputWindowHandle);\n\t...\n}\n\n// frameworks/base/services/core/java/com/android/server/input/InputManagerService.java\npublic void setInputWindows(InputWindowHandle[] windowHandles,\n        InputWindowHandle focusedWindowHandle) {\n    ...\n    nativeSetInputWindows(mPtr, windowHandles);\n}\n\n// frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp\nstatic void nativeSetInputWindows(JNIEnv* env, jclass /* clazz */,\n        jlong ptr, jobjectArray windowHandleObjArray) {\n    NativeInputManager* im = reinterpret_cast<NativeInputManager*>(ptr);\n\n    im->setInputWindows(env, windowHandleObjArray);\n}\n\n// frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp\nvoid NativeInputManager::setInputWindows(JNIEnv* env, jobjectArray windowHandleObjArray) {\n    ...\n    mInputManager->getDispatcher()->setInputWindows(windowHandles);\n    ...\n}\n\n// frameworks/native/services/inputflinger/InputDispatcher.cpp\nvoid InputDispatcher::setInputWindows(const Vector<sp<InputWindowHandle> >& inputWindowHandles) {\n\t...\n    mWindowHandles = inputWindowHandles;\n\n    sp<InputWindowHandle> newFocusedWindowHandle;\n    ...\n    for (size_t i = 0; i < mWindowHandles.size(); i++) {\n        const sp<InputWindowHandle>& windowHandle = mWindowHandles.itemAt(i);\n        ...\n        if (windowHandle->getInfo()->hasFocus) {\n            newFocusedWindowHandle = windowHandle;\n        }\n        ...\n        mFocusedWindowHandle = newFocusedWindowHandle;\n    }\n    ...\n}\n```\n\n这个流程主要是更新窗口的焦点状态,然后最终调用setInputWindows,更新mWindowHandles和mFocusedWindowHandle,他们一个代表所有window的handler一个代码焦点window的handler。\n\n时序图如下:\n\n{% img /AndroidInput系统二/3.png %}\n\n# 事件分发\n\n于是我们就到了最后的具体的事件分发流程里面,大家下看看代码:\n\n```\nvoid InputDispatcher::dispatchEventLocked(nsecs_t currentTime,\n        EventEntry* eventEntry, const Vector<InputTarget>& inputTargets) {\n    ...\n    for (size_t i = 0; i < inputTargets.size(); i++) {\n        const InputTarget& inputTarget = inputTargets.itemAt(i);\n\n        ssize_t connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel);\n        if (connectionIndex >= 0) {\n            sp<Connection> connection = mConnectionsByFd.valueAt(connectionIndex);\n            prepareDispatchCycleLocked(currentTime, connection, eventEntry, &inputTarget);\n        }\n        ...\n    }\n}\n\nvoid InputDispatcher::prepareDispatchCycleLocked(nsecs_t currentTime,\n        const sp<Connection>& connection, EventEntry* eventEntry, const InputTarget* inputTarget) {\n    ...\n    enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget);\n}\n\nvoid InputDispatcher::enqueueDispatchEntriesLocked(nsecs_t currentTime,\n        const sp<Connection>& connection, EventEntry* eventEntry, const InputTarget* inputTarget) {\n    bool wasEmpty = connection->outboundQueue.isEmpty();\n    ...\n    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,\n            InputTarget::FLAG_DISPATCH_AS_IS);\n    ...\n    if (wasEmpty && !connection->outboundQueue.isEmpty()) {\n        startDispatchCycleLocked(currentTime, connection);\n    }\n}\n\nvoid InputDispatcher::enqueueDispatchEntryLocked(\n        const sp<Connection>& connection, EventEntry* eventEntry, const InputTarget* inputTarget,\n        int32_t dispatchMode) {\n    ...\n    inputTargetFlags = (inputTargetFlags & ~InputTarget::FLAG_DISPATCH_MASK) | dispatchMode;\n\n    DispatchEntry* dispatchEntry = new DispatchEntry(eventEntry,\n            inputTargetFlags, inputTarget->xOffset, inputTarget->yOffset,\n            inputTarget->scaleFactor);\n\n    switch (eventEntry->type) {\n        case EventEntry::TYPE_KEY: {\n            KeyEntry* keyEntry = static_cast<KeyEntry*>(eventEntry);\n            dispatchEntry->resolvedAction = keyEntry->action;\n            dispatchEntry->resolvedFlags = keyEntry->flags;\n            ...\n            break;\n        }\n        ...\n    }\n    ...\n    connection->outboundQueue.enqueueAtTail(dispatchEntry);\n    ...\n}\n\nvoid InputDispatcher::startDispatchCycleLocked(nsecs_t currentTime,\n        const sp<Connection>& connection) {\n    ...\n    while (connection->status == Connection::STATUS_NORMAL\n            && !connection->outboundQueue.isEmpty()) {\n        DispatchEntry* dispatchEntry = connection->outboundQueue.head;\n        dispatchEntry->deliveryTime = currentTime;\n        ...\n        EventEntry* eventEntry = dispatchEntry->eventEntry;\n        switch (eventEntry->type) {\n            case EventEntry::TYPE_KEY: {\n                KeyEntry* keyEntry = static_cast<KeyEntry*>(eventEntry);\n\n                // Publish the key event.\n                status = connection->inputPublisher.publishKeyEvent(dispatchEntry->seq,\n                        keyEntry->deviceId, keyEntry->source,\n                        dispatchEntry->resolvedAction, dispatchEntry->resolvedFlags,\n                        keyEntry->keyCode, keyEntry->scanCode,\n                        keyEntry->metaState, keyEntry->repeatCount, keyEntry->downTime,\n                        keyEntry->eventTime);\n                break;\n            }\n            ...\n        }\n        ...\n        connection->outboundQueue.dequeue(dispatchEntry);\n        ...\n        connection->waitQueue.enqueueAtTail(dispatchEntry);\n        ...\n    }\n}\n```\n\n上面的代码简单来说就是:\n\n1. 遍历inputTargets拿到对应的connection\n2. 在enqueueDispatchEntryLocked里面将事件放到connection->outboundQueue里面\n3. 在startDispatchCycleLocked里面用connection->inputPublisher.publishKeyEvent去将消息通过socket传到应用层\n4. 从connection->outboundQueue里面移出事件放到connection->waitQueue里面等待事件完成。\n\n然后就是等待事件完成了,由于上层的事件分发机制大家都比较熟悉了我这里就不讲了。\n\n我们回过头来看InputDispatcher::registerInputChannel,里面注册了handleReceiveCallback回调:\n\n```\nstatus_t InputDispatcher::registerInputChannel(const sp<InputChannel>& inputChannel,\n        const sp<InputWindowHandle>& inputWindowHandle, bool monitor) {\n        ...\n        mLooper->addFd(fd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, this);\n        ...\n}\n```\n\n当上层完成了事件的处理之后就会发送消息调用handleReceiveCallback:\n\n```\nint InputDispatcher::handleReceiveCallback(int fd, int events, void* data) {\n    InputDispatcher* d = static_cast<InputDispatcher*>(data);\n    ...\n    d->finishDispatchCycleLocked(currentTime, connection, seq, handled);\n    ...\n    d->runCommandsLockedInterruptible();\n    ...\n}\n```\n\n这里会先调用InputDispatcher::finishDispatchCycleLocked去往mCommandQueue里面加入一个执行InputDispatcher:: doDispatchCycleFinishedLockedInterruptible的Command:\n\n```\nvoid InputDispatcher::finishDispatchCycleLocked(nsecs_t currentTime,\n        const sp<Connection>& connection, uint32_t seq, bool handled) {\n    ...\n    onDispatchCycleFinishedLocked(currentTime, connection, seq, handled);\n}\n\nvoid InputDispatcher::onDispatchCycleFinishedLocked(\n        nsecs_t currentTime, const sp<Connection>& connection, uint32_t seq, bool handled) {\n    CommandEntry* commandEntry = postCommandLocked(\n            & InputDispatcher::doDispatchCycleFinishedLockedInterruptible);\n    commandEntry->connection = connection;\n    commandEntry->eventTime = currentTime;\n    commandEntry->seq = seq;\n    commandEntry->handled = handled;\n}\n\nInputDispatcher::CommandEntry* InputDispatcher::postCommandLocked(Command command) {\n    CommandEntry* commandEntry = new CommandEntry(command);\n    mCommandQueue.enqueueAtTail(commandEntry);\n    return commandEntry;\n}\n```\n\n然后InputDispatcher::runCommandsLockedInterruptible会执行这个Command:\n\n```\nbool InputDispatcher::runCommandsLockedInterruptible() {\n    if (mCommandQueue.isEmpty()) {\n        return false;\n    }\n\n    do {\n        CommandEntry* commandEntry = mCommandQueue.dequeueAtHead();\n\n        Command command = commandEntry->command;\n        (this->*command)(commandEntry);\n\n        commandEntry->connection.clear();\n        delete commandEntry;\n    } while (! mCommandQueue.isEmpty());\n    return true;\n}\n```\n\n也就是说InputDispatcher:: doDispatchCycleFinishedLockedInterruptible会被调用,然后在里面会将消息移出connection->waitQueue:\n\n```\nvoid InputDispatcher::doDispatchCycleFinishedLockedInterruptible(\n        CommandEntry* commandEntry) {\n    sp<Connection> connection = commandEntry->connection;\n    ...\n    DispatchEntry* dispatchEntry = connection->findWaitQueueEntry(seq);\n    ...\n    if (dispatchEntry == connection->findWaitQueueEntry(seq)) {\n        connection->waitQueue.dequeue(dispatchEntry);\n        ...\n    }\n}\n```\n\n到这里整个消息的分发流程就完成了。\n","tags":["技术相关","Android"]},{"title":"Android Input系统(一) 事件的获取流程","url":"/2020/01/23/Android-Input系统-一-事件的获取流程/","content":"\n应用层的事件分发流程看得多了,但是对事件是怎么从底层获取分发的一直不是很了解,刚好临近春节这几天没那么忙,看了下源码([android-8.0.0_r1](https://cs.android.com/android/platform/superproject/+/android-8.0.0_r1:))和一些博客,这里给大家分享下。\n\n# 启动与初始化\n\n首先framework层的设备事件获取和分发都是在InputManagerService里面进行的,它在SystemServer里面启动:\n\n```\n// frameworks/base/services/java/com/android/server/SystemServer.java\npublic final class SystemServer {\n\t...\n\n    public static void main(String[] args) {\n        new SystemServer().run();\n    }\n    ...\n    private void run() {\n    \t...\n    \tstartOtherServices();\n    \t...\n    }\n    ...\n\n    private void startOtherServices() {\n    \tinputManager = new InputManagerService(context);\n    \t...\n\t\tinputManager.start();\n    }\n    ...\n}\n```\n\nInputManagerService在构造函数里面会调用nativeInit,初始化native层相关环境,得到一个指针mPtr,这个指针其实是c++里面new出来的对象,所以在start的时候调用nativeStart将这个mPtr传回进去就能启动native层的相关逻辑\n\n```\n// frameworks/base/services/core/java/com/android/server/input/InputManagerService.java\npublic InputManagerService(Context context) {\n\t...\n\tmPtr = nativeInit(this, mContext, mHandler.getLooper().getQueue());\n\t...\n}\n...\npublic void start() {\n\tnativeStart(mPtr);\n\t...\n}\n```\n\n我们接着来来看看natvie层,nativeInit的时候其实是new了一个NativeInputManager出来并且返回.这个NativeInputManager属于JNI层,作用是联通framework层的InputManagerService和native层的InputManager。所以上面的mPtr其实就是NativeInputManager的指针,而且NativeInputManager的构造函数里面又会创建InputManager,我们这次要看的事件获取和分发就主要在它内部实现:\n\n```\n// frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp\nstatic jlong nativeInit(JNIEnv* env, jclass /* clazz */,\n        jobject serviceObj, jobject contextObj, jobject messageQueueObj) {\n    ...\n    NativeInputManager* im = new NativeInputManager(contextObj, serviceObj,\n            messageQueue->getLooper());\n    im->incStrong(0);\n    return reinterpret_cast<jlong>(im);\n}\n...\nNativeInputManager::NativeInputManager(jobject contextObj,\n        jobject serviceObj, const sp<Looper>& looper) :\n        mLooper(looper), mInteractive(true) {\n\t...\n\n    sp<EventHub> eventHub = new EventHub();\n    mInputManager = new InputManager(eventHub, this, this);\n}\n```\n\n在nativeStart的时候就会将这个InputManager启动:\n\n```\n// frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp\nstatic void nativeStart(JNIEnv* env, jclass /* clazz */, jlong ptr) {\n\tNativeInputManager* im = reinterpret_cast<NativeInputManager*>(ptr);\n\n\tstatus_t result = im->getInputManager()->start();\n\t...\n}\n```\n\nInputManager里面会启动两条线程，分别用于事件的读取和分发:\n\n```\n// frameworks/native/services/inputflinger/InputManager.cpp\nInputManager::InputManager(\n        const sp<EventHubInterface>& eventHub,\n        const sp<InputReaderPolicyInterface>& readerPolicy,\n        const sp<InputDispatcherPolicyInterface>& dispatcherPolicy) {\n    mDispatcher = new InputDispatcher(dispatcherPolicy);\n    mReader = new InputReader(eventHub, readerPolicy, mDispatcher);\n    initialize();\n}\n\nvoid InputManager::initialize() {\n    mReaderThread = new InputReaderThread(mReader);\n    mDispatcherThread = new InputDispatcherThread(mDispatcher);\n}\n\nstatus_t InputManager::start() {\n    status_t result = mDispatcherThread->run(\"InputDispatcher\", PRIORITY_URGENT_DISPLAY);\n    ...\n\n    result = mReaderThread->run(\"InputReader\", PRIORITY_URGENT_DISPLAY);\n    ...\n\n    return OK;\n}\n```\n\n通过上面的启动流程,我们可以整理出相关模块的层次关系如下:\n\n{% img /AndroidInput系统一/1.png %}\n\n启动的时序图如下:\n\n{% img /AndroidInput系统一/2.png %}\n\n今天这篇文章主要讲的就是Native层的事件获取流程,几个相关模块的功能如下:\n\n- EventHub : 从底层设备驱动读取事件消息\n- InputReader : 从EventHub读取事件消息发送给InputDispatcher\n- InputDispatcher : 接收来自的InputReader的实现消息并分发到应用层\n\n# 事件读取\n\n## Thread\n\n到了这里其实整个启动就完成了,在继续讲InputManager是怎么读取事件之前我觉得有必要先看看Thread是怎么工作的。\n\nThread::run方法会调用createThreadEtc,这个方法的第一个参数是一个函数指针。\ncreateThreadEtc会去启动一个线程去调用这个传进去的函数。\n\n这里我们看到传进去的是\\_threadLoop方法,所以\\_threadLoop方法会在子线程中执行:\n\n\n```\n// system/core/libutils/Threads.cpp\nstatus_t Thread::run(const char* name, int32_t priority, size_t stack)\n{\n\t...\n\tres = createThreadEtc(_threadLoop,\n                this, name, priority, stack, &mThread);\n\t...\n}\n```\n\n\\_threadLoop是Thread的一个静态成员函数,它传入的参数是createThreadEtc的第二个参数,即Thread的this指针,所以可以在这里把它转回Thread*,之后就在一个while循环里面不断的执行Thread::threadLoop方法:\n\n```\n\n// system/core/libutils/Threads.cpp\nint Thread::_threadLoop(void* user)\n{\n\tThread* const self = static_cast<Thread*>(user);\n\n\tsp<Thread> strong(self->mHoldSelf);\n\t...\n\n\tdo {\n\t\t...\n\t\tresult = self->threadLoop();\n\t\t...\n\t\tif (result == false || self->mExitPending) {\n\t\t\t...\n\t\t\tbreak;\n\t\t}\n\t\t...\n\t} while(strong != 0);\n\n\treturn 0;\n}\n```\n\n而threadLoop是一个纯虚函数,就相当于java里面的抽象方法,由子类去实现\n\n```\n// system/core/libutils/include/utils/Thread.h\nclass Thread : virtual public RefBase\n{\n\t..\n\tvirtual bool        threadLoop() = 0;\n\t...\n}\n```\n\n## InputDispatcherThread\n\nok,我们来看看InputDispatcherThread是怎么实现它的:\n\n```\n// frameworks/native/services/inputflinger/InputDispatcher.cpp\nbool InputDispatcherThread::threadLoop() {\n    mDispatcher->dispatchOnce();\n    return true;\n}\n\nvoid InputDispatcher::dispatchOnce() {\n    nsecs_t nextWakeupTime = LONG_LONG_MAX;\n    ...\n    if (!haveCommandsLocked()) {\n        dispatchOnceInnerLocked(&nextWakeupTime);\n    }\n\n    ...\n    if (runCommandsLockedInterruptible()) {\n        nextWakeupTime = LONG_LONG_MIN;\n    }\n    ...\n    nsecs_t currentTime = now();\n    int timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);\n    mLooper->pollOnce(timeoutMillis);\n}\n```\n\ndispatchOnce去执行消息分发或者运行命令,但是因为一开始并没有读到任何的消息或者命令,所以第一次dispatchOnce并没有做什么实际的工作,于是最后跑到了mLooper::pollOnce,这个方法里面会阻塞住,等待其他线程唤醒mLooper(这块的知识以前有写过一篇[深入native层死抠Handler](http://blog.islinjw.cn/2019/11/05/%E6%B7%B1%E5%85%A5native%E5%B1%82%E6%AD%BB%E6%8A%A0Handler/),感兴趣的同学可以去看看)\n\n也就是说现在InputDispatcher已经阻塞在那里等待消息的到来，再去进行分发了。而这个消息是哪里来的呢?\n\n\n## InputReaderThread\n\n答案就是之前创建的另外一个线程InputReaderThread:\n\n```\n// frameworks/native/services/inputflinger/InputReader.cpp\nbool InputReaderThread::threadLoop() {\n    mReader->loopOnce();\n    return true;\n}\n\n\nvoid InputReader::loopOnce() {\n    ...\n    size_t count = mEventHub->getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);\n    ...\n\n    if (count) {\n        processEventsLocked(mEventBuffer, count);\n    }\n    ...\n    mQueuedListener->flush();\n}\n\nvoid InputReader::processEventsLocked(const RawEvent* rawEvents, size_t count) {\n    for (const RawEvent* rawEvent = rawEvents; count;) {\n        ...\n        int32_t deviceId = rawEvent->deviceId;\n        processEventsForDeviceLocked(deviceId, rawEvent, batchSize);\n        ...\n        count -= batchSize;\n        rawEvent += batchSize;\n    }\n}\n\nvoid InputReader::processEventsForDeviceLocked(int32_t deviceId,\n        const RawEvent* rawEvents, size_t count) {\n    ssize_t deviceIndex = mDevices.indexOfKey(deviceId);\n    InputDevice* device = mDevices.valueAt(deviceIndex);\n    device->process(rawEvents, count);\n}\n```\n\n在threadLoop里面会去通过mEventHub向底层驱动读取事件,然后找到事件对应的InputDevice去处理,InputDevice是在addDeviceLocked里面添加的:\n\n```\n// frameworks/native/services/inputflinger/InputReader.cpp\nvoid InputReader::addDeviceLocked(nsecs_t when, int32_t deviceId) {\n\t...\n\tInputDevice* device = createDeviceLocked(deviceId, controllerNumber, identifier, classes);\n\t...\n\tmDevices.add(deviceId, device);\n}\n\nInputDevice* InputReader::createDeviceLocked(int32_t deviceId, int32_t controllerNumber,\n        const InputDeviceIdentifier& identifier, uint32_t classes) {\n    InputDevice* device = new InputDevice(&mContext, deviceId, bumpGenerationLocked(),\n            controllerNumber, identifier, classes);\n    ...\n\n    if (keyboardSource != 0) {\n        device->addMapper(new KeyboardInputMapper(device, keyboardSource, keyboardType));\n    }\n    ...\n\n    return device;\n}\n```\n\ncreateDeviceLocked里面会根据设备的类型给InputDevice添加Mapper,例如键盘设备会添加KeyboardInputMapper。\n\n知道了InputDevice是啥,我们再来以键盘设备为例看看它的process方法里面干了什么:\n\n```\n// frameworks/native/services/inputflinger/InputReader.cpp\nvoid InputDevice::process(const RawEvent* rawEvents, size_t count) {\n    size_t numMappers = mMappers.size();\n    for (const RawEvent* rawEvent = rawEvents; count--; rawEvent++) {\n        ...\n        for (size_t i = 0; i < numMappers; i++) {\n            InputMapper* mapper = mMappers[i];\n            mapper->process(rawEvent);\n        }\n        ...\n    }\n}\n\n\nvoid KeyboardInputMapper::process(const RawEvent* rawEvent) {\n    switch (rawEvent->type) {\n    case EV_KEY: {\n        ...\n        processKey(rawEvent->when, rawEvent->value != 0, scanCode, usageCode);\n        ...\n        break;\n    }\n    ...\n    }\n}\n\nvoid KeyboardInputMapper::processKey(nsecs_t when, bool down, int32_t scanCode,\n        int32_t usageCode) {\n    ...\n    keyCode = rotateKeyCode(keyCode, mOrientation);\n    ...\n    nsecs_t downTime = mDownTime;\n    ...\n    NotifyKeyArgs args(when, getDeviceId(), mSource, policyFlags,\n            down ? AKEY_EVENT_ACTION_DOWN : AKEY_EVENT_ACTION_UP,\n            AKEY_EVENT_FLAG_FROM_SYSTEM, keyCode, scanCode, keyMetaState, downTime);\n    getListener()->notifyKey(&args);\n}\n\n```\n\n我们看到它最终调用了KeyboardInputMapper的processKey函数,封装了一个按键事件的NotifyKeyArgs发送给一个Listener,那这个Listener是啥呢:\n\n\n```\n// frameworks/native/services/inputflinger/InputReader.h\nclass InputMapper {\n\t...\n\tinline InputListenerInterface* getListener() { return mContext->getListener(); }\n\t...\n\tInputReaderContext* mContext;\n\t...\n}\n\n...\nclass InputReader : public InputReaderInterface {\n\t...\n\tclass ContextImpl : public InputReaderContext {\n\t\tInputReader* mReader;\n\t\t...\n\t}\n\t...\n}\n\n\n// frameworks/native/services/inputflinger/InputReader.cpp\nInputListenerInterface* InputReader::ContextImpl::getListener() {\n    return mReader->mQueuedListener.get();\n}\n```\n\n它最后get出来其实是InputReader的mQueuedListener,而这里的notifyKey方法也没有立马就将NotifyKeyArgs发送出去,它只是先保存到了一个队列里面:\n\n```\n// frameworks/native/services/inputflinger/InputListener.cpp\nvoid QueuedInputListener::notifyKey(const NotifyKeyArgs* args) {\n    mArgsQueue.push(new NotifyKeyArgs(*args));\n}\n\n```\n\n然后有认真听讲的同学可能会记得上面InputReader::loopOnce里面最后其实是有调用它的flush方法的:\n\n```\n// frameworks/native/services/inputflinger/InputReader.cpp\nvoid InputReader::loopOnce() {\n    ...\n    size_t count = mEventHub->getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);\n    ...\n\n    if (count) {\n        processEventsLocked(mEventBuffer, count);\n    }\n    ...\n    mQueuedListener->flush();\n}\n```\n\n这个flush方法里面才是真正的发送消息给mInnerListener:\n\n```\n// frameworks/native/services/inputflinger/InputListener.cpp\nvoid QueuedInputListener::flush() {\n    size_t count = mArgsQueue.size();\n    for (size_t i = 0; i < count; i++) {\n        NotifyArgs* args = mArgsQueue[i];\n        args->notify(mInnerListener);\n        delete args;\n    }\n    mArgsQueue.clear();\n}\n\nvoid NotifyKeyArgs::notify(const sp<InputListenerInterface>& listener) const {\n    listener->notifyKey(this);\n}\n```\n\n这个mInnerListener又是哪里来的呢:\n\n```\n// frameworks/native/services/inputflinger/InputListener.cpp\nQueuedInputListener::QueuedInputListener(const sp<InputListenerInterface>& innerListener) :\n        mInnerListener(innerListener) {\n}\n\n// frameworks/native/services/inputflinger/InputReader.cpp\nInputReader::InputReader(const sp<EventHubInterface>& eventHub,\n        const sp<InputReaderPolicyInterface>& policy,\n        const sp<InputListenerInterface>& listener) :\n        mContext(this), mEventHub(eventHub), mPolicy(policy),\n        mGlobalMetaState(0), mGeneration(1),\n        mDisableVirtualKeysTimeout(LLONG_MIN), mNextTimeout(LLONG_MAX),\n        mConfigurationChangesToRefresh(0) {\n    mQueuedListener = new QueuedInputListener(listener);\n    ...\n}\n\n// frameworks/native/services/inputflinger/InputManager.cpp\nInputManager::InputManager(\n        const sp<EventHubInterface>& eventHub,\n        const sp<InputReaderPolicyInterface>& readerPolicy,\n        const sp<InputDispatcherPolicyInterface>& dispatcherPolicy) {\n    mDispatcher = new InputDispatcher(dispatcherPolicy);\n    mReader = new InputReader(eventHub, readerPolicy, mDispatcher);\n    ...\n}\n```\n\nmInnerListener其实是InputDispatcher,在InputDispatcher::notifyKey里面会将NotifyKeyArgs封装成KeyEntry丢到mInboundQueue.isEmpty中,然后唤醒InputDispatcher::dispatchOnce里面阻塞住的mLooper:\n\n```\n// frameworks/native/services/inputflinger/InputDispatcher.cpp\nvoid InputDispatcher::notifyKey(const NotifyKeyArgs* args) {\n    ...\n    int32_t repeatCount = 0;\n    KeyEntry* newEntry = new KeyEntry(args->eventTime,\n            args->deviceId, args->source, policyFlags,\n            args->action, flags, keyCode, args->scanCode,\n            metaState, repeatCount, args->downTime);\n\n    needWake = enqueueInboundEventLocked(newEntry);\n    ...\n\n    if (needWake) {\n        mLooper->wake();\n    }\n}\n\nbool InputDispatcher::enqueueInboundEventLocked(EventEntry* entry) {\n    bool needWake = mInboundQueue.isEmpty();\n    mInboundQueue.enqueueAtTail(entry);\n    ...\n    return needWake;\n}\n```\n\n于是dispatchOnce继续执行重新被子线程调用,接下来就是从mInboundQueue里面拿出消息去分发了。分发这一块的逻辑也比较复杂我们放到下一篇继续讲。\n\n事件读取的时序图如下:\n\n{% img /AndroidInput系统一/3.png %}\n\n# EventHub\n\n上面讲的事件获取流程大概是这样的,loopOnce不断被死循环调用通过mEventHub获取事件放到mQueuedListener,里面,然后再通过mQueuedListener::flush,方法唤醒InputDispatcher去分发事件:\n\n\n```\n// frameworks/native/services/inputflinger/InputReader.cpp\nvoid InputReader::loopOnce() {\n    ...\n    size_t count = mEventHub->getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);\n    ...\n\n    if (count) {\n        processEventsLocked(mEventBuffer, count);\n    }\n    ...\n    mQueuedListener->flush();\n}\n```\n\n但是这样是不是意味着InputReader是通过轮询去获取设备驱动的事件的?效率会不会很低?\n\n其实不是的,EventHub::getEvents在设备没有接收到事件的时候也是阻塞的:\n\n```\n// frameworks/native/services/inputflinger/EventHub.cpp\nsize_t EventHub::getEvents(int timeoutMillis, RawEvent* buffer, size_t bufferSize) {\n    ...\n    int pollResult = epoll_wait(mEpollFd, mPendingEventItems, EPOLL_MAX_EVENTS, timeoutMillis);\n    ...\n}\n```\n\nepoll\\_wait是liunx的多路复用IO接口,这里会阻塞等待mEpollFd这个设备的接收到消息.\n\n# 总结\n\n所以现在整个事件的获取流程就清晰了:\n\n1. SystemServer启动InputManagerService\n2. InputManagerService启动NativeInputManager\n3. NativeInputManager启动InputManager\n4. InputManager启动InputReaderThread和InputDispatcherThread\n5. InputReaderThread调用InputReader从EventHub读取设备事件唤醒InputDispatcherThread\n6. InputDispatcherThread拿到实际进行分发\n\nPS:本文参考了[Stan_Z](https://www.jianshu.com/u/7f26e9b13731)的[Android Input系列文章](https://www.jianshu.com/p/5a879b7ad3b2),我也推荐大家去看看,这里面还讲了很多其他的细节\n","tags":["技术相关","Android"]},{"title":"深入native层死抠Handler","url":"/2019/11/05/深入native层死抠Handler/","content":"\nHandler算是面试里面最大几率被问到的问题了,很多同学也能回答上来一些东西,像什么Looper、MessagerQueue啊([看这里](http://blog.islinjw.cn/2017/07/02/Android%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0-Handler/)),但是如果想知道一个人是否有专研精神的话,其实handler可以一直往下问。例如postDelayed是怎么实现的?([看这里](http://blog.islinjw.cn/2019/03/02/Handler-postDelayed%E7%9A%84%E5%8E%9F%E7%90%86/))\n\n问到了这里其实对于绝大多数面试其实已经够了,但是如果你面的公司比较看重基础或者面试官想看看你是否有专研精神,他可能会继续问MessageQueue.nativePollOnce\n\n- 如何做到等待一段时间?\n- 在有消息到来的时候是如何被唤醒的?\n\n这部分其实已经到了native层的知识了,但是作为一个高级安卓工程师,这部分的知识其实多了解一点也是好的。\n\nMessageQueue.nativePollOnce的c层实现在/frameworks/base/core/jni/android\\_os\\_MessageQueue.cpp,我们从这里开始往下挖:\n\n\n```\n//  /frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,\n        jlong ptr, jint timeoutMillis) {\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr);\n    nativeMessageQueue->pollOnce(env, obj, timeoutMillis);\n}\n\n...\n\n//  /frameworks/base/core/jni/android_os_MessageQueue.cpp\nvoid NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) {\n    mPollEnv = env;\n    mPollObj = pollObj;\n    mLooper->pollOnce(timeoutMillis);\n    mPollObj = NULL;\n    mPollEnv = NULL;\n\n    if (mExceptionObj) {\n        env->Throw(mExceptionObj);\n        env->DeleteLocalRef(mExceptionObj);\n        mExceptionObj = NULL;\n    }\n}\n\n...\n\n//  /system/core/libutils/Looper.cpp\nint Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {\n    ...\n    result = pollInner(timeoutMillis);\n    ...\n}\n\n//  /system/core/libutils/Looper.cpp\nint Looper::pollInner(int timeoutMillis) {\n\t...\n\tint eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);\n\t...\n}\n```\n\n中间我省略了很多代码,感兴趣的可以自行查看,这里最重要的是最后它使用了一个叫做epoll\\_wait的方法。如果有做过Linux下的c/c++开发的话可能会对它比较熟悉。它是epoll模型的方法,是Linux提供的一种IO多路复用的机制。一般情况下会和其他两种模型select和poll进行比较。\n\n# io多路复用\n\nio多路复用可能做过服务器的同学会比较熟悉,在java里面提供的NIO模型也是干这活的。\n\n我来稍微解释一下什么叫做io多路复用。我们普通的io流都是阻塞的,当io流里面数据还没有准备好的时候就会阻塞在那。所以当需要处理多个io例如服务器与多个客户端连接的时候,如果用普通的io那就只能有多少个客户端连接就创建多少个线程:\n\n{% img /深入native层死抠Handler/1.png %}\n\n这样的架构有几个问题:\n\n- 服务器数量是有限的\n- 可能有很多的连接一直处于空闲状态\n\n而io多路复用则只需要一条线程去检测多个io流,如果所有io流都没有消息的时候就会阻塞,当任意一条或者多条io流有消息的时候,就会返回:\n\n{% img /深入native层死抠Handler/2.png %}\n\n例如多人聊天室就是一种非常适合io多路复用的例子,可能会同时有很多个用户登录,但是不会同时在同一个时刻发言。如果用普通io模型,则需要开很多的线程,大部分线程是空闲的,而且在处理多个客户的消息的时候需要切换线程,对系统来讲也是比较重的。而使用io多路复用则可以重复使用一条线程,减少线程空闲和切换的情况。\n\n当然大多数情况下，io多路复用和多线程也是配合起来使用的,这样也能重复发挥主机的多核性能。\n\n# Handler是如何使用epoll模型的\n\n前面讲到的是io多路复用的概念，但是看起来和我们的handler好像没有什么关系是吗？毕竟handler看起来并不需要使用到io流。\n\n但是io流的一些特性让它经常被用在各种消息框架中。\n\n例如,当没有io流没有数据的时候epoll\\_wait会阻塞,而当消息到来的时候它会返回。这个特性可以用来实现MessageQueue的阻塞等待消息。\n\n又例如epoll\\_wait的最后一个参数可以设置超时,等待一段确定的时间时候就算io流中没有消息也会返回。这个特性可以用来实现postDelay。\n\n那io流的意思是不是说handler底层是通过读写文件实现的呢？性能会不会很低？\n\nLinux早就对这个场景有所考量。所以这里epoll\\_wait监听的不是普通的文件读写,而是专门为事件通知优化过的文件描述符,它实际上并没有做文件的读写:\n\n```\nmWakeEventFd = eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);\n```\n\n它使用起来和一般的文件很像,有三个主要方法:\n\n- write 往描述符中写入一个n，内部的计算器会+n\n- read 从描述符中读取一个整数,如果内部计数器为0则会阻塞，如果不为0则分两种情况，1是创建的时候设置了EFD\\_SEMAPHORE,就会返回1,且计数器减一，否则返回计数器的值，且计数器归零\n- close 关闭描述符\n\n所以当有消息到来的时候我们会最终调到write方法往描述符里+1:\n\n```\n//  Handler.java\npublic boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n    MessageQueue queue = mQueue;\n    ...\n    return enqueueMessage(queue, msg, uptimeMillis);\n}\n\nprivate boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n    msg.target = this;\n    ...\n    return queue.enqueueMessage(msg, uptimeMillis);\n}\n\n//  MessageQueue.java\nboolean enqueueMessage(Message msg, long when) {\n  ...\n  if (needWake) {\n      nativeWake(mPtr);\n  }\n}\n\n//  /frameworks/base/core/jni/android_os_MessageQueue.cpp\nstatic void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) {\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr);\n    nativeMessageQueue->wake();\n}\n\n\n//  /frameworks/base/core/jni/android_os_MessageQueue.cpp\nvoid NativeMessageQueue::wake() {\n    mLooper->wake();\n}\n\n//  /system/core/libutils/Looper.cpp\nvoid Looper::wake() {\n    ...\n    uint64_t inc = 1;\n    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &inc, sizeof(uint64_t)));\n    ...\n}\n```\n\n写入成功之后前面看到的epoll\\_wait就会被唤醒,然后读取数据将计数器归零:\n\n\n```\n\n//  /system/core/libutils/Looper.cpp\nint Looper::pollInner(int timeoutMillis) {\n  ...\n  int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);\n  ...\n\n  for (int i = 0; i < eventCount; i++) {\n      int fd = eventItems[i].data.fd;\n      uint32_t epollEvents = eventItems[i].events;\n      if (fd == mWakeEventFd) {\n          if (epollEvents & EPOLLIN) {\n              awoken();\n          } else {\n              ALOGW(\"Ignoring unexpected epoll events 0x%x on wake event fd.\", epollEvents);\n          }\n      }\n      ...\n    }\n    ...\n}\n\nvoid Looper::awoken() {\n    ...\n    uint64_t counter;\n    TEMP_FAILURE_RETRY(read(mWakeEventFd, &counter, sizeof(uint64_t)));\n}\n```\n\n# epoll模型的使用简介\n\nepoll模型实际上有三个重要方法：\n\n## epoll\\_create\n\n创建一个epoll专用的文件描述符,它就是那个多路复用的io,可以用来监听其他多个文件描述符\n\n```\n//  /system/core/libutils/Looper.cpp\nstatic const int EPOLL_SIZE_HINT = 8;\n...\nmEpollFd = epoll_create(EPOLL_SIZE_HINT);\n```\n\n它的参数是一个整数设置它最多可以监听多少个文件描述符，而且从Linux 2.6.8开始这个参数可以省略只要传大于0的值就好，数量不需要指定上限。\n\n我们看到这里安卓设置了个8，其实它不仅可以监听默认的mWakeEventFd，我们还可以添加自己定义的描述符给它去监听\n\n## epoll\\_ctl\n\n那我们怎样添加文件描述符监听呢？就靠这个方法了：\n\n```\n//  /system/core/libutils/Looper.cpp\nint result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, & eventItem);\n```\n\n这样就能将mWakeEventFd给add进去让mEpollFd监听\n\n## epoll\\_wait\n\n这个方法其实介绍了蛮多了,它的功能就是阻塞监听add进来的描述符,只要其中任意一个或多个描述符可用或者超时时间到达就会返回。\n\n而可用的描述符会被放到第二个参数传入的数组中\n\n```\n//  /system/core/libutils/Looper.cpp\nstruct epoll_event eventItems[EPOLL_MAX_EVENTS];\nint eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);\n```\n\n# select/poll\n\n其实到了这里Handler的底层已经差不多了,但是一般select/poll/epoll三者都会被摆在一起讨论,所以我这里也简单介绍一下另外两者。\n\n它们其实都是linux提供的io多路复用模型,区别在于\n\nselect底层使用了一个固定大小的set保存监听的描述符,所以对监听的数量有限制，最多是1024个。为什么是1024呢？因为默认情况下单个进程的文件描述符的个数最多是1024，可以用下面命令查看:\n\n> ulimit -n\n\n但是由于这个set的存放原理是开辟了1024比特位的内存，然后直接将文件描述符这个整数对应的比特位置1，所以实际上它是对文件描述符的最大值有限制，也就是说就算你使用\"ulimit -HSn 2048\"命令将最大的描述符个数改成2048，也不能用两个select去监听所有的描述符。\n\npoll就算为了解决这个问题存在的,它接收一个描述符数组去监听,没有限制描述符的最大个数。\n\n但是select/和poll都有一个缺点,就是它们都需要遍历整个描述符集合或者数组才能知道哪个描述符是可用的,所以它时间实际复杂度是O(n)\n\n而epoll直接将可用的描述符放在一起告诉用户所以它的时间复杂度是O(1)，当然系统底层肯定是增加了复杂度才能让用户用起来方便的，不过不用担心，底层也是使用了红黑树这种高效的数据结构,所以epoll模型的整体时间复杂度还是比较select/poll高的。\n","tags":["技术相关","Android"]},{"title":"OpenSL ES 读取蓝牙语音遥控器音频","url":"/2019/10/23/OpenSLES读取蓝牙语音遥控器音频/","content":"\n最近协助处理一个OpenSL的问题。问题背景和描述如下:\n\n我司的安卓电视需要使用OpenSL从语音遥控器上采集音频,而语音遥控器有两种协议:2.4G和蓝牙。\n\n在2.4G遥控上功能正常,但是使用蓝牙遥控器,没有任何报错,流程也正常跑通,但是读取到的音频数据全部是空数据。\n\n其实OpenSL我之前也只是简单入门而已(笔记在[这里](http://blog.islinjw.cn/2018/09/01/OpenSLES%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/)),首先想到的是去修改它的设备类型\n\n```\npHelper->device.locatorType = SL_DATALOCATOR_IODEVICE;\npHelper->device.deviceType = SL_IODEVICE_AUDIOINPUT;\npHelper->device.deviceID = SL_DEFAULTDEVICEID_AUDIOINPUT;\n```\n\n但是查看了下locatorType、deviceType、deviceID可以选择的选项,发现并没有适合的:\n\n```\n/** Data locator */\n#define SL_DATALOCATOR_URI\t\t\t((SLuint32) 0x00000001)\n#define SL_DATALOCATOR_ADDRESS\t\t((SLuint32) 0x00000002)\n#define SL_DATALOCATOR_IODEVICE\t\t((SLuint32) 0x00000003)\n#define SL_DATALOCATOR_OUTPUTMIX\t\t((SLuint32) 0x00000004)\n#define SL_DATALOCATOR_RESERVED5\t\t((SLuint32) 0x00000005)\n#define SL_DATALOCATOR_BUFFERQUEUE\t((SLuint32) 0x00000006)\n#define SL_DATALOCATOR_MIDIBUFFERQUEUE\t((SLuint32) 0x00000007)\n#define SL_DATALOCATOR_RESERVED8\t\t((SLuint32) 0x00000008)\n\n/** IODevice-types */\n#define SL_IODEVICE_AUDIOINPUT\t((SLuint32) 0x00000001)\n#define SL_IODEVICE_LEDARRAY\t((SLuint32) 0x00000002)\n#define SL_IODEVICE_VIBRA\t\t((SLuint32) 0x00000003)\n#define SL_IODEVICE_RESERVED4\t((SLuint32) 0x00000004)\n#define SL_IODEVICE_RESERVED5\t((SLuint32) 0x00000005)\n\n/** Device ids */\n#define SL_DEFAULTDEVICEID_AUDIOINPUT \t((SLuint32) 0xFFFFFFFF)\n#define SL_DEFAULTDEVICEID_AUDIOOUTPUT \t((SLuint32) 0xFFFFFFFE)\n#define SL_DEFAULTDEVICEID_LED          ((SLuint32) 0xFFFFFFFD)\n#define SL_DEFAULTDEVICEID_VIBRA        ((SLuint32) 0xFFFFFFFC)\n#define SL_DEFAULTDEVICEID_RESERVED1    ((SLuint32) 0xFFFFFFFB)\n```\n\n其实以前在用java层的AudioRecorder的时候就遇到过获取不到蓝牙语音遥控器音频的问题,当时是通过将audioSource设置成MediaRecorder.AudioSource.CAMCORDER解决的.\n\n所以猜测OpenSL里面大概也是这样处理,在OpenSLES\\_AndroidConfiguration.h下找到类似的宏定义:\n\n```\n/**   uses the microphone audio source with the same orientation as the camera\n *     if available, the main device microphone otherwise */\n#define SL_ANDROID_RECORDING_PRESET_CAMCORDER           ((SLuint32) 0x00000002)\n```\n\n这个宏用于指定音频设备的预设值。也就是说需要改变的不是音频设备的类型,依然使用SL\\_DEFAULTDEVICEID\\_AUDIOINPUT这个设备去读取音频,只不过将它的配置改成SL\\_ANDROID\\_RECORDING\\_PRESET\\_CAMCORDER让这个AUDIOINPUT设备读取的是摄像机方向的麦克风数据。\n\n那要怎么修改这个预设值呢?\n\n从[安卓开发者文档](https://developer.android.com/ndk/guides/audio/opensl/android-extensions)找到了播放器的设置方法:\n\n```\n// CreateAudioPlayer and specify SL_IID_ANDROIDCONFIGURATION\n// in the required interface ID array. Do not realize player yet.\n// ...\nSLAndroidConfigurationItf playerConfig;\nresult = (*playerObject)->GetInterface(playerObject,\n    SL_IID_ANDROIDCONFIGURATION, &playerConfig);\nassert(SL_RESULT_SUCCESS == result);\nSLint32 streamType = SL_ANDROID_STREAM_ALARM;\nresult = (*playerConfig)->SetConfiguration(playerConfig,\n    SL_ANDROID_KEY_STREAM_TYPE, &streamType, sizeof(SLint32));\nassert(SL_RESULT_SUCCESS == result);\n// ...\n// Now realize the player here.\n```\n\n其实录音的方法也是类似的,通过SLAndroidConfigurationItf的SetConfiguration方法去配置。不过文档其实默认读者都是了解OpenSL的使用方法的了,所以还有些必要的代码其实没有展示出来。\n\n要从playerObject里面用GetInterface获取到SLAndroidConfigurationItf,必须在CreateAudioPlayer的时候就将SLAndroidConfigurationItf的id传入,这样playerObject才会有SLAndroidConfigurationItf这个接口。要不然GetInterface会获取失败。\n\n这里我就直接将录音代码展示出来了,注意看我注释的那两行:\n\n```\nSLObjectItf recorderObject;\n\nSLInterfaceID id[] = { \n        SL_IID_ANDROIDSIMPLEBUFFERQUEUE, \n        SL_IID_ANDROIDCONFIGURATION     // 需要指定AudioRecorder包含SLAndroidConfigurationItf\n};\nSLboolean required[] = {\n        SL_BOOLEAN_TRUE, \n        SL_BOOLEAN_TRUE  // 指定SL_IID_ANDROIDCONFIGURATION是必须包含的\n};\n\n(*engineInterface)->CreateAudioRecorder(\n        engineInterface,\n        &(recorderObject),\n        &(source),\n        &(sink),\n        2,\n        id,\n        required\n);\n\nSLAndroidConfigurationItf configItf;\n(*recorderObject)->GetInterface(recorderObject, SL_IID_ANDROIDCONFIGURATION, (void*)&configItf);\n\nSLuint32 presetValue = SL_ANDROID_RECORDING_PRESET_CAMCORDER;\n(*configItf)->SetConfiguration(configItf, SL_ANDROID_KEY_RECORDING_PRESET, &presetValue, sizeof(SLuint32));\n\n(*recorderObject)->Realize(recorderObject, SL_BOOLEAN_FALSE);\n```\n\n顺嘴说一句,如果我们不设置SL\\_ANDROID\\_RECORDING\\_PRESET\\_CAMCORDER,它默认是用SL\\_ANDROID\\_RECORDING\\_PRESET\\_GENERIC。\n\n\n所有的配置如下:\n\n```\n\n/**  配置中“无”不能设置，它是用来表示当前设置不匹配任何配置 */\n#define SL_ANDROID_RECORDING_PRESET_NONE                ((SLuint32) 0x00000000)\n\n/**  平台上通用的录像配置 */\n#define SL_ANDROID_RECORDING_PRESET_GENERIC             ((SLuint32) 0x00000001)\n\n/**  如果有的话使用具有相同的方向与摄像机的麦克风的音频源,否则使用过主麦克风 */\n#define SL_ANDROID_RECORDING_PRESET_CAMCORDER           ((SLuint32) 0x00000002)\n\n/**  使用为语音识别优化过的主要麦克风 */\n#define SL_ANDROID_RECORDING_PRESET_VOICE_RECOGNITION   ((SLuint32) 0x00000003)\n\n/** 使用为音频通信优化过的主要麦克风 */\n#define SL_ANDROID_RECORDING_PRESET_VOICE_COMMUNICATION ((SLuint32) 0x00000004)\n\n/** 使用未经处理的主麦克风 */\n#define SL_ANDROID_RECORDING_PRESET_UNPROCESSED         ((SLuint32) 0x00000005)\n```\n\n# 其它坑\n\n然后除了上面的SL\\_IID\\_ANDROIDCONFIGURATION之外,其实我这边还遇到了几个坑,这里也记录一下\n\n- __采样率需要和录音设备硬件一致__\n\n由于代码里面一直用16000Hz的采样率,在2.4G语音遥控器上也工作的好好的,于是适配蓝牙语音遥控之后就没有修改它,然后发现读取直接阻塞住了,读取音频数据的回调一直没有被调用(如果不设置SL\\_ANDROID\\_RECORDING\\_PRESET\\_CAMCORDER的时候虽然也拿不到音频数据,但是回调是会调用的,只不过拿到的数据都是空数据)。之后改成了和硬件一致的44100Hz之后就正常了\n\n- __SetConfiguration必须在Realize前面调用__\n\n其实这块并不是我司代码的问题,我们的项目接入了亚马逊的Alexa sdk,它对OpenSL进行了一层封装,它在创建AudioRecorder之后顺手就Realize了,但是它原本也是有提供封装好的SetConfiguration的配置的,于是我们就直接在上面改了。\n\n于是就一直没有效果。最后还是在分析log的时候发现调用SetConfiguration的时候底层输出了“Realize已经调用”的打印才找到问题所在。\n\n这里忍不住吐槽一下,亚马逊写这块的人明显对OpenSL也不是很熟悉,除了这个问题之外我们还发现了不少其他的低级问题。看来亚马逊这种大公司的代码审查也做的不怎么样嘛......","tags":["技术相关","Android","音视频"]},{"title":"安卓特效相机(四) 视频录制","url":"/2019/10/09/安卓特效相机-四-视频录制/","content":"\n系列文章:\n\n[安卓特效相机(一) Camera2的使用](http://blog.islinjw.cn/2019/08/27/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%B8%80-Camera2%E7%9A%84%E4%BD%BF%E7%94%A8/)\n[安卓特效相机(二) EGL基础](http://blog.islinjw.cn/2019/09/13/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%BA%8C-EGL%E5%9F%BA%E7%A1%80/)\n[安卓特效相机(三) OpenGL ES 特效渲染](http://blog.islinjw.cn/2019/09/22/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%B8%89-OpenGL-ES-%E7%89%B9%E6%95%88%E6%B8%B2%E6%9F%93/)\n[安卓特效相机(四) 视频录制](http://blog.islinjw.cn/2019/10/09/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E5%9B%9B-%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/)\n\n前几篇文章已经讲完了摄像头画面的捕捉和特效渲染,这篇文章我们来讲一讲最后的视频录制部分。\n\n我们这里将使用MediaRecorder去录制视频。MediaRecorder可以同时录制视频和音频。我们将音频源直接设置成摄像头,让它从摄像头里面读取音频数据:\n\n```\nmMediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);\nmMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);\nmMediaRecorder.setAudioEncodingBitRate(AUDIO_BIT_RATE);\n```\n\n但是视频源并不能直接设置成摄像头,因为摄像头捕捉到的画面是原始的视频画面,我们上上一篇文章中讲到了如何将这个原始画面绘制到纹理,然后通过特效处理现实到TextureView上:\n\n{% img /安卓特效相机四/1.png %}\n\n所以如果我们直接将MediaRecorder的视频源设置成摄像头的话录制下来的视频并没有带上特效。\n\n那要怎么做呢? MediaRecorder有一种视频源叫做MediaRecorder.VideoSource.SURFACE,意思是从Surface里面读取画面去录制。那我们是不是直接吧TextureView的SurfaceTexture创建的Surface传给MediaRecorder让它捕捉TextureView的内容就行了呢?\n\n可惜的是如果直接用MediaRecorder.setInputSurface将Surface设置进去,会抛出异常:\n\n```\n09-22 14:53:47.473   897   943 E AndroidRuntime: java.lang.IllegalArgumentException: not a PersistentSurface\n09-22 14:53:47.473   897   943 E AndroidRuntime:        at android.media.MediaRecorder.setInputSurface(MediaRecorder.java:165)\n```\n\n原因是只能设置MediaCodec.PersistentSurface类型的Surface:\n\n```\n/**\n * Configures the recorder to use a persistent surface when using SURFACE video source.\n * <p> May only be called before {@link #prepare}. If called, {@link #getSurface} should\n * not be used and will throw IllegalStateException. Frames rendered to the Surface\n * before {@link #start} will be discarded.</p>\n\n * @param surface a persistent input surface created by\n *           {@link MediaCodec#createPersistentInputSurface}\n * @throws IllegalStateException if it is called after {@link #prepare} and before\n * {@link #stop}.\n * @throws IllegalArgumentException if the surface was not created by\n *           {@link MediaCodec#createPersistentInputSurface}.\n * @see MediaCodec#createPersistentInputSurface\n * @see MediaRecorder.VideoSource\n */\npublic void setInputSurface(@NonNull Surface surface) {\n    if (!(surface instanceof MediaCodec.PersistentSurface)) {\n        throw new IllegalArgumentException(\"not a PersistentSurface\");\n    }\n    native_setInputSurface(surface);\n}\n```\n\n好吧直接滴干活不行那我们就悄悄滴干活。\n\n首先还是需要视频源设置成MediaRecorder.VideoSource.SURFACE,然后配置一堆的视频信息。这些设置项具体是什么意思讲起来比较费劲,我就不展开了,大家感兴趣的可以自行搜索:\n\n```\nmMediaRecorder.setVideoSource(MediaRecorder.VideoSource.SURFACE);\nmMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);\nmMediaRecorder.setOutputFile(mLastVideo.getPath());\nmMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.H264);\nmMediaRecorder.setVideoEncodingBitRate(VIDEO_BIT_RATE);\nmMediaRecorder.setVideoSize(mPreview.getWidth(), mPreview.getHeight());\nmMediaRecorder.setVideoFrameRate(VIDEO_FRAME_RATE);\nmMediaRecorder.setOrientationHint(0);\n```\n\n配置完之后开启录制:\n\n```\ntry {\n    mMediaRecorder.prepare();\n} catch (IOException e) {\n    Toast.makeText(this, \"failed to prepare MediaRecorder\", Toast.LENGTH_LONG)\n        .show();\n}\nmMediaRecorder.start();\n```\n\n上面的都是一些常规操作,大部分使用MediaRecorder的代码都是这样用的,下面我们来看正片:\n\n```\nreturn mGLRender.createEGLSurface(mMediaRecorder.getSurface());\n```\n\n这里拿到MediaRecorder的那个视频源Surface,给它创建了一个EGLSurface。我们在之前那篇[EGL基础](http://blog.islinjw.cn/2019/09/13/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%BA%8C-EGL%E5%9F%BA%E7%A1%80/)里面介绍过它。\n\n我们可以用EGL14.eglMakeCurrent方法指定OpenGL往哪个Surface里面绘制,所以我们直接修改代码将OpenGL的目标Suface设置成这个视频源Surface就可以了吗?\n\n恭喜你,得到了一个BUG。\n\n现在视频是可以录制了,但是预览画面黑了。为什么,回顾下这幅图:\n\n{% img /安卓特效相机四/1.png %}\n\n我们需要要将OpenGL的画面绘制到TextureView上才能在屏幕上看到特效渲染后的预览画面。\n\n那怎么办?TextureView和MediaRecorder只能二选一了吗?不,小孩子才做选择题，成年人当然是全都要。\n\n我们让OpengGL辛苦点,画两次...\n\n{% img /安卓特效相机四/2.png %}\n\n首先修改下GLRender.render方法, EGLSurface由外面传进来,这样我们就能在外面控制它往TextureView和MediaRecord绘制了:\n\n```\npublic void render(float[] matrix, EGLSurface eglSurface) {\n    makeCurrent(eglSurface);\n    GLES20.glUniformMatrix4fv(mTransformMatrixId, 1, false, matrix, 0);\n\n    GLES20.glActiveTexture(GLES20.GL_TEXTURE0);\n    GLES20.glBindTexture(GLES11Ext.GL_SAMPLER_EXTERNAL_OES, mGLTextureId);\n    GLES20.glUniform1i(mTexPreviewId, 0);\n\n    GLES20.glClear(GLES20.GL_DEPTH_BUFFER_BIT | GLES20.GL_COLOR_BUFFER_BIT);\n    GLES20.glDrawElements(GLES20.GL_TRIANGLES, ORDERS.length, GLES20.GL_UNSIGNED_SHORT, mOrder);\n    EGL14.eglSwapBuffers(mEGLDisplay, eglSurface);\n}\n```\n\n然后在绘制的时候绘制两次:\n\n```\nmCameraTexture.updateTexImage();\nmCameraTexture.getTransformMatrix(mTransformMatrix);\n\nmGLRender.render(mTransformMatrix, mGLRender.getDefaultEGLSurface());\nif (mRecordSurface != null) {\n    mGLRender.render(mTransformMatrix, mRecordSurface);\n    mGLRender.setPresentationTime(mRecordSurface, mCameraTexture.getTimestamp());\n}\n```\n\n这里需要注意的是我们需要给这一帧设置下时间戳,用于录制视频的时间同步:\n\n```\npublic void setPresentationTime(EGLSurface eglSurface, long nsecs) {\n    EGLExt.eglPresentationTimeANDROID(mEGLDisplay, eglSurface, nsecs);\n}\n```\n\n好了,这个录像的实现方法比较简单。到此整个特效相机的教程就结束了,希望对大家有用。\n\n这篇文章的demo依然在[github](https://github.com/bluesky466/CameraDemo/tree/feature_record)(注意是feature_record分支)","tags":["技术相关","Android","音视频"]},{"title":"安卓特效相机(三) OpenGL ES 特效渲染","url":"/2019/09/22/安卓特效相机-三-OpenGL-ES-特效渲染/","content":"\n系列文章:\n\n[安卓特效相机(一) Camera2的使用](http://blog.islinjw.cn/2019/08/27/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%B8%80-Camera2%E7%9A%84%E4%BD%BF%E7%94%A8/)\n[安卓特效相机(二) EGL基础](http://blog.islinjw.cn/2019/09/13/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%BA%8C-EGL%E5%9F%BA%E7%A1%80/)\n[安卓特效相机(三) OpenGL ES 特效渲染](http://blog.islinjw.cn/2019/09/22/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%B8%89-OpenGL-ES-%E7%89%B9%E6%95%88%E6%B8%B2%E6%9F%93/)\n[安卓特效相机(四) 视频录制](http://blog.islinjw.cn/2019/10/09/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E5%9B%9B-%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/)\n\n# 特效的实现原理\n\n接下来这篇文章我们讲下特效的具体实现原理。\n\n由于预览画面的渲染是将Surface传给CameraDevice由它去绘制的,而且我没有找到什么可以接管或者添加渲染效果的接口,所以并不能直接去处理摄像头的画面。\n\n于是这里我们只能用一种游戏中常用的手段去处理,这种手段的名字叫做RTT(render to texture),中文名叫做渲染到纹理。\n\n玩法是先将我们想要处理的画面,不直接绘制到屏幕,而是绘制成一张图片,然后我们再拿这张图片去做一些特殊的处理,或者特殊的用途:\n\n{% img /安卓特效相机三/5.png %}\n\n例如游戏中水面的倒影一种比较古老的实现方法就是先将岸上的画面绘制成一张图片,然后倒过来然后做一些扭曲、模糊、淡化等处理,然后贴到水面上。\n\n又例如下面这种狙击镜的实现原理就是先将摄像头位置调到远处,将远处的画面绘制到一张贴图上,然后将摄像头位置再调回角色处,把刚刚得到的远处的画面的图片直接贴到狙击镜上:\n\n{% img /安卓特效相机三/4.jpeg %}\n\n所以在这个特效相机的例子里面我们的实现原理如下:\n\n{% img /安卓特效相机三/6.png %}\n\n# OpenGL实现\n\n我们使用OpenGL ES 2.0版本,这个版本要求我们用GLSL实现顶点着色器和片元着色器。这两个着色器其实是两个运行在GPU的程序。\n\nGLSL全称是OpenGL Shading Language即OpenGL着色语言,它在语法上和C语言有点像。只是看的话相信大家都能看懂,我就不仔细介绍语法了。\n\nOpenGL可编程渲染管线的整个流程比较复杂,作为初学者我们只要理解其中的顶点着色器和和片元着色器就可以了。简单来讲就是OpenGL会在顶点着色器确定顶点的位置,然后这些顶点连起来就是我们想要的图形。接着在片元着色器里面给这些图形上色:\n\n{% img /安卓特效相机三/1.png %}\n\n我们直接看看两个着色器的代码。\n\n## 顶点着色器\n\nOpenGL会将每个顶点的坐标传递给顶点着色器,我们可以在这里改变顶点的位置。例如我们给每个顶点都加上一个偏移,就能实现整个图形的移动。\n\n在这个demo里面我们不改变顶点的坐标,只是简单的将它从二维转换成四维。现实世界里面都是三维的,那为什么要装换成四维呢?原因是我们可以用4\\*4的矩阵对坐标进行旋转、缩放、平移等变换,但是4\\*4的矩阵只能和四维向量相乘,所以需要在xyz之外加多一个维度,我们一般情况下直接把这个维度的值设成1就好。然后将计算得到的四维坐标放到gl\\_Position作为最终结果值:\n\n```\nattribute vec2 vPosition;\nattribute vec2 vCoord;\n\nvarying vec2 vPreviewCoord;\nuniform mat4 matTransform;\n\nvoid main() {\n    gl_Position = vec4(vPosition, 0, 1);\n    vPreviewCoord = (matTransform * vec4(vCoord.xy, 0, 1)).xy;\n}\n```\n\n然后除了vPosition这个顶点的坐标,大家还会看到vCoord,它是纹理坐标。什么是纹理坐标呢?\n\n纹理其实可以理解成图片,我们将图片的左下角定义成原点(0,0),左上角、右上角、右下角分别为(0,1)、(1,1)、(1,0):\n\n{% img /安卓特效相机三/2.png %}\n\n我们的每个顶点,除了携带顶点坐标之外,还携带了纹理坐标的信息,顶点坐标确定了这个图形的形状,而纹理坐标则确定贴图要怎么样贴到这个图形上。然后在片元着色器里面就可以根据这个纹理坐标去给图形贴上贴图了:\n\n{% img /安卓特效相机三/3.png %}\n\n不过看到代码可以看到,我们这里还用matTransform这个矩阵对纹理坐标进行了变换。这里是由于我们的图片不是普通的图片,而是将摄像头的画面画到另外一个surface之后拿过来的,需要进行变换。这块等下再仔细讲解。\n\n## 片元顶点着色器\n\n```\n#extension GL_OES_EGL_image_external : require\n\nprecision highp float;\n\nvarying vec2 vPreviewCoord;\n\nuniform samplerExternalOES texPreview;\nuniform mat4 uColorMatrix;\n\nvoid main() {\n    gl_FragColor = uColorMatrix * texture2D(texPreview, vPreviewCoord).rgba;\n}\n```\n\n片元着色器就比较简单了,第一行是由于我们使用了samplerExternalOES需要开启特殊配置,这个是由于在安卓上我们只能用samplerExternalOES类型的纹理去接收摄像头的画面,而使用samplerExternalOES需要开启GL\\_OES\\_EGL\\_image\\_external功能。\n\n然后这个texPreview就是我们摄像头画面绘制成的那张图片了,我们用texture2D这个方法去读取图片某个像素的颜色值,它的第一个参数就是我们的纹理,第二个参数就是我们的纹理坐标,也就是上一步顶点着色器计算的到的纹理坐标:\n\n```\nvPreviewCoord = (matTransform * vec4(vCoord.xy, 0, 1)).xy;\n```\n\n这里有同学可能会疑问我们在顶点着色器不是只计算了顶点的纹理坐标吗?那图形边上和内部的纹理坐标又是怎么来的呢?\n\n没错顶点着色器只是处理顶点的,有多少个顶点,顶点着色器就会执行多少次,处理完所有的顶点之后,我们将值传给varying类型的变量,OpenGL就会帮我们对varying变量做插值,计算出图像上每个像素对应的纹理坐标,然后每个像素都会调用片元着色器去处理。于是运行完所有像素的片元着色器之后整个图像就显示出来了:\n\n{% img /安卓特效相机三/7.png %}\n\n通过texture2D函数获得这个像素在预览画面对应的颜色值之后我们再用一个特效处理矩阵去和它相乘做特效处理。例如黑白、怀旧、反相的处理就是不同的矩阵去和这个颜色相乘,得到最终显示出来的颜色。\n\n例如一个颜色(r,g,b)反相效果其实就是(1.0\\-r, 1.0\\-b, 1.0\\-f),所以我们可以用这个矩阵去和像素颜色相乘:\n\n```\n-1.0f  0.0f  0.0f 1.0f\n 0.0f -1.0f  0.0f 1.0f\n 0.0f  0.0f -1.0f 1.0f\n 0.0f  0.0f  0.0f 1.0f\n```\n\n至于原理的话不知道大家记不记得线性代数的知识:\n\n```\n-1.0f  0.0f  0.0f 1.0f         r       -r + a\n 0.0f -1.0f  0.0f 1.0f    *    g   =   -g + a\n 0.0f  0.0f -1.0f 1.0f         b       -b + a\n 0.0f  0.0f  0.0f 1.0f         a       a\n```\n\n然后我们把alpha通道设置成1,0,就是[1.0-r, 1.0-g, 1.0-b, 1.0]就是(r,g,b,1)的反相颜色了。\n\n其他的效果类似的,我这边列出两个特效矩阵给大家用:\n\n```\n// 去色效果矩阵\n0.299f 0.587f 0.114f 0.0f\n0.299f 0.587f 0.114f 0.0f\n0.299f 0.587f 0.114f 0.0f\n0.0f   0.0f   0.0f   1.0f\n\n// 怀旧效果矩阵\n0.393f 0.769f 0.189f 0.0f\n0.349f 0.686f 0.168f 0.0f\n0.272f 0.534f 0.131f 0.0f\n0.0f   0.0f   0.0f   1.0f\n```\n\n## 创建渲染器\n\n我们写好顶点着色器和片元着色器之后要让他们在我们的OpenGL程序里面运行。\n\n我们可以用下面代码创建着色器\n\n```\npublic int loadShader(int shaderType, InputStream source) {\n        // 读取着色器代码\n        String sourceStr;\n        try {\n            sourceStr = readStringFromStream(source);\n        } catch (IOException e) {\n            throw new RuntimeException(\"read shaderType \" + shaderType + \" source failed\", e);\n        }\n\n        // 创建着色器并且编译\n        int shader = GLES20.glCreateShader(shaderType); // 创建着色器程序\n        GLES20.glShaderSource(shader, sourceStr); // 加载着色器源码\n        GLES20.glCompileShader(shader); // 编译着色器程序\n\n        // 检查编译是否出现异常\n        int[] compiled = new int[1];\n        GLES20.glGetShaderiv(shader, GLES20.GL_COMPILE_STATUS, compiled, 0);\n        if (compiled[0] == 0) {\n            String log = GLES20.glGetShaderInfoLog(shader);\n            GLES20.glDeleteShader(shader);\n            throw new RuntimeException(\"create shaderType \" + shaderType + \" failed : \" + log);\n        }\n        return shader;\n    }\n```\n\n它最关键的其实就是中间这三行代码:\n\n```\nint shader = GLES20.glCreateShader(shaderType); // 创建着色器程序\nGLES20.glShaderSource(shader, sourceStr); // 加载着色器源码\nGLES20.glCompileShader(shader); // 编译着色器程序\n```\n\n在GLES20.glCreateShader的时候需要指定着色器类型,顶点着色器(GLES20.GL\\_VERTEX\\_SHADER)或者片元着色器(GLES20.GL\\_FRAGMENT\\_SHADER)创建出来的着色器程序需要链接到我们的渲染程序当中:\n\n```\npublic int createProgram(InputStream vShaderSource, InputStream fShaderSource) {\n    // 创建渲染程序\n    int program = GLES20.glCreateProgram();\n    GLES20.glAttachShader(program, loadShader(GLES20.GL_VERTEX_SHADER, vShaderSource));\n    GLES20.glAttachShader(program, loadShader(GLES20.GL_FRAGMENT_SHADER, fShaderSource));\n    GLES20.glLinkProgram(program);\n\n    // 检查链接是否出现异常\n    int[] linked = new int[1];\n    GLES20.glGetProgramiv(program, GLES20.GL_LINK_STATUS, linked, 0);\n    if (linked[0] == 0) {\n        String log = GLES20.glGetProgramInfoLog(program);\n        GLES20.glDeleteProgram(program);\n        throw new RuntimeException(\"link program failed : \" + log);\n    }\n    return program;\n}\n```\n\n\n最后调用GLES20.glUseProgram方法使用创建的渲染程序:\n\n```\nAssetManager asset = context.getAssets();\ntry {\n    mProgram = createProgram(asset.open(VERTICES_SHADER), asset.open(FRAGMENT_SHADER));\n} catch (IOException e) {\n    throw new RuntimeException(\"can't open shader\", e);\n}\nGLES20.glUseProgram(mProgram);\n```\n\n## glViewport\n\n这里有个比较重要的方法要先讲一下,GLES20.glViewport定义了视窗的位置。\n\nOpenGL虽然是在Surface上绘制,但我们可以不铺满整个Surface,可以只在它的某部分绘制，例如我们可以用下面代码只用TextureSurface的左下角的四分之一去显示OpenGL的画面:\n\n```\n//width、height是TextureView的宽高\nGLES20.glViewport(0, 0, width/2, height/2);\n```\n\n{% img /安卓特效相机三/8.png %}\n\n当然一般情况下我们都是铺满整个Surface\n\n```\nGLES20.glViewport(0, 0, width, height);\n```\n\n## 填充顶点信息\n\n从顶点着色器代码来看,我们的顶点携带了两种信息,一个是顶点的坐标、一个是纹理坐标:\n\n```\nattribute vec2 vPosition;\nattribute vec2 vCoord;\n```\n\n在java代码中,glUseProgram之后我们可以这样拿到他们的id:\n\n```\nmPositionId = GLES20.glGetAttribLocation(mProgram, \"vPosition\");\nmCoordId = GLES20.glGetAttribLocation(mProgram, \"vCoord\");\n```\n\n然后就可以通过这两个id,去给这两个变量填充值了。那具体要填充些什么值呢?\n\n在OpenGL中,三角形是基本图形,任何的图形都可以由三角形组合而来。我们的TextureView其实是一个矩形,它可以由两个三角形组成。但是这个矩形的坐标应该设置成多少呢?\n\n默认情况下当我们设置一个顶点的x=0,y=0的时候它就在OpenGL画面的中心,x轴正方向在右边,y轴正方向在上边,画面的上下左右分别是y=1、y=-1、x=-1、x=1:\n\n{% img /安卓特效相机三/9.png %}\n\n无论z坐标是多少都会忽略,只会管x,y坐标。有同学可能会疑惑,OpenGL不是可以处理三维图形运算的吗?\n没错,但是OpenGL ES 2.0将整个三维运算都交给了我们,我们需要自己去乘观察矩阵和投影矩阵才能得到三维的效果,这块比较复杂这里就不讲了。我们不去乘的话OpenGL就变成了上面说的这样。\n\n好了现在可以定义我们的顶点的坐标了:\n\n{% img /安卓特效相机三/10.png %}\n\n我们当然可以用六个点去定义两个三角形:\n\n```\nfloat[] VERTICES = {\n        // 左下角三角形\n        -1.0f, 1.0f,\n        -1.0f, -1.0f,\n        1.0f, -1.0f,\n\n        // 右上角三角形\n        1.0f, -1.0f,\n        1.0f, 1.0f,\n        -1.0f, 1.0f\n};\n```\n\n但是这样的话有两个交点被重复定义了,占用内存比较多,更多情况下我们会用四个点,然后再加一个序号数组去标识三角形的顶点:\n\n```\nprivate static final float[] VERTICES = {\n        -1.0f, 1.0f,\n        -1.0f, -1.0f,\n        1.0f, -1.0f,\n        1.0f, 1.0f\n};\n\nprivate static final short[] ORDERS = {\n        0, 1, 2, // 左下角三角形\n\n        2, 3, 0  // 右上角三角形\n};\n```\n\n设置顶点坐标的代码如下:\n\n```\nmVertices = CommonUtils.toFloatBuffer(VERTICES);\nGLES20.glVertexAttribPointer(mPositionId, 2, GLES20.GL_FLOAT, false, 0, mVertices);\nGLES20.glEnableVertexAttribArray(mPositionId);\n\n...\n\npublic static FloatBuffer toFloatBuffer(float[] data) {\n    ByteBuffer buffer = ByteBuffer.allocateDirect(data.length * 4);\n    buffer.order(ByteOrder.nativeOrder());\n    FloatBuffer floatBuffer = buffer.asFloatBuffer();\n    floatBuffer.put(data);\n    floatBuffer.position(0);\n    return floatBuffer;\n}\n```\n\n纹理坐标同理:\n\n```\nprivate static private float[] TEXTURE_COORDS = {\n        0.0f, 1.0f,\n        0.0f, 0.0f,\n        1.0f, 0.0f,\n        1.0f, 1.0f\n};\n\n...\n\nmCoords = CommonUtils.toFloatBuffer(TEXTURE_COORDS);\nGLES20.glVertexAttribPointer(mCoordId, 2, GLES20.GL_FLOAT, false, 0, mCoords);\nGLES20.glEnableVertexAttribArray(mCoordId);\n```\n\n## 填充颜色特效矩阵\n\n片元着色器中的uColorMatrix的设置类似,只不过由于它是uniform类型的变量,我们用GLES20.glUniformMXXXX去设置:\n\n```\nprivate static float[] COLOR_MATRIX = {\n    -1.0f, 0.0f, 0.0f, 1.0f,\n    0.0f, -1.0f, 0.0f, 1.0f,\n    0.0f, 0.0f, -1.0f, 1.0f,\n    0.0f, 0.0f, 0.0f, 1.0f\n};\n    \nmColorMatrixId = GLES20.glGetUniformLocation(mProgram, \"uColorMatrix\");\n\nGLES20.glUniformMatrix4fv(mColorMatrixId, 1, true, COLOR_MATRIX, 0);\n```\n\nglUniformMatrix4fv方法的第三个参数比较值得注意,这里我们填了true，代表需要转置,这是由于OpenGL的矩阵是列优先的:\n\n{% img /安卓特效相机三/11.png %}\n\n因为我们的COLOR\\_MATRIX是一个一维数组,其实实际上是这样的:\n\n```\nprivate float[] COLOR_MATRIX = {-1.0f, 0.0f, 0.0f, 1.0f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f};\n```\n\n它去到GPU之后设置给uColorMatrix得到了这个4\\*4的矩阵:\n\n```\n-1.0f,  0.0f,  0.0f, 0.0f,\n 0.0f, -1.0f,  0.0f, 0.0f,\n 0.0f,  0.0f, -1.0f, 0.0f,\n 1.0f,  1.0f,  1.0f, 1.0f\n```\n\n所以我们需要给他做转置操作得到：\n\n```\n-1.0f, 0.0f, 0.0f, 1.0f,\n0.0f, -1.0f, 0.0f, 1.0f,\n0.0f, 0.0f, -1.0f, 1.0f,\n0.0f, 0.0f, 0.0f, 1.0f\n```\n\n\n## 纹理变换矩阵\n\n在顶点着色器里面我们讲到了matTransform这个变换矩阵用于变换纹理坐标,它是从SurfaceTexture里面拿到的:\n\n```\nprivate float[] mTransformMatrix = new float[16];\n...\nmPreviewTexutre.getTransformMatrix(mTransformMatrix);\n...\nmTransformMatrixId = GLES20.glGetUniformLocation(mProgram, \"matTransform\");\n...\nGLES20.glUniformMatrix4fv(mTransformMatrixId, 1, false, matrix, 0);\n```\n\nSurfaceTexture从哪里来的我们等下再说,我们的摄像头就是往这里绘制画面。可以用getTransformMatrix方法得到变换矩阵:\n\n```\n/**\n    * Retrieve the 4x4 texture coordinate transform matrix associated with the texture image set by\n    * the most recent call to updateTexImage.\n    *\n    * This transform matrix maps 2D homogeneous texture coordinates of the form (s, t, 0, 1) with s\n    * and t in the inclusive range [0, 1] to the texture coordinate that should be used to sample\n    * that location from the texture.  Sampling the texture outside of the range of this transform\n    * is undefined.\n    *\n    * The matrix is stored in column-major order so that it may be passed directly to OpenGL ES via\n    * the glLoadMatrixf or glUniformMatrix4fv functions.\n    *\n    * @param mtx the array into which the 4x4 matrix will be stored.  The array must have exactly\n    *     16 elements.\n    */\n   public void getTransformMatrix(float[] mtx) {\n       ...\n   }\n```\n\n它返回4\\*4的纹理坐标变换矩阵:\n\n> Retrieve the 4x4 texture coordinate transform matrix associated with the texture image\n\n然后它是列优先的可以直接使用不用转置:\n\n> The matrix is stored in column-major order so that it may be passed directly to OpenGL ES via the glLoadMatrixf or glUniformMatrix4fv functions.\n\n所以第三个参数我们设置成false:\n\n```\nGLES20.glUniformMatrix4fv(mTransformMatrixId, 1, false, matrix, 0);\n```\n\n## 创建纹理绘制摄像头画面\n\n我们一直说要将摄像头的画面画到图片上,那图片是怎么来的呢?并不是用安卓上常见的Bitmap去画,而是用GLES20.glGenTextures创建一张OpenGL的纹理:\n\n```\npublic int getTexture() {\n    if (mGLTextureId == -1) {\n        int[] textures = new int[1];\n        GLES20.glGenTextures(1, textures, 0);\n        mGLTextureId = textures[0];\n    }\n\n    return mGLTextureId;\n}\n```\n\n但是创建出来就只是一个id,要怎么给摄像机去用呢?不知道大家还就不记得第一篇[博客](http://blog.islinjw.cn/2019/08/27/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%B8%80-Camera2%E7%9A%84%E4%BD%BF%E7%94%A8/)里面讲到如何设置摄像机画面的接收Surface:\n\n\n```\npublic void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) {\n    ...\n    mPreviewSurface = new Surface(surface);\n    ...\n}\n\n...\n\nCaptureRequest.Builder builder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);\nbuilder.addTarget(mPreviewSurface);\nsession.setRepeatingRequest(builder.build(), null, null);\n```\n\n所以我们也要将这个纹理转换成Surface放到CaptureRequest的Target里面传给CameraDevice:\n\n```\n\nmCameraTexture = new SurfaceTexture(mGLRender.getTexture());\n\n...\n\nCaptureRequest.Builder builder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);\nbuilder.addTarget(mCameraTexture);\nsession.setRepeatingRequest(builder.build(), mCaptureCallback, mHandler);\n```\n\n这里我们传入了个mCaptureCallback,摄像机画面绘制到纹理上之后会调用回调,我们需要在回调里面将画面上传到GPU,前面说的纹理转换矩阵也是在这个时候才去获取的:\n\n```\n@Override\npublic void onCaptureCompleted() {\n  mCameraTexture.updateTexImage();\n  mCameraTexture.getTransformMatrix(mTransformMatrix);\n  ...\n}\n```\n\n这里有说明OpenGL ES里面只能用GL\\_TEXTURE\\_EXTERNAL\\_OES这种纹理去接收:\n\n```\n/**\n * Update the texture image to the most recent frame from the image stream.  This may only be\n * called while the OpenGL ES context that owns the texture is current on the calling thread.\n * It will implicitly bind its texture to the GL_TEXTURE_EXTERNAL_OES texture target.\n */\npublic void updateTexImage() {\n    nativeUpdateTexImage();\n}\n```\n\n所以我们拿到片元着色器里的texPreview之后需要将它绑定到GLES11Ext.GL\\_SAMPLER\\_EXTERNAL\\_OES:\n\n```\nmTexPreviewId = GLES20.glGetUniformLocation(mProgram, \"texPreview\");\n\n...\n\nGLES20.glActiveTexture(GLES20.GL_TEXTURE0);\nGLES20.glBindTexture(GLES11Ext.GL_SAMPLER_EXTERNAL_OES, mGLTextureId);\nGLES20.glUniform1i(mTexPreviewId, 0);\n```\n\n# 绘制与双缓冲\n\n最后的最后我们要执行绘制操作,将整个画面绘画出来:\n\n```\nGLES20.glClear(GLES20.GL_DEPTH_BUFFER_BIT | GLES20.GL_COLOR_BUFFER_BIT);\nGLES20.glDrawElements(GLES20.GL_TRIANGLES, ORDERS.length, GLES20.GL_UNSIGNED_SHORT, mOrder);\nEGL14.eglSwapBuffers(mEGLDisplay, mEGLSurface);\n```\n\n这个GLES20.glClear用于将上一帧的画面清除,要不然如果有透明通道的话两帧的画面就会重叠。\n而GLES20.glDrawElements代表用mOrder这个顶点顺序去绘制图形,GLES20.GL\\_TRIANGLES代表要绘制的是三角形。\n\n\n最后的mGLCore.swapBuffers代表交互缓冲区,这是由于OpenGL使用了双缓冲的技术。\n\n\n什么是双缓冲呢?就是有两个缓冲区域:前台缓冲和后台缓冲。前台缓冲即我们看到的屏幕,后台缓冲则在内存当中。\n\n我们会先在后台缓冲绘制图像,绘制完成之后调用EGL14.eglSwapBuffers交换两个缓冲区,原先绘制的缓冲就变成了前台缓冲,显示在屏幕上:\n\n{% img /安卓特效相机三/12.png %}\n\n为什么需要双缓冲呢?这是为了解决绘制的时候屏幕闪烁的问题。我们都知道一般手机屏幕的刷新率是60Hz，而且有些高端的手机甚至比这个更高。\n\n也就是说屏幕一秒钟至少从前台缓冲中获取60次画面显示出来,如果只有一个缓冲的话,假设我们的绘制比较复杂耗时比较多,那可能屏幕会拿到画到一半的图片,就会造成闪烁。而两个缓冲的话就画到一半的图像都在后台缓冲并不会显示,只有完全画好才会交换变成前台缓冲去显示,就解决了这个闪烁的问题。\n\n# 完整代码\n\n完整代码见[github](https://github.com/bluesky466/CameraDemo/tree/feature_shader)(注意是feature\\_shader分支,master分支是第一篇文章的demo)","tags":["技术相关","Android","音视频"]},{"title":"安卓特效相机(二) EGL基础","url":"/2019/09/13/安卓特效相机-二-EGL基础/","content":"\n系列文章:\n\n[安卓特效相机(一) Camera2的使用](http://blog.islinjw.cn/2019/08/27/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%B8%80-Camera2%E7%9A%84%E4%BD%BF%E7%94%A8/)\n[安卓特效相机(二) EGL基础](http://blog.islinjw.cn/2019/09/13/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%BA%8C-EGL%E5%9F%BA%E7%A1%80/)\n[安卓特效相机(三) OpenGL ES 特效渲染](http://blog.islinjw.cn/2019/09/22/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%B8%89-OpenGL-ES-%E7%89%B9%E6%95%88%E6%B8%B2%E6%9F%93/)\n[安卓特效相机(四) 视频录制](http://blog.islinjw.cn/2019/10/09/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E5%9B%9B-%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/)\n\n上一篇[文章](http://blog.islinjw.cn/2019/08/27/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%B8%80-Camera2%E7%9A%84%E4%BD%BF%E7%94%A8/)已经和大家讲解了下Camera2的使用,能够将相机捕捉到的画面显示到TextureView上,接下来就是要对这个画面进行特效处理了。这里我们选用OpenGL ES去实现特效。\n\n但是在讲如何使用OpenGL ES去实现特效之前我们要先讲下EGL\n\n# EGL\n\nOpenGL作为一个被广泛使用的跨平台图形库,相信大家或多或少都有听说。安卓上使用的是它针对手机、PDA和游戏主机等嵌入式设备而设计的子集OpenGL ES\n\n为了实现跨平台,OpenGL本体只包含了图形运算方面的接口,也可以大致理解为只包含操作GPU的API。而作为和平台强相关的本地窗口系统交互部分由于每个平台都不一样,而且没有办法抽离出统一的接口,所以不能包含进OpenGL本体里面。例如Android上我们可以指定OpenGL绘制在哪个Surface上,但是IOS上并没有这个东西,所以不能在OpenGL里面开一个接口接收Surface这个参数。\n\n那OpenGL运行到实际的系统上的时候又是怎么和具体的系统做交互的呢？计算机领域有一句话:\"计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决\"。EGL就是安卓上的这个中间层,OpenGL通过它来和安卓系统的交互。我们可以用这个EGL来设置安卓上特有的一些配置项,比如之前说的Surface。顺带提一嘴在IOS里面这个中间层叫做EAGL。\n\n\n## EGL的使用\n\nEGL的使用其实套路比较死板,没有比较死记整个流程和api,只要大概知道每个接口的作用就好。可以写一个自己的工具类,配置上默认值,在需要的时候再去修改。\n\n在代码里面安卓经过这么多年的迭代已经给我们提供了几个版本的EGL,比如EGL10、EGL11、EGL14。它们用法基本一样,我这里就用EGL14举例了。\n\nEGL使用的整个流程如下:\n\n{% img /安卓特效相机二/1.png %}\n\n### 初始化EGL\n\n首先我们要创建EGLDisplay并且初始化EGL环境:\n\n```\nmEGLDisplay = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY);\n\nif (mEGLDisplay == EGL14.EGL_NO_DISPLAY){\n    throw new RuntimeException(\"can't get eglGetDisplay\");\n}\n\nif (!EGL14.eglInitialize(mEGLDisplay, null, 0, null, 0)) {\n    throw new RuntimeException(\"eglInitialize failed\");\n}\n```\n\nEGLDisplay指的是物理的显示设备比如我们的手机屏幕,我们可以通过传入屏幕设备的id去获取到设备句柄,绝大多数情况下我们传入EGL14.EGL\\_DEFAULT\\_DISPLAY获取默认的屏幕就好,而且一般情况下我们的手机也只有一个屏幕。\n\n如果拿不到设备就会返回EGL\\_NO\\_DISPLAY。\n\n拿到EGLDisplay之后就可以调用EGL14.eglInitialize去初始化EGL环境。第一个参数是EGLDisplay,然后可以通过后面的参数获取系统中EGL的实现版本号,做一些兼容处理,这里我们没有使用什么高级特性,不需要获取,传null和0就好。如果需要获取的话可以传入一个数组,并且指定major版本和minor想要存放到数组的哪个位置去获取。\n\n### 选择EGLConfig\n\n在使用OpenGL的时候EGLDisplay支持的配置有很多种,例如颜色可能支持ARGB888、RGB888、RGB444、RGB565等,我们可以通过eglGetConfigs拿到EGLDisplay支持的所有配置,然后选择我们需要的。\n\n```\npublic static native boolean eglGetConfigs(\n    EGLDisplay dpy,\n    EGLConfig[] configs,\n    int configsOffset,\n    int config_size,\n    int[] num_config,\n    int num_configOffset\n);\n```\n\n不过如果直接去遍历所有的配置找我们需要的那个,代码写起来比较麻烦。所以EGL提供了一个eglChooseConfig方法,我们输入关心的属性,其他的属性让EGL自己匹配就好。可能会匹配出多个EGLConfig,这个时候随便选一个都可以:\n\n```\nprivate EGLConfig chooseEglConfig(EGLDisplay display) {\n    int[] attribList = {\n            EGL14.EGL_BUFFER_SIZE, 32,\n            EGL14.EGL_ALPHA_SIZE, 8,\n            EGL14.EGL_RED_SIZE, 8,\n            EGL14.EGL_GREEN_SIZE, 8,\n            EGL14.EGL_BLUE_SIZE, 8,\n            EGL14.EGL_RENDERABLE_TYPE, EGL14.EGL_OPENGL_ES2_BIT,\n            EGL14.EGL_SURFACE_TYPE, EGL14.EGL_WINDOW_BIT,\n            EGL14.EGL_NONE\n    };\n    EGLConfig[] configs = new EGLConfig[1];\n    int[] numConfigs = new int[1];\n    if (!EGL14.eglChooseConfig(\n            display,\n            attribList,\n            0,\n            configs,\n            0,\n            configs.length,\n            numConfigs,\n            0)) {\n        throw new RuntimeException(\"eglChooseConfig failed\");\n    }\n    return configs[0];\n}\n\n...\n\nmEGLConfig = chooseEglConfig(mEGLDisplay);\n```\n\n### 创建EGLContext\n\nEGLContext是OpenGL的线程相关上下文环境,我们在OpenGL中创建的数据如图片、顶点、着色器等最后获取到的只是一个id,它的具体内容其实依赖这个EGLContext。所以接下来我们需要将它创建出来。\n\n```\nmEGLContext = createEglContext(mEGLDisplay, mEGLConfig);\nif (mEGLContext == EGL14.EGL_NO_CONTEXT) {\n    throw new RuntimeException(\"eglCreateContext failed\");\n}\n\nprivate EGLContext createEglContext(EGLDisplay display, EGLConfig config) {\n    int[] contextList = {\n            EGL14.EGL_CONTEXT_CLIENT_VERSION, 2,\n            EGL14.EGL_NONE\n    };\n    return EGL14.eglCreateContext(\n            display,\n            config,\n            EGL14.EGL_NO_CONTEXT,\n            contextList,\n            0);\n}\n```\n\n这个上下文环境是线程相关的,一般来讲OpenGL的操作都在同一个线程中进行,但是有些复杂的业务场景可能需要多线程,于是可以在eglCreateContext的第三个参数里面传入share_context做到多线程共享。如果不需要多线程共享的话传入EGL14.EGL\\_NO\\_CONTEXT就好\n\n### 创建并指定EGLSurface\n\n我们在EGLDisplay指定了屏幕,在EGLContext里面提供了上下文环境,最后一步就是要指定一个EGLSurface告诉OpenGL应该往哪里画东西。\n\n\n很多安卓程序员可能就算写过一些简单的OpenGL程序,也没有直接使用过EGL。因为我们熟悉的GLSurfaceView已经帮我们封装好了,我们只需要在Render.onDrawFrame里面直接使用OpenGL的接口绘图就好了,绘制的图形就好显示在GLSurfaceViews上。\n\n但是由于我们这里使用TextureView替代SurfaceView,并且也没有啥GLTextureView帮我们封装好EGL。需要自己去配置EGL并用TextureView的SurfaceTexture去创建并指定EGLSurface让预览画面绘制到TextureView上:\n\n```\npublic EGLSurface createEGLSurface(Surface surface) {\n        int[] attribList = {\n                EGL14.EGL_NONE\n        };\n        return EGL14.eglCreateWindowSurface(\n                mEGLDisplay,\n                mEGLConfig,\n                surface,\n                attribList,\n                0);\n    }\n\n...\n\npublic void makeCurrent(EGLSurface eglSurface) {\n    EGL14.eglMakeCurrent(mEGLDisplay, eglSurface, eglSurface, mEGLContext);\n}\n\n...\n\npublic void initEGL(SurfaceTexture surface) {\n    ...\n    EGLSurface eglSurface = createEGLSurface(new Surface(surface));\n    makeCurrent(eglSurface);\n    ...\n}\n```\n\n我们可以用eglCreateWindowSurface创建EGLSurface然后用eglMakeCurrent指定OpenGL绘制的结果最后输出到这个EGLSurface上。\n\n其实TextureView和SurfaceView都可以用来显示预览画面,它们各有优缺点。SurfaceView在WMS中有对应的WindowState实际上是多开了个窗口浮在应用的上面,因为这个Surface不在View hierachy中，它的显示也不受View的属性控制，所以不能进行平移，缩放等变换。而TextureView不会创建多个窗口,所以可以用view的属性去控制它,但是渲染的性能的话会比SurfaceView稍微低一点。\n\n# 总结\n\n总结一下EGL的三大模块和相关方法如下:\n\n{% img /安卓特效相机二/2.png %}\n\n完整的EGL初始化代码如下,大多数情况不需要修改就可以直接拷贝去用了:\n\n```\nprivate void initEGL(SurfaceTexture surface) {\n        mEGLDisplay = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY);\n\n        if (mEGLDisplay == EGL14.EGL_NO_DISPLAY) {\n            throw new RuntimeException(\"can't get eglGetDisplay\");\n        }\n\n        if (!EGL14.eglInitialize(mEGLDisplay, null, 0, null, 0)) {\n            throw new RuntimeException(\"eglInitialize failed\");\n        }\n\n        mEGLConfig = chooseEglConfig(mEGLDisplay);\n        mEGLContext = createEglContext(mEGLDisplay, mEGLConfig);\n        if (mEGLContext == EGL14.EGL_NO_CONTEXT) {\n            throw new RuntimeException(\"eglCreateContext failed\");\n        }\n\n        EGLSurface eglSurface = createEGLSurface(new Surface(surface));\n        makeCurrent(eglSurface);\n    }\n\n\n    private EGLConfig chooseEglConfig(EGLDisplay display) {\n        int[] attribList = {\n            EGL14.EGL_BUFFER_SIZE, 32,\n            EGL14.EGL_ALPHA_SIZE, 8,\n            EGL14.EGL_RED_SIZE, 8,\n            EGL14.EGL_GREEN_SIZE, 8,\n            EGL14.EGL_BLUE_SIZE, 8,\n            EGL14.EGL_RENDERABLE_TYPE, EGL14.EGL_OPENGL_ES2_BIT,\n            EGL14.EGL_SURFACE_TYPE, EGL14.EGL_WINDOW_BIT,\n            EGL14.EGL_NONE\n        };\n        EGLConfig[] configs = new EGLConfig[1];\n        int[] numConfigs = new int[1];\n        if (!EGL14.eglChooseConfig(\n            display,\n            attribList,\n            0,\n            configs,\n            0,\n            configs.length,\n            numConfigs,\n            0)) {\n            throw new RuntimeException(\"eglChooseConfig failed\");\n        }\n        return configs[0];\n    }\n\n    private EGLContext createEglContext(EGLDisplay display, EGLConfig config) {\n        int[] contextList = {\n            EGL14.EGL_CONTEXT_CLIENT_VERSION, 2,\n            EGL14.EGL_NONE\n        };\n        return EGL14.eglCreateContext(\n            display,\n            config,\n            EGL14.EGL_NO_CONTEXT,\n            contextList,\n            0);\n    }\n\n    public EGLSurface createEGLSurface(Surface surface) {\n        int[] attribList = {\n            EGL14.EGL_NONE\n        };\n        return EGL14.eglCreateWindowSurface(\n            mEGLDisplay,\n            mEGLConfig,\n            surface,\n            attribList,\n            0);\n    }\n\n    public void makeCurrent(EGLSurface eglSurface) {\n        EGL14.eglMakeCurrent(mEGLDisplay, eglSurface, eglSurface, mEGLContext);\n    }\n}\n```\n","tags":["技术相关","Android","音视频"]},{"title":"安卓特效相机(一) Camera2的使用","url":"/2019/08/27/安卓特效相机-一-Camera2的使用/","content":"\n系列文章:\n\n[安卓特效相机(一) Camera2的使用](http://blog.islinjw.cn/2019/08/27/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%B8%80-Camera2%E7%9A%84%E4%BD%BF%E7%94%A8/)\n[安卓特效相机(二) EGL基础](http://blog.islinjw.cn/2019/09/13/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%BA%8C-EGL%E5%9F%BA%E7%A1%80/)\n[安卓特效相机(三) OpenGL ES 特效渲染](http://blog.islinjw.cn/2019/09/22/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%B8%89-OpenGL-ES-%E7%89%B9%E6%95%88%E6%B8%B2%E6%9F%93/)\n[安卓特效相机(四) 视频录制](http://blog.islinjw.cn/2019/10/09/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E5%9B%9B-%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/)\n\n谷歌在安卓5.0的时候废弃了原来的Camera架构,推出了全新的Camera2架构。api相对之前的版本有很大的区别。\n\n为了熟悉这个Camera2架构的使用,我写了个简单的[特效相机应用](https://github.com/bluesky466/ShaderCamera),它支持三种简单的特效:\n\n{% img /安卓特效相机一/5.jpg %}\n\n接下来的几篇文章我会一步步讲下整个程序是如何实现的。\n\n# 整体架构\n\n这篇文章主要讲Camera2的使用,包括预览和拍照。\n\nCamera2的整体架构如下:\n\n{% img /安卓特效相机一/1.png %}\n\n一台安卓设备可能拥有多个摄像设备,比如一般手机都有前后摄像头,而每个摄像头即为一个CameraDevice。应用程序可以通过CameraManager获取到所有的摄像设备的信息,打开摄像设备然后创建一个CameraCaptureSession连接应用程序与摄像设备。之后应用程序就可以使用这个CameraCaptureSession向摄像设备发送CaptureRequest来指挥摄像头工作。\n\n所以使用Camera2的流程大致为:\n\n1. 从CameraManager选择摄像设备并打开\n2. 创建与CameraDevice的CameraCaptureSession\n3. 使用CameraCaptureSession向CameraDevice发送CaptureRequest\n\n# 获取摄像设备信息\n\n## 镜头朝向\n\n通常应用程序想要使用摄像头,需要先遍历设备所有的摄像头,然后选出合适的摄像头去拍摄,例如我们想使用后置摄像头:\n\n```\nCameraManager manager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);\n\ntry {\n    for (String id : manager.getCameraIdList()) {\n        CameraCharacteristics cc = manager.getCameraCharacteristics(id);\n        if (cc.get(CameraCharacteristics.LENS_FACING) == facing) {\n        \t...\n            break;\n        }\n    }\n} catch (Exception e) {\n    Log.e(TAG, \"can not open camera\", e);\n}\n```\n\n通过CameraManager.getCameraIdList()方法可以列出所有摄像头的id,然后通过CameraManager.getCameraCharacteristics可以拿到对应摄像头的CameraCharacteristics(特征集合),通过这个CameraCharacteristics我们可以拿到摄像头的一些属性,例如上面的镜头朝向。\n\n## 输出尺寸\n\n应用展示摄像头画面的view大小千奇百怪,如果摄像头只能拍摄一种尺寸的画面,那屏幕上显示的时候就势必需要进行缩放了。如果view长宽比和拍摄的画面长宽比是一样的还好,只需要等比缩放就可以了。但是如果长宽比不一样那就势必要发生形变或者裁切像素了。\n\n于是一般摄像头都会支持多种尺寸的输出画面,开发者可以种里面选取最合适的尺寸去显示。\n\n```\nSize[] previewSizes = cc.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP).getOutputSizes(SurfaceTexture.class);\nSize previewSize = getMostSuitableSize(previewSizes, width, height);\npreview.setDefaultBufferSize(previewSize.getWidth(), previewSize.getHeight());\n...\nmanager.openCamera(id, mOpenCameraCallback, handler);\n```\n\n可以看到输出尺寸和想要用于显示的类相关,例如我们的demo使用SurfaceTexture去显示,就可以获取摄像头支持SurfaceTexture的所有尺寸。\n\n然后指定输出尺寸并不是将想要的尺寸设置给摄像机,而是设置SurfaceTexture的Buffer大小,然后摄像头在将画面绘制到SurfaceTexture上的时候就会使用最接近的尺寸去绘制了。\n\nCamera2支持将画面绘制到下面的几种目标:\n\n- ImageReader\n- MediaRecorder\n- MediaCodec\n- Allocation\n- SurfaceHolder\n- SurfaceTexture\n\ngetMostSuitableSize里面我们选择长宽比最接近width*height的尺寸:\n\n```\n private Size getMostSuitableSize(\n        Size[] sizes,\n        float width,\n        float height) {\n\n    float targetRatio = height / width;\n    Size result = null;\n    for (Size size : sizes) {\n        if (result == null || isMoreSuitable(result, size, targetRatio)) {\n            result = size;\n        }\n    }\n    return result;\n}\n\nprivate boolean isMoreSuitable(Size current, Size target, float targetRatio) {\n    if (current == null) {\n        return true;\n    }\n    float dRatioTarget = Math.abs(targetRatio - getRatio(target));\n    float dRatioCurrent = Math.abs(targetRatio - getRatio(current));\n    return dRatioTarget < dRatioCurrent\n            || (dRatioTarget == dRatioCurrent && getArea(target) > getArea(current));\n}\n\n```\n\n## 相机方向\n\n细心的同学可能会看到这里的长宽比我用的是height/width,这是由于摄像机的方向和屏幕方向相差了90度,所以相机的长宽比应该是屏幕的宽长比。\n\n这个摄像头方向的介绍可以看[官方文档](https://developer.android.com/reference/android/hardware/Camera.CameraInfo#orientation):\n\n\n> The orientation of the camera image. The value is the angle that the camera image needs to be rotated clockwise so it shows correctly on the display in its natural orientation. It should be 0, 90, 180, or 270.\n>\n> For example, suppose a device has a naturally tall screen. The back-facing camera sensor is mounted in landscape. You are looking at the screen. If the top side of the camera sensor is aligned with the right edge of the screen in natural orientation, the value should be 90. If the top side of a front-facing camera sensor is aligned with the right of the screen, the value should be 270.\n\n比方说后置摄像头的正方向就是竖着拿屏幕的时候的屏幕的右方:\n\n{% img /安卓特效相机一/4.png %}\n\n所以竖着拿手机的时候拍的照片其实是横的。于是我们在计算长宽比查找最时候的尺寸的时候就需要旋转90度,也就是用height/width。\n\n# 打开摄像头\n\n我们可以使用CameraManager.openCamera方法打开指定的摄像头:\n\n```\nprivate CameraDevice.StateCallback mOpenCameraCallback =\n            new CameraDevice.StateCallback() {\n                @Override\n                public void onOpened(CameraDevice camera) {\n                    openCameraSession(camera);\n                }\n\n                @Override\n                public void onDisconnected(CameraDevice camera) {\n                }\n\n                @Override\n                public void onError(CameraDevice camera, int error) {\n                }\n            };\n\n...\n\nmanager.openCamera(id, mOpenCameraCallback, handler);\n```\n\nmOpenCameraCallback是打开结果的回调,而handler则决定了这个回调在哪个线程调用\n\n# 连接摄像头\n\n在打开摄像头的回调里我们可以拿到CameraDevice,然后但是我们并不能直接指挥摄像设备去干活,而是要通过CameraCaptureSession。\n\n那怎么创建与CameraDevice的CameraCaptureSession呢？\n\n可以通过CameraDevice.createCaptureSession\n\n```\nprivate CameraCaptureSession.StateCallback mCreateSessionCallback =\n        new CameraCaptureSession.StateCallback() {\n            @Override\n            public void onConfigured(CameraCaptureSession session) {\n                mCameraCaptureSession = session;\n                requestPreview(session);\n            }\n\n            @Override\n            public void onConfigureFailed(CameraCaptureSession session) {\n\n            }\n        };\n...\n\nprivate void openCameraSession(CameraDevice camera) {\n        mCameraDevice = camera;\n        try {\n            List<Surface> outputs = Arrays.asList(mPreviewSurface);\n            camera.createCaptureSession(outputs, mCreateSessionCallback, mHandler);\n        } catch (CameraAccessException e) {\n            Log.e(TAG, \"createCaptureSession failed\", e);\n        }\n    }\n```\n\n除了同样需要传入回调和指定回调执行线程的handler之外。\n\n然后还需要传入一个列表告诉摄像设备它需要绘制到什么地方,Camera2支持同时往多个目标绘制画面。\n\n但是并不是说我们这里指定mPreviewSurface,摄像头就会直接开始往里面绘制画面了,还需要发送request去请求绘制。\n\n# 发送绘制请求\n\nCaptureRequest的配置比较多,如果一个个去配的话比较繁琐,所以谷歌已经给我们创建好了几个常用的模板,我们可以根据自己的需求去选择一个来做修改\n\n## 实时预览\n\n我们用TextureView来实时预览摄像机画面:\n\n```\nmPreview.setSurfaceTextureListener(new TextureView.SurfaceTextureListener() {\n    @SuppressLint(\"NewApi\")\n    @Override\n    public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) {\n        mSurfaceTexture = surface;\n        mPreviewSurface = new Surface(surface);\n        ...\n        openCamera(mSurfaceTexture,\n                CameraCharacteristics.LENS_FACING_BACK,\n                mPreview.getWidth(),\n                mPreview.getHeight());\n        ...\n    }\n\n    @Override\n    public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) {\n\n    }\n\n    @Override\n    public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) {\n        return false;\n    }\n\n    @Override\n    public void onSurfaceTextureUpdated(SurfaceTexture surface) {\n\n    }\n});\n```\n\nCaptureRequest这里依然需要指定将画面绘制到我们的预览Surface上:\n\n```\nCaptureRequest.Builder builder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);\nbuilder.addTarget(mPreviewSurface);\nsession.setRepeatingRequest(builder.build(), null, null);\n```\n\n\n值得注意的是每一次请求只会绘制一次,如果是预览界面的话需要不停绘制,我们可以使用CameraCaptureSession.setRepeatingRequest让他不断发送Request去不断的绘制,达到实时预览的功能。\n\n这个方法的第一个参数是CaptureRequest,第二和第三个参数仍然是回调和handler,这里我们不需要监听回调,都设成null就好。\n\n## 拍照\n\n我们可以创建ImageReader来接收画面:\n\n```\nSize[] photoSizes = cc.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)\n                           .getOutputSizes(ImageReader.class);\nmImageReader = getImageReader(getMostSuitableSize(photoSizes, width, height));\n\n...\n\nprivate ImageReader.OnImageAvailableListener mOnImageAvailableListener\n            = new ImageReader.OnImageAvailableListener() {\n        @Override\n        public void onImageAvailable(ImageReader reader) {\n            savePhoto(reader);\n        }\n    };\n\nprivate ImageReader getImageReader(Size size) {\n    ImageReader imageReader = ImageReader.newInstance(\n            size.getWidth(),\n            size.getHeight(),\n            ImageFormat.JPEG,\n            5);\n    imageReader.setOnImageAvailableListener(mOnImageAvailableListener, mHandler);\n    return imageReader;\n}\n```\n\n在触摸屏幕的时候发送请求绘制画面到ImageReader上:\n\n```\nprivate void takePhoto() {\n    try {\n        CaptureRequest.Builder builder = mCameraDevice.createCaptureRequest(\n                CameraDevice.TEMPLATE_STILL_CAPTURE);\n        builder.addTarget(mPreviewSurface);\n        builder.addTarget(mImageReader.getSurface());\n        int rotation = getWindowManager().getDefaultDisplay().getRotation();\n        builder.set(CaptureRequest.JPEG_ORIENTATION, mSensorOrientation);\n        mCameraCaptureSession.capture(builder.build(), null, null);\n    } catch (CameraAccessException e) {\n        Log.d(TAG, \"takePhoto failed\", e);\n    }\n}\n```\n\n## 图片方向\n\n我们这里设置了下CaptureRequest.JPEG_ORIENTATION,原因和上面说的摄像头设备的方向有关,如果不设置的话,预览的窗口里面是竖着拍的照片实际保存下来会变成横的。\n\n这个mSensorOrientation也是从CameraCharacteristics里面获取的:\n\n```\nCameraCharacteristics cc = manager.getCameraCharacteristics(id);\n...\nmSensorOrientation = cc.get(CameraCharacteristics.SENSOR_ORIENTATION);\n```\n\n## 请求队列\n\n细心的同学可能还会注意到,这个请求不仅将mImageReader.getSurface()添加到Target，同时也将mPreviewSurface添加到Target了,这是为什么呢?\n\n不知道大家还记不记得之前我们说过,每一个CaptureRequest会执行一次绘制,实时预览靠的就是setRepeatingRequest不断重复的发送CaptureRequest。\n\n其实CameraDevice对CaptureRequest的执行是串行的,当没有拍照的请求的时候,请求队列是这样的:\n\n{% img /安卓特效相机一/2.png %}\n\n而当有拍照的请求进去的时候，请求队列是这样的:\n\n{% img /安卓特效相机一/3.png %}\n\n预览请求中间插入了一个拍照请求,如果这个拍照请求里面没有将画面绘制到预览的View上面,预览画面就会少了一帧,相当于卡了一下。所以拍照的时候也要将mPreviewSurface放到Target中。\n\n# 关闭摄像头\n\n我们需要在退出应用的时候关闭摄像头,要不然可能会影响其他应用使用摄像头:\n\n```\nprivate CameraDevice mCameraDevice;。\n\n...    \n\nif (mImageReader != null) {\n    mImageReader.close();\n    mImageReader = null;\n}\n\nif (mCameraCaptureSession != null) {\n    mCameraCaptureSession.close();\n    mCameraCaptureSession = null;\n}\n\nif (mCameraDevice != null) {\n    mCameraDevice.close();\n    mCameraDevice = null;\n}\n```\n\n本篇文章的完整代码可以在[github](https://github.com/bluesky466/CameraDemo)上获取\n","tags":["技术相关","Android","音视频"]},{"title":"binder机制深入探究","url":"/2019/06/22/binder机制深入探究/","content":"\n之前有写过一篇笔记[《Android温故而知新 - AIDL》](http://blog.islinjw.cn/2017/09/26/Android%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0-AIDL/)从应用层分析了aidl的数据是怎么传递的,还有一篇[《Android跨进程抛异常的原理》](http://blog.islinjw.cn/2018/11/10/Android%E8%B7%A8%E8%BF%9B%E7%A8%8B%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84%E5%8E%9F%E7%90%86/)分析了异常是怎样做到跨进程的。最近准备一个培训的时候又去看了下binder底层的实现原理，这里也记录下来做个笔记。\n\n回顾下应用层的这张示意图:\n\n{% img /binder深入探究/1.png %}\n\n客户端用一个id指定想要调用的方法,并将参数序列化传给binder驱动。binder驱动将数据传到服务端,服务端将参数解序列化,并且调用指定的方法。再将返回值传给binder驱动。binder驱动最后将返回值传会客户端。\n\n这就是应用层看到的binder跨进程调用的流程。那数据在binder驱动里面是怎么传递的呢？我们接下来就来一起看看。\n\n# binder数据的一次复制\n\n由于不同进程之间的内存是相互隔离的,一般情况下不能直接访问其他进程的数据。所以普通的ipc机制,数据先要从进程A内存复制到内核内存中,然后再复制到进程B内存,总共经历了两次复制:\n\n{% img /binder深入探究/2.png %}\n\n相信大家都应该有听过Binder机制传输数据只需要一次复制,那它又是怎么做到的呢?\n\n## mmap\n\n这里要先介绍mmap这个系统调用,mmap系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问,往这块内存读取数据就是向文件读写数据,而不必再调用read(),write()等操作。\n\n相信通过文件进行跨进程通信的原理大家都能理解吧:\n\nA进程往一个文件写入数据,B进程再从这个文件将数据读取出来。\n\n如果使用mmap系统调用的话,文件在用户看来就是一段内存,我们直接通过指针往这块内存赋值或者读取就能实现文件的读写。两个进程就能通过这种方式做跨进程通信了。\n\n那有人就会说了,mmap实际上是一种文件读写的简化操作,用它做跨进程通信会导致频繁读写文件,效率不会很低吗？\n\n其实mmap除了可以使用普通文件以提供内存映射IO,或者是特殊文件以提供匿名内存映射.也就是说如果我们使用的是特殊的文件的话,映射的是一块匿名的内存区域,是不涉及文件IO的。\n\n## binder\\_mmap\n\nbinder\\_mmap就是安卓为了binder通讯机制专门写的一套逻辑。当使用mmap对\"/dev/binder\"这个文件进行映射的时候,系统会调用到注册好的binder\\_mmap方法。\n\n这个方法会在用户空间和binder内核空间各开辟一块相同大小的虚拟内存,它们的虚拟内存地址可能不一样,但他们指向的是同一块物理内存:\n\n{% img /binder深入探究/3.png %}\n\n也就是说Binder驱动通过指针往这块内存区域赋值,用户进程也能直接通过指针读取出来,返回来用户进程往这块内存写入的数据,binder驱动也能直接用指针读取出来。\n\n## 一次复制的过程\n\n当两个进程通过Binder机制进行通信,如果进程A想向进程B传输数据。当进程A将想要传输的数据告诉binder驱动,Binder驱动就会将它复制到进程B在Binder内核空间所对应的虚拟内存。这样进程B就能在自己的用户空间使用内存访问读取到传过来的数据了。\n\n{% img /binder深入探究/4.png %}\n\n# Binder机制的数据大小限制\n\n我们都知道使用Intent传递数据的大小是有限制的,所以我们不能通过它去传大数据。\n\n那为什么会有这个限制呢?\n\n首先我们使用Intent.putExtra保存数据,然后将数据发给AMS的过程是基于binder通讯机制的。它的数据复制过程就是上一节的内容。\n\n但是上一节没有讲到的是mmap在创建内存映射的时候需要指定映射内存的大小。也就是说我们映射出来的内存不是无限大的,是有确定大小的。这个大小在不同的进程中会有同,比如ServiceManager进程的限制是128K,而由Zygote进程fork出来的进程的大小限制是1M-8K。\n\n由于应用层的应用都是由Zygote进程fork出来的,所以我们的应用的binder内存限制是1M-8K:\n\n```\n// frameworks/native/libs/binder/ProcessState.cpp\n\n#define BINDER_VM_SIZE ((1 * 1024 * 1024) - sysconf(_SC_PAGE_SIZE) * 2)\n\nProcessState::ProcessState(const char *driver)\n    : mDriverName(String8(driver))\n    , mDriverFD(open_driver(driver))\n    , mVMStart(MAP_FAILED)\n    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)\n    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)\n    , mExecutingThreadsCount(0)\n    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)\n    , mStarvationStartTimeMs(0)\n    , mManagesContexts(false)\n    , mBinderContextCheckFunc(NULL)\n    , mBinderContextUserData(NULL)\n    , mThreadPoolStarted(false)\n    , mThreadPoolSeq(1)\n{\n    if (mDriverFD >= 0) {\n       ...\n        mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);\n        ...\n}\n```\n\n那是不是说Intent能传递的数据的最大大小就是1M-8K了呢,实际上最大的大小比这个值会小一些,因为binder驱动还需要用这块内存去传一些其他的数据去指定服务端和调用的方法。\n\n然后有没有人觉得这个值很奇怪呢？为什么不是1M？为什么要减去8K?\n\n其实安卓源码里面最开始这个值的确是1M来着,是在后面才去掉的这8K,我们可以看看它的log:\n\n```\ncommit c0c1092183ceb38dd4d70d2732dd3a743fefd567\nAuthor: Rebecca Schultz Zavin <rebecca@android.com>\nDate:   Fri Oct 30 18:39:55 2009 -0700\n\n    Modify the binder to request 1M - 2 pages instead of 1M.  The backing store\n    in the kernel requires a guard page, so 1M allocations fragment memory very\n    badly.  Subtracting a couple of pages so that they fit in a power of\n    two allows the kernel to make more efficient use of its virtual address space.\n\n    Signed-off-by: Rebecca Schultz Zavin <rebecca@android.com>\n\ndiff --git a/libs/binder/ProcessState.cpp b/libs/binder/ProcessState.cpp\nindex d7daf7342..2d4e10ddd 100644\n--- a/libs/binder/ProcessState.cpp\n+++ b/libs/binder/ProcessState.cpp\n@@ -41,7 +41,7 @@\n #include <sys/mman.h>\n #include <sys/stat.h>\n\n-#define BINDER_VM_SIZE (1*1024*1024)\n+#define BINDER_VM_SIZE ((1*1024*1024) - (4096 *2))\n\n static bool gSingleProcess = false;\n```\n\nlog上解释了,减去这8K的原因是为了优化内存调用。\n\n这里具体解释下就是,Linux的内存管理是以内存页为单位去管理的,一个内存页是4K的大小,然后计算机读取2的n次方的内存是最高效的,所以这个1M的内存大小并没有什么毛病。\n\n但是问题出在Linux会给内存自动添加一个保护页,如果我们指定1M大小的内存的话实际上计算机在加载内存的时候需要加载1M加1页的内存,十分零散,不高效。\n\n所以这里减去两页,也就是8K。那所有的数据加起来不足1M,每次加载内存的时候只需要直接按1M去高效加载就可以了。\n\n# Binder的注册于查找\n\n还有一个问题是binder驱动是怎么找到我们客户端想要调用的服务端的？\n\n这要分两种情况,普通的服务比如我们写的service是由AMS管理的,而系统服务如AMS则是由ServiceManager管理的。\n\n## bindSerivce过程\n\n先来看看普通服务的管理逻辑,具体就是bindService的流程。\n\n当有Context.bindService被调用的时候,应用会通过Binder通信向AMS请求一个服务,AMS内部维护了一个ServiceMap,当接到这个请求之后会通过Intent去这里查找对应的ServiceRecord,如果查找不到就会启动这个Service,并且获得这个Service.onBind方法返回的Binder,然后将它保存到ServiceMap中,再传给请求服务的进程。这个进程内部会去调用onServiceConnected。\n\n{% img /binder深入探究/5.gif %}\n\n然后等到下个客户端请求同一个服务的时候,AMS就用Intent能从ServiceMap中查到这个服务,于是就不需要再调用服务的onBind了,可以直接返回给客户端了。\n\n{% img /binder深入探究/6.gif %}\n\n## ServiceManager\n\n普通的应用是通过AMS去查询Service的Binder的,但是我们知道应用和AMS之间也是通过Binder机制通信的,那AMS的Binder又是从哪里获取的呢?\n\n答案就是ServiceManager。\n\n系统服务进程会调用ServiceManager.addService,将服务注册到ServiceManger中。客户端调用Context.getSystemService的时候最终会调用到ServiceManager.getService获取到注册的系统服务。\n\n其他进程和ServiceManager进程也是通过Binder机制来通信的,那么这就有个鸡生蛋蛋生鸡的问题了。ServiceManger进程的Binder又是怎么拿到的呢？\n\nServiceManager进程的Binder在Binder驱动中比较特殊。它的id是0,其他应用可以通过0这个具体的id(其实在源码里面是叫handler,但为了好理解这里就说id吧)去拿到ServiceManager进程的Binder\n\n{% img /binder深入探究/7.png %}\n\n### Context.getSystemService的原理\n\n那是不是每一次调用Context.getSystemService都需要调用ServiceManager.getService跨进程从ServiceManager查询系统服务呢?\n\n我们的用户应用默默为我们做了一层缓存,只有第一次查询的时候才需要调用ServiceManager.getService,之后就记录了下来,下次再查同一个服务,会从缓存中直接返回,不需要再调用ServiceManager.getService。\n\n追踪ContextImpl.getSystemService，发现它是调用了SystemServiceRegistry.getSystemService:\n\n```\nclass ContextImpl extends Context {\n    ...\n    @Override\n    public Object getSystemService(String name) {\n        return SystemServiceRegistry.getSystemService(this, name);\n    }\n    ...\n```\n\n然后我们就去查看SystemServiceRegistry.getSystemService的源码,发现它从SYSTEM_SERVICE_FETCHERS中查找到一个ServiceFetcher,然后通过这个ServiceFetcher获取:\n\n```\nfinal class SystemServiceRegistry {\n    ...\n\n    public static Object getSystemService(ContextImpl ctx, String name) {\n        ServiceFetcher<?> fetcher = SYSTEM_SERVICE_FETCHERS.get(name);\n        return fetcher != null ? fetcher.getService(ctx) : null;\n    }\n    ...\n}\n```\n\n所以这个SYSTEM_SERVICE_FETCHERS和ServiceFetcher又是怎么回事呢:\n\n```\n\n    static {\n        ...\n        registerService(Context.COUNTRY_DETECTOR, CountryDetector.class,\n                new StaticServiceFetcher<CountryDetector>() {\n            @Override\n            public CountryDetector createService() {\n                IBinder b = ServiceManager.getService(Context.COUNTRY_DETECTOR);\n                return new CountryDetector(ICountryDetector.Stub.asInterface(b));\n            }});\n        ...\n    }\n    ...\n    private static <T> void registerService(String serviceName, Class<T> serviceClass,\n            ServiceFetcher<T> serviceFetcher) {\n        ...\n        SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);\n    }\n    ...\n    static abstract class StaticServiceFetcher<T> implements ServiceFetcher<T> {\n        private T mCachedInstance;\n\n        @Override\n        public final T getService(ContextImpl unused) {\n            synchronized (StaticServiceFetcher.this) {\n                if (mCachedInstance == null) {\n                    mCachedInstance = createService();\n                }\n                return mCachedInstance;\n            }\n        }\n\n        public abstract T createService();\n    }\n    ...\n}\n```\n\n其实这是一个单例模式的变种,只有在第一次查询这个服务的时候ServiceFetcher会判断这个服务是否已经获取过,如果没有才调用createService去从ServiceManager查询,否则直接返回。\n\n这部分内容感兴趣的同学可以《Android源码设计模式解析与实战》第二版。它的第一个源码设计模式讲的就是Context.getSystemService。","tags":["技术相关","Android"]},{"title":"可能是全网讲最细的安卓resources.arsc解析教程(二)","url":"/2019/05/21/可能是全网讲最细的安卓resources-arsc解析教程-二/","content":"\n上篇[博客](http://blog.islinjw.cn/2019/05/18/%E5%8F%AF%E8%83%BD%E6%98%AF%E5%85%A8%E7%BD%91%E8%AE%B2%E6%9C%80%E7%BB%86%E7%9A%84%E5%AE%89%E5%8D%93resources-arsc%E8%A7%A3%E6%9E%90%E6%95%99%E7%A8%8B-%E4%B8%80/)写到,Package资源剩下的部分是由多组RES\\_TABLE\\_TYPE\\_SPEC\\_TYPE和RES\\_TABLE\\_TYPE\\_TYPE构成的。\n\n一个RES\\_TABLE\\_TYPE\\_SPEC\\_TYPE后面跟着一个或者多个RES\\_TABLE\\_TYPE\\_TYPE构成一种类型的资源的描述(例如string类型、bool类型、dimen类型等)\n\n# RES\\_TABLE\\_TYPE\\_SPEC\\_TYPE\n\n我们接着来看看RES\\_TABLE\\_TYPE\\_SPEC\\_TYPE的头部结构体:\n\n```\n/**\n * A specification of the resources defined by a particular type.\n *\n * There should be one of these chunks for each resource type.\n *\n * This structure is followed by an array of integers providing the set of\n * configuration change flags (ResTable_config::CONFIG_*) that have multiple\n * resources for that configuration.  In addition, the high bit is set if that\n * resource has been made public.\n */\nstruct ResTable_typeSpec\n{\n    struct ResChunk_header header;\n\n    // The type identifier this chunk is holding.  Type IDs start\n    // at 1 (corresponding to the value of the type bits in a\n    // resource identifier).  0 is invalid.\n    uint8_t id;\n\n    // Must be 0.\n    uint8_t res0;\n    // Must be 0.\n    uint16_t res1;\n\n    // Number of uint32_t entry configuration masks that follow.\n    uint32_t entryCount;\n\n    enum {\n        // Additional flag indicating an entry is public.\n        SPEC_PUBLIC = 0x40000000\n    };\n};\n```\n\n\n从注释中可以知道ResTable\\_typeSpec头部后面会跟着entryCount个uint32\\_t,代表这种类型有entryCount个数据,并且每个uint32\\_t标识了这个数据在哪些configuration下有特殊的值。\n\n这些configuration可能是不同的地区、不同的屏幕分辨率、不同的sdk版本等:\n\n```\n// Flags indicating a set of config values.  These flag constants must\n// match the corresponding ones in android.content.pm.ActivityInfo and\n// attrs_manifest.xml.\nenum {\n    CONFIG_MCC = ACONFIGURATION_MCC,\n    CONFIG_MNC = ACONFIGURATION_MCC,\n    CONFIG_LOCALE = ACONFIGURATION_LOCALE,\n    CONFIG_TOUCHSCREEN = ACONFIGURATION_TOUCHSCREEN,\n    CONFIG_KEYBOARD = ACONFIGURATION_KEYBOARD,\n    CONFIG_KEYBOARD_HIDDEN = ACONFIGURATION_KEYBOARD_HIDDEN,\n    CONFIG_NAVIGATION = ACONFIGURATION_NAVIGATION,\n    CONFIG_ORIENTATION = ACONFIGURATION_ORIENTATION,\n    CONFIG_DENSITY = ACONFIGURATION_DENSITY,\n    CONFIG_SCREEN_SIZE = ACONFIGURATION_SCREEN_SIZE,\n    CONFIG_SMALLEST_SCREEN_SIZE = ACONFIGURATION_SMALLEST_SCREEN_SIZE,\n    CONFIG_VERSION = ACONFIGURATION_VERSION,\n    CONFIG_SCREEN_LAYOUT = ACONFIGURATION_SCREEN_LAYOUT,\n    CONFIG_UI_MODE = ACONFIGURATION_UI_MODE,\n    CONFIG_LAYOUTDIR = ACONFIGURATION_LAYOUTDIR,\n};\n```\n\n这里直接举个例子,例如我们可能会在res/values目录下创建一些bool配置:\n\n```\n<bool name=\"abc_action_bar_embed_tabs\">true</bool>\n<bool name=\"abc_allow_stacked_button_bar\">false</bool>\n<bool name=\"abc_config_actionMenuItemAllCaps\">true</bool>\n```\n\n然后可能在竖屏的情况下我们不需要显示action bar,所以在res/values-port目录下我们会把abc\\_action\\_bar\\_embed\\_tabs的值设置成false\n\n```\n<bool name=\"abc_action_bar_embed_tabs\">false</bool>\n```\n\n然后下面代码就能在横屏、竖屏下拿到不同的配置了:\n\n```\ncontext.getResources().getBoolean(R.bool.abc_action_bar_embed_tabs);\n```\n\n在代码里面,我们可以先读取ResTable\\_typeSpec,然后根据entryCount得到这种类型有多少个数据(例如这里的bool就有abc\\_action\\_bar\\_embed\\_tabs、abc\\_allow\\_stacked\\_button\\_bar、abc\\_config\\_actionMenuItemAllCaps三个数据,所以bool类型下的entryCount就是3),然后继续读entryCount个uint32\\_t,读出来就是每个数据在哪些configuration下有特殊的值。\n\n```\n//printStringFromStringsPool:\n\nvoid printStringFromStringsPool(uint32_t* pOffsets, char* pStringsStart, uint32_t stringIndex, uint32_t isUtf8) {\n    //前面两个字节是长度,要跳过\n    char* str = pStringsStart + *(pOffsets + stringIndex) + 2;\n    if(isUtf8) {\n        printf(\"%s\\n\", str);\n    } else {\n        printUtf16String((char16_t*)str);\n    }\n}\n\n\n//main:\n\n...\n\nResTable_typeSpec typeSpecHeader;\nuint32_t config;\nuint16_t type;\nwhile(fread((void*)&type, sizeof(u_int16_t), 1, pFile) != 0) {\n    fseek(pFile, -sizeof(uint16_t), SEEK_CUR);\n    if(RES_TABLE_TYPE_SPEC_TYPE == type) {\n        fread((void*)&typeSpecHeader, sizeof(struct ResTable_typeSpec), 1, pFile);\n        printf(\"type: id=0x%x,name=\", typeSpecHeader.id);\n        printStringFromStringsPool(\n                (uint32_t*)pTypeStrings,\n                (char*)pTypeStrings + typeStringPoolHeader.stringsStart - sizeof(struct ResStringPool_header),\n                typeSpecHeader.id - 1,\n                typeStringPoolHeader.flags & ResStringPool_header::UTF8_FLAG\n        );\n\n        for(int i = 0 ; i < typeSpecHeader.entryCount ; i++) {\n            fread((void*)&config, sizeof(uint32_t), 1, pFile);\n            printf(\"%x\\n\",config);\n        }\n    } \n\t...\n}\n\n...\n```\n\n我们直接找到bool类型下的打印:\n\n```\n...\ntype:id=3,name=bool\n80\n0\n0\n\n...\n```\n\n可以看到bool类型下的确有三个uint32\\_t,分别是80、0、0。这个80代表的就是CONFIG\\_ORIENTATION,也就是说这个数据在不同的屏幕方向下面会有和默认值不同的值。而0则代表了这个数据只有一个默认值,不会跟着configuration的变化而改变:\n\n```\n//configuration.h\nACONFIGURATION_ORIENTATION = 0x0080,\n\n//ResTable_config里面的enum\nCONFIG_ORIENTATION = ACONFIGURATION_ORIENTATION,\n\n```\n\n让我们返回去对比下:\n\n```\n// res/values目录下\n<bool name=\"abc_action_bar_embed_tabs\">true</bool>\n<bool name=\"abc_allow_stacked_button_bar\">false</bool>\n<bool name=\"abc_config_actionMenuItemAllCaps\">true</bool>\n\n// res/values-port目录下\n<bool name=\"abc_action_bar_embed_tabs\">false</bool>\n```\n\n第一个abc\\_action\\_bar\\_embed\\_tabs在不同的屏幕方向下可能值会改变,所以它的uint32\\_t值是80,也就是CONFIG\\_ORIENTATION,而abc\\_allow\\_stacked\\_button_bar 和abc\\_config\\_actionMenuItemAllCaps只有默认的配置,所以他们的uint32\\_t都是0。\n\n所以RES\\_TABLE\\_TYPE\\_SPEC\\_TYPE的作用就是将数据受到哪些configuration影响都标识出来。\n\n在读取数据的时候先看看它是否会受configuration影响,如果不会,直接读默认的RES\\_TABLE\\_TYPE\\_TYPE里面的默认值就好,否则就根据当前的configuration去到后面对应的RES\\_TABLE\\_TYPE\\_TYPE下面读取对应的值了。\n\n# RES\\_TABLE\\_TYPE\\_TYPE\n\n讲的这里终于到了最重要的部分,我们在xml里面配的值,都会在RES\\_TABLE\\_TYPE\\_TYPE里面体现出来。\n\n我们照例先来看看它的头部结构体:\n\n```\n/**\n * A collection of resource entries for a particular resource data\n * type. Followed by an array of uint32_t defining the resource\n * values, corresponding to the array of type strings in the\n * ResTable_package::typeStrings string block. Each of these hold an\n * index from entriesStart; a value of NO_ENTRY means that entry is\n * not defined.\n *\n * There may be multiple of these chunks for a particular resource type,\n * supply different configuration variations for the resource values of\n * that type.\n *\n * It would be nice to have an additional ordered index of entries, so\n * we can do a binary search if trying to find a resource by string name.\n */\nstruct ResTable_type\n{\n    struct ResChunk_header header;\n\n    enum {\n        NO_ENTRY = 0xFFFFFFFF\n    };\n\n    // The type identifier this chunk is holding.  Type IDs start\n    // at 1 (corresponding to the value of the type bits in a\n    // resource identifier).  0 is invalid.\n    uint8_t id;\n\n    // Must be 0.\n    uint8_t res0;\n    // Must be 0.\n    uint16_t res1;\n\n    // Number of uint32_t entry indices that follow.\n    uint32_t entryCount;\n\n    // Offset from header where ResTable_entry data starts.\n    uint32_t entriesStart;\n\n    ResTable_config config;\n};\n```\n\n这个ResTable\\_type里有个config成员,它就是具体的配置了,我们可以把它打印出来:\n\n```\nelse if(RES_TABLE_TYPE_TYPE == type) {\n    fread((void*)&typeHeader, sizeof(struct ResTable_type), 1, pFile);\n    printConfig(typeHeader.config);\n    ...\n}\n```\n\n找到bool的那一段,可以看到它有两个RES\\_TABLE\\_TYPE\\_TYPE,第一个是默认的配置(values目录),第二个是port下的配置(values-port目录):\n\n```\n...\ntype: id=0x3,name=bool\n80\n0\n0\nconfig : \nconfig : port\n...\n```\n\n然后根据注释的说明我们知道,ResTable\\_type头部后跟着entryCount个uint32\\_t,代表了每个entry相对entriesStart的偏移。这里和RES\\_STRING\\_POOL\\_TYPE有点像,也是从偏移数组读取数据的偏移值,然后从entriesStart进行偏移得到数据的地址。\n\n{% img /可能是全网讲最细的安卓resources_arsc解析教程二/1.png %}\n\n\n那entriesStart后面的entry是什么呢？其实entry有两种类型ResTable\\_entry和ResTable\\_map\\_entry。\n\n他们其实是有继承关系的,ResTable\\_map\\_entry是ResTable\\_entry的子类(这里的继承关系是c++里面的继承关系,前面我们都是用c语言去讲的,但是这里必须引入c++了,不过也是最基础的继承而已,大家可以自行搜索下)。\n\n\n```\n/**\n * This is the beginning of information about an entry in the resource\n * table.  It holds the reference to the name of this entry, and is\n * immediately followed by one of:\n *   * A Res_value structure, if FLAG_COMPLEX is -not- set.\n *   * An array of ResTable_map structures, if FLAG_COMPLEX is set.\n *     These supply a set of name/value mappings of data.\n */\nstruct ResTable_entry\n{\n    // Number of bytes in this structure.\n    uint16_t size;\n\n    enum {\n        // If set, this is a complex entry, holding a set of name/value\n        // mappings.  It is followed by an array of ResTable_map structures.\n        FLAG_COMPLEX = 0x0001,\n        // If set, this resource has been declared public, so libraries\n        // are allowed to reference it.\n        FLAG_PUBLIC = 0x0002,\n        // If set, this is a weak resource and may be overriden by strong\n        // resources of the same name/type. This is only useful during\n        // linking with other resource tables.\n        FLAG_WEAK = 0x0004\n    };\n    uint16_t flags;\n\n    // Reference into ResTable_package::keyStrings identifying this entry.\n    struct ResStringPool_ref key;\n};\n\n\n/**\n * Extended form of a ResTable_entry for map entries, defining a parent map\n * resource from which to inherit values.\n */\nstruct ResTable_map_entry : public ResTable_entry\n{\n    // Resource identifier of the parent mapping, or 0 if there is none.\n    ResTable_ref parent;\n    // Number of name/value pairs that follow for FLAG_COMPLEX.\n    uint32_t count;\n};\n```\n\n看到注释我们可以知道, ResTable\\_entry有个flags成员变量,如果它的FLAG\\_COMPLEX位被置1(也就是说flags & 0x0001 != 0),则它是个ResTable\\_map\\_entry结构。\n\n两种结构的不同之处在于ResTable\\_entry后面跟着的是一个Res\\_value,而ResTable\\_map\\_entry后面跟着的是多个name/value键值对,这个键值对是用struct ResTable\\_map来表示的。\n\n\n## ResTable\\_entry\n\n我们先从ResTable\\_entry讲起,我们读完struct ResTable\\_type头部信息之后继续将offset数组和entriesStart开始到剩下的部分都读进去保存到pOffset和pData中。\n\n\n接着就可以用*(pOffsets + i)得到每个entry的偏移,再与entriesStart相加得到entry的具体位置。这里有一点需要注意的是如果offset是ResTable_type::NO\\_ENTRY,也就是0xFFFFFFFF的时候,代表它是无效的,直接跳过即可:\n\n\n```\nelse if(RES_TABLE_TYPE_TYPE == type) {\n    fread((void*)&typeHeader, sizeof(struct ResTable_type), 1, pFile);\n    printConfig(typeHeader.config);\n\n    // 实际struct ResTable_type的大小可能不同sdk版本不一样,所以typeHeader.header.headerSize才是真正的头部大小\n    fseek(pFile, typeHeader.header.headerSize -  sizeof(struct ResTable_type), SEEK_CUR);;\n\n    uint32_t* pOffsets = (uint32_t*)malloc(typeHeader.entryCount * sizeof(uint32_t));\n    fread((void*)pOffsets, sizeof(uint32_t), typeHeader.entryCount, pFile);\n\n    unsigned char* pData = (unsigned char*)malloc(typeHeader.header.size - typeHeader.entriesStart);\n    fread((void*)pData, typeHeader.header.size - typeHeader.entriesStart, 1, pFile);\n\n    for(int i = 0 ; i< typeHeader.entryCount ; i++) {\n        uint32_t offset = *(pOffsets + i);\n        if(offset == ResTable_type::NO_ENTRY) {\n            continue;\n        }\n        struct ResTable_entry* pEntry = (struct ResTable_entry*)(pData + offset);\n        printf(\"entryIndex: 0x%x, key :\\n\", i);\n        printStringFromStringsPool(\n            (uint32_t*)pKeyStrings,\n            (char*)pKeyStrings + keyStringPoolHeader.stringsStart - sizeof(struct ResStringPool_header),\n            pEntry->key.index,\n            keyStringPoolHeader.flags & ResStringPool_header::UTF8_FLAG\n        );\n        if(pEntry->flags & ResTable_entry::FLAG_COMPLEX) {\n           ...\n        } else {\n            struct Res_value* pValue = (struct Res_value*)((unsigned char*)pEntry + sizeof(struct ResTable_entry));\n            printf(\"value :\\n\");\n            printValue(pValue, globalStringPoolHeader, pGlobalStrings);\n            printf(\"\\n\");\n        }\n    }\n    free(pOffsets);\n    free(pData);\n}\n```\n\npEntry->key.index就是资源的key在资源key字符串池中的序号了,直接打印即可。\n\n然后找到struct ResTable\\_entry后面跟着的struct Res\\_value,这个结构体里面就是资源的值。但是这个值的获取比较复杂,我们先来看看这个结构体的定义:\n\n```\n\n/**\n * Representation of a value in a resource, supplying type\n * information.\n */\nstruct Res_value\n{\n    // Number of bytes in this structure.\n    uint16_t size;\n\n    // Always set to 0.\n    uint8_t res0;\n\n    // Type of the data value.\n    enum {\n        // The 'data' is either 0 or 1, specifying this resource is either\n        // undefined or empty, respectively.\n        TYPE_NULL = 0x00,\n        // The 'data' holds a ResTable_ref, a reference to another resource\n        // table entry.\n        TYPE_REFERENCE = 0x01,\n        // The 'data' holds an attribute resource identifier.\n        TYPE_ATTRIBUTE = 0x02,\n        // The 'data' holds an index into the containing resource table's\n        // global value string pool.\n        TYPE_STRING = 0x03,\n        // The 'data' holds a single-precision floating point number.\n        TYPE_FLOAT = 0x04,\n        // The 'data' holds a complex number encoding a dimension value,\n        // such as \"100in\".\n        TYPE_DIMENSION = 0x05,\n        // The 'data' holds a complex number encoding a fraction of a\n        // container.\n        TYPE_FRACTION = 0x06,\n        // The 'data' holds a dynamic ResTable_ref, which needs to be\n        // resolved before it can be used like a TYPE_REFERENCE.\n        TYPE_DYNAMIC_REFERENCE = 0x07,\n        // The 'data' holds an attribute resource identifier, which needs to be resolved\n        // before it can be used like a TYPE_ATTRIBUTE.\n        TYPE_DYNAMIC_ATTRIBUTE = 0x08,\n        \n        // Beginning of integer flavors...\n        TYPE_FIRST_INT = 0x10,\n\n        // The 'data' is a raw integer value of the form n..n.\n        TYPE_INT_DEC = 0x10,\n        // The 'data' is a raw integer value of the form 0xn..n.\n        TYPE_INT_HEX = 0x11,\n        // The 'data' is either 0 or 1, for input \"false\" or \"true\" respectively.\n        TYPE_INT_BOOLEAN = 0x12,\n\n        // Beginning of color integer flavors...\n        TYPE_FIRST_COLOR_INT = 0x1c,\n\n        // The 'data' is a raw integer value of the form #aarrggbb.\n        TYPE_INT_COLOR_ARGB8 = 0x1c,\n        // The 'data' is a raw integer value of the form #rrggbb.\n        TYPE_INT_COLOR_RGB8 = 0x1d,\n        // The 'data' is a raw integer value of the form #argb.\n        TYPE_INT_COLOR_ARGB4 = 0x1e,\n        // The 'data' is a raw integer value of the form #rgb.\n        TYPE_INT_COLOR_RGB4 = 0x1f,\n\n        // ...end of integer flavors.\n        TYPE_LAST_COLOR_INT = 0x1f,\n\n        // ...end of integer flavors.\n        TYPE_LAST_INT = 0x1f\n    };\n    uint8_t dataType;\n    \n     // Structure of complex data values (TYPE_UNIT and TYPE_FRACTION)\n    enum {\n        // Where the unit type information is.  This gives us 16 possible\n        // types, as defined below.\n        COMPLEX_UNIT_SHIFT = 0,\n        COMPLEX_UNIT_MASK = 0xf,\n\n        // TYPE_DIMENSION: Value is raw pixels.\n        COMPLEX_UNIT_PX = 0,\n        // TYPE_DIMENSION: Value is Device Independent Pixels.\n        COMPLEX_UNIT_DIP = 1,\n        // TYPE_DIMENSION: Value is a Scaled device independent Pixels.\n        COMPLEX_UNIT_SP = 2,\n        // TYPE_DIMENSION: Value is in points.\n        COMPLEX_UNIT_PT = 3,\n        // TYPE_DIMENSION: Value is in inches.\n        COMPLEX_UNIT_IN = 4,\n        // TYPE_DIMENSION: Value is in millimeters.\n        COMPLEX_UNIT_MM = 5,\n\n        // TYPE_FRACTION: A basic fraction of the overall size.\n        COMPLEX_UNIT_FRACTION = 0,\n        // TYPE_FRACTION: A fraction of the parent size.\n        COMPLEX_UNIT_FRACTION_PARENT = 1,\n\n        // Where the radix information is, telling where the decimal place\n        // appears in the mantissa.  This give us 4 possible fixed point\n        // representations as defined below.\n        COMPLEX_RADIX_SHIFT = 4,\n        COMPLEX_RADIX_MASK = 0x3,\n\n        // The mantissa is an integral number -- i.e., 0xnnnnnn.0\n        COMPLEX_RADIX_23p0 = 0,\n        // The mantissa magnitude is 16 bits -- i.e, 0xnnnn.nn\n        COMPLEX_RADIX_16p7 = 1,\n        // The mantissa magnitude is 8 bits -- i.e, 0xnn.nnnn\n        COMPLEX_RADIX_8p15 = 2,\n        // The mantissa magnitude is 0 bits -- i.e, 0x0.nnnnnn\n        COMPLEX_RADIX_0p23 = 3,\n        \n        // Where the actual value is.  This gives us 23 bits of\n        // precision.  The top bit is the sign.\n        COMPLEX_MANTISSA_SHIFT = 8,\n        COMPLEX_MANTISSA_MASK = 0xffffff\n    };\n\n    // Possible data values for TYPE_NULL.\n    enum {\n        // The value is not defined.\n        DATA_NULL_UNDEFINED = 0,\n        // The value is explicitly defined as empty.\n        DATA_NULL_EMPTY = 1\n    };\n\n    // The data for this item, as interpreted according to dataType.\n    typedef uint32_t data_type;\n    data_type data;\n};\n```\n\n我们先需要根据dataType判断这个值是什么类型的,然后再根据不同的类型,从data读取具体的值。读取的方法比较复杂,我就不具体讲解,大家可以参考我的demo代码理解。\n\n我们找到bool部分的打印,可以看到key和value就都打印出来了:\n\n```\ntype: id=0x3,name=bool\n80\n0\n0\nconfig :\nentryIndex: 0x0, key :\nabc_action_bar_embed_tabs\nvalue :\n(boolean) true\n\nentryIndex: 0x1, key :\nabc_allow_stacked_button_bar\nvalue :\n(boolean) false\n\nentryIndex: 0x2, key :\nabc_config_actionMenuItemAllCaps\nvalue :\n(boolean) true\n\nconfig : port\nentryIndex: 0x0, key :\nabc_action_bar_embed_tabs\nvalue :\n(boolean) false\n```\n\n## ResTable\\_map\\_entry\n\n从上面可以看出来ResTable\\_entry代表的是普通键值对的资源如string、bool、drawable等,那ResTable\\_map\\_entry又代表的是啥呢?\n\n其实它代表的是类型style、attr的资源:\n\n```\n<attr name=\"buttonTintMode\">\n\t<enum name=\"src_over\" value=\"3\"/>\n\t<enum name=\"src_in\" value=\"5\"/>\n\t<enum name=\"src_atop\" value=\"9\"/>\n\t<enum name=\"multiply\" value=\"14\"/>\n\t<enum name=\"screen\" value=\"15\"/>\n\t<enum name=\"add\" value=\"16\"/>\n</attr>\n\n<style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\">\n        <item name=\"colorPrimary\">@color/colorPrimary</item>\n        <item name=\"colorPrimaryDark\">@color/colorPrimaryDark</item>\n        <item name=\"colorAccent\">@color/colorAccent</item>\n</style>\n```\n\n像上面的R.attr.buttonTintMode和R.style.AppTheme的值都需要用一个map去表示。\n\n我们来看看struct ResTable\\_map\\_entry:\n\n```\n/**\n * Extended form of a ResTable_entry for map entries, defining a parent map\n * resource from which to inherit values.\n */\nstruct ResTable_map_entry : public ResTable_entry\n{\n    // Resource identifier of the parent mapping, or 0 if there is none.\n    ResTable_ref parent;\n    // Number of name/value pairs that follow for FLAG_COMPLEX.\n    uint32_t count;\n};\n```\n\n它的parent成员变量就定义了这个style的parent,count成员变量则代表了这个map的大小,也就是ResTable\\_map\\_entry后面跟着的键值对的数量。\n\n### 资源的id\n\nstruct ResTable\\_ref也是一个需要重点讲解的结构体,它的定义很简单:\n\n```\n/**\n *  This is a reference to a unique entry (a ResTable_entry structure)\n *  in a resource table.  The value is structured as: 0xpptteeee,\n *  where pp is the package index, tt is the type index in that\n *  package, and eeee is the entry index in that type.  The package\n *  and type values start at 1 for the first item, to help catch cases\n *  where they have not been supplied.\n */\nstruct ResTable_ref\n{\n    uint32_t ident;\n};\n```\n\n这个ident代表的就是资源的id。这个值其实我们在java里面也能看到:\n\n```\npublic final class R {\n\t...\n\tpublic static final class bool {\n\t    public static final int abc_action_bar_embed_tabs=0x7f030000;\n\t    public static final int abc_allow_stacked_button_bar=0x7f030001;\n\t    public static final int abc_config_actionMenuItemAllCaps=0x7f030002;\n\t  }\n\t...\n}\n```\n\n资源的id其实是有固定的格式和含义的,它的格式如下:\n\n> 0xpptteeee\n\n头一个字节保存了packageId,接着的一个字节保存了typeId,后面的两个字节保存了entryIndex。例如我们的abc\\_allow\\_stacked\\_button\\_bar=0x7f030001,它的packageId=0x7f, typeId=0x3, entryIndex=0x1。\n\n我们在解析package资源的时候就已经把package id打印了出来,它就是0x7f:\n\n```\ntype:512, headSize:288, size:188068, id:7f, packageName:com.cvte.tv.myapplication\n```\n\n而在后面解析资源的时候也把typeId和entryIndex打印了出来:\n\n```\ntype: id=0x3,name=bool\n80\n0\n0\nconfig :\nentryIndex: 0x0, key :\nabc_action_bar_embed_tabs\nvalue :\n(boolean) true\n\nentryIndex: 0x1, key :\nabc_allow_stacked_button_bar\n```\n\n于是乎我们就能定位到abc\\_allow\\_stacked\\_button\\_bar这个资源了。\n\n所以我们的style的parent.ident就可以定位到style的parent资源。\n\n有时候我们会看到packageId是0x01,在我们的resource.arsc里面找不到对应的package。这个package指定其实是系统资源包,我们在xml里面配置的@android:color/black就会使用到系统资源包里面的资源,这个资源是不会打包进我们的应用的:\n\n```\n...\n\ntype: id=0x4,name=color\n\n...\n\nentryIndex: 0x41, key :\nprimary_dark_material_dark\nvalue :\n(reference) 0x0106000c\n\n...\n```\n\n### ResTable\\_map\n\nResTable\\_map\\_entry后面跟着的键值对数组其实就是一个个的ResTable\\_map:\n\n{% img /可能是全网讲最细的安卓resources_arsc解析教程二/2.png %}\n\nstruct ResTable\\_map定义如下:\n\n```\n/**\n * A single name/value mapping that is part of a complex resource\n * entry.\n */\nstruct ResTable_map\n{\n    // The resource identifier defining this mapping's name.  For attribute\n    // resources, 'name' can be one of the following special resource types\n    // to supply meta-data about the attribute; for all other resource types\n    // it must be an attribute resource.\n    ResTable_ref name;\n\n    // Special values for 'name' when defining attribute resources.\n    enum {\n        // This entry holds the attribute's type code.\n        ATTR_TYPE = Res_MAKEINTERNAL(0),\n\n        // For integral attributes, this is the minimum value it can hold.\n        ATTR_MIN = Res_MAKEINTERNAL(1),\n\n        // For integral attributes, this is the maximum value it can hold.\n        ATTR_MAX = Res_MAKEINTERNAL(2),\n\n        // Localization of this resource is can be encouraged or required with\n        // an aapt flag if this is set\n        ATTR_L10N = Res_MAKEINTERNAL(3),\n\n        // for plural support, see android.content.res.PluralRules#attrForQuantity(int)\n        ATTR_OTHER = Res_MAKEINTERNAL(4),\n        ATTR_ZERO = Res_MAKEINTERNAL(5),\n        ATTR_ONE = Res_MAKEINTERNAL(6),\n        ATTR_TWO = Res_MAKEINTERNAL(7),\n        ATTR_FEW = Res_MAKEINTERNAL(8),\n        ATTR_MANY = Res_MAKEINTERNAL(9)\n\n    };\n    \n     // Bit mask of allowed types, for use with ATTR_TYPE.\n    enum {\n        // No type has been defined for this attribute, use generic\n        // type handling.  The low 16 bits are for types that can be\n        // handled generically; the upper 16 require additional information\n        // in the bag so can not be handled generically for TYPE_ANY.\n        TYPE_ANY = 0x0000FFFF,\n\n        // Attribute holds a references to another resource.\n        TYPE_REFERENCE = 1<<0,\n\n        // Attribute holds a generic string.\n        TYPE_STRING = 1<<1,\n\n        // Attribute holds an integer value.  ATTR_MIN and ATTR_MIN can\n        // optionally specify a constrained range of possible integer values.\n        TYPE_INTEGER = 1<<2,\n\n        // Attribute holds a boolean integer.\n        TYPE_BOOLEAN = 1<<3,\n\n        // Attribute holds a color value.\n        TYPE_COLOR = 1<<4,\n\n        // Attribute holds a floating point value.\n        TYPE_FLOAT = 1<<5,\n\n        // Attribute holds a dimension value, such as \"20px\".\n        TYPE_DIMENSION = 1<<6,\n\n        // Attribute holds a fraction value, such as \"20%\".\n        TYPE_FRACTION = 1<<7,\n\n        // Attribute holds an enumeration.  The enumeration values are\n        // supplied as additional entries in the map.\n        TYPE_ENUM = 1<<16,\n\n        // Attribute holds a bitmaks of flags.  The flag bit values are\n        // supplied as additional entries in the map.\n        TYPE_FLAGS = 1<<17\n        };\n\n    // Enum of localization modes, for use with ATTR_L10N.\n    enum {\n        L10N_NOT_REQUIRED = 0,\n        L10N_SUGGESTED    = 1\n    };\n\n    // This mapping's value.\n    Res_value value;\n};\n```\n\n它的name代表的就是这个键值对的key,而它的value代表的就是键值对的值。\n\nname同样的是个struct ResTable\\_ref,它同样可以从资源id拿到对应的资源,但是这个name有点特殊,如果是它的ident的值是下面枚举中的一个的话:\n\n```\n#define Res_MAKEINTERNAL(entry) (0x01000000 | (entry&0xFFFF))\n\nenum {\n    // This entry holds the attribute's type code.\n    ATTR_TYPE = Res_MAKEINTERNAL(0),\n\n    // For integral attributes, this is the minimum value it can hold.\n    ATTR_MIN = Res_MAKEINTERNAL(1),\n\n    // For integral attributes, this is the maximum value it can hold.\n    ATTR_MAX = Res_MAKEINTERNAL(2),\n\n    // Localization of this resource is can be encouraged or required with\n    // an aapt flag if this is set\n    ATTR_L10N = Res_MAKEINTERNAL(3),\n\n    // for plural support, see android.content.res.PluralRules#attrForQuantity(int)\n    ATTR_OTHER = Res_MAKEINTERNAL(4),\n    ATTR_ZERO = Res_MAKEINTERNAL(5),\n    ATTR_ONE = Res_MAKEINTERNAL(6),\n    ATTR_TWO = Res_MAKEINTERNAL(7),\n    ATTR_FEW = Res_MAKEINTERNAL(8),\n    ATTR_MANY = Res_MAKEINTERNAL(9)\n};\n```\n\n例如如果index==0x01000000,就代表name是ATTR\\_TYPE,也代表这个资源是attr。\n\n此时,它的value也是特殊的,是下面枚举中的一个,代表attr的类型:\n\n```\nenum {\n    // No type has been defined for this attribute, use generic\n    // type handling.  The low 16 bits are for types that can be\n    // handled generically; the upper 16 require additional information\n    // in the bag so can not be handled generically for TYPE_ANY.\n    TYPE_ANY = 0x0000FFFF,\n\n    // Attribute holds a references to another resource.\n    TYPE_REFERENCE = 1<<0,\n\n    // Attribute holds a generic string.\n    TYPE_STRING = 1<<1,\n\n    // Attribute holds an integer value.  ATTR_MIN and ATTR_MIN can\n    // optionally specify a constrained range of possible integer values.\n    TYPE_INTEGER = 1<<2,\n\n    // Attribute holds a boolean integer.\n    TYPE_BOOLEAN = 1<<3,\n\n    // Attribute holds a color value.\n    TYPE_COLOR = 1<<4,\n\n    // Attribute holds a floating point value.\n    TYPE_FLOAT = 1<<5,\n\n    // Attribute holds a dimension value, such as \"20px\".\n    TYPE_DIMENSION = 1<<6,\n\n    // Attribute holds a fraction value, such as \"20%\".\n    TYPE_FRACTION = 1<<7,\n\n    // Attribute holds an enumeration.  The enumeration values are\n    // supplied as additional entries in the map.\n    TYPE_ENUM = 1<<16,\n\n    // Attribute holds a bitmaks of flags.  The flag bit values are\n    // supplied as additional entries in the map.\n    TYPE_FLAGS = 1<<17\n};\n```\n\n解析代码如下:\n\n```\nif(pEntry->flags & ResTable_entry::FLAG_COMPLEX) {\n    struct ResTable_map_entry* pMapEntry = (struct ResTable_map_entry*)(pData + offset);\n    for(int i = 0; i <pMapEntry->count ; i++) {\n        struct ResTable_map* pMap = (struct ResTable_map*)(pData + offset + pMapEntry->size + i * sizeof(struct ResTable_map_entry));\n        printf(\"\\tname:0x%x, valueType:%u, value:%u\\n\", pMap->name.ident, pMap->value.dataType, pMap->value.data);\n    }\n}\n```\n\n让我们找到buttonTintMode的打印\n\n\n```\nentryIndex: 0x69, key :\nbuttonTintMode\n    name:0x1000000, valueType:16, value:65536\n    name:0x7f070019, valueType:16, value:16\n    name:0x7f070050, valueType:16, value:14\n    name:0x7f070061, valueType:16, value:15\n    name:0x7f070078, valueType:16, value:9\n    name:0x7f070079, valueType:16, value:5\n    name:0x7f07007a, valueType:16, value:3\n```\n\n第一个ResTable\\_ref的name的indent的值是0x1000000,就代表name是ATTR\\_TYPE,也代表这个资源是attr。然后value是65536,也就是TYPE\\_ENUM。\n\n\n然后我们顺便找下7f070019、7f070050、7f070061、7f070078、7f070079、7f07007a资源的定义:\n\n```\n...\n\ntype: id=0x7,name=id\n\n...\n\nentryIndex: 0x19, key :\nadd\nvalue :\n(boolean) false\n\n...\n\nentryIndex: 0x50, key :\nmultiply\nvalue :\n(boolean) false\n\n...\n\nentryIndex: 0x61, key :\nscreen\nvalue :\n(boolean) false\n\n...\n\nentryIndex: 0x78, key :\nsrc_atop\nvalue :\n(boolean) false\n\nentryIndex: 0x79, key :\nsrc_in\nvalue :\n(boolean) false\n\nentryIndex: 0x7a, key :\nsrc_over\nvalue :\n(boolean) false\n```\n\n# Demo\n\n完整的demo可以在github上找到:\n\nhttps://github.com/bluesky466/ResourcesArscDemo\n\n呼~长舒一口气,终于大功告成。","tags":["技术相关","Android"]},{"title":"可能是全网讲最细的安卓resources.arsc解析教程(一)","url":"/2019/05/18/可能是全网讲最细的安卓resources-arsc解析教程-一/","content":"\naapt工具在编译资源会将一些资源或者资源索引打包成resources.arsc。这个文件以二进制数据的形式记录数据，c/c++加载起来特别方便。\n\n了解resources.arsc的结构对理解安卓的资源加载原理有很重要的帮助。\n\n这几天写resources.arsc解析工具时候在网上搜到了不少的资料、博客，但是它们写的都不是特别的详细，都会漏掉一些东西没有提。导致在实现的时候遇到了很多的坑。这里我希望尽量把自己总结出来的东西一步步都列出来，尽量做到只需要看这篇博客就能自己实现一个resources.arsc的解析器。\n\n这个[工具](https://github.com/bluesky466/ResourcesParser)已经在github上开源(使用C++11,已经在mac和ubuntu上报make编译通过正常运行,Windows的同学就只好说声抱歉了)，感兴趣的同学也可以直接下载下来玩玩。\n\n# 总体结构\n\nresources.arsc是以一个个Chunk块的形式组织的,Chunk的头部信息记录了这个Chunk的类型、长度等数据。\n\n从整体上来看，其结构为：资源索引表头部+字符串资源池+N个Package数据块:\n\n{% img /可能是全网讲最细的安卓resources_arsc解析教程一/1.png %}\n\n# 头部数据解析\n\n整个resources.arsc就是一个Chunk块，所以文件的开头就是这个Chunk的头部信息.不过需要注意的是resources.arsc文件采用_小端编码_方式.所以数据应该按字节从后往前读。\n\n头部的结构如下:\n\n头部类型(两个字节)，头部大小(两个字节)，Chunk块大小(四个字节)\n\n我们找一个apk文件，将它后缀改成.zip直接解压，就可以得到resources.arsc，这里实际举个例子，用编辑工具查看到resources.arsc的前8个字节的数据，这里以16进制显示:\n\n```\n0200 0c00 acb6 0300\n```\n\n首先头部类型的两个字节是0200(每两个16进制数字代表了一个字节)，但是这里是小端序，所以要从后往前读，得到实际的值0x0002。\n\n> 02 00 -> 00 02\n\nresources.arsc内部记录的数据类型在ResourceTypes.h里面定义，我们找到头部类型的枚举，可以查到0x0002对应的类型是RES\\_TABLE\\_TYPE。返回去看上面的图，可以看到类型的确是RES\\_TABLE\\_TYPE。\n\n```\nenum {                                                                                                          \n    RES_NULL_TYPE               = 0x0000,                                                                       \n    RES_STRING_POOL_TYPE        = 0x0001,                                                                       \n    RES_TABLE_TYPE              = 0x0002,                                                                       \n    RES_XML_TYPE                = 0x0003,                                                                       \n\n    // Chunk types in RES_XML_TYPE                                                                              \n    RES_XML_FIRST_CHUNK_TYPE    = 0x0100,                                                                       \n    RES_XML_START_NAMESPACE_TYPE= 0x0100,                                                                       \n    RES_XML_END_NAMESPACE_TYPE  = 0x0101,                                                                       \n    RES_XML_START_ELEMENT_TYPE  = 0x0102,                                                                       \n    RES_XML_END_ELEMENT_TYPE    = 0x0103,                                                                       \n    RES_XML_CDATA_TYPE          = 0x0104,                                                                       \n    RES_XML_LAST_CHUNK_TYPE     = 0x017f,                                                                       \n    // This contains a uint32_t array mapping strings in the string              \n    // pool back to resource identifiers.  It is optional.                       \n    RES_XML_RESOURCE_MAP_TYPE   = 0x0180,                                                                       \n\n    // Chunk types in RES_TABLE_TYPE                                                                            \n    RES_TABLE_PACKAGE_TYPE      = 0x0200,                                                                       \n    RES_TABLE_TYPE_TYPE         = 0x0201,                                                                       \n    RES_TABLE_TYPE_SPEC_TYPE    = 0x0202,                                                                       \n    RES_TABLE_LIBRARY_TYPE      = 0x0203                                                                        \n};\n```\n\n\n接着是头部大小的两个字节0c00(每两个16进制数字代表了一个字节)，从后往前读得到实际值0x000c，也就是说这个头部大小有12个字节\n\n> 0c 00 -> 00 0c\n\n再接着的是Chunk块大小的四个字节acb6 0300(每两个16进制数字代表了一个字节),从后往前读得到实际值0x0003b6ac，转换回十进制是243372，也就是说resources.arsc文件的大小是243372字节。\n\n> ac b6 03 00 -> 00 03 b6 ac\n\n我们可以用wc命令查看这个文件的大小:\n\n```\nwc resources.arsc\n277   2932 243372 resources.arsc\n```\n\nresources.arsc文件这样组织的原因是可以很方便的使用c/c++去加载。\n\n我们在源码里面找到Chunk头部信息的ResChunk\\_header结构体:\n\n```\n/**                                                                                                             \n* Header that appears at the front of every data chunk in a resource.            \n*/                                                                                                              \nstruct ResChunk_header                                                                                          \n{                                                                                                               \n   // Type identifier for this chunk.  The meaning of this value depends         \n   // on the containing chunk.                                                                                  \n   uint16_t type;                                                                                               \n\n   // Size of the chunk header (in bytes).  Adding this value to                 \n   // the address of the chunk allows you to find its associated data            \n   // (if any).                                                                                                 \n   uint16_t headerSize;                                                                                         \n\n   // Total size of this chunk (in bytes).  This is the chunkSize plus           \n   // the size of any data associated with the chunk.  Adding this value         \n   // to the chunk allows you to completely skip its contents (including         \n   // any child chunks).  If this value is the same as chunkSize, there is       \n   // no data associated with the chunk.                                                                        \n   uint32_t size;                                                                                               \n};  \n```\n\n下面就是show time了，由于普通机器设备上使用的都是小端序号,所以用c语言解析resources.arsc文件的头部信息只要直接填充ResChunk\\_header结构体就好了:\n\n\n```\n#include <stdio.h>                                                               \n#include <stdlib.h>                                                              \n#include <stdint.h>                                                              \n\nstruct ResChunk_header {                                                         \n    uint16_t type;                                                               \n    int16_t headerSize;                                                          \n    uint32_t size;                                                               \n};                                                                               \n\nint main(int argc, char *argv[]) {                                               \n    struct ResChunk_header header;                                               \n\n    FILE* pFile = fopen(argv[1], \"rb\");                                          \n    fread((void*)&header, sizeof(struct ResChunk_header), 1, pFile);             \n    fclose(pFile);                                                               \n\n    printf(\"type:%u, headSize:%u, size:%u\\n\", header.type, header.headerSize, header.size);\n    return 0;                                                                    \n}\n```\n\n编译后运行,查看打印:\n\n```\n./a.out resources.arsc\ntype:2, headSize:12, size:243372\n```\n\n## 头部类型\n\n每个头部类型都会有一个具体的结构体和它对应,例如我们的RES\\_TABLE\\_TYPE类型对应的就是ResTable\\_header:\n\n```\nstruct ResTable_header                                                           \n{                                                                                \n    struct ResChunk_header header;                                               \n\n    uint32_t packageCount;                                                       \n};\n```\n\n这些结构体的第一个成员都是是ResChunk\\_header，然后后面才是这个类型的特有数据。所以我们改下代码去读取完整的头部信息:\n\n```\n#include <stdio.h>                                                               \n#include <stdlib.h>                                                              \n#include <stdint.h>                                                              \n\nstruct ResChunk_header {                                                         \n    uint16_t type;                                                               \n    int16_t headerSize;                                                          \n    uint32_t size;                                                               \n};                                                                               \n\nstruct ResTable_header{                                                          \n    struct ResChunk_header header;                                               \n    uint32_t packageCount;                                                       \n};                                                                               \n\nint main(int argc, char *argv[]) {                                               \n    uint16_t type;                                                               \n\n    FILE* pFile = fopen(argv[1], \"rb\");                                          \n    fread((void*)&type, sizeof(type), 1, pFile);                                 \n    if(type == RES_TABLE_TYPE) {                                                          \n        struct ResTable_header header = {0x002};                                 \n        fread((void*)(((char*)&header)+2), sizeof(struct ResTable_header)-2, 1, pFile);\n        printf(\"type:%u, headSize:%u, size:%u, packageCount:%u\\n\",           \n                header.header.type,                                              \n                header.header.headerSize,                                        \n                header.header.size,                                              \n                header.packageCount);                                            \n    }                                                                            \n    fclose(pFile);                                                               \n    return 0;                                                                    \n}\n```\n\n运行得到:\n\n```\n./a.out resources.arsc\ntype:2, headSize:12, size:243372, packageCount:1\n```\n\n这里的packageCount指的是resources.arsc里面包含了多少个package的资源,一般只有一个。\n\n到这里，RES\\_TABLE\\_TYPE的头部信息我们就解析完成了。\n\n# 全局字符串池\n\n{% img /可能是全网讲最细的安卓resources_arsc解析教程一/3.png %}\n\n我们看回上面的图，头部之后紧接着的是Global String Pool。它其实也是一个Chunk，所以也有头部。我们可以用同样的方法去解析:\n\n```\nstruct ResStringPool_header readResStringPoolHeader(FILE* pFile) {               \n    struct ResStringPool_header header;                                          \n    uint16_t type;                                                               \n    fread((void*)&header, sizeof(struct ResStringPool_header), 1, pFile);        \n    printf(\"type:%u, headSize:%u, size:%u, stringCount:%u, stringStart:%u, styleCount:%u, styleStart:%u\\n\",\n                header.header.type,                                              \n                header.header.headerSize,                                        \n                header.header.size,                                              \n                header.stringCount,                                              \n                header.stringsStart,                                             \n                header.styleCount,                                               \n                header.stylesStart);                                             \n    return header;                                                               \n}\n```\n\n打印如下，这个字符串池里面有1971个字符串:\n\n```\n./a.out resources.arsc\ntype:2, headSize:12, size:243372, packageCount:1\ntype:1, headSize:28, size:72732, stringCount:1971, stringStart:7912, styleCount:0, styleStart:0\n```\n\n接着看图，ResStringPool\\_header后面跟着的是\n\n字符串偏移数组+style偏移数组+字符串+style\n\nresources.arsc会把所有的应用里面出现的字符串都放到这个全局字符串池里面，不过style的话我现在还没有理解它的作用，遇到的值都是0，所以这里先忽略。我们只讲字符串。\n\n这个字符串偏移数组其实是一个uint32\\_t的数组,记录了每个字符串距离stringStart的偏移，而stringStart就是具体存放字符串的内存的位置距离ResStringPool\\_header起始地址的字节数。\n\n需要注意的是，字符串的前两个字节记录了字符串的长度，而且字符串的编码格式由ResStringPool\\_header::flags指定(utf-8或者utf-16)\n\n可能这么讲有些抽象，可以结合下面的示意图还有代码理解一下:\n\n{% img /可能是全网讲最细的安卓resources_arsc解析教程一/2.png %}\n\n```\nunsigned char* readStringsFromStringPool(FILE* pFile,  struct ResStringPool_header header) {\n    uint32_t size = header.header.size - sizeof(struct ResStringPool_header);    \n    unsigned char* pData = (unsigned char*)malloc(size);                         \n    fread((void*)pData, size, 1, pFile);                                         \n    uint32_t* pOffsets = (uint32_t*)pData;                                       \n\n    //stringsStart指的是header的起始地址到字符串起始地址的距离                   \n    //pData已经是header末尾的地址了，所以要减去header的大小                      \n    char* pStringsStart = pData + header.stringsStart - sizeof(struct ResStringPool_header);\n\n    for(int i = 0 ; i < header.stringCount ; i++) {                              \n        //前面两个字节是长度,要跳过                                              \n        char* str = pStringsStart + *(pOffsets + i) + 2;                         \n        if(header.flags & UTF8_FLAG) {                                           \n            printf(\"%s\\n\", str);                                                 \n        } else {                                                                 \n            printUtf16String(str);                                               \n        }                                                                        \n    }                                                                            \n\n    return pData;                                                                \n}                                                                         \n```\n\n这里的会把应用里面用到的字符串资源都打印出来，值得注意的是这里的字符串资源指的不仅是我们定义的string标签里的值:\n\n```\n...\nDelete 鍵\n查看全部\n瀏覽首頁\n空格鍵\n與「%s」分享\n選擇分享對象\n...\n```\n\n还包括了资源的路径等其他字符串资源:\n\n```\n...\nres/anim/abc_fade_in.xml                                                         \nres/anim/abc_fade_out.xml                                                        \nres/anim/abc_grow_fade_in_from_bottom.xml                                        \nres/anim/abc_popup_enter.xml                                                     \nres/anim/abc_popup_exit.xml                                                      \nres/anim/abc_shrink_fade_out_from_bottom.xml                                     \nres/anim/abc_slide_in_bottom.xml                                                 \nres/anim/abc_slide_in_top.xml                                                    \nres/anim/abc_slide_out_bottom.xml                                                \nres/anim/abc_slide_out_top.xml                                                   \nres/anim/abc_tooltip_enter.xml                                                   \nres/anim/abc_tooltip_exit.xml                                                    \nres/color-v23/abc_btn_colored_borderless_text_material.xml                       \nres/color-v23/abc_btn_colored_text_material.xml                                  \nres/color-v23/abc_color_highlight_material.xml                                   \nres/color-v23/abc_tint_btn_checkable.xml          \n...\n```\n\n# Package资源\n\n{% img /可能是全网讲最细的安卓resources_arsc解析教程一/4.png %}\n\n让我们继续往下读,接下来的就是包内的资源了。resources.arsc可以支持打入多个package的资源,但是一般只会有一个package。\n\n每个package的资源同样打包成一个Chunk,它的头部信息由ResTable\\_package结构体表示:\n\n\n```\nint readResTablePackageHeader(FILE* pFile, struct ResTable_package* pHeader) {\n    if(fread((void*)pHeader, sizeof(struct ResTable_package), 1, pFile) == 0) {\n        return 0;\n    }\n    printf(\"type:%u, headSize:%u, size:%u, id:%x, packageName:\",\n                pHeader->header.type,\n                pHeader->header.headerSize,\n                pHeader->header.size,\n                pHeader->id);\n    printUtf16String((char16_t*)pHeader->name);\n    return 1;\n}\n```\n\n头部信息记录了package的id和名字:\n\n```\ntype:512, headSize:288, size:188068, id:7f, packageName:com.cvte.tv.myapplication\n```\n\n## 资源类型字符串池\n\n{% img /可能是全网讲最细的安卓resources_arsc解析教程一/5.png %}\n\n紧接着头部之后的又是一个字符串池,它和之前介绍的全局字符串资源池的结构是一样的,我们可以用同样的方法去读取:\n\n```\nstruct ResTable_package packageHeader;\nwhile(readResTablePackageHeader(pFile, &packageHeader)) {\n    struct ResStringPool_header typeStringPoolHeader = readResStringPoolHeader(pFile);\n    unsigned char* pTypeStrings = readStringsFromStringPool(pFile, typeStringPoolHeader);\n\t...\n}\n```\n\n这里记录的是这个package里面存储的资源的类型:\n\n```\ntype:1, headSize:28, size:248, stringCount:12, stringStart:76, styleCount:0, styleStart:0\nanim\nattr\nbool\ncolor\ndimen\ndrawable\nid\ninteger\nlayout\nmipmap\nstring\nstyle\n```\n\n可以看到这个package里面有anim、attr、bool、color、dimen、drawable、id、integer、layout、mipmap、string、style这么多中类型的资源。\n\n## 资源项名称字符串池\n\n{% img /可能是全网讲最细的安卓resources_arsc解析教程一/6.png %}\n\n接下来又是一个字符串资源池,再读一次:\n\n```\nstruct ResTable_package packageHeader;\nwhile(readResTablePackageHeader(pFile, &packageHeader)) {\n    struct ResStringPool_header typeStringPoolHeader = readResStringPoolHeader(pFile);\n    unsigned char* pTypeStrings = readStringsFromStringPool(pFile, typeStringPoolHeader);\n\n    struct ResStringPool_header keyStringPoolHeader = readResStringPoolHeader(pFile);\n    unsigned char* pKeyStrings = readStringsFromStringPool(pFile, keyStringPoolHeader);\n    ...\n}\n```\n\n这里读出来的就是我们的资源的key:\n\n```\ntype:1, headSize:28, size:41208, stringCount:1221, stringStart:4912, styleCount:0, styleStart:0\nabc_fade_in\nabc_fade_out\nabc_grow_fade_in_from_bottom\nabc_popup_enter\nabc_popup_exit\nabc_shrink_fade_out_from_bottom\nabc_slide_in_bottom\nabc_slide_in_top\nabc_slide_out_bottom\nabc_slide_out_top\nabc_tooltip_enter\nabc_tooltip_exit\nactionBarDivider\nactionBarItemBackground\nactionBarPopupTheme\nactionBarSize\nactionBarSplitStyle\nactionBarStyle\nactionBarTabBarStyle\n...\nactivity_main       <- activity_main在这里\n...\napp_name            <- app_name在这里\n...\n```\n\n比如我们的app\\_name字符串,就会生成R.string.app\\_name,而这个\"app\\_name\"就会出现在资源项名称字符串池里面:\n\n```\n<string name=\"app_name\">My Application</string>\n```\n\n又或者我们定义了activity\\_main.xml,就会生成R.layout.activity\\_main,而这个\"activity\\_main\"也会出现在资源项名称字符串池里面。\n\n## 资源\n\n接下来的就是一系列的RES\\_TABLE\\_TYPE\\_SPEC\\_TYPE和RES\\_TABLE\\_TYPE\\_TYPE,不过上面的图画的不是很清晰。\n\nPackage资源剩下的部分是按资源类型分组的。一个RES\\_TABLE\\_TYPE\\_SPEC\\_TYPE跟着多个RES\\_TABLE\\_TYPE\\_TYPE为一组,记录一个类型在不同配置下的资源。\n\n比如我们在前面的资源类型字符串池里面看到有anim、attr、bool、color、dimen、drawable、id、integer、layout、mipmap、string、style,十二种类型的资源,于是就有十二组的RES\\_TABLE\\_TYPE\\_SPEC\\_TYPE和RES\\_TABLE\\_TYPE\\_TYPE,而且顺序也是按资源类型字符串池里面的顺序排的:\n\n{% img /可能是全网讲最细的安卓resources_arsc解析教程一/7.png %}\n\n可以看到每一组都是以一个RES\\_TABLE\\_TYPE\\_SPEC\\_TYPE开头记录该类型的资源的信息,然后跟着多个RES\\_TABLE\\_TYPE\\_TYPE记录该类型在不同Config下的数据(如color、color-v21、color-v23或者我们更熟悉的string、string-en-US、string-zh-CN、string-zh-TW等)\n\n我们可以实际看看打印:\n\n```\nstruct ResChunk_header chunkHeader;\nuint8_t id;\nwhile(fread((void*)&chunkHeader, sizeof(struct ResChunk_header), 1, pFile)\n        && chunkHeader.type != RES_TABLE_PACKAGE_TYPE) {\n    fread((void*)&id, sizeof(uint8_t), 1, pFile);\n    printf(\"0x%x, %d\\n\", chunkHeader.type, id);\n    fseek(pFile, chunkHeader.size - sizeof(struct ResChunk_header) - sizeof(uint8_t), SEEK_CUR);\n}\n```\n\n输出:\n\n```\n0x202, 1\n0x201, 1\n0x202, 2\n0x201, 2\n0x202, 3\n0x201, 3\n0x201, 3\n0x202, 4\n0x201, 4\n0x201, 4\n0x201, 4\n0x202, 5\n0x201, 5\n0x201, 5\n0x201, 5\n0x201, 5\n0x201, 5\n0x201, 5\n0x201, 5\n...\n```\n\n这里打印了type和id,type 0x202代表了RES\\_TABLE\\_TYPE\\_SPEC\\_TYPE，0x201代表了RES\\_TABLE\\_TYPE\\_TYPE。\n\n而id则代表了资源类型字符串池里面的顺序,例如1是anim，2是attr，3是bool...\n\n翻译过来就是:\n\n```\nRES_TABLE_TYPE_SPEC_TYPE,  anim\nRES_TABLE_TYPE_TYPE,       anim\nRES_TABLE_TYPE_SPEC_TYPE,  attr\nRES_TABLE_TYPE_TYPE,       attr\nRES_TABLE_TYPE_SPEC_TYPE,  bool\nRES_TABLE_TYPE_TYPE,       bool\nRES_TABLE_TYPE_TYPE,       bool\nRES_TABLE_TYPE_SPEC_TYPE,  color\nRES_TABLE_TYPE_TYPE,       color\nRES_TABLE_TYPE_TYPE,       color\nRES_TABLE_TYPE_TYPE,       color\nRES_TABLE_TYPE_SPEC_TYPE,  dimen\nRES_TABLE_TYPE_TYPE,       dimen\nRES_TABLE_TYPE_TYPE,       dimen\nRES_TABLE_TYPE_TYPE,       dimen\nRES_TABLE_TYPE_TYPE,       dimen\nRES_TABLE_TYPE_TYPE,       dimen\nRES_TABLE_TYPE_TYPE,       dimen\nRES_TABLE_TYPE_TYPE,       dimen\n...\n```\n\n好的,因为信息量已经有点大了,本节先到这里。接下来是整个resources.arsc中最重要的资源的具体定义会在下一篇笔记中介绍,完整的demo代码也会在[下一篇博客](http://blog.islinjw.cn/2019/05/21/%E5%8F%AF%E8%83%BD%E6%98%AF%E5%85%A8%E7%BD%91%E8%AE%B2%E6%9C%80%E7%BB%86%E7%9A%84%E5%AE%89%E5%8D%93resources-arsc%E8%A7%A3%E6%9E%90%E6%95%99%E7%A8%8B-%E4%BA%8C/)的末尾给出。","tags":["技术相关","Android"]},{"title":"一起入门gradle自定义插件编写(二) - 深入理解build.gradle","url":"/2019/04/26/一起入门gradle自定义插件编写-二-深入理解build-gradle/","content":"\n这篇博客我们来通过groovy的语法去深入理解build.gradle的底层实现。\n\n通过分析build.gradle里面的实现原理,我们在写自己的自定义gradle插件的时候就能使用同样的配置方法了。\n\n在上一篇[博客](http://blog.islinjw.cn/2019/04/14/%E4%B8%80%E8%B5%B7%E5%85%A5%E9%97%A8gradle%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E4%B8%80/)里面提到,在gradle文件里面默认使用的都是project这个对象的方法或者属性,并且分析了apply方法的完整形式:\n\n```\nproject.apply(['plugin': 'com.android.application'])\n```\n\n其实android,和dependencies代码块也是一样的,省略了project对象,添加上之后变成这样:\n\n```\nproject.android {\n    compileSdkVersion 28\n    defaultConfig {\n        applicationId \"me.linjw.demo\"\n        minSdkVersion 24\n        targetSdkVersion 28\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\nproject.dependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation 'com.android.support:appcompat-v7:28.0.0'\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'com.android.support.test:runner:1.0.2'\n    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'\n}\n```\n\n我们先讲dependencies,按住ctrl键用鼠标点击它可以跳转到到Project接口的void dependencies(Closure configureClosure)方法\n\n也就是说它其实是project的一个方法,传入一个Closure对象作为参数.然后这里是省略了方法的括号,它的完整形式如下:\n\n```\nproject.dependencies({\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation 'com.android.support:appcompat-v7:28.0.0'\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'com.android.support.test:runner:1.0.2'\n    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'\n})\n```\n\n# groovy闭包\n\n这个Closure就是闭包的意思,闭包作为脚本语言里面比较常见的东西我就不过多介绍了,感兴趣的同学可以自行搜索.\n\ngroovy里的闭包就是用话括号来定义的,可以看看下面闭包的例子:\n\n```\n//定义闭包并且把它赋值给closure变量\ndef closure = {\n    println('hello world!')\n}\n\n//调用闭包\nclosure()\n```\n\n这里的closure()会调用闭包的方法,打印出\"hello world!\"\n\n这里的闭包也是一个省略的写法,它的完整写法如下:\n\n```\ndef closure = {->\n    println('hello world!')\n}\n```\n\n\"->\"左边是闭包的输入参数,由于这里不需要输入参数,所以它左边没有东西.我们可以看看下面的例子,这个闭包接收两个参数:\n\n```\ndef closure = { str1, str2 ->\n    println(str1 + ' ' + str2)\n}\n\nclosure('hello', 'world')\n```\n\n特殊的,如果闭包只接收一个参数,也可以省略参数名和\"->\",它会默认包含一个隐式的参数it:\n\n```\ndef closure = {\n    println(it)\n}\n\nclosure('hello world!') // 打印hello world!\nclosure() // 打印null\n```\n\n可以看到,如果只有一个参数的话在调用闭包的时候可以不传参数,它会默认传入null.\n\n# delegate\n\ndependencies方法传入的闭包里面的implementation其实也是调用的方法,我们补全它们的括号\n\n```\nproject.dependencies({\n    implementation(fileTree(dir: 'libs', include: ['*.jar']))\n    implementation('com.android.support:appcompat-v7:28.0.0')\n    testImplementation('junit:junit:4.12')\n    androidTestImplementation('com.android.support.test:runner:1.0.2')\n    androidTestImplementation('com.android.support.test.espresso:espresso-core:3.0.2')\n})\n```\n\n那这个implementation方法又是哪里来的呢?是groovy闭包自带的方法?还是全局的方法?\n\n其实都不是,这里我们先从闭包的delegate说起,顾名思义它是闭包的一个委托对象,闭包中没有的方法都会调到它那里去.\n\n我们来看下面的例子,在闭包中调用foo()方法,调用的时候会报错,因为找不到foo()方法:\n\n```\ndef closure = {\n    foo()\n}\nclosure() // 报错,找不到foo()方法\n```\n\n如果我们定义一个类,里面实现foo方法,然后将这个类设置成闭包的delegate,则在闭包中找不到foo()方法的时候就会去它的代理中找:\n\n```\nclass TestClass {\n    def foo() {\n        println('foo')\n    }\n}\ndef closure = {\n    foo()\n    println(delegate)\n}\nclosure.delegate = new TestClass()\nclosure() // 先在TestClass.foo方法中打印'foo',然后打印闭包的delegate对象'TestClass@755e1c30'\n```\n\n这个时候让我们看看dependencies闭包的delegate:\n\n```\nproject.dependencies({\n    println(delegate)\n    implementation(fileTree(dir: 'libs', include: ['*.jar']))\n    implementation('com.android.support:appcompat-v7:28.0.0')\n    testImplementation('junit:junit:4.12')\n    androidTestImplementation('com.android.support.test:runner:1.0.2')\n    androidTestImplementation('com.android.support.test.espresso:espresso-core:3.0.2')\n})\n```\n\n输出为\n\n> org.gradle.api.internal.artifacts.dsl.dependencies.DefaultDependencyHandler_Decorated@ee11179\n\n这个DefaultDependencyHandler_Decorated东西我们不用细究,只要知道它是DefaultDependencyHandler的子类就行\n\n# dependencies的原理\n\n我们都知道当我们在配置了productFlavors的时候,可以为每个product单独配置依赖库\n\n```\nandroid {\n\t...\n\tproductFlavors {\n\t    demo {\n\t    }\n\t}\n}\n\ndependencies {\n\t...\n\tdemoImplementation 'com.google.code.gson:gson:2.6.2'\n}\n```\n\n但是这个demoImplementation方法又是怎么生成的呢?\n\n其实最后它们都是调用到了DefaultDependencyHandler.add方法,也就是说我们的dependencies其实实际的形式是这样的:\n\n```\nproject.dependencies({\n    add('implementation', fileTree(dir: 'libs', include: ['*.jar']))\n    add('implementation', 'com.android.support:appcompat-v7:28.0.0')\n    add('testImplementation', 'junit:junit:4.12')\n    add('androidTestImplementation', 'com.android.support.test:runner:1.0.2')\n    add('androidTestImplementation', 'com.android.support.test.espresso:espresso-core:3.0.2')\n    add('demoImplementation', 'com.google.code.gson:gson:2.6.2')\n})\n```\n\n这个add方法是怎么调用到的呢?groovy里面可以有几种方法做到,这里就讲一种:\n\n\n```\nclass Delegate {\n    def invokeMethod(String name, args) {\n        println('method : ' + name)\n        println('args : ' + args)\n    }\n}\n\ndef closure = {\n    demoImplementation 'com.google.code.gson:gson:2.6.2'\n}\n\nclosure.delegate = new Delegate()\nclosure()\n```\n\n上面的例子,我们在闭包中调用了delegate中也没有的方法demoImplementation,这个时候会调用delegate的invokeMethod,打印如下:\n\n```\nmethod : demoImplementation\nargs : [com.google.code.gson:gson:2.6.2]\n```\n\n所以这个时候我们就可以在这个invokeMethod方法里面给每个product配置依赖了。\n\n\n# Extension\n\n与project.dependencies不同project.android,project里面并没有一个方法叫做android。\n\n那这个project.android方法是怎么调用的呢?它是通过project的一个Extension,也就是project的一个拓展。\n\n这个拓展是怎么来的呢?可以看看下面的代码:\n\n```\nclass MyAndroid {\n    def compileSdkVersion;\n\n    def compileSdkVersion(compileSdkVersion) {\n        this.compileSdkVersion = compileSdkVersion\n    }\n}\n\nproject.extensions.add('myAndroid', new MyAndroid())\n\nproject.myAndroid {\n    compileSdkVersion 28\n}\n```\n\n我们只需要使用project.extensions.add方法加入一个名字叫做myAndroid的Extension,gradle就会为我们在project里面添加一个名字叫做myAndroid的方法,接收一个闭包,然后在这个方法里面会将传入的闭包的delegate设置成我们new出来的MyAndroid对象。\n\n## metaClass\n\n这个Extension又是怎么实现的呢？\n\n其实脚本语言一般都支持动态添加方法和属性,groovy同样也支持。\n\n我们在groovy中可以使用metaClass进行运行是元编程,动态创建类、方法等\n\n\n例如,下面代码中我们给Demo类动态添加了hello属性和sayHello方法:\n\n```\nclass Demo {\n\n}\n\nDemo.metaClass.\"hello\" = \"hello world\"\nDemo.metaClass.\"sayHello\" = { println(\"hello world\") }\n\nDemo demo = new Demo()\ndemo.sayHello()\nprintln(demo.hello)\n```\n\n甚至当重名的时候它还会根据我们设置的是值还是闭包帮我们分别创建属性和方法:\n\n```\nclass Demo {\n\n}\n\nDemo.metaClass.\"hello\" = \"hello world\"\nDemo.metaClass.\"hello\" = { println(\"hello world\") }\n\nDemo demo = new Demo()\ndemo.hello()\nprintln(demo.hello)\n```\n\n有了这个元编程的技术,要实现Extension就简单了:\n\n\n```\ndef addExtensions(String name, Object handler) {\n    project.metaClass.\"$name\" = { it ->\n        it.delegate = handler\n        it()\n    }\n    project.metaClass.\"$name\" = handler\n}\n\nclass MyAndroid {\n    def compileSdkVersion;\n\n    def compileSdkVersion(compileSdkVersion) {\n        this.compileSdkVersion = compileSdkVersion\n    }\n}\n\naddExtensions('myAndroid', new MyAndroid())\n\nproject.myAndroid {\n    compileSdkVersion 28\n}\n\nprintln(project.myAndroid.compileSdkVersion)\n```\n","tags":["技术相关","Android"]},{"title":"来谈一谈安卓应用的破解","url":"/2019/04/22/来谈一谈安卓应用的破解/","content":"\n之前有写过一篇[博客](http://blog.islinjw.cn/2019/03/22/%E5%A4%A7%E6%A6%82%E4%BC%98%E7%A7%80%E7%9A%84java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E8%A6%81%E4%BC%9A%E5%88%86%E6%9E%90class%E6%96%87%E4%BB%B6%E5%90%A7/)介绍了下java字节码的查看和分析\n\n其实除了分析java内部类、枚举等java语言的实现原理之外,在一些特定的场景也是比较有用的.\n\n这篇文章做个死,给大家讲解通过字节码去破解某些安卓应用的原理.(现在一般都是通过修改smali去做的，但是其实基于字节码也是可以做到的，这篇文章基于之前的java字节码分析，所以只讲字节码的方式，smali的话大家可以自行搜索)\n\n很多的单机游戏,甚至是一些网络游戏他们运行的时候逻辑运算都是放在本地的.服务端只是接收客户端上传的运算结果.还有一些收费应用,其实功能都在本地代码里面了,只不过是判断了下是否有付费,如果有付费才显示功能入口.\n\n如果我们可以修改它的代码,将上传的结果或者是否付费的判断改成我们希望的,就可以为所欲为了.\n\n# 反编译\n\n要修改应用的代码逻辑,首先要先分析原来的代码逻辑是怎样的.\n\n但由于应用的代码都是各家公司的私有财产,除非有人做大死泄露了出来,一般我们是拿不到的.所以这个时候我们就只能使用反编译技术了.\n\n如果大家到网上搜索apk的反编译技术,大概率会搜到下面的方法:\n\n1. 使用apktool工具解压apk\n2. 使用dex2jar工具将安卓优化后的dex文件转换成java的class\n3. 使用jd-gui工具查看class里面的java代码\n\n这么繁琐的操作其实已经过时了,我这边介绍个一键式傻瓜操作的工具给大家\n\n## jadx\n\njadx是个开源的安卓反编译工具,它的代码托管在[github](https://github.com/skylot/jadx)上,大家可以去[下载](https://github.com/skylot/jadx/releases/tag/v0.9.0)来使用\n\n用法很简单,下载之后解压,然后进入bin目录运行jadx-gui(linux/mac)或者jadx-gui.bat(windows),就可以启动一个可视化的界面了,然后点击\"文件->打开\",并且选择我们想要反编译的应用,就能看到apk里面的代码了\n\n{% img /浅谈安卓应用的破解/1.png %}\n\n{% img /浅谈安卓应用的破解/2.png %}\n\n我这里反编译了一个demo应用,它的MainActivity.onCreate里面判断了一个flag变量,然后弹出Toast.\n\n我们安装这个apk运行起来可以看到弹出toast: \"hello world!\"\n\n{% img /浅谈安卓应用的破解/0.png %}\n\n其他应用也是类似的,可以这样查看它们的代码.\n\n不过正式发布的应用一般都会做混淆操作,这个时候我们反编译处理看到的代码的类名、方法名、变量名就都会变成a,b,c这样无意义的字符.\n\n但是只是名字变了,执行逻辑是完全一样的,所以只要够细心,还是可以理清楚它的代码逻辑的.\n\njadx有个厉害的功能就是可以导出gradle工程,点击\"文件->另存为Gradle项目\"就可以导出gradle项目了,然后改下目录结构,就可以用Android studio去打开工程并且编辑修改代码了.\n\n如果修改之后编译成功,那么我们的目的就达到了,可以为所欲为,但是这个项目大概率是不能编译成功的,有很多奇奇怪怪的错误.\n\n接下来我就带大家一步步破解这个apk，修改它的逻辑，不弹\"hello world!\"而是弹\"hello java\".\n\n# 修改应用的字节码\n\n我们可以用jadx去很方便的分析代码逻辑,但是如果重新编译失败的话我们就只有走别的路子了.\n\n这里介绍直接编辑字节码的方式.走这条路的话就没有什么傻瓜操作可以用了.还是老老实实一步步来吧\n\n## 1. 解压apk\n\napk其实是一种zip压缩包,我们可以将它的后缀改成.zip,然后直接解压\n\n{% img /浅谈安卓应用的破解/3.png %}\n\n我们将解压出来的东西都放到app-release-unsigned目录里面:\n\n{% img /浅谈安卓应用的破解/4.png %}\n\n## 2. 将dex转换成jar\n\n我们都知道安卓的虚拟机不是普通的java虚拟机,它不能直接运行java的class文件,需要优化成dex文件.\n\n而我们修改字节码的时候就需要将它转换回来了,这里使用的就是[dex-tools工具](https://github.com/bluesky466/filesave/blob/master/apk%E7%A0%B4%E8%A7%A3/dex-tools-2.1-SNAPSHOT.zip)的dex2jar功能:\n\n这里我只介绍Linux下命令的用法,就不介绍Windows上的使用了,其实是类似的使用.bat的版本,大家可以自行搜索.\n\n将classes.dex转换成jar文件:\n\n>  ~/dex-tools-2.1-SNAPSHOT/d2j-dex2jar.sh classes.dex\n\n它会生成classes-dex2jar.jar文件:\n\n{% img /浅谈安卓应用的破解/5.png %}\n\n## 3. 修改class字节码\n\n其实jar文件也是一种zip压缩包,我们依然可以直接把后缀改成zip,然后解压:\n\n{% img /浅谈安卓应用的破解/6.png %}\n\n然后找到MainActivity.class\n\n{% img /浅谈安卓应用的破解/7.png %}\n\n这个时候我们就能用上篇文章说的javap命令去查看里面的代码了:\n\n> javap -c MainActivity\n\n{% img /浅谈安卓应用的破解/8.png %}\n\n这里第16行的意思就是付过栈顶的两个变量不相等就跳到第32行代码,否则继续执行\n\n> 16: if_icmpne     32\n\n而我们可以看到,继续执行的话会输出hello world!,如果跳的32行的话就会输出hello java!\n\n这里我们可以直接将if_icmpne改成if_icmpeq,在相等的时候跳到32行,否则继续执行,这样原来的\"hello world!\"提示就会变成\"hello java!\"了\n\n如果直接用编辑器打开class文件,里面是一些二进制的值.\n\n那我们要怎么修改呢?\n\n这里我们会用到另外一个工具[jbe](https://github.com/bluesky466/filesave/blob/master/apk%E7%A0%B4%E8%A7%A3/jbe.zip),全称是java bytecode editor\n\n下载了之后解压,进入bin目录使用下面命令打开图形界面:\n\n> java ee.ioc.cs.jbe.browser.BrowserApplication\n\n{% img /浅谈安卓应用的破解/9.png %}\n\n在图形界面打开MainActivity.class,并且找到我们的MainActivity.onCreate代码:\n\n{% img /浅谈安卓应用的破解/10.png %}\n\n然后点击Code Editor选项就可以对字节码进行修改了,这里我们将if_icmpne改成if_icmpeq,然后点击Save method:\n\n{% img /浅谈安卓应用的破解/11.png %}\n\n这样我们的逻辑修改就完成了\n\n## 4. 重新打包dex\n\n接下来我们将重新打包apk,首先将class压缩成zip,__注意目录结构__:\n\n{% img /浅谈安卓应用的破解/12.png %}\n\n然后将后缀改成jar,并且使用jar2dex生成dex:\n\n> ~/dex-tools-2.1-SNAPSHOT/d2j-jar2dex.sh classes-dex2jar.jar\n\n接着用生成的dex替换原来的classes.dex,然后删除所有刚刚生成的临时文件,如classes-dex2jar.zip和classes-dex2jar目录\n\n{% img /浅谈安卓应用的破解/13.png %}\n\n## 5.删除签名信息\n\n一般我们拿到的应用都是签名过的应用，应用签名之后会将资源和代码的校验信息保存到apk里，如果我们修改了dex文件，就会导致校验失败，这样的话apk是不能安装的。\n\n所以我们需要把原来的签名删掉，具体做法就是删除META-INF目录里面的三个文件:\n\nCERT.RSA\nCERT.SF\nMANIFEST.MF\n\n## 6. 重新打包apk\n\n接下来同样的压缩文件生成zip压缩包,__注意目录结构__:\n\n{% img /浅谈安卓应用的破解/14.png %}\n\n最后将zip后缀改成apk,我们的apk就打包好了\n\n# 重签名\n\n由于我们重新打包的apk删除了签名信息,如果直接安装是会失败的,需要我们重新给它签名.\n\n## 创建签名\n\n可以用下面命令创建alias为android.keystore,文件名也是android.keystore的签名文件\n\n> keytool -genkeypair -alias android.keystore -keyalg RSA -validity 400 -keystore android.keystore\n\n按下回车之后它会让你输入一些密码、开发者信息等,完成之后就能得到一个android.keystore文件\n\n## 签名应用\n\n然后我们使用得到的android.keystore去给应用重新签名:\n\n> jarsigner -keystore android.keystore -signedjar release.apk app-release-unsigned.apk android.keystore\n\n得到签好名的release.apk\n\n大功告成!\n\n让我们安装进去运行看看,toast已经变成了\"hello java!\":\n\n{% img /浅谈安卓应用的破解/16.png %}\n","tags":["技术相关","Android"]},{"title":"一起入门gradle自定义插件编写(一)","url":"/2019/04/14/一起入门gradle自定义插件编写一/","content":"\n\n相信现在的安卓程序员对gradle脚本的配置应该都或多或少有些了解,例如applicationId、version、混淆等的基本配置应该都是比较熟悉的了,像比较高级的自定义buildTypes、productFlavors可能也多多少少了解一些.\n\n但是对于groovy语言和如何自定义gradle插件,相信很多同学还是比较陌生的.\n\n作为一个有理想的安卓程序员,我觉得这种高阶的技能还是需要懂的.像一些热更新、插件化等高级技能都会涉及到groovy代码的编写甚至自定义gradle插件.\n\n# project.apply方法\n\n我们新建一个Android Studio项目,得到两个build.gradle文件,一个是项目根目录下的,一个是模块目录(如app目录)下的.我们只看模块目录下的:\n\n```\napply plugin: 'com.android.application'\n\nandroid {\n    compileSdkVersion 28\n    defaultConfig {\n        applicationId \"me.linjw.demo\"\n        minSdkVersion 24\n        targetSdkVersion 28\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation 'com.android.support:appcompat-v7:28.0.0'\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'com.android.support.test:runner:1.0.2'\n    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'\n}\n```\n\n这里的第一行代码指定了com.android.application这个插件的使用,这个插件用来构建apk项目.\n\n```\napply plugin: 'com.android.application'\n```\n\n另外比较常见的插件有用于构建aar包的com.android.library插件\n\n```\napply plugin: 'com.android.library'\n```\n\n和用于构建jar包的java-library插件\n\n```\napply plugin: 'java-library'\n```\n\n我们都知道build.gradle使用的是groovy语法,那这个使用插件的代码的语法含义又是怎样的呢?让我们一起来看看.\n\n第一个知识点是我们在gradle文件里面默认使用的都是project这个对象的方法或者属性,也就是说我们的插件配置代码等价于:\n\n```\nproject.apply plugin: 'com.android.application'\n```\n\n## groovy基本语法\n\n接下来我们就要开始学一些groovy的基本语法了.\n\n我们可以像一般的强类型语言一样去定义方法,也可以选择像一些动态语言一样忽略参数和返回值类型:\n\n```\nint foo(int x, int y) {\n    return x + y\n}\n\ndef foo2(def x, def y) {\n    return x + y\n}\n```\n\n在调用方法的时候为了简洁,你可以选择省略括号,比如下面的两行代码是效果是一样的,而且我们可以看到,在定义变量的时候也可以选择忽略变量的类型:\n\n```\ndef x = foo(1,2)\nint y = foo 1,2\n```\n\n接下来看看groovy中list和map的定义方式:\n\n```\ndef list = [1, 2, 3, 4]\ndef map = ['key1': 'val1', key2: 'val2', 3: 'val3', 1.23: 312]\n```\n\n可以看到,map很灵活,key/value都可以是任意的类型,然后在key是字符串的时候甚至可以直接省略引号.\n\n甚至,在当作方法参数的时候,我们连map的中括号也是可以省略的,让我们来看看groovy代码是怎样一步步省略到极致的:\n\n```\n//下面的四行方法是完全等价的\n\n//不做任何省略\nfunc(['key1': 1, 'key2': 'val2'])\n\n//省略key的双引号\nfunc([key1: 1, key2: 'val2'])\n\n//省略map中括号\nfunc(key1: 1, key2: 'val2')\n\n//省略方法调用的小括号\nfunc key1: 1, key2: 'val2'\n```\n\n现在让我们回过头来看这行代码,是不是感觉突然好像有点理解了?\n\n```\napply plugin: 'com.android.application'\n```\n\n首先它省略了调用apply的project对象,然后它省略了key的双引号,接着又省略了map里面的中括号,最后还省略了方法调用的小括号\n\n如果不做任何省略的话,它的完整形式应该是:\n\n```\nproject.apply(['plugin': 'com.android.application'])\n```\n\n其实我们也按住ctrl键然后用鼠标点击apply,查看方法的声明:\n\n```\npublic interface PluginAware {\n  ...\n  void apply(Map<String, ?> options);\n  ...\n}\n```\n\n可以看到它跳转到了一个java接口里面,这个apply其实是PluginAware这个接口中的一个方法,参数为Map类型.\n\ngroovy其实是一种基于jvm的脚本,它可以直接使用java的代码.\n\n所以我们可以选择直接用java编写插件,也可以选择使用groovy语言编写,不过最后groovy也是会被编译器编译成java字节码的.\n\n# 编写自定义gradle代码\n\n在gradle中编写代码有三种方式\n\n最简单的一种是直接在build.gradle文件里面添加我们的代码\n\n第二种是新建一个gradle文件,在里面编写我们的代码,然后用apply from在build.gradle里面导入我们的代码\n\n第三中就是编写我们自己的插件了\n\n第一种方法我们就不说了,直接讲第二种.\n\n## apply from操作\n\n首先我们需要创建一个gradle文件,然后在里面写我们的方法.\n\n例如我在项目根目录下面新建了一个mycode.gradle文件,然后写好代码:\n\n```\ndef add(def x, def y) {\n    return x + y\n}\nprintln('=================')\nprintln(add(1, 2))\nprintln('=================')\n```\n\n然后在app目录下的build.gradle里面使用apply from操作导入这个文件:\n\n```\napply plugin: 'com.android.application'\napply from: '../mycode.gradle'\n```\n\n然后点击build,就可以看到输出了:\n\n```\nExecuting tasks: [build]\n\nNDK is missing a \"platforms\" directory.\nIf you are using NDK, verify the ndk.dir is set to a valid NDK directory.  It is currently set to /home/linjw/android/sdk/ndk-bundle.\nIf you are not using NDK, unset the NDK variable from ANDROID_NDK_HOME or local.properties to remove this warning.\n\n=================\n3\n=================\nNDK is missing a \"platforms\" directory.\nIf you are using NDK, verify the ndk.dir is set to a valid NDK directory.  It is currently set to /home/linjw/android/sdk/ndk-bundle.\nIf you are not using NDK, unset the NDK variable from ANDROID_NDK_HOME or local.properties to remove this warning.\n...\n```\n\n当然我们知道apply是一个接收Map的方法,我们不用调用两次apply方法,也可以直接这么写,直接在一次调用中com.android.application插件和mycode.gradle的导入\n\n```\napply plugin: 'com.android.application', from: '../mycode.gradle'\n```\n\n## 自定义gradle插件\n\n最高级的方法就是直接编写自定义插件了,编写好的插件可以发布到jcenter或者maven上给人使用.\n\n### 创建Gradle Module\n\n首先我们需要创建一个Gradle Module用于编写gradle插件的代码.但是Android Studio是没有办法直接创建Gradle Module的.\n\n所以我们新建个普通的apk项目,或者新建个Android Library module然后再更改下配置将它改成Gradle Module就好\n\n我这里就直接用新建出来的apk项目了.\n\n第一步是进入app目录,将里面的东西全部都删掉.\n\n#### 1.编写build.gradle\n\n然后新建一个在app目录下新建一个build.gradle文件,写入代码:\n\n```\napply plugin: 'groovy'\n\ndependencies {\n    compile gradleApi()\n    compile localGroovy()\n}\n```\n\n#### 2.编写代码\n\n接着在app目录下面新建src目录,然后进入src目录新建main目录,然后再进入main继续新建groovy目录\n\n最后在groovy目录中根据包名新建目录层级,并且新建MyPlugin.groovy文件用于编写我们的插件代码.\n\n我的包名是me.linjw.plugin,所以目录结构如下:\n\n{% img /一起入门gradle自定义插件编写一/1.png %}\n\n插件都需要实现Plugin<Project>接口,然后编写自己代码.代码如下:\n\n```\npackage me.linjw.plugin\n\nimport org.gradle.api.Plugin\nimport org.gradle.api.Project\n\npublic class MyPlugin implements Plugin<Project> {\n    def add(def x, def y) {\n        return x + y\n    }\n\n    void apply(Project project) {\n        println(\"=======MyPlugin========\")\n        println(add(1, 2))\n        println(\"===============\")\n    }\n}\n```\n\n#### 3.注册插件\n\n上面我们已经编写好了我们的插件了,接下来的事情就是告诉gradle哪个是我们的插件类.\n\nmain目录下新建resources目录,然后在resources目录里面再新建META-INF目录,再在META-INF里面新建gradle-plugins目录.最后在gradle-plugins目录里面新建properties文件.\n\n这个properties文件的名字就是你插件的名字了,例如之前看到的com.android.application、com.android.library\n\n我这边的名字为me.islinlw.plugin.demo.properties\n\n接着在properties文件里面配置我们的插件类:\n\nimplementation-class=me.linjw.plugin.MyPlugin\n\n{% img /一起入门gradle自定义插件编写一/5.png %}\n\n#### 发布插件到本地maven\n\n这个时候其实点击build已经可以在app/build/libs目录下看到我们的插件被编译成app.jar了\n\n但是需要先发布出去别人才能使用,一般可以发布到公司内部或者公网的仓库如jcenter等.我们这边由于是demo,可以先选择发布到电脑的本地仓库.\n\n我们修改下build.gradle:\n\n```\napply plugin: 'groovy'\napply plugin: 'maven'\n\ndependencies {\n    compile gradleApi()\n    compile localGroovy()\n}\n\n\nrepositories {\n    mavenCentral()\n}\n\ngroup='me.islinjw.plugin'\nversion='1.0.0'\n\nuploadArchives {\n    repositories {\n        mavenDeployer {\n            repository(url: uri('/home/linjw/workspace/LocalMaven'))\n        }\n    }\n}\n```\n\n然后点击uploadArchives,就可以将插件发布到/home/linjw/workspace/LocalMaven\n\n{% img /一起入门gradle自定义插件编写一/2.png %}\n\n#### 使用插件\n\n让我们打开一个项目来验证下.\n\n首先在项目根目录的build.gradle的buildscript.repositories里面配置本地仓库的路径,并且在buildscript.dependencies配置插件依赖:\n\n{% img /一起入门gradle自定义插件编写一/3.png %}\n\n最后在app目录下的build.gradle里面使用我们的插件:\n\n{% img /一起入门gradle自定义插件编写一/4.png %}\n\n就可以点击build看到输出了\n\n```\n16:57:12: Executing task 'build'...\n\nExecuting tasks: [build]\n\nNDK is missing a \"platforms\" directory.\nIf you are using NDK, verify the ndk.dir is set to a valid NDK directory.  It is currently set to /home/linjw/android/sdk/ndk-bundle.\nIf you are not using NDK, unset the NDK variable from ANDROID_NDK_HOME or local.properties to remove this warning.\n\n=======MyPlugin========\n3\n===============\nNDK is missing a \"platforms\" directory.\nIf you are using NDK, verify the ndk.dir is set to a valid NDK directory.  It is currently set to /home/linjw/android/sdk/ndk-bundle.\nIf you are not using NDK, unset the NDK variable from ANDROID_NDK_HOME or local.properties to remove this warning.\n```\n\n#### 修改插件的ArtifactID\n\n我们看到添加依赖的时候,插件的ArtifactID其实是app,这个又要怎么修改呢?\n\n```\nclasspath 'me.islinjw.plugin:app:1.0.0'\n```\n\n回到我们的插件项目的根目录,修改settings.gradle,将模块名改成DemoPlugin:\n\n\n```\n//原来是include ':app'\ninclude ':DemoPlugin'\n```\n\n然后将我们的app目录改名成DemoPlugin\n\n最后再发布一次,就修改完成了\n\n于是依赖就变成了\n\n```\nclasspath 'me.islinjw.plugin:DemoPlugin:1.0.0'\n```\n","tags":["技术相关","Android"]},{"title":"大概优秀的java程序员都要会分析class文件吧","url":"/2019/03/22/大概优秀的java程序员都要会分析class文件吧/","content":"\n相信大家在学java的时候都会听到这样的一些结论:\n\n1. enum 是一个类\n2. 泛型的实现使用了类型擦除技术\n3. 非静态内部类持有外部类的引用\n4. 需要将自由变量声明成final才能给匿名内部类访问\n\n...\n\n初学的时候的时候可能在书上读过,但是很容易就会忘记,等到踩坑踩多了,就会形成慢慢记住。但是很多的同学也只是记住了而已,对于实际的原理或者原因并不了解。\n\n这篇文章的目的主要就是教会大家查看java的字节码,然后懂得去分析这些结论背后的原理。\n\n# 枚举最后会被编译成一个类\n\n我们先从简单的入手.\n\njava的新手对于枚举的理解可能是:存储几个固定值的集合,例如下面的Color枚举,使用的时候最多也就通过ordinal()方法获取下枚举的序号或者从Color.values()里面使用序号拿到一个Color:\n\n```\npublic enum Color {\n    RED,\n    GREEN,\n    BLUE\n}\n\nint index = Color.BLUE.ordinal();\nColor color = Color.values()[index];\n```\n\n如果是从C/C++过来的人比如我,很容易形成这样一种固定的思维:枚举就是一种被命名的整型的集合。\n\n在c/c++里面这种想法还能说的过去,但是到了java就大错特错了,错过了java枚举的一些好用的特性。\n\n还是拿我们上面的Color枚举,颜色我们经常使用0xFF0000这样的16进制整型或者“#FF0000”这样的字符串去表示。\n\n在java中,我们可以这样将这个Color枚举和整型还有字符串关联起来:\n\n\n```\npublic enum Color {\n    RED(0xFF0000, \"#FF0000\"),\n    GREEN(0x00FF00, \"#00FF00\"),\n    BLUE(0x0000FF, \"#0000FF\");\n\n    private int mIntVal;\n    private String mStrVal;\n\n    Color(int intVal, String strVal) {\n        mIntVal = intVal;\n        mStrVal = strVal;\n    }\n\n    public int getIntVal() {\n        return mIntVal;\n    }\n\n    public String getStrVal() {\n        return mStrVal;\n    }\n}\n\nSystem.out.println(Color.RED.getIntVal());\nSystem.out.println(Color.RED.getStrVal());\n```\n\n可以看到我们给Color这个枚举,增加了两个成员变量用来存整型和字符串的表示,然后还提供两个get方法给外部获取。\n\n\n甚至进一步的,枚举的一种比较常用的技巧就是在static块中创建映射:\n\n```\npublic enum Color {\n    RED(0xFF0000, \"#FF0000\"),\n    GREEN(0x00FF00, \"#00FF00\"),\n    BLUE(0x0000FF, \"#0000FF\");\n\n    private static final Map<String, Color> sMap = new HashMap<>();\n\n    static {\n        for (Color color : Color.values()) {\n            sMap.put(color.getStrVal(), color);\n        }\n    }\n\n    public static Color getFromStrVal(String strVal){\n        return sMap.get(strVal);\n    }\n\n    private int mIntVal;\n    private String mStrVal;\n\n    Color(int intVal, String strVal) {\n        mIntVal = intVal;\n        mStrVal = strVal;\n    }\n\n    public int getIntVal() {\n        return mIntVal;\n    }\n\n    public String getStrVal() {\n        return mStrVal;\n    }\n}\n\nSystem.out.println(Color.getFromStrVal(\"#FF0000\").getIntVal());\nSystem.out.println(Color.RED.getIntVal());\n```\n\n看起来是不是感觉和一个类的用法很像?\"enum 是一个类\"这样句话是不是讲的很有道理。\n\n当然用法和类很像并不能说明什么。\n\n接下来就到了我们这篇文章想讲的第一个关键知识点了。\n\n## 反编译class文件\n\n首先我们还是将Color简化回最初的样子,然后保存在Color.java文件中:\n\n```\n// Color.java\npublic enum Color {\n    RED,\n    GREEN,\n    BLUE\n}\n```\n\n然后通过javac命令进行编译,得到Color.class\n\n> javac Color.java\n\n得到的class文件就是jvm可以加载运行的文件,里面都是一些java的字节码。\n\njava其实默认提供了一个javap命令，给我们去查看class文件里面的代码。例如,在Color.class所在的目录使用下面命令:\n\n> javap Color\n\n可以看到下面的输出:\n\n```\nCompiled from \"Color.java\"\npublic final class Color extends java.lang.Enum<Color> {\n  public static final Color RED;\n  public static final Color GREEN;\n  public static final Color BLUE;\n  public static Color[] values();\n  public static Color valueOf(java.lang.String);\n  static {};\n}\n```\n\n是不是有种恍然大明白的感觉?Color在class文件里面实际上是被编译成了一个继承java.lang.Enum的类,而我们定义的RED、GREEN、BLUE实际上是这个类的静态成员变量。\n\n这么去看的话我们那些加成员变量、加方法的操作是不是就变得很常规了?\n\n所以说\"enum 是一个类\"的意思其实是enum会被java编译器编译成一个继承java.lang.Enum的类!\n\n# java运行时栈帧\n\n相信大家都知道,java虚拟机里面的方法调用是以方法栈的形式去执行的.压人栈内的元素就叫做栈帧.\n\n<深入理解java虚拟机>一书中是这么介绍栈帧的:\n\n> 栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区的虚拟机栈(Virtual Machine Stack)的栈元素。栈帧存储了方法的局部变量表，操作数栈，动态连接和方法返回地址等信息。第一个方法从调用开始到执行完成，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。\n\n也就是说,java方法的调用,其实是一个个栈帧入栈出栈的过程,而栈帧内部又包含了局部变量表,操作数栈等部分:\n\n{% img /大概优秀的java程序员都要会分析class文件吧/1.png %}\n\n\n局部变量表和操作数栈是栈帧内进行执行字节码的重要部分.\n\n局部变量表顾名思义,就是用来保存方法参数和方法内部定义的局部变量的一段内存区域.\n\n而操作数栈也是一个后入先出的栈,程序运行过程中各种字节码指令往其中压入和弹出栈进行运算的.\n\n## java字节码分析\n\n我们用一个简单的代码做demo:\n\n```\n// Test.java\npublic class Test {                                                              \n    public static void main(String[] args) {                                     \n        int a = 12;                                                              \n        int b = 21;                                                              \n        int c = a + b;                                                           \n        System.out.println(String.valueOf(c));                                   \n    }                                                                            \n}\n```\n\n首先使用javac命令编译代码,然后使用javap命令查看字节码:\n\n> javac Test.java\n> javap Test\n\n得到下面的输出:\n\n```\nCompiled from \"Test.java\"\npublic class Test {\n  public Test();\n  public static void main(java.lang.String[]);\n}\n```\n\n可以看到这里只有方法的声明,并没有具体的代码执行过程.这是因为执行过程都被编译成一个个字节码指令了.\n\n我们可以用javap -c命令被这些指令也显示出来:\n\n> javap -c Test\n\n输出为:\n\n```\nCompiled from \"Test.java\"\npublic class Test {\n  public Test();\n    Code:\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n       4: return\n\n  public static void main(java.lang.String[]);\n    Code:\n       0: bipush        12\n       2: istore_1\n       3: bipush        21\n       5: istore_2\n       6: iload_1\n       7: iload_2\n       8: iadd\n       9: istore_3\n      10: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n      13: iload_3\n      14: invokestatic  #3                  // Method java/lang/String.valueOf:(I)Ljava/lang/String;\n      17: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n      20: return\n}\n```\n\n我们来一步步分析main方法里面的字节码指令:\n\n```\n// 将12这个常量压入操作数栈\n0: bipush        12\n\n// 弹出操作数栈顶的元素,保存到局部变量表第1个位置中,即将12从栈顶弹出,保存成变量1,此时栈已空\n2: istore_1\n\n// 将21这个常量压入操作数栈\n3: bipush        21\n\n// 弹出操作数栈顶的元素,保存到局部变量表第2个位置中,即将21从栈顶弹出,保存成变量2,此时栈已空\n5: istore_2\n\n// 从局部变量表获取第1个位置的元素,压入操作数栈中,即将12压入栈中\n6: iload_1\n\n// 从局部变量表获取第2个位置的元素,压入操作数栈中,即将21压入栈中\n7: iload_2\n\n// 弹出操作数栈顶的两个元素,进行加法操作,得到的结果再压入栈中,即弹出21和12相加得到33,再压入栈中\n8: iadd\n\n// 弹出操作数栈顶的元素,保存到局部变量表第3个位置中,即将33从栈顶弹出,保存成变量3,此时栈已空\n9: istore_3\n\n// 读取System中的静态成员变量out压入栈中\n10: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n\n// 从局部变量表获取第3个位置的元素,压入操作数栈中,即将33压入栈中\n13: iload_3\n\n// 弹出栈顶的33,执行String.valueOf方法,并将得到的返回值\"33\"压回栈中\n14: invokestatic  #3                  // Method java/lang/String.valueOf:(I)Ljava/lang/String;\n\n// 弹出栈顶的\"33\"和System.out变量去执行println方法\n17: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n\n// 退出方法\n20: return\n```\n\n上面的的流程比较复杂，可以结合下面这个动图理解一下:\n\n{% img /大概优秀的java程序员都要会分析class文件吧/gif1.gif %}\n\n如果看的比较仔细的同学可能会有疑问，为什么举报变量表里一开始位置0就会有个String[]在那呢？\n\n其实这个字符串数组就是传入的参数args,jvm会把参数都压如举报变量表给方法去使用,如果调用的是非静态方法,还会将该方法的调用对象也一起压入栈中.\n\n可能有同学一开始会对istore、iload...这些字节码指令的作用不那么熟悉,或者有些指令不知道有什么作用。不过这个没有关系，不需要死记硬背，遇到的时候搜索一下就是了。\n\n# 类型擦除的原理\n\n泛型是java中十分好用且常用的技术,之前也有写过两篇博客 [《java泛型那些事》](http://blog.islinjw.cn/2018/01/06/java%E6%B3%9B%E5%9E%8B%E9%82%A3%E4%BA%9B%E4%BA%8B/),[《再谈Java泛型》](http://blog.islinjw.cn/2018/02/04/%E5%86%8D%E8%B0%88Java%E6%B3%9B%E5%9E%8B/)总结过.感兴趣的同学可以去看看.\n\n这里我们就从编译出来的class文件里面看看泛型的实现:\n\n```\npublic class Test {                                                              \n    public static void main(String[] args) {                                     \n        foo(1);                                                                  \n    }                                                                            \n\n    public static <T> T foo(T a){                                                \n        return a;                                                                \n    }                                                                            \n}\n```\n\n让我们使用\"javap -c\"命令看看它生成的class文件是怎样的:\n\n```\nCompiled from \"Test.java\"\npublic class Test {\n  public Test();\n    Code:\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n       4: return\n\n  public static void main(java.lang.String[]);\n    Code:\n       0: iconst_1\n       1: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n       4: invokestatic  #3                  // Method foo:(Ljava/lang/Object;)Ljava/lang/Object;\n       7: pop\n       8: return\n\n  public static <T> T foo(T);\n    Code:\n       0: aload_0\n       1: areturn\n}\n```\n\n可以看到虽然声明部分还是可以看到泛型的影子:\n\n> public static <T> T foo(T);\n\n但是在调用的时候实际上是\n\n>  Method foo:(Ljava/lang/Object;)Ljava/lang/Object;\n\nmain 方法中先用iconst_1将常量1压入栈中,然后用Integer.valueOf方法装箱成Integer最后调用参数和返回值都是Object的foo方法.\n\n所以说泛型的实现原理实际上是将类型都变成了Obejct,所以才能接收所有继承Object的类型,但是像int,char这种不是继承Object的类型是不能传入的.\n\n然后由于类型最后都被擦除剩下Object了,所以jvm是不知道原来输入的类型的,于是乎下面的这种代码就不能编译通过了:\n\n```\npublic <T> T foo(){\n    return new T(); // 编译失败,因为T的类型最后会被擦除,变成Object\n}\n```\n\n# 非静态内部类持有外部类的引用的原因\n\n我们都知道非静态内部类是持有外部类的引用的,所以在安卓中使用Handler的话一般会声明成静态内部类,然后加上弱引用去防止内存泄露.\n\n接下来就让我们一起看看非静态内部类是怎么持有外部类的引用的。先写一个简单的例子:\n\n```\npublic class Test {\n    public void foo() {\n        Runnable r = new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(String.valueOf(Test.this));\n            }\n        };\n    }\n}\n```\n\n通过javac命令编译之后发现得到了两个class文件:\n\n> Test$1.class Test.class\n\nTest.class文件好理解应该就是Test这个类的定义,那Test$1.class定义的Test$1类又是从哪里来的呢？\n\n这里还有个大家可能忽略的知识点,java里面变量名类名是可以包含$符号的,例如下面的代码都是合法且可以通过编译并且正常运行的\n\n```\nint x$y = 123;\nSystem.out.println(x$y);\n```\n\n回到正题,让我们先来用\"javap -c\"命令看看Test.class里面的内容:\n\n```\nCompiled from \"Test.java\"\npublic class Test {\n  public Test();\n    Code:\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n       4: return\n\n  public void foo();\n    Code:\n       0: new           #2                  // class Test$1\n       3: dup\n       4: aload_0\n       5: invokespecial #3                  // Method Test$1.\"<init>\":(LTest;)V\n       8: astore_1\n       9: return\n}\n```\n\n我们来解析下foo方法:\n\n```\n// new一个Test$1类的对象,压入栈中\n0: new           #2                  // class Test$1\n\n// 复制一份栈顶的元素压入栈中,即现在栈里面有两个相同的Test$1对象\n3: dup\n\n// 将局部变量表位置为0的元素压入栈中,由于foo方法不是静态方法,所以这个元素实际上就是Test对象,即this\n4: aload_0\n\n// 调用Test$1(Test)这个构造方法,它有一个Test类型的参数,我们传入的就是栈顶的Test对象,同时我们会将栈顶第二个元素Test$1对象也传进去(也就是说用这个Test$1对象去执行构造方法)。于是我们就弹出了栈顶的一个Test对象和一个Test$1对象\n5: invokespecial #3                  // Method Test$1.\"<init>\":(LTest;)V\n\n// 将栈剩下的最后一个Test$1保存到局部变量表的位置1中。\n8: astore_1\n\n// 退出方法\n9: return\n```\n\n根据上面的字节码,我们可以逆向得到下面的代码:\n\n```\npublic class Test {\n    public void foo() {\n        Runnable r = new Test$1(this);\n    }\n}\n```\n\n接着我们再来看看Test$1.class：\n\n```\nCompiled from \"Test.java\"\nclass Test$1 implements java.lang.Runnable {\n  final Test this$0;\n\n  Test$1(Test);\n    Code:\n       0: aload_0\n       1: aload_1\n       2: putfield      #1                  // Field this$0:LTest;\n       5: aload_0\n       6: invokespecial #2                  // Method java/lang/Object.\"<init>\":()V\n       9: return\n\n  public void run();\n    Code:\n       0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;\n       3: aload_0\n       4: getfield      #1                  // Field this$0:LTest;\n       7: invokestatic  #4                  // Method java/lang/String.valueOf:(Ljava/lang/Object;)Ljava/lang/String;\n      10: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n      13: return\n}\n```\n\n这里定义了一个实现Runnable接口的Test$1类，它有一个参数为Test的构造方法和一个run方法。然后还有一个Test类型的成员变量this$0。继续解析这个两个方法的字节码:\n\n```\n  Test$1(Test);\n    Code:\n    \t// 将局部变量表中位置为0的元素压入栈中,由于这个方法不是静态的,所以这个元素就是Test$1的this对象\n       0: aload_0\n\n       // 将局部变量表位置为1的元素压入栈中,这个元素就是我们传入的参数Test对象\n       1: aload_1\n\n       // 这里弹出栈顶的两个元素,第一个Test对象,赋值给第二元素Test$1对象的this$0成员变量。也就是把我们传进来的Test对象保存给成员变量 this$0\n       2: putfield      #1                  // Field this$0:LTest;\n\n       // 将局部变量表中位置为0的元素压入栈中,还是Test$1的this对象\n       5: aload_0\n\n       // 使用栈顶Test$1的this对象去初始化\n       6: invokespecial #2                  // Method java/lang/Object.\"<init>\":()V\n\n       // 退出方法\n       9: return\n\n  public void run();\n    Code:\n        //拿到System的静态成员变量out压入栈中\n       0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;\n\n       // 将局部变量表中位置为0的元素压入栈中,由于这个方法不是静态的,所以这个元素就是Test$1的this对象\n       3: aload_0\n\n       // 弹出栈顶Test$1的this对象,获取它的this$0成员变量,压入栈中\n       4: getfield      #1                  // Field this$0:LTest;\n\n       // 弹出栈顶的this$0对象执行String.valueOf方法,得到的String对象压入栈中\n       7: invokestatic  #4                  // Method java/lang/String.valueOf:(Ljava/lang/Object;)Ljava/lang/String;\n\n       // 弹出栈顶的String对象和System.out对象去执行println方法,即调用System.out.println打印这个String对象\n       10: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n\n       // 退出方法\n       13: return\n```\n\n来来来,我们继续脑补它的源代码:\n\n```\npublic class Test$1 implements java.lang.Runnable {\n    final Test this$0;\n\n    public Test$1(Test test) {\n        this$0 = test;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(String.valueOf(this$0));\n    }\n}\n```\n\n所以我们通过字节码,发现下面这个代码:\n\n```\npublic class Test {\n    public void foo() {\n        Runnable r = new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(String.valueOf(Test.this));\n            }\n        };\n    }\n}\n```\n\n编译之后最终会生成两个类:\n\n```\npublic class Test {\n    public void foo() {\n        Runnable r = new Test$1(this);\n    }\n}\n\npublic class Test$1 implements java.lang.Runnable {\n    final Test this$0;\n\n    public Test$1(Test test) {\n        this$0 = test;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(String.valueOf(this$0));\n    }\n}\n```\n\n这就是非静态内部类持有外部类的引用的原因啦。\n\n到这里这篇文章想讲的东西就已经都讲完了,还剩下一个问题就当做作业让同学们自己尝试这去分析吧:\n\n> 需要将自由变量声明成final才能给匿名内部类访问\n","tags":["技术相关","java"]},{"title":"Handler.postDelayed的原理","url":"/2019/03/02/Handler-postDelayed的原理/","content":"\n大部分同学在回答Handler的原理的时候都能回答出Handler将消息丢到MessageQueue中,然后Looper.loop死循环不断从MessageQueue中拿消息去执行。\n\n这块我之前也有写个文章介绍,如果忘了可以去[看看](http://blog.islinjw.cn/2017/07/02/Android%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0-Handler/)。\n\n但是如果再继续追问Handler.postDelay又是怎么做到的就讲不出来了。这里就给大家讲一讲。\n\n# 源码解析\n\n首先来看看handler里面是怎么处理postDelayed的:\n\n```\npublic class Handler {\n\t...\n\n\tpublic final boolean postDelayed(Runnable r, long delayMillis) {\n        return sendMessageDelayed(getPostMessage(r), delayMillis);\n    }\n    ...\n    public final boolean sendMessageDelayed(Message msg, long delayMillis) {\n        ...\n        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\n    }\n    ...\n    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n        MessageQueue queue = mQueue;\n        ...\n        return enqueueMessage(queue, msg, uptimeMillis);\n    }\n    ...\n    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n        msg.target = this;\n        ...\n        return queue.enqueueMessage(msg, uptimeMillis);\n    }\n    ...\n}\n```\n\n可以发现最后它也是把Runnable封装成Message然后发给MessageQueue去处理的,所以我们继续看看MessageQueue.enqueueMessage方法:\n\n```\nboolean enqueueMessage(Message msg, long when) {\n    ...\n    synchronized (this) {\n        ...\n        msg.markInUse();\n        msg.when = when;\n        Message p = mMessages;\n        boolean needWake;\n        if (p == null || when == 0 || when < p.when) {\n        \t// 插入到队列头\n            msg.next = p;\n            mMessages = msg;\n            needWake = mBlocked;\n        } else {\n        \t// 按时间排序插入队列\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();\n            Message prev;\n            for (;;) {\n                prev = p;\n                p = p.next;\n                if (p == null || when < p.when) {\n                    break;\n                }\n                if (needWake && p.isAsynchronous()) {\n                    needWake = false; //如果不是插入队列头的话不需要唤醒线程,让它继续等到拿队列头的消息的时候再重新计算睡眠时间\n                }\n            }\n            msg.next = p; // invariant: p == prev.next\n            prev.next = msg;\n        }\n\n        if (needWake) {\n        \t// 唤醒线程\n            nativeWake(mPtr);\n        }\n    }\n    return true;\n}\n```\n\n这个方法的作用其实很简单,按时间顺序把Message插入MessageQueue,形成一个按时间排序的单链表,然后唤醒线程。\n\n然后看看唤醒了什么线程?\n\n我们都知道MessageQueue中的消息是由Looper.loop里面的一个死循环去读取的。\n\n```\npublic static void loop() {\n    final Looper me = myLooper();\n    if (me == null) {\n        throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }\n    final MessageQueue queue = me.mQueue;\n    ...\n    for (;;) {\n        Message msg = queue.next(); // might block\n        ...\n    }\n    ...\n}\n```\n\n这个这里还提示了MessageQueue.next方法也许会阻塞,所以我们看看next方法里面干了什么:\n\n```\n\nMessage next() {\n    ...\n\n    int nextPollTimeoutMillis = 0;\n    for (;;) {\n        ...\n\n        //阻塞nextPollTimeoutMillis时间\n        nativePollOnce(ptr, nextPollTimeoutMillis);\n\n        synchronized (this) {\n            final long now = SystemClock.uptimeMillis();\n            Message prevMsg = null;\n            Message msg = mMessages;\n            if (msg != null && msg.target == null) {\n                // 跳过队列前面的无用Message\n                do {\n                    prevMsg = msg;\n                    msg = msg.next;\n                } while (msg != null && !msg.isAsynchronous());\n            }\n            if (msg != null) {\n                if (now < msg.when) {\n                    //如果时间没有到,就计算需要等待的时间\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {\n                    //从队列头拿出Message\n                    mBlocked = false;\n                    if (prevMsg != null) {\n                        prevMsg.next = msg.next;\n                    } else {\n                        mMessages = msg.next;\n                    }\n                    msg.next = null;\n                    msg.markInUse();\n                    return msg;\n                }\n            } \n            ...\n        }\n        ...\n    }\n}\n\n```\n\n这里面有个native方法nativePollOnce,阻塞线程一段固定的时间,当然MessageQueue.enqueueMessage里面的nativeWake方法也能直接唤醒它。当有Message插入队列头的时候,就会唤醒线程。然后MessageQueue.next方法就会拿出队列头的Message计算是否需要再等待一段时间去执行。\n\n\n# 举个例子\n\n代码比较晕没有关系,我们用一个简单的例子把流程描述一下就好理解了。\n\n首先假设队列里面有两个消息，分别在三秒、四秒之后执行,也就是说MessageQueue.next的线程会睡眠三秒之后才去消息队列拿队列头的消息:\n\n{% img /Handler.postDelayed的原理/1.png %}\n\n此时,我们又post了一个一秒之后执行的Message,于是它会被插入到队列头,然后MessageQueue.next的线程会被唤醒。但是拿到队列头的消息发现时间还没有到,于是又会再睡眠一秒:\n\n\n{% img /Handler.postDelayed的原理/2.png %}\n\n等了一秒之后MessageQueue.next的线程自己苏醒拿出队列头的MessageC去分发,然后继续拿MessageA。但是发现时间又没有到,于是又会再睡眠两秒:\n\n\n{% img /Handler.postDelayed的原理/3.png %}\n\n这个时候如果我们插入了一个立马执行的消息呢？它也是会插入到队列头,然后唤醒MessageQueue.next的线程,去队列头取消息执行。执行完之后又会拿MessageA。但是发现时间又没有到,于是又会再睡眠两秒。\n","tags":["技术相关","Android"]},{"title":"安卓音视频播放 - NuPlayer","url":"/2019/01/19/安卓音视频播放-NuPlayer/","content":"\n系列文章:\n\n- [安卓音视频播放 - 总体架构](http://blog.islinjw.cn/2019/01/17/%E5%AE%89%E5%8D%93%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/)\n- [安卓音视频播放 - AwesomePlayer](http://blog.islinjw.cn/2019/01/17/%E5%AE%89%E5%8D%93%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE-AwesomePlayer/)\n- [安卓音视频播放 - NuPlayer](http://blog.islinjw.cn/2019/01/19/%E5%AE%89%E5%8D%93%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE-NuPlayer/)\n\n这里有一点需要提一下,不像StagefrightPlayerFactory直接就创建出了StagefrightPlayer, NuPlayerFactory创建出来的是NuPlayerDriver,不过NuPlayerDriver内部也是封装了NuPlayer,对NuPlayer进行调用就是了:\n\n```\nclass NuPlayerFactory : public MediaPlayerFactory::IFactory {\n\t...\n\n    virtual sp<MediaPlayerBase> createPlayer(pid_t pid) {\n        ALOGV(\" create NuPlayer\");\n        return new NuPlayerDriver(pid);\n    }\n};\n```\n\n接下来就要介绍NuPlayer了,NuPlayer的特点在于它用了Handler机制去实现子线程解码。对的,就是我们熟悉的Handler机制.只不过它是在C/C++的实现,但是原理和java层的是一样的。\n\n看下接口声明就会感觉似曾相识了:\n\n```\nstruct ALooper : public RefBase {\n\t...\n\tstatus_t start(bool runOnCallingThread = false,bool canCallJava = false,int32_t priority = PRIORITY_DEFAULT);\n\t...\n    status_t stop();\n    ...\n    void post(const sp<AMessage> &msg, int64_t delayUs);\n    ...\n    bool loop();\n    ...\n}\n\n\nstruct AHandler : public RefBase {\n...\nprotected:\n    virtual void onMessageReceived(const sp<AMessage> &msg) = 0;\n...\n}\n\nstruct AMessage : public RefBase {\n    AMessage();\n    AMessage(uint32_t what, const sp<const AHandler> &handler);\n\t...\n    void setTarget(const sp<const AHandler> &handler);\n\n    void clear();\n\n    void setInt32(const char *name, int32_t value);\n    void setInt64(const char *name, int64_t value);\n    void setSize(const char *name, size_t value);\n    void setFloat(const char *name, float value);\n    void setDouble(const char *name, double value);\n    void setPointer(const char *name, void *value);\n    void setString(const char *name, const char *s, ssize_t len = -1);\n    void setString(const char *name, const AString &s);\n    void setObject(const char *name, const sp<RefBase> &obj);\n    void setBuffer(const char *name, const sp<ABuffer> &buffer);\n    void setMessage(const char *name, const sp<AMessage> &obj);\n    ...\n    status_t post(int64_t delayUs = 0);\n    ...\n}\n```\n\n而Looper就是在NuPlayerDriver中创建并启动的\n\n```\n\nNuPlayerDriver::NuPlayerDriver(pid_t pid)\n    : mState(STATE_IDLE),\n      mIsAsyncPrepare(false),\n      mAsyncResult(UNKNOWN_ERROR),\n      mSetSurfaceInProgress(false),\n      mDurationUs(-1),\n      mPositionUs(-1),\n      mSeekInProgress(false),\n      mLooper(new ALooper),\n      mPlayerFlags(0),\n      mAtEOS(false),\n      mLooping(false),\n      mAutoLoop(false) {\n    ALOGV(\"NuPlayerDriver(%p)\", this);\n    mLooper->setName(\"NuPlayerDriver Looper\");\n\n    mLooper->start(\n            false, /* runOnCallingThread */\n            true,  /* canCallJava */\n            PRIORITY_AUDIO);\n\n    mPlayer = new NuPlayer(pid);\n    mLooper->registerHandler(mPlayer);\n\n    mPlayer->setDriver(this);\n}\n\nNuPlayerDriver::~NuPlayerDriver() {\n    ALOGV(\"~NuPlayerDriver(%p)\", this);\n    mLooper->stop();\n}\n```\n\n我们的NuPlayer其实是一个AHandler:\n\n```\nstruct NuPlayer : public AHandler {\n\t...\n    virtual void onMessageReceived(const sp<AMessage> &msg);\n    ...\n}\n```\n\n它通过AMessage::post方法将操作放到子线程中,这操作简直不能再熟悉,甚至就没有细讲的必要:\n\n```\nvoid NuPlayer::setDataSourceAsync(const sp<IStreamSource> &source) {\n    sp<AMessage> msg = new AMessage(kWhatSetDataSource, this);\n\n    sp<AMessage> notify = new AMessage(kWhatSourceNotify, this);\n\n    msg->setObject(\"source\", new StreamingSource(notify, source));\n    msg->post();\n}\n\n...\n\nvoid NuPlayer::prepareAsync() {\n    (new AMessage(kWhatPrepare, this))->post();\n}\n\n...\n\nvoid NuPlayer::onMessageReceived(const sp<AMessage> &msg) {\n\t...\n\tswitch (msg->what()) {\n\t\tcase kWhatSetDataSource:\n        {\n            ALOGV(\"kWhatSetDataSource\");\n\n            CHECK(mSource == NULL);\n\n            status_t err = OK;\n            sp<RefBase> obj;\n            CHECK(msg->findObject(\"source\", &obj));\n            if (obj != NULL) {\n                Mutex::Autolock autoLock(mSourceLock);\n                mSource = static_cast<Source *>(obj.get());\n            } else {\n                err = UNKNOWN_ERROR;\n            }\n\n            CHECK(mDriver != NULL);\n            sp<NuPlayerDriver> driver = mDriver.promote();\n            if (driver != NULL) {\n                driver->notifySetDataSourceCompleted(err);\n            }\n            break;\n        }\n\n        case kWhatPrepare:\n        {\n            mSource->prepareAsync();\n            break;\n        }\t\t\n        ...\n\t}\n\t...\n}\n```\n\n# NuPlayer::Source\n\nNuPlayer::Source顾名思义,是数据源的意思,它复制从音视频源读取数据。\n\n数据源在java层调用setDataSource方法之后,传递到NuPlayer都会打包成不同的NuPlayer::Source\n\n```\nvoid NuPlayer::setDataSourceAsync(const sp<IMediaHTTPService> &httpService, const char *url, const KeyedVector<String8, String8> *headers) {\n    sp<AMessage> msg = new AMessage(kWhatSetDataSource, this);\n    size_t len = strlen(url);\n\n    sp<AMessage> notify = new AMessage(kWhatSourceNotify, this);\n\n    sp<Source> source;\n    if (IsHTTPLiveURL(url)) {\n        source = new HTTPLiveSource(notify, httpService, url, headers);\n    } else if (!strncasecmp(url, \"rtsp://\", 7)) {\n        source = new RTSPSource(notify, httpService, url, headers, mUIDValid, mUID);\n    } else if ((!strncasecmp(url, \"http://\", 7) || !strncasecmp(url, \"https://\", 8)) && ((len >= 4 && !strcasecmp(\".sdp\", &url[len - 4])) || strstr(url, \".sdp?\"))) {\n        source = new RTSPSource(notify, httpService, url, headers, mUIDValid, mUID, true);\n    } else {\n        sp<GenericSource> genericSource = new GenericSource(notify, mUIDValid, mUID);\n        status_t err = genericSource->setDataSource(httpService, url, headers);\n\n        if (err == OK) {\n            source = genericSource;\n        } else {\n            ALOGE(\"Failed to set data source!\");\n        }\n    }\n    msg->setObject(\"source\", source);\n    msg->post();\n}\n\nvoid NuPlayer::setDataSourceAsync(int fd, int64_t offset, int64_t length) {\n    sp<AMessage> msg = new AMessage(kWhatSetDataSource, this);\n\n    sp<AMessage> notify = new AMessage(kWhatSourceNotify, this);\n\n    sp<GenericSource> source = new GenericSource(notify, mUIDValid, mUID);\n\n    status_t err = source->setDataSource(fd, offset, length);\n\n    if (err != OK) {\n        ALOGE(\"Failed to set data source!\");\n        source = NULL;\n    }\n\n    msg->setObject(\"source\", source);\n    msg->post();\n}\n\nvoid NuPlayer::setDataSourceAsync(const sp<DataSource> &dataSource) {\n    sp<AMessage> msg = new AMessage(kWhatSetDataSource, this);\n    sp<AMessage> notify = new AMessage(kWhatSourceNotify, this);\n\n    sp<GenericSource> source = new GenericSource(notify, mUIDValid, mUID);\n    status_t err = source->setDataSource(dataSource);\n\n    if (err != OK) {\n        ALOGE(\"Failed to set data source!\");\n        source = NULL;\n    }\n\n    msg->setObject(\"source\", source);\n    msg->post();\n}\n\nvoid NuPlayer::setDataSourceAsync(const sp<IStreamSource> &source) {\n    sp<AMessage> msg = new AMessage(kWhatSetDataSource, this);\n\n    sp<AMessage> notify = new AMessage(kWhatSourceNotify, this);\n\n    msg->setObject(\"source\", new StreamingSource(notify, source));\n    msg->post();\n}\n```\n\n上面的HTTPLiveSource、RTSPSource、GenericSource、StreamingSource都继承NuPlayer::Source\n\n```\nstruct NuPlayer::HTTPLiveSource : public NuPlayer::Source {\n\t...\n}\n\nstruct NuPlayer::RTSPSource : public NuPlayer::Source {\n\t...\n}\n\nstruct NuPlayer::GenericSource : public NuPlayer::Source {\n\t...\n}\n\nstruct NuPlayer::StreamingSource : public NuPlayer::Source {\n\t...\n}\n```\n\n{% img /安卓音视频播放-NuPlayer/1.png %}\n\n可以看到NuPlayer根据音视频源的类型,创建了不同的NuPlayer::Source,然后放到了一个what=kWhatSetDataSource的AMessage中post了出去。\n\n让我们跟踪下NuPlayer这个Handler是怎么处理kWhatSetDataSource消息的:\n\n```\nvoid NuPlayer::onMessageReceived(const sp<AMessage> &msg) {\n    switch (msg->what()) {\n        case kWhatSetDataSource:\n        {\n        \t...\n        \tsp<RefBase> obj;\n        \tCHECK(msg->findObject(\"source\", &obj));\n        \t...\n        \tmSource = static_cast<Source *>(obj.get());\n        \t...\n        }\n    ...\n}\n```\n其实就是赋值了一下mSource\n\n## NuPlayer::Source准备数据\n\n首先在调用prepare方法之后NuPlayer会发送kWhatPrepare消息,在NuPlayer::onMessageReceived里面会调用NuPlayer::Source::prepareAsync方法:\n\n```\nvoid NuPlayer::prepareAsync() {\n    (new AMessage(kWhatPrepare, this))->post();\n}\n\nvoid NuPlayer::onMessageReceived(const sp<AMessage> &msg) {\n    switch (msg->what()) {\n        ...\n        case kWhatPrepare:\n        {\n            mSource->prepareAsync();\n            break;\n        }\n        ...\n    }\n}\n\n```\n\nNuPlayer::Source::prepareAsync是让NuPlayer::Source去准备好数据源,例如通过网络请求获取或者打开文件获取。\n\nNuPlayer::Source内部基本也是通过Handler机制异步去加载数据的,这里只举一个NuPlayer::GenericSource的例子:\n\n\n```\nvoid NuPlayer::GenericSource::prepareAsync() {\n    if (mLooper == NULL) {\n        mLooper = new ALooper;\n        mLooper->setName(\"generic\");\n        mLooper->start();\n\n        mLooper->registerHandler(this);\n    }\n\n    sp<AMessage> msg = new AMessage(kWhatPrepareAsync, this);\n    msg->post();\n}\n\nvoid NuPlayer::GenericSource::onMessageReceived(const sp<AMessage> &msg) {\n    switch (msg->what()) {\n      case kWhatPrepareAsync:\n      {\n          onPrepareAsync();\n          break;\n      }\n      ....\n}\n\nvoid NuPlayer::GenericSource::onPrepareAsync() {\n\t...\n\tif (!mUri.empty()) {\n\t\tconst char* uri = mUri.c_str();\n\t\t...\n\t\tmDataSource = DataSource::CreateFromURI(\n                   mHTTPService, uri, &mUriHeaders, &contentType,\n                   static_cast<HTTPBase *>(mHttpSource.get()));\n\t} else {\n\t\tmIsWidevine = false;\n\t\tmDataSource = new FileSource(mFd, mOffset, mLength);\n\t\tmFd = -1;\n\t}\n\t...\n\tfinishPrepareAsync();\n}\n```\n\n准备好数据之后会调用finishPrepareAsync用构造的时候传给NuPlayer::Source的kWhatSourceNotify消息复制出一个新的kWhatPrepared消息反向通知NuPlayer,这是一种标准的原型模式:\n\n```\n\nvoid NuPlayer::GenericSource::finishPrepareAsync() {\n\t...\n\tnotifyPrepared();\n\t...\n}\n\nvoid NuPlayer::Source::notifyPrepared(status_t err) {\n    sp<AMessage> notify = dupNotify();\n    notify->setInt32(\"what\", kWhatPrepared);\n    notify->setInt32(\"err\", err);\n    notify->post();\n}\n\nstruct NuPlayer::Source : public AHandler {\n\t...\n\tSource(const sp<AMessage> &notify)\n       : mNotify(notify) {\n\t}\n\t...\n\tsp<AMessage> dupNotify() const { return mNotify->dup(); }\n\t...\n}\n```\n\n然后NuPlayer::Source其实也充当了Demux的功能,它生命了一个dequeueAccessUnit纯虚方法,这个方法就是从数据源分离获取音频或者视频数据:\n\n```\nvirtual status_t dequeueAccessUnit( bool audio, sp<ABuffer> *accessUnit) = 0;\n```\n\n{% img /安卓音视频播放-NuPlayer/2.png %}\n\n# NuPlayer::Decoder\n\nNuPlayer::Decoder是NuPlayer的解码模块,然我们来看看它是怎么创建的吧。\n\n```\nvoid NuPlayer::start() {\n    (new AMessage(kWhatStart, this))->post();\n}\n\nvoid NuPlayer::onMessageReceived(const sp<AMessage> &msg) {\n    switch (msg->what()) {\n        ...\n        case kWhatStart:\n        {\n            ...\n            onStart();\n            ...\n        }\n        ...\n    }\n}\n\n//startPositionUs 有个默认值-1\nvoid NuPlayer::onStart(int64_t startPositionUs) {\n\t...\n\tsp<AMessage> notify = new AMessage(kWhatRendererNotify, this);\n\t...\n    mRenderer = new Renderer(mAudioSink, notify, flags);\n    ...\n    postScanSources();\n}\n\n```\n\n在onStart里面创建了Renderer,然后调用postScanSources\n\n```\n\nvoid NuPlayer::postScanSources() {\n    if (mScanSourcesPending) {\n        return;\n    }\n\n    sp<AMessage> msg = new AMessage(kWhatScanSources, this);\n    msg->setInt32(\"generation\", mScanSourcesGeneration);\n    msg->post();\n\n    mScanSourcesPending = true;\n}\n\nvoid NuPlayer::onMessageReceived(const sp<AMessage> &msg) {\n    switch (msg->what()) {\n        ...\n        case kWhatScanSources:\n        {\n            ...\n            if (mSurface != NULL) {\n                if (instantiateDecoder(false, &mVideoDecoder) == -EWOULDBLOCK) {\n                    rescan = true;\n                }\n            }\n\n            if (mAudioSink != NULL && mAudioDecoder == NULL) {\n                if (instantiateDecoder(true, &mAudioDecoder) == -EWOULDBLOCK) {\n                    rescan = true;\n                }\n            }\n            ...\n        }\n        ...\n    }\n}\n\nstatus_t NuPlayer::instantiateDecoder(bool audio, sp<DecoderBase> *decoder, bool checkAudioModeChange) {\n\t...\n\tsp<AMessage> format = mSource->getFormat(audio);\n\t...\n\tif (audio) {\n\t\t...\n\t\t*decoder = new Decoder(notify, mSource, mPID, mRenderer);\n\t\t...\n\t} else {\n\t\t...\n\t\t*decoder = new Decoder(notify, mSource, mPID, mRenderer, mSurface, mCCDecoder);\n\t\t...\n\t}\n\t(*decoder)->init();\n    (*decoder)->configure(format);\n\t...\n}\n\nvoid NuPlayer::Decoder::onConfigure(const sp<AMessage> &format) {\n\t...\n\tAString mime;\n    CHECK(format->findString(\"mime\", &mime));\n    ...\n\tmCodec = MediaCodec::CreateByType(\n            mCodecLooper, mime.c_str(), false /* encoder */, NULL /* err */, mPid);\n\t...\n}\n```\n\n从这里可以看到NuPlayer::Decoder实际上是通过MediaCodec去进行音视频的解码的。\n\nMediaCodec是安卓提供的,访问底层编解码器的接口。其实最后也是依赖OpenMax的。\n\n# NuPlayer::Render\n\nNuPlayer::Render顾名思义是做渲染的,但是经过代码分析,其实它的逻辑只是做音视频同步,然后音频渲染会交给MediaPlayerBase::AudioSink,而视频渲染会交回给NuPlayer::Decoder再交给MediaCodec。\n\n\n当NuPlayer::Decoder从NuPlayer::Source拿到数据并解码之后,会调用NuPlayer::Renderer::queueBuffer方法将解码之后的数据丢给NuPlayer::Renderer\n\n```\nbool NuPlayer::Decoder::handleAnOutputBuffer(\n        size_t index,\n        size_t offset,\n        size_t size,\n        int64_t timeUs,\n        int32_t flags) {\n\tsp<ABuffer> buffer;\n\tmCodec->getOutputBuffer(index, &buffer); // 从MediaCodec获取解码之后的数据\n\t...\n\t// 注意这里,这个reply用于让mRenderer回调NuPlayer::Decoder视频绘制.\n\t// 不过很多人都会忽略这行注释吧,没关系,读到后面你们还会返回来看的...\n\tsp<AMessage> reply = new AMessage(kWhatRenderBuffer, this); \n\t...\n\tmRenderer->queueBuffer(mIsAudio, buffer, reply);\n\t...\n}\n```\n\nNuPlayer::Renderer会往消息队列丢入kWhatQueueBuffer消息:\n\n```\nvoid NuPlayer::Renderer::queueBuffer(\n        bool audio,\n        const sp<ABuffer> &buffer,\n        const sp<AMessage> &notifyConsumed) {\n    sp<AMessage> msg = new AMessage(kWhatQueueBuffer, this);\n    msg->setInt32(\"queueGeneration\", getQueueGeneration(audio));\n    msg->setInt32(\"audio\", static_cast<int32_t>(audio));\n    msg->setBuffer(\"buffer\", buffer);\n    msg->setMessage(\"notifyConsumed\", notifyConsumed);\n    msg->post();\n}\n\nvoid NuPlayer::Renderer::onMessageReceived(const sp<AMessage> &msg) {\n    switch (msg->what()) {\n        case kWhatQueueBuffer:\n        {\n            onQueueBuffer(msg);\n            break;\n        }\n        ...\n}\n\nvoid NuPlayer::Renderer::onQueueBuffer(const sp<AMessage> &msg) {\n    int32_t audio;\n    CHECK(msg->findInt32(\"audio\", &audio));\n    ...\n    sp<ABuffer> buffer;\n    CHECK(msg->findBuffer(\"buffer\", &buffer));\n    \n    sp<AMessage> notifyConsumed;\n    CHECK(msg->findMessage(\"notifyConsumed\", &notifyConsumed));\n\n    QueueEntry entry;\n    entry.mBuffer = buffer;\n    entry.mNotifyConsumed = notifyConsumed;\n    \n    ...\n    if (audio) {\n        Mutex::Autolock autoLock(mLock);\n        mAudioQueue.push_back(entry);\n        postDrainAudioQueue_l();\n    } else {\n        mVideoQueue.push_back(entry);\n        postDrainVideoQueue();\n    }\n    ...\n}\n```\n\n这里会判断是从AudioDecoder传来的音频数据,还是从VideoDecoder传来的视频数据。音频数据会丢到mAudioQueue而视频数据会丢到mVideoQueue,然后调用postDrainAudioQueue_l或者postDrainVideoQueue通过Handler机制发送音频处理消息或者视频处理消息\n\n## 音频处理\n\n让我们先看看音频部分的处理\n\n```\nvoid NuPlayer::Renderer::postDrainAudioQueue_l(int64_t delayUs) {\n\t...\n\tsp<AMessage> msg = new AMessage(kWhatDrainAudioQueue, this);\n    msg->setInt32(\"drainGeneration\", mAudioDrainGeneration);\n    msg->post(delayUs);\n}\n\nvoid NuPlayer::Renderer::onMessageReceived(const sp<AMessage> &msg) {\n    switch (msg->what()) {\n        case kWhatDrainAudioQueue:\n        {\n            if (onDrainAudioQueue()) {\n            \t...\n            }\n            ...\n        }\n        ...\n}\n\nbool NuPlayer::Renderer::onDrainAudioQueue() {\n\t...\n\twhile (!mAudioQueue.empty()) {\n        QueueEntry *entry = &*mAudioQueue.begin();\n        ...\n        ssize_t written = mAudioSink->write(entry->mBuffer->data() + entry->mOffset,\n                                            copy, false /* blocking */);\n        ...\n   }\n   ...\n}\n```\n\n可以看到这里NuPlayer::Renderer会从mAudioQueue拿音频数据然后写入mAudioSink。mAudioSink内部就会调用声音输出设备如喇叭等去播放了。\n\n## 视频处理\n\n接着看看视频处理\n\n```\nvoid NuPlayer::Renderer::postDrainVideoQueue() {\n\tsp<AMessage> msg = new AMessage(kWhatDrainVideoQueue, this);\n\t...\n\tmsg->post(postDelayUs);\n\t...\n}\n\nvoid NuPlayer::Renderer::onMessageReceived(const sp<AMessage> &msg) {\n    switch (msg->what()) {\n        case kWhatDrainVideoQueue:\n        {\n            ...\n            onDrainVideoQueue();\n            ...\n        }\n        ...\n}\n\nvoid NuPlayer::Renderer::onDrainVideoQueue() {\n\t...\n\tQueueEntry *entry = &*mVideoQueue.begin();\n\t...\n\t\n    entry->mNotifyConsumed->setInt64(\"timestampNs\", realTimeUs * 1000ll);\n    entry->mNotifyConsumed->setInt32(\"render\", !tooLate);\n    entry->mNotifyConsumed->post();\n\t...\n}\n```\n\n视频处理这里其实还会做一些数值计算,主要用于视频的平滑播放,这里就忽略了。然后就调用了mNotifyConsumed的post方法。这个mNotifyConsumed是啥呢?大家可以往上拉回到NuPlayer::Decoder::handleAnOutputBuffer给NuPlayer::Renderer丢入解码后的音视频数据那里,估计很多人都没有注意到。\n\n总之,它会给NuPlayer::Decoder发一个kWhatRenderBuffer消息,然后就会让NuPlayer::Decoder去渲染视频画面了,不过它也是交给MediaCodec去渲染而已:\n\n```\nvoid NuPlayer::Decoder::onMessageReceived(const sp<AMessage> &msg) {\n    ALOGV(\"[%s] onMessage: %s\", mComponentName.c_str(), msg->debugString().c_str());\n\n    switch (msg->what()) {\n        case kWhatRenderBuffer:\n        {\n            if (!isStaleReply(msg)) {\n                onRenderBuffer(msg);\n            }\n            break;\n        }\n        ...\n}\n\nvoid NuPlayer::Decoder::onRenderBuffer(const sp<AMessage> &msg) {\n\t...\n   err = mCodec->renderOutputBufferAndRelease(bufferIx, timestampNs);\n   ...\n}\n```\n\n这个mCodec大家可能都忘了是啥,其实在NuPlayer::Decoder那节有说过的,就是MediaCodec:\n\n```\nvoid NuPlayer::Decoder::onConfigure(const sp<AMessage> &format) {\n\t...\n\tAString mime;\n    CHECK(format->findString(\"mime\", &mime));\n\t...\n\tmCodec = MediaCodec::CreateByType(\n            mCodecLooper, mime.c_str(), false /* encoder */, NULL /* err */, mPid);\n\t...\n}\n```\n\n# 整体架构图\n\n所以NuPlayer的整个架构图如下:\n\n{% img /安卓音视频播放-NuPlayer/3.png %}\n\n可以看出来, NuPlayer的核心功能是依赖MediaCodec去实现的\n","tags":["技术相关","Android","音视频"]},{"title":"安卓音视频播放 - AwesomePlayer","url":"/2019/01/17/安卓音视频播放-AwesomePlayer/","content":"\n系列文章:\n\n- [安卓音视频播放 - 总体架构](http://blog.islinjw.cn/2019/01/17/%E5%AE%89%E5%8D%93%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/)\n- [安卓音视频播放 - AwesomePlayer](http://blog.islinjw.cn/2019/01/17/%E5%AE%89%E5%8D%93%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE-AwesomePlayer/)\n- [安卓音视频播放 - NuPlayer](http://blog.islinjw.cn/2019/01/19/%E5%AE%89%E5%8D%93%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE-NuPlayer/)\n\n# 音视频播放基础流程\n\n在讲具体的实现之前我们看一下音视频播放的基础流程:\n\n{% img /安卓音视频播放-AwesomePlayer/1.png %}\n\n流程很简单,就是将复用的音视频流解复用出编码后的音频流和编码后的视频流。然后通过音频解码解出PCM数据给音频设备去播放,通过视频解码解出YUV数据给视频设备去播放。\n\n# StagefrightPlayer\n\n[上一篇文章](http://blog.islinjw.cn/2019/01/17/%E5%AE%89%E5%8D%93%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/)有讲到MediaPlayerService会通过MediaPlayerFactory创建Player,其中一个创建的就是StagefrightPlayer.但它实际上是一个空壳,只是简单的调用AwesomePlayer的实现而已:\n\n\n```\n//StagefrightPlayer.h\nclass StagefrightPlayer : public MediaPlayerInterface {\n\t...\nprivate:\n\tAwesomePlayer *mPlayer;\n\t...\n}\n\n//StagefrightPlayer.cpp\nstatus_t StagefrightPlayer::pause() {\n    ALOGV(\"pause\");\n\n    return mPlayer->pause();\n}\n\nbool StagefrightPlayer::isPlaying() {\n    ALOGV(\"isPlaying\");\n    return mPlayer->isPlaying();\n}\n\nstatus_t StagefrightPlayer::seekTo(int msec) {\n    ALOGV(\"seekTo %.2f secs\", msec / 1E3);\n\n    status_t err = mPlayer->seekTo((int64_t)msec * 1000);\n\n    return err;\n}\n...\n```\n\n\n所以我们直接看AwesomePlayer的实现。\n\n# 多线程架构\n\n音视频的处理一般都很耗时,所以AwesomePlayer开了一个子线程去工作,防止阻塞住MediaPlayerService的主线程。\n\n具体的架构如下(这幅图是在这篇[博客](https://www.cnblogs.com/shakin/p/4463639.html)抄来的,这篇文章写得的确不错,大家感兴趣可以去仔细读一下:\n\n{% img /安卓音视频播放-AwesomePlayer/2.png %}\n\n首先AwesomePlayer内部有个TimedEventQueue对象,所有的操作都会封装成一个个的Event,丢到这个队列里。然后TimedEventQueue创建了一个子线程,不断从队列中拿出Event来执行。\n\n\n例如prepare操作最后会调到prepareAsync_l,这里面就是创建了个Event,通过postEvent丢到队列里:\n\n```\nstatus_t AwesomePlayer::prepareAsync_l() {\n    ...\n\n    if (!mQueueStarted) {\n        mQueue.start();\n        mQueueStarted = true;\n    }\n\n\t...\n    mAsyncPrepareEvent = new AwesomeEvent(\n            this, &AwesomePlayer::onPrepareAsyncEvent);\n\n    mQueue.postEvent(mAsyncPrepareEvent);\n\n    return OK;\n}\n\n```\n\nAwesomeEvent继承TimedEventQueue::Event,实现了fire方法,回调了注册的方法:\n\n```\nstruct AwesomeEvent : public TimedEventQueue::Event {\n    AwesomeEvent(\n            AwesomePlayer *player,\n            void (AwesomePlayer::*method)())\n        : mPlayer(player),\n          mMethod(method) {\n    }\n    ...\n    virtual void fire(TimedEventQueue *queue, int64_t /* now_us */) {\n        (mPlayer->*mMethod)();\n    }\n    ...\n};\n```\n\nTimedEventQueue::start创建了一个子线程,调用TimedEventQueue::threadEntry方法,这里面有个死循环一直在从Event队列中拿出Event,执行fire方法:\n\n```\nvoid TimedEventQueue::start() {\n    if (mRunning) {\n        return;\n    }\n\n    mStopped = false;\n\n    pthread_attr_t attr;\n    pthread_attr_init(&attr);\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n\n    pthread_create(&mThread, &attr, ThreadWrapper, this);\n\n    pthread_attr_destroy(&attr);\n\n    mRunning = true;\n}\n\nvoid *TimedEventQueue::ThreadWrapper(void *me) {\n\n    androidSetThreadPriority(0, ANDROID_PRIORITY_FOREGROUND);\n\n    static_cast<TimedEventQueue *>(me)->threadEntry();\n\n    return NULL;\n}\n\nvoid TimedEventQueue::threadEntry() {\n    ...\n    for (;;) {\n        ...\n        event = removeEventFromQueue_l(eventID);\n\n        if (event != NULL) {\n            // Fire event with the lock NOT held.\n            event->fire(this, now_us);\n        }\n    }\n}\n```\n\n\n# Demux\n\n我们先来看看prepare回调的时候实际是调用了AwesomePlayer::beginPrepareAsync\\_l()方法,在这里会实际的去设置数据源,然后初始化Demux、视频解码器和音频解码器:\n\n```\nvoid AwesomePlayer::onPrepareAsyncEvent() {\n    Mutex::Autolock autoLock(mLock);\n    beginPrepareAsync_l();\n}\n\n\nvoid AwesomePlayer::beginPrepareAsync_l() {\n    ...\n    status_t err = finishSetDataSource_l();\n    ...\n    status_t err = initVideoDecoder();\n    ...\n    status_t err = initAudioDecoder();\n}\n```\n\n\n先来看看AwesomePlayer::finishSetDataSource_l实际上是为音视频源找到对应的MediaExtractor,这个MediaExtractor的功能就是实现播放器的基础流程中的Demux,分解出视频流和音频流:\n\n{% img /安卓音视频播放-AwesomePlayer/3.png %}\n\n代码如下:\n\n```\n\nstatus_t AwesomePlayer::finishSetDataSource_l() {\n    ...\n    extractor = MediaExtractor::Create(dataSource, sniffedMIME.empty() ? NULL : sniffedMIME.c_str());\n    ...\n    status_t err = setDataSource_l(extractor);\n    ...\n}\n\n\nstatus_t AwesomePlayer::setDataSource_l(const sp<MediaExtractor> &extractor) {\n    ...\n    for (size_t i = 0; i < extractor->countTracks(); ++i) {\n        sp<MetaData> meta = extractor->getTrackMetaData(i);\n\n        const char *_mime;\n        CHECK(meta->findCString(kKeyMIMEType, &_mime));\n\n        String8 mime = String8(_mime);\n        ...\n        if (!haveVideo && !strncasecmp(mime.string(), \"video/\", 6)) {\n            setVideoSource(extractor->getTrack(i));\n            ...\n        } else if (!haveAudio && !strncasecmp(mime.string(), \"audio/\", 6)) {\n            setAudioSource(extractor->getTrack(i));\n            ...\n        }\n        ...\n    }\n    ...\n}\n```\n\n\nMediaExtractor::Create的实现也是蛮粗暴的,判断媒体类型,然后创建不同的MediaExtractor,如MPEG4Extractor、MP3Extractor等:\n\n```\n\nsp<MediaExtractor> MediaExtractor::Create(const sp<DataSource> &source, const char *mime) {\n\t..\n\tMediaExtractor *ret = NULL;\n\t    if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG4)\n\t            || !strcasecmp(mime, \"audio/mp4\")) {\n\t        ret = new MPEG4Extractor(source);\n\t    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG)) {\n\t        ret = new MP3Extractor(source, meta);\n\t    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AMR_NB)\n\t            || !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AMR_WB)) {\n\t        ret = new AMRExtractor(source);\n\t    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_FLAC)) {\n\t        ret = new FLACExtractor(source);\n\t    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_WAV)) {\n\t        ret = new WAVExtractor(source);\n\t    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_OGG)) {\n\t        ret = new OggExtractor(source);\n\t    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MATROSKA)) {\n\t        ret = new MatroskaExtractor(source);\n\t    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG2TS)) {\n\t        ret = new MPEG2TSExtractor(source);\n\t    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_WVM)) {\n\t        // Return now.  WVExtractor should not have the DrmFlag set in the block below.\n\t        return new WVMExtractor(source);\n\t    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC_ADTS)) {\n\t        ret = new AACExtractor(source, meta);\n\t    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG2PS)) {\n\t        ret = new MPEG2PSExtractor(source);\n\t    }\n\t...\n}\n```\n\n{% img /安卓音视频播放-AwesomePlayer/4.png %}\n\n# 解码器\n\n然后AwesomePlayer::initVideoDecoder、AwesomePlayer::initAudioDecoder里面就是调用OMXCodec去做解码,OMXCodec其实是OpenMax的一层封装。OpenMax就是具体的解码器实现了:\n\n```\n\nstatus_t AwesomePlayer::initVideoDecoder(uint32_t flags) {\n\t...\n\tmVideoSource = OMXCodec::Create(\n            mClient.interface(), mVideoTrack->getFormat(),\n            false, // createEncoder\n            mVideoTrack,\n            NULL, flags, USE_SURFACE_ALLOC ? mNativeWindow : NULL);\n   ...\n}\n\n\nstatus_t AwesomePlayer::initAudioDecoder() {\n\t...\n\tmOmxSource = OMXCodec::Create(\n                mClient.interface(), mAudioTrack->getFormat(),\n                false, // createEncoder\n                mAudioTrack);\n    ...\n}\n```\n\n# 播放流程\n\n应用在java层调用MediaPlayer.start,最终会通过IPC去到MediaPlayerService里调用到StagefrightPlayer::start方法,我们直接从这里开始往下挖:\n\n\n```\n//从这里开始是StagefrightPlayer.cpp里的代码\nstatus_t StagefrightPlayer::start() {\n    return mPlayer->play();\n}\n\n//从这里开始是AwesomePlayer.cpp里的代码\nstatus_t AwesomePlayer::play() {\n\t...\n    return play_l();\n}\n\nstatus_t AwesomePlayer::play_l() {\n    ...\n    createAudioPlayer_l();\n    ...\n    postVideoEvent_l();\n    ...\n    return OK;\n}\n\nvoid AwesomePlayer::postVideoEvent_l(int64_t delayUs) {\n    ...\n    mQueue.postEventWithDelay(mVideoEvent, delayUs < 0 ? 10000 : delayUs);\n}\n```\n\n在AwesomePlayer::play\\_l方法里面调用AwesomePlayer::createAudioPlayer\\_l创建了一个AudioPlayer,然后调用AwesomePlayer::postVideoEvent\\_l往mQueue里丢了一个事件。\n\n还记得这个mVideoEvent吗?它对应的是AwesomePlayer::onVideoEvent方法,也就是说把这个Event丢到mQueue里面之后AwesomePlayer::onVideoEvent就会在子线程中被调用\n\n```\nmVideoEvent = new AwesomeEvent(this, &AwesomePlayer::onVideoEvent);\n```\n\n让我们继续看看AwesomePlayer::onVideoEvent方法里面干了什么:\n\n```\nvoid AwesomePlayer::onVideoEvent() {\n\t...\n\tstatus_t err = mVideoSource->read(&mVideoBuffer, &options);\n\t...\n\tif ((mNativeWindow != NULL)\n            && (mVideoRendererIsPreview || mVideoRenderer == NULL)) {\n        mVideoRendererIsPreview = false;\n\n        initRenderer_l();\n    }\n    ...\n    if (mAudioPlayer != NULL && !(mFlags & (AUDIO_RUNNING | SEEK_PREVIEW))) {\n        startAudioPlayer_l();\n    }\n    ...\n    if (mVideoRenderer != NULL) {\n        ...\n        mVideoRenderer->render(mVideoBuffer);\n        ...\n        }\n    ...\n\tpostVideoEvent_l();\n}\n```\n\n这个方法最重要的就是创建一个VideoRender,从mVideoSource读取解码好的视频帧去渲染,渲染完之后再调AwesomePlayer::postVideoEvent\\_l再往队列丢入一个VideoEvent。于是画面就不断的刷新了。\n\n可以看到,这个方法内部也启动了音频播放器去播放音频。而且其实它还做了一些音视频同步的工作,但是考虑到逻辑比较啰嗦,我这里就省略了。\n\n\n# VideoRender\n\n最后让我们来看看VideoRendere是怎么来的\n\n```\nvoid AwesomePlayer::initRenderer_l() {\n\t...\n\tif (USE_SURFACE_ALLOC\n\t        && !strncmp(component, \"OMX.\", 4)\n\t        && strncmp(component, \"OMX.google.\", 11)\n\t        && strcmp(component, \"OMX.Nvidia.mpeg2v.decode\")) {\n\t    mVideoRenderer =\n\t        new AwesomeNativeWindowRenderer(mNativeWindow, rotationDegrees);\n\t} else {\n\t    mVideoRenderer = new AwesomeLocalRenderer(mNativeWindow, meta);\n\t}\n}\n```\n\n可以看到,是根据解码器类型用mNativeWindow创建了不同的AwesomeNativeWindowRenderer或者AwesomeLocalRenderer。这个mNativeWindow就是画面最终需要渲染到的地方\n\n我们看看mNativeWindow是怎么来的:\n\n```\n// AwesomePlayer.cpp\nstatus_t AwesomePlayer::setNativeWindow_l(const sp<ANativeWindow> &native) {\n    mNativeWindow = native;\n    ...\n}\n\nstatus_t AwesomePlayer::setSurfaceTexture(const sp<IGraphicBufferProducer> &bufferProducer) {\n   ...\n   err = setNativeWindow_l(new Surface(bufferProducer));\n   ...\n}\n\n//StagefrightPlayer.cpp\nstatus_t StagefrightPlayer::setVideoSurfaceTexture(\n        const sp<IGraphicBufferProducer> &bufferProducer) {\n    ALOGV(\"setVideoSurfaceTexture\");\n\n    return mPlayer->setSurfaceTexture(bufferProducer);\n}\n\n//MediaPlayerService.cpp\nstatus_t MediaPlayerService::Client::setVideoSurfaceTexture(\n\t...\n\tsp<MediaPlayerBase> p = getPlayer();\n\t...\n\tstatus_t err = p->setVideoSurfaceTexture(bufferProducer);\n\t...\n}\n\n//MediaPlayer.cpp\nstatus_t MediaPlayer::setVideoSurfaceTexture(\n        const sp<IGraphicBufferProducer>& bufferProducer)\n{\n    ...\n    return mPlayer->setVideoSurfaceTexture(bufferProducer);\n}\n\n\n//android_media_MediaPlayer.cpp\nstatic void setVideoSurface(JNIEnv *env, jobject thiz, jobject jsurface, jboolean mediaPlayerMustBeAlive)\n{\n    sp<MediaPlayer> mp = getMediaPlayer(env, thiz);\n    ...\n    sp<Surface> surface(android_view_Surface_getSurface(env, jsurface));\n    ...\n    new_st = surface->getIGraphicBufferProducer();\n    ...\n    mp->setVideoSurfaceTexture(new_st);\n}\n\nstatic void android_media_MediaPlayer_setVideoSurface(JNIEnv *env, jobject thiz, jobject jsurface)\n{\n    setVideoSurface(env, thiz, jsurface, true /* mediaPlayerMustBeAlive */);\n}\n\n//android.media.MediaPlayer.java\npublic class MediaPlayer extends PlayerBase\n                         implements SubtitleController.Listener\n                                  , VolumeAutomation\n                                  , AudioRouting\n{\n\t...\n\tprivate native void _setVideoSurface(Surface surface);\n\t...\n\tpublic void setDisplay(SurfaceHolder sh) {\n        mSurfaceHolder = sh;\n        Surface surface;\n        if (sh != null) {\n            surface = sh.getSurface();\n        } else {\n            surface = null;\n        }\n        _setVideoSurface(surface);\n        updateSurfaceScreenOn();\n    }\n    ...\n}\n```\n\n可以看到,VideoRendere最终是根据MediaPlayer.setDisplay这个方法设置的SurfaceHolder创建的到的。这就解释了画面是怎么渲染到指定的SurfaceView上的。\n\n# 完整架构图\n\n\n整个渲染的架构如下:\n\n{% img /安卓音视频播放-AwesomePlayer/5.png %}\n\n\n","tags":["技术相关","Android","音视频"]},{"title":"安卓音视频播放 - 总体架构","url":"/2019/01/17/安卓音视频播放-总体架构/","content":"\n系列文章:\n\n- [安卓音视频播放 - 总体架构](http://blog.islinjw.cn/2019/01/17/%E5%AE%89%E5%8D%93%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/)\n- [安卓音视频播放 - AwesomePlayer](http://blog.islinjw.cn/2019/01/17/%E5%AE%89%E5%8D%93%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE-AwesomePlayer/)\n- [安卓音视频播放 - NuPlayer](http://blog.islinjw.cn/2019/01/19/%E5%AE%89%E5%8D%93%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE-NuPlayer/)\n\n安卓上我们经常会使用MediaPlayer这个类去播放音频和视频,这篇笔记便从MediaPlayer着手,一层层分析安卓的音视频播放框架。\n\n# MediaPlayer\n\nMediaPlayer的使用很简单,如果是想要在一个SurfaceView上播放,assets下的video.mp4视频,只需要下面的几行代码就能在手机上看到视频画面了:\n\n```\nSurfaceView surfaceView = (SurfaceView) findViewById(R.id.surface);\nsurfaceView.getHolder().addCallback(new SurfaceHolder.Callback() {\n    @Override\n    public void surfaceCreated(SurfaceHolder holder) {\n        MediaPlayer player = new MediaPlayer();\n        player.setDisplay(holder); //设置画面显示在哪\n\n        try {\n            player.setDataSource(getAssets().openFd(\"video.mp4\"));  //设置视频源\n            player.prepare(); //准备视频数据\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        player.start(); //开始播放\n    }\n\n    @Override\n    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {\n\n    }\n\n    @Override\n    public void surfaceDestroyed(SurfaceHolder holder) {\n\n    }\n});\n```\n\nMediaPlayer的API和用法很简单,基本上只需要看熟谷歌官方给的这幅状态图,就能很方便的使用了。其实大部分情况下无非也就是setDataSource、prepare、start、pause、stop、reset、release这几个方法的调用:\n\n{% img /安卓音视频播放架构一/1.jpeg %}\n\n具体的使用细节我这边就不去赘述了,感兴趣的可以参考下[官方文档](https://developer.android.com/reference/android/media/MediaPlayer)。\n\n# 安卓Media框架\n\n我们在应用里面调了MediaPlayer的方法,其实底层都会通过IPC机制调到MediaPlayerService。其实不仅是MediaPlayer,android.media包下的媒体播放接口像AudioTrack、SoundPool、MediaCodec都是会调到MediaPlayerService去做具体的编解码操作的,安卓的媒体播放是个典型的C/S架构,可以参考下[官方文档](https://source.android.com/devices/media)的架构图:\n\n{% img /安卓音视频播放架构一/2.png %}\n\n使用C/S架构的好处就是可以比较方便的统一管理软硬件编解码资源.\n\n整个框架除了java层的MediaPlayer之外还涉及三个关键so库:\n\n- libmedia\\_jni.so 负责使用jni连接java层和native层,然后调用MediaPlayer类提供的接口\n- libmedia.so 对上层提供了MediaPlayer类负责客户端与MediaPlayerService的IPC通讯\n- libmediaplayerservice.so 负责统筹调度具体的编码器和解码器,它内部也实现了libmedia.so的IMediaPlayer类用于接收客户端通过IPC机制发送的指令\n\n他们的依赖关系如下\n\n{% img /安卓音视频播放架构一/3.png %}\n\n## 代码细节\n\n然后我们来追踪下具体的代码实现.\n\n其实android.media.MediaPlayer这个java类只是native层的一个代理,具体的实现都是通过jni调用到libmedia\\_jni.so里面的c/c++代码:\n\n```\npublic class MediaPlayer extends PlayerBase implements SubtitleController.Listener {\n  ...\n  static {\n    System.loadLibrary(\"media_jni\");\n    native_init();\n  }\n  ...\n  private static native final void native_init();\n  ...\n  private native void _setVideoSurface(Surface surface);\n  ...\n  private native void _prepare() throws IOException, IllegalStateException;\n  ...\n  private native void _start() throws IllegalStateException;\n  ...\n  public void setDataSource(FileDescriptor fd, long offset, long length) throws IOException, IllegalArgumentException, IllegalStateException {\n    _setDataSource(fd, offset, length);\n  }\n  ...\n  public void setDisplay(SurfaceHolder sh) {\n    mSurfaceHolder = sh;\n    Surface surface;\n    if (sh != null) {\n      surface = sh.getSurface();\n    } else {\n      surface = null;\n    }\n    _setVideoSurface(surface);\n    updateSurfaceScreenOn();\n  }\n  ...\n  public void prepare() throws IOException, IllegalStateException {\n    _prepare();\n    scanInternalSubtitleTracks();\n  }\n  ...\n  public void start() throws IllegalStateException {\n    baseStart();\n    stayAwake(true);\n    _start();\n  }\n  ...\n}\n```\n\nlibmedia\\_jni.so的实现可以在/frameworks/base/media/jni/android\\_media\\_MediaPlayer.cpp里面找到:\n\n```\nstatic void\nandroid_media_MediaPlayer_native_setup(JNIEnv *env, jobject thiz, jobject weak_this)\n{\n    sp<MediaPlayer> mp = new MediaPlayer();\n    ...\n    setMediaPlayer(env, thiz, mp);\n}\n\nstatic void\nandroid_media_MediaPlayer_prepare(JNIEnv *env, jobject thiz)\n{\n    sp<MediaPlayer> mp = getMediaPlayer(env, thiz);\n    ...\n    sp<IGraphicBufferProducer> st = getVideoSurfaceTexture(env, thiz);\n    mp->setVideoSurfaceTexture(st);\n\n    process_media_player_call( env, thiz, mp->prepare(), \"java/io/IOException\", \"Prepare failed.\" );\n}\n\nstatic void\nandroid_media_MediaPlayer_start(JNIEnv *env, jobject thiz)\n{\n    sp<MediaPlayer> mp = getMediaPlayer(env, thiz);\n    ...\n    process_media_player_call( env, thiz, mp->start(), NULL, NULL );\n}\n...\n```\n\n而libmedia\\_jni.so内部也是依赖了MediaPlayer这个类去干活,它的代码可以在/frameworks/av/include/media/mediaplayer.h和/frameworks/av/media/libmedia/mediaplayer.cpp找到,而它编译之后打包在libmedia.so中\n\n上面我们看到libmedia\\_jni.so里面调用了MediaPlayer的方法去干活,那MediaPlayer又是怎么干活的呢,看看具体代码:\n\n```\n//mediaplayer.h\nsp<IMediaPlayer> mPlayer;\n\n//mediaplayer.cpp\nstatus_t MediaPlayer::prepare()\n{\n    ...\n    status_t ret = prepareAsync_l();\n    ...\n}\n\nstatus_t MediaPlayer::prepareAsync_l()\n{\n    ...\n    return mPlayer->prepareAsync();\n    ...\n}\n```\n\n这里又依赖了一个IMediaPlayer,让我们继续挖一挖这个IMediaPlayer又是什么来的:\n\n```\nstatus_t MediaPlayer::attachNewPlayer(const sp<IMediaPlayer>& player)\n{\n    ...\n    mPlayer = player;\n    ...\n}\n\nstatus_t MediaPlayer::setDataSource(\n        const sp<IMediaHTTPService> &httpService,\n        const char *url, const KeyedVector<String8, String8> *headers)\n{\n    ALOGV(\"setDataSource(%s)\", url);\n    status_t err = BAD_VALUE;\n    if (url != NULL) {\n        const sp<IMediaPlayerService> service(getMediaPlayerService());\n        if (service != 0) {\n            sp<IMediaPlayer> player(service->create(this, mAudioSessionId));\n            if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||\n                (NO_ERROR != player->setDataSource(httpService, url, headers))) {\n                player.clear();\n            }\n            err = attachNewPlayer(player);\n        }\n    }\n    return err;\n}\n\n// MediaPlayer继承IMediaDeathNotifier\nIMediaDeathNotifier::getMediaPlayerService() {\n    Mutex::Autolock _l(sServiceLock);\n    if (sMediaPlayerService == 0) {\n        sp<IServiceManager> sm = defaultServiceManager();\n        sp<IBinder> binder;\n        do {\n            binder = sm->getService(String16(\"media.player\"));\n            if (binder != 0) {\n                break;\n            }\n            usleep(500000); // 0.5 s\n        } while (true);\n\n        if (sDeathNotifier == NULL) {\n            sDeathNotifier = new DeathNotifier();\n        }\n        binder->linkToDeath(sDeathNotifier);\n        sMediaPlayerService = interface_cast<IMediaPlayerService>(binder);\n    }\n    return sMediaPlayerService;\n}\n```\n\n可以看到getMediaPlayerService方法实际是从ServiceManager里面获取了\"media.player\"这个服务,然后拿到了IMediaPlayerService的Binder代理,又去到了MediaPlayerService::create方法:\n\n```\nsp<IMediaPlayer> MediaPlayerService::create(const sp<IMediaPlayerClient>& client,\n        audio_session_t audioSessionId)\n{\n    pid_t pid = IPCThreadState::self()->getCallingPid();\n    int32_t connId = android_atomic_inc(&mNextConnId);\n\n    sp<Client> c = new Client(\n            this, pid, connId, client, audioSessionId,\n            IPCThreadState::self()->getCallingUid());\n\n    ALOGV(\"Create new client(%d) from pid %d, uid %d, \", connId, pid,\n         IPCThreadState::self()->getCallingUid());\n\n    wp<Client> w = c;\n    {\n        Mutex::Autolock lock(mLock);\n        mClients.add(w);\n    }\n    return c;\n}\n```\n\nMediaPlayerService会创建一个Client返回给客户端,客户端这个Client调用到MediaPlayerService的功能了。顺嘴说一句,Client是MediaPlayerService的一个内部类,它继承了BnMediaPlayerService,而BnMediaPlayer又继承了BnInterface\\<IMediaPlayer\\>\n\n```\n//MediaPlayerService.h\nclass MediaPlayerService : public BnMediaPlayerService {\n\t...\n\tclass Client : public BnMediaPlayer {\n\t\t...\n\t}\n\t...\n}\n\n//IMediaPlayer.h\nclass BnMediaPlayer: public BnInterface<IMediaPlayer>\n{\npublic:\n    virtual status_t    onTransact( uint32_t code,\n                                    const Parcel& data,\n                                    Parcel* reply,\n                                    uint32_t flags = 0);\n};\n```\n\n## MediaPlayerService的工作原理\n\n查看MediaPlayerService的源码,可以知道在setDataSource的时候查找支持该源的播放器,然后创建出来使用:\n\n```\nstatus_t MediaPlayerService::Client::setDataSource(const sp<IMediaHTTPService> &httpService, const char *url, const KeyedVector<String8, String8> *headers)\n{\n    ...\n    player_type playerType = MediaPlayerFactory::getPlayerType(this, url);\n    sp<MediaPlayerBase> p = setDataSource_pre(playerType);\n    ...\n    setDataSource_post(p, p->setDataSource(httpService, url, headers));\n    ...\n}\n\nsp<MediaPlayerBase> MediaPlayerService::Client::setDataSource_pre(player_type playerType) {\n    ...\n    sp<MediaPlayerBase> p = createPlayer(playerType);\n    ...\n}\n\nsp<MediaPlayerBase> MediaPlayerService::Client::createPlayer(player_type playerType)\n{\n    sp<MediaPlayerBase> p = mPlayer;\n    ...\n    p = MediaPlayerFactory::createPlayer(playerType, this, notify, mPid);\n    ...\n    return p;\n}\n```\n\n可以看到内部都是通过MediaPlayerFactory这个工厂去实现的,MediaPlayerFactory::registerBuiltinFactories方法注册了一些播放器,根据音视频源选择合适的播放器去播放。值得强调的是在sdk 23及以前的系统中会有StagefrightPlayer、NuPlayer两个播放器,sdk 24之后,真正工作的播放器就只有一个NuPlayer了。当然,各个厂家自己的提供的播放器也可以在这里注册,像小米盒子的ROM就导入过VLC框架的播放器。由于我司还有大量的安卓4.4的机器,所以我这里会把两个播放器都讲一下。\n\n\n```\n// android sdk 23\nvoid MediaPlayerFactory::registerBuiltinFactories() {\n    Mutex::Autolock lock_(&sLock);\n\n    if (sInitComplete)\n        return;\n\n    registerFactory_l(new StagefrightPlayerFactory(), STAGEFRIGHT_PLAYER);\n    registerFactory_l(new NuPlayerFactory(), NU_PLAYER);\n    registerFactory_l(new TestPlayerFactory(), TEST_PLAYER);\n\n    sInitComplete = true;\n}\n\n// android sdk 24\nvoid MediaPlayerFactory::registerBuiltinFactories() {\n    Mutex::Autolock lock_(&sLock);\n\n    if (sInitComplete)\n        return;\n\n    registerFactory_l(new NuPlayerFactory(), NU_PLAYER);\n    registerFactory_l(new TestPlayerFactory(), TEST_PLAYER);\n\n    sInitComplete = true;\n}\n```\n\nStagefrightPlayer实际上指的是AwesomePlayer,在早期的安卓系统使用AwesomePlayer去播放本地视频,用NuPlayer去播放流媒体。后来因为某些原因(具体原因我没有找到,只是说AwesomePlayer有问题)所以逐渐用弃用了AwesomePlayer,统一使用NuPlayer去播放。在某些过度版本的安卓系统开发者选项里面还可以选择NuPlayer代替AwesomePlayer,到后期都不用选了,只有一个NuPlayer可以用。\n\n关于AwesomePlayer和NuPlayer的具体代码实现,我会在下篇文章继续解析．让我们继续讲这两个播放器都依赖的OpenMax框架．\n\n# OpenMax(OMX)框架\n\n开放多媒体加速层（英语：Open Media Acceleration，缩写为OpenMAX），一个不需要授权、跨平台的软件抽象层，以C语言实现的软件界面，用来处理多媒体。它是由Khronos Group提出的标准，也由他们来维持，目标在于创造一个统一的界面，加速大量多媒体资料的处理。\n\n也就是说OpenMax提供了具体的软硬件编解码能力,AwesomePlayer和NuPlayer依赖它,就能实现编解码功能.\n\nOpenMax分成三层：\n\n## 开发层（Development Layer，DL）\n\n这一层定义了一些基础的音频、视频以及图像算法,比如音频信号处理的快速傅立叶变换、滤波器,图像处理的色域转换(RGB、YUV等)、视频处理的MPEG-4, H.264, MP3, AAC 和 JPEG编解码等.\n\nDL层分为五个应用领域：\n\nAC - 音频编解码器\nIC - 图像编解码器\nIP - 图像处理（通用图像处理功能）\nSP - 信号处理（通用音频处理功能）\nVC - 视频编解码器（H264和MP4组件）\n\n它们都是一些比较算法层面的接口,由芯片原厂实现\n\n## 整合层（Integration Layer，IL）\n\n这一层整合了DL层的算法和功能,作为一个比较低层级的编解码器接口,也就是说实现了这一层的接口就实现了一个编解码器.它可以是软件的也可以是硬件的\n\n## 应用层（Application Layer，AL）\n\nAL层为多媒体中间件与应用层之间提供一个标准化的API接口,不同的系统都应有对应的实现,应用程序依赖这一层的接口进行编程,就能获得很好的跨平台特性.\n\n# 完整框架图\n\n到这里,整个音视频播放架构就很清晰了\n\n{% img /安卓音视频播放架构一/4.png %}\n","tags":["技术相关","Android","音视频"]},{"title":"Android跨进程抛异常的原理","url":"/2018/11/10/Android跨进程抛异常的原理/","content":"\n今天接到了个需求,需要用到跨进程抛异常。\n\n# 怎样将异常从服务端抛到客户端\n\n也就是说在Service端抛出的异常需要可以在Client端接收。印象中binder是可以传异常的,所以aidl直接走起:\n\n```\n// aidl文件\ninterface ITestExceptionAidl {\n    boolean testThrowException();\n}\n\n// service端实现\npublic class AidlService extends Service {\n    @Nullable\n    @Override\n    public IBinder onBind(Intent intent) {\n        return new ITestExceptionAidl.Stub() {\n\n            @Override\n            public boolean testThrowException() throws RemoteException {\n                if (true) {\n                    throw new RuntimeException(\"TestException\");\n                }\n                return true;\n            }\n        };\n    }\n}\n\n// client端实现\nbindService(intent, new ServiceConnection() {\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service) {\n        ITestExceptionAidl aidl = ITestExceptionAidl.Stub.asInterface(service);\n\n        try {\n            aidl.testThrowException();\n        } catch (Exception e) {\n            Log.e(\"testtest\", \"Exception\", e);\n        }\n    }\n\n    @Override\n    public void onServiceDisconnected(ComponentName name) {\n\n    }\n}, Context.BIND_AUTO_CREATE);\n```\n\n但是这个程序实际上运行起来是这样的:\n\n```\n01-01 05:31:55.475  4868  4880 E JavaBinder: *** Uncaught remote exception!  (Exceptions are not yet supported across processes.)\n01-01 05:31:55.475  4868  4880 E JavaBinder: java.lang.RuntimeException: TestException\n01-01 05:31:55.475  4868  4880 E JavaBinder:    at me.linjw.demo.ipcdemo.AidlService$1.testThrowException(AidlService.java:22)\n01-01 05:31:55.475  4868  4880 E JavaBinder:    at me.linjw.demo.ipcdemo.ITestExceptionAidl$Stub.onTransact(ITestExceptionAidl.java:48)\n01-01 05:31:55.475  4868  4880 E JavaBinder:    at android.os.Binder.execTransact(Binder.java:565)\n```\n\n看日志里面的ITestExceptionAidl$Stub.onTransact,也就是说在service端就已经被异常打断了,并没有传给client端,而且第一个大大的\"Exceptions are not yet supported across processes.\"是说异常不允许跨进程吗?但是我明明记得AIDL生成的代码里面就有向Parcel写入异常啊:\n\n```\npublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {\n    switch (code) {\n        case INTERFACE_TRANSACTION: {\n            reply.writeString(DESCRIPTOR);\n            return true;\n        }\n        case TRANSACTION_testThrowException: {\n            data.enforceInterface(DESCRIPTOR);\n            boolean _result = this.testThrowException();\n            reply.writeNoException(); // 这里写入的是没有抛出异常\n            reply.writeInt(((_result) ? (1) : (0)));\n            return true;\n        }\n    }\n    return super.onTransact(code, data, reply, flags);\n}\n```\n\n查找Parcel的源码,其实是有writeException方法的:\n\n\n```\npublic final void writeException(Exception e) {\n    int code = 0;\n    if (e instanceof Parcelable\n            && (e.getClass().getClassLoader() == Parcelable.class.getClassLoader())) {\n        // We only send Parcelable exceptions that are in the\n        // BootClassLoader to ensure that the receiver can unpack them\n        code = EX_PARCELABLE;\n    } else if (e instanceof SecurityException) {\n        code = EX_SECURITY;\n    } else if (e instanceof BadParcelableException) {\n        code = EX_BAD_PARCELABLE;\n    } else if (e instanceof IllegalArgumentException) {\n        code = EX_ILLEGAL_ARGUMENT;\n    } else if (e instanceof NullPointerException) {\n        code = EX_NULL_POINTER;\n    } else if (e instanceof IllegalStateException) {\n        code = EX_ILLEGAL_STATE;\n    } else if (e instanceof NetworkOnMainThreadException) {\n        code = EX_NETWORK_MAIN_THREAD;\n    } else if (e instanceof UnsupportedOperationException) {\n        code = EX_UNSUPPORTED_OPERATION;\n    } else if (e instanceof ServiceSpecificException) {\n        code = EX_SERVICE_SPECIFIC;\n    }\n    writeInt(code);\n    StrictMode.clearGatheredViolations();\n    if (code == 0) {\n        if (e instanceof RuntimeException) {\n            throw (RuntimeException) e;\n        }\n        throw new RuntimeException(e);\n    }\n    writeString(e.getMessage());\n    ...\n}\n```\n\n可以看到其实Parcel是支持写入异常的,但是只支持Parcelable的异常或者下面这几种异常:\n\n- SecurityException\n- BadParcelableException\n- IllegalArgumentException\n- NullPointerException\n- IllegalStateException\n- NetworkOnMainThreadException\n- UnsupportedOperationException\n- ServiceSpecificException\n\n如果是普通的RuntimeException,这打断写入,继续抛出。\n\n于是我们将RuntimeException改成它支持的UnsupportedOperationException试试:\n\n```\n// service端改成抛出UnsupportedOperationException\nppublic class AidlService extends Service {\n    @Nullable\n    @Override\n    public IBinder onBind(Intent intent) {\n        return new ITestExceptionAidl.Stub() {\n\n            @Override\n            public boolean testThrowException() throws RemoteException {\n                if (true) {\n                    throw new UnsupportedOperationException(\"TestException\");\n                }\n                return true;\n            }\n        };\n    }\n}\n\n// client端实现还是一样,不变\nbindService(intent, new ServiceConnection() {\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service) {\n        ITestExceptionAidl aidl = ITestExceptionAidl.Stub.asInterface(service);\n\n        try {\n            aidl.testThrowException();\n        } catch (Exception e) {\n            Log.e(\"testtest\", \"Exception\", e);\n        }\n    }\n\n    @Override\n    public void onServiceDisconnected(ComponentName name) {\n\n    }\n}, Context.BIND_AUTO_CREATE);\n```\n\n这样运行的话客户端就能捕获到异常:\n\n```\n01-01 05:49:46.770 19937 19937 E testtest: RemoteException\n01-01 05:49:46.770 19937 19937 E testtest: java.lang.UnsupportedOperationException: TestException\n01-01 05:49:46.770 19937 19937 E testtest:      at android.os.Parcel.readException(Parcel.java:1728)\n01-01 05:49:46.770 19937 19937 E testtest:      at android.os.Parcel.readException(Parcel.java:1669)\n01-01 05:49:46.770 19937 19937 E testtest:      at me.linjw.demo.ipcdemo.ITestExceptionAidl$Stub$Proxy.testThrowException(ITestExceptionAidl.java:77)\n01-01 05:49:46.770 19937 19937 E testtest:      at me.linjw.demo.ipcdemo.MainActivity$3.onServiceConnected(MainActivity.java:132)\n01-01 05:49:46.770 19937 19937 E testtest:      at android.app.LoadedApk$ServiceDispatcher.doConnected(LoadedApk.java:1465)\n01-01 05:49:46.770 19937 19937 E testtest:      at android.app.LoadedApk$ServiceDispatcher$RunConnection.run(LoadedApk.java:1482)\n01-01 05:49:46.770 19937 19937 E testtest:      at android.os.Handler.handleCallback(Handler.java:751)\n01-01 05:49:46.770 19937 19937 E testtest:      at android.os.Handler.dispatchMessage(Handler.java:95)\n01-01 05:49:46.770 19937 19937 E testtest:      at android.os.Looper.loop(Looper.java:154)\n01-01 05:49:46.770 19937 19937 E testtest:      at android.app.ActivityThread.main(ActivityThread.java:6097)\n01-01 05:49:46.770 19937 19937 E testtest:      at java.lang.reflect.Method.invoke(Native Method)\n01-01 05:49:46.770 19937 19937 E testtest:      at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1052)\n01-01 05:49:46.770 19937 19937 E testtest:      at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:942)\n```\n\n# 跨进程传递异常的原理\n\n好,知道了如何去跨进程传递异常之后,然后我们来看看异常到底是如何传递过去的。\n\n让我们再来看看异常写入的代码:\n\n```\n// 有异常的情况\npublic final void writeException(Exception e) {\n    int code = 0;\n    if (e instanceof Parcelable\n            && (e.getClass().getClassLoader() == Parcelable.class.getClassLoader())) {\n        // We only send Parcelable exceptions that are in the\n        // BootClassLoader to ensure that the receiver can unpack them\n        code = EX_PARCELABLE;\n    } else if (e instanceof SecurityException) {\n        code = EX_SECURITY;\n    } else if (e instanceof BadParcelableException) {\n        code = EX_BAD_PARCELABLE;\n    } else if (e instanceof IllegalArgumentException) {\n        code = EX_ILLEGAL_ARGUMENT;\n    } else if (e instanceof NullPointerException) {\n        code = EX_NULL_POINTER;\n    } else if (e instanceof IllegalStateException) {\n        code = EX_ILLEGAL_STATE;\n    } else if (e instanceof NetworkOnMainThreadException) {\n        code = EX_NETWORK_MAIN_THREAD;\n    } else if (e instanceof UnsupportedOperationException) {\n        code = EX_UNSUPPORTED_OPERATION;\n    } else if (e instanceof ServiceSpecificException) {\n        code = EX_SERVICE_SPECIFIC;\n    }\n    writeInt(code);\n    StrictMode.clearGatheredViolations();\n    if (code == 0) {\n        if (e instanceof RuntimeException) {\n            throw (RuntimeException) e;\n        }\n        throw new RuntimeException(e);\n    }\n    writeString(e.getMessage());\n    \n    // 之后还有一些写入堆栈的操作,比较多,这里可以不看\n}\n\npublic final void writeNoException() {\n    if (StrictMode.hasGatheredViolations()) {\n    \t\n\t\t// 如果StrictMode收集到了写违规行为会走这里,我们可以不关注它\n        writeInt(EX_HAS_REPLY_HEADER);\n        ...\n    } else {\n    \t// 一般情况下会走这里\n        writeInt(0);\n    }\n}\n```\n\n这里给每种支持的异常都编了个号码,它会往Parcel写入。而0代表的是没有发生异常。然后再看看读取异常的代码:\n\n```\npublic boolean testThrowException() throws android.os.RemoteException {\n    android.os.Parcel _data = android.os.Parcel.obtain();\n    android.os.Parcel _reply = android.os.Parcel.obtain();\n    boolean _result;\n    try {\n        _data.writeInterfaceToken(DESCRIPTOR);\n        mRemote.transact(Stub.TRANSACTION_testThrowException, _data, _reply, 0);\n        _reply.readException();\n        _result = (0 != _reply.readInt());\n    } finally {\n        _reply.recycle();\n        _data.recycle();\n    }\n    return _result;\n}\n\n\n// android.os.Parcel.readException\npublic final void readException() {\n    int code = readExceptionCode();\n    if (code != 0) {\n        String msg = readString();\n        \n        //在这个方法里面创建异常并且抛出\n        readException(code, msg);\n    }\n}\n```\n\n然后这里有个需要注意的点就是异常必须是写在Parcel的头部的,也就是说如果没有异常,我们先要将0写到头部,然后再将返回值继续往后面写入。如果有异常,我们要先将异常编码写入头部,然后就不需要再写入返回值了。\n\n这样,在客户端读取的时候读取的头部就能知道到底有没有异常,没有异常就继续读取返回值,有异常就将异常读取出来并且抛出。\n\n\n```\n// service端代码\nboolean _result = this.testThrowException();\nreply.writeNoException(); // 先写入异常\nreply.writeInt(((_result) ? (1) : (0))); // 再写入返回值\n\n\n// client端代码\nmRemote.transact(Stub.TRANSACTION_testThrowException, _data, _reply, 0);\n_reply.readException(); // 先读取异常,有异常的话readException方法里面会直接抛出\n_result = (0 != _reply.readInt()); // 再读取返回值\n```\n\n也就是Parcel的头部是一个标志位,标志了有异常或者无异常:\n\n\n{% img /Android跨进程抛异常的原理/1.png %}\n\n但是我们看到AIDL生成的代码都是写入的无异常,那我们抛出的异常是怎么传过去的呢?还记得这个打印吗?\n\n```\n01-01 05:31:55.475  4868  4880 E JavaBinder: *** Uncaught remote exception!  (Exceptions are not yet supported across processes.)\n01-01 05:31:55.475  4868  4880 E JavaBinder: java.lang.RuntimeException: TestException\n01-01 05:31:55.475  4868  4880 E JavaBinder:    at me.linjw.demo.ipcdemo.AidlService$1.testThrowException(AidlService.java:22)\n01-01 05:31:55.475  4868  4880 E JavaBinder:    at me.linjw.demo.ipcdemo.ITestExceptionAidl$Stub.onTransact(ITestExceptionAidl.java:48)\n01-01 05:31:55.475  4868  4880 E JavaBinder:    at android.os.Binder.execTransact(Binder.java:565)\n```\n\n我们去android.os.Binder.execTransact这里找找看, onTransact方法实际就是在这里被调用的\n\n```\nprivate boolean execTransact(int code, long dataObj, long replyObj, int flags) {\n\tParcel data = Parcel.obtain(dataObj);\n\tParcel reply = Parcel.obtain(replyObj);\n\tboolean res;\n\t\n\ttry {\n\t    res = onTransact(code, data, reply, flags);\n\t} catch (RemoteException|RuntimeException e) {\n\t    ...\n\t    reply.setDataPosition(0);\n\t    reply.writeException(e);\n\t    res = true;\n\t} catch (OutOfMemoryError e) {\n\t    RuntimeException re = new RuntimeException(\"Out of memory\", e);\n\t    reply.setDataPosition(0);\n\t    reply.writeException(re);\n\t    res = true;\n\t}\n\tcheckParcel(this, code, reply, \"Unreasonably large binder reply buffer\");\n\treply.recycle();\n\tdata.recycle();\n\t\n\treturn res;\n}\n```\n\n看,这里如果catch到了方法,也就是说我们服务端有抛出异常,就会在catch代码块里面先就Parcel的游标重置回0,然后往Parcel头部写入异常。\n\n好,到了这里其实整个流程就差不多了,但是我发现我没有看到那个\"Exceptions are not yet supported across processes.\"字符串,这个不支持的提示又是哪里来的呢?\n\n让我们再回忆下代码,在遇到不支持的异常类型的时候, writeException也会抛出异常:\n\n```\npublic final void writeException(Exception e) {\n    int code = 0;\n    if (e instanceof Parcelable\n            && (e.getClass().getClassLoader() == Parcelable.class.getClassLoader())) {\n        // We only send Parcelable exceptions that are in the\n        // BootClassLoader to ensure that the receiver can unpack them\n        code = EX_PARCELABLE;\n    } else if (e instanceof SecurityException) {\n        code = EX_SECURITY;\n    } else if (e instanceof BadParcelableException) {\n        code = EX_BAD_PARCELABLE;\n    } else if (e instanceof IllegalArgumentException) {\n        code = EX_ILLEGAL_ARGUMENT;\n    } else if (e instanceof NullPointerException) {\n        code = EX_NULL_POINTER;\n    } else if (e instanceof IllegalStateException) {\n        code = EX_ILLEGAL_STATE;\n    } else if (e instanceof NetworkOnMainThreadException) {\n        code = EX_NETWORK_MAIN_THREAD;\n    } else if (e instanceof UnsupportedOperationException) {\n        code = EX_UNSUPPORTED_OPERATION;\n    } else if (e instanceof ServiceSpecificException) {\n        code = EX_SERVICE_SPECIFIC;\n    }\n    writeInt(code);\n    StrictMode.clearGatheredViolations();\n    \n    // code为0,代表不支持这种异常,继续把异常抛出或者创建RuntimeException抛出\n    if (code == 0) {\n        if (e instanceof RuntimeException) {\n            throw (RuntimeException) e;\n        }\n        throw new RuntimeException(e);\n    }\n    ...\n}\n```\n\n由于这个writeException,已经是在catch代码块里面运行的了,没有人再去catch它,于是就会打断这个流程,直接跳出。形成了一个Uncaught remote exception。\n\n最后我们找到/frameworks/base/core/jni/android\\_util\\_Binder.cpp的onTransact方法,这里通过jni调到Java的execTransact方法,调用完之后进行ExceptionCheck,如果发现有异常的话就report_exception:\n\n```\nvirtual status_t onTransact(uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags = 0) {\n    JNIEnv* env = javavm_to_jnienv(mVM);\n\n    IPCThreadState* thread_state = IPCThreadState::self();\n    const int32_t strict_policy_before = thread_state->getStrictModePolicy();\n    \n    jboolean res = env->CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,\n        code, reinterpret_cast<jlong>(&data), reinterpret_cast<jlong>(reply), flags);\n\n    if (env->ExceptionCheck()) {\n        jthrowable excep = env->ExceptionOccurred();\n\n        // 就是这里啦\n        report_exception(env, excep,\n            \"*** Uncaught remote exception!  \"\n            \"(Exceptions are not yet supported across processes.)\");\n        res = JNI_FALSE;\n\n        env->DeleteLocalRef(excep);\n    }\n    ...\n}\n```\n\n","tags":["技术相关","Android"]},{"title":"记一个多线程锁的bug","url":"/2018/11/09/记一个多线程锁的bug/","content":"\n测试报了个问题,说我们的应用在退出之后,立即重新启动会无效,必须等几秒之后才能正常启动。\n\n追踪代码之后发现问题出在对一个资源的获取上。我们的应用在启动的时候需要获取一个设备资源,但是这个设备资源在程序退出之后几秒才被释放。导致在这几秒内重新启动程序的话就会获取设备资源失败。\n\n程序的大概逻辑如下:\n\n1. 获取到设备之后会起一个子线程,不断从设备中读取数据,然后分发给上层\n2. 退出的时候需要关闭这个子线程,并且释放设备资源\n3. 为了防止正在从设备中读取的时候释放设备,需要加锁保护\n\n读取数据的代码如下:\n\n```\n//在子线程中起一个死循环不断从设备读取数据\nwhile (true) {\n    synchronized (mLock) {\n        if (Thread.currentThread().isInterrupted()) {\n            break;\n        }\n\n        // 从设备中读取数据并且分发\n    }\n}\n```\n\n退出的时候会退出子线程,并且释放设备资源:\n\n```\nsynchronized (mLock) {\n    mWorkThread.interrupt();\n    // 释放设备资源\n}\n```\n\n乍一看是没有问题的,但是实际加上打印的话会发现,子线程的while在做完一个循环释放锁之后,又立马抢占了锁。导致在退出的时候迟迟不能获取到锁,一直阻塞在那。大概四五秒之后才拿到锁,打断子线程的死循环。\n\n这位前辈不小心踩到了个坑: synchronized是非公平锁。\n\n也就是说,当两个线程在竞争一个锁的时候,系统并不会公平的将锁你一次我一次的依次给两个线程,而是随机的给一个线程,并且比较大的概率是给上次获得锁的线程。这样就导致while循环里一直抢占锁资源,这样退出的那个代码块就一直被阻塞在那里了。\n\n暗暗欣喜自己之前的书没有白看,立马就想到关键原因。于是大手一挥,公平锁伺候:\n\n\n```\nprivate final ReentrantLock mLock = new ReentrantLock(true);\n\n...\n\n//在子线程中起一个死循环不断从设备读取数据\nwhile (true) {\n    mLock.lock();\n    if (Thread.currentThread().isInterrupted()) {\n        break;\n    }\n\n    // 从设备中读取数据并且分发\n    mLock.unlock();\n}\n\n...\n\n//退出的时候会退出子线程,并且释放设备资源\nmLock.lock();\nmWorkThread.interrupt();\n// 释放设备资源\nmLock.unlock();\n```\n\n验证ok,继续解别的bug去了。\n\n\n吃过午饭,缓了缓神,诈尸般反应过来。我也被带坑里去了!\n\n\n为什么一定要用加锁的方法?这锁一加,代码的执行效率怎么办？\n\n赶紧再改:\n\n\n```\n//在子线程中起一个死循环不断从设备读取数据\nwhile (true) {\n    if (Thread.currentThread().isInterrupted()) {\n        break;\n    }\n\n    // 从设备中读取数据并且分发\n}\n// 释放设备资源\n\n...\n\n//退出的时候会退出子线程\nmWorkThread.interrupt();\nmWorkThread.join(); // 用join去等待子线程退出,子线程在跳出while循环的时候会自己是否资源\n```\n\n解bug的时候还是需要有自己的思路才行,不能被有问题的代码影响,要不然最后往往不能彻底解决问题,甚至有可能继续埋坑。","tags":["技术相关","java"]},{"title":"插件化之启动没有注册的Activity","url":"/2018/10/25/插件化之启动没有注册的Activity/","content":"\n启动没有在AndroidManifest中注册的Activity是安卓插件化中一个很重要的知识点,只有这样你才能把Activity中分离出来,放到插件中．\n\n启动没有在AndroidManifest中注册的Activity，会涉及到Activity启动流程、反射、动态代理的知识,我觉得就算不学插件化,掌握这些知识也是很有用的．\n\n\n# Activity的启动流程\n\n为了达到启动没有在AndroidManifest中注册的Activity的目的,我们先来分析下Activity的启动流程,看看有没有什么突破口.\n\n这部分的知识我在[《从源码看Activity生命周期》](http://blog.islinjw.cn/2018/03/07/%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9C%8BActivity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/)这篇博客里面其实也有讲过,这里只做大概的讲解,然后做一些补充,感兴趣的同学可以将两篇博客结合起来看看．\n\n## 抛出ActivityNotFoundException的原因\n\n如果使用startActivity去启动一个没有在AndroidManifest中注册的Activity,正常情况下是会抛出ActivityNotFoundException的,那这个异常是怎么抛出来的呢?\n\n我们知道调用Activity.startActivity方法,实际上最后是调用了Instrumentation.execStartActivity:\n\n```\npublic class Instrumentation {\n  ...\n\n  public ActivityResult execStartActivity(\n                  Context who, IBinder contextThread, IBinder token, Activity target,\n                  Intent intent, int requestCode, Bundle options) {\n      ...\n      int result = ActivityManagerNative.getDefault()\n                         .startActivity(whoThread, who.getBasePackageName(), intent,\n                                      intent.resolveTypeIfNeeded(who.getContentResolver()),\n                                      token, target != null ? target.mEmbeddedID : null,\n                                      requestCode, 0, null, null, options);\n      checkStartActivityResult(result, intent);\n      ...\n  }\n\n  ...\n\n  public static void checkStartActivityResult(int res, Object intent) {\n        ...\n        switch (res) {\n              case ActivityManager.START_INTENT_NOT_RESOLVED:\n              case ActivityManager.START_CLASS_NOT_FOUND:\n                  if (intent instanceof Intent && ((Intent)intent).getComponent() != null)\n                      throw new ActivityNotFoundException(\n                              \"Unable to find explicit activity class \"\n                              + ((Intent)intent).getComponent().toShortString()\n                              + \"; have you declared this activity in your AndroidManifest.xml?\");\n                  throw new ActivityNotFoundException(\n                          \"No Activity found to handle \" + intent);\n              ...\n        }\n        ...\n    }\n\n    ...\n}\n\n```\n\n可以看到Instrumentation又是通过ActivityManagerNative.getDefault()拿到一个IActivityManager去调用其startActivity来启动Activity的．\n\n这个IActivityManager内部实际是通过Binder机制将处理转发给ActivityManagerService:\n\n```\npublic abstract class ActivityManagerNative extends Binder implements IActivityManager\n    ...\n\n    static public IActivityManager getDefault() {\n       return gDefault.get();\n    }\n\n    ...\n\n    private static final Singleton<IActivityManager> gDefault = new Singleton<IActivityManager>() {\n        protected IActivityManager create() {\n            //实际上是用Binder机制与AMS进行交互\n            IBinder b = ServiceManager.getService(\"activity\");\n            IActivityManager am = asInterface(b);\n            return am;\n        }\n    };\n\n    ...\n}\n```\n\n所以可以看到通过ActivityManagerService去startActivity之后会有个返回值.\n\nActivityManagerService内部会使用PackageManagerService查询这个Activity是否在AndroidManifest中注册.如果没有,就会返回START\\_CLASS\\_NOT\\_FOUND或者START\\_INTENT\\_NOT\\_RESOLVED,这个时候Instrumentation就会抛出ActivityNotFoundException.\n\n所以ActivityNotFoundException就是这样被抛出的．\n\n## Activity是怎样被创建的\n\n我们都知道两个不同的进程直接是不能直接访问内存的,所以处于应用进程的Activity肯定还是应用进程去创建,而不是被AMS创建的.\n\n这块的代码在ActivityThread中实现:\n\n```\npublic final class ActivityThread {\n    ...\n    final H mH = new H();\n\n    ...\n    @Override\n    public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,\n            ActivityInfo info, Configuration curConfig, Configuration overrideConfig,\n            CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,\n            int procState, Bundle state, PersistableBundle persistentState,\n            List<ResultInfo> pendingResults, List<ReferrerIntent> pendingNewIntents,\n            boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) {\n        ...\n        sendMessage(H.LAUNCH_ACTIVITY, r);\n    }\n\n    ...\n    private class H extends Handler {\n        public static final int LAUNCH_ACTIVITY         = 100;\n        ...\n\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case LAUNCH_ACTIVITY: {\n                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\");\n                    final ActivityClientRecord r = (ActivityClientRecord) msg.obj;\n\n                    r.packageInfo = getPackageInfoNoCheck(\n                            r.activityInfo.applicationInfo, r.compatInfo);\n                    handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\");\n                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                } break;\n                ...\n            }\n            ...\n    }\n    ...\n}\n```\n\nAMS会调用ActivityThread的scheduleLaunchActivity,在这个方法中会使用一个Hander同步到主线程中再去创建Activity.\n\n## Activity启动的原理图\n\n{% img /插件化之启动没有注册的Activity/1.png %}\n\n\n# 怎样欺骗ActivityManagerService\n\n从上面的Activity启动的原理图可以看到大概的流程是:\n\n应用将要启动的Activity告诉AMS->AMS检查Activity是否注册->AMS让ActivityThread去创建Activity．\n\n那是不是可以这样呢?\n\n1. 新建一个StubActivity并且在AndroidManifest中注册\n2. 将想要启动的Activity换成StubActivity,而将真正想要启动的Activity保存到Extra中\n3. 骗过AMS\n4. 在ActivityThread中拿出真正想要创建的Activity换回来去创建\n\n\n修改后的原理如下:\n\n{% img /插件化之启动没有注册的Activity/2.png %}\n\n## 将要启动的Activity替换成StubActivity\n\n第一步是将要启动的Activity替换成StubActivity,我们回顾下上一节看到的ActivityManagerNative代码:\n\n```\npublic abstract class ActivityManagerNative extends Binder implements IActivityManager\n    ...\n\n    static public IActivityManager getDefault() {\n       return gDefault.get();\n    }\n\n    ...\n\n    private static final Singleton<IActivityManager> gDefault = new Singleton<IActivityManager>() {\n        protected IActivityManager create() {\n            //实际上是用Binder机制与AMS进行交互\n            IBinder b = ServiceManager.getService(\"activity\");\n            IActivityManager am = asInterface(b);\n            return am;\n        }\n    };\n\n    ...\n}\n```\n\n可以看到这个gDefault其实是个静态的私有成员变量.\n\n那我们是不是可以通过反射,将它替换成我们写的Singleton<IActivityManager>,然后保存好原来的gDefault,在替换的代码里面先将要启动的Activity替换成StubActivity,然后再将Intent传给原来的gDefault?\n\n\n大概的做法如下:\n\n```\n\nclass MyActivityManager implements IActivityManager {\n    private IActivityManager mOrigin;\n\n    public MyActivityManager(IActivityManager origin) {\n        mOrigin = origin;\n    }\n    public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,\n            String resolvedType, IBinder resultTo, String resultWho, int requestCode, int flags,\n            ProfilerInfo profilerInfo, Bundle options) throws RemoteException {\n        // TODO 将要启动的activity替换成StubActivity\n\n        return mOrigin. startActivity(caller, callingPackage, intent,\n            resolvedType, resultTo, resultWho, requestCode, flags,\n            profilerInfo, options);\n    }\n    ...\n}\n\nClass c = Class.forName(\"android.app.ActivityManagerNative\");\nfinal Field field =  c.getDeclaredField(\"gDefault\");\nfield.setAccessible(true);\n\nSingleton<IActivityManager> proxy = new Singleton<IActivityManager>() {\n    protected IActivityManager create() {\n        return new MyActivityManager(field.get(null));\n    }\n};\n\nfield.set(null, proxy);\n\n```\n\n但是这个做法问题很大,首先我们要将IActivityManager的所有方法都实现一遍转发给mOrigin。而且最大的问题是IActivityManager和Singleton被隐藏了,我们在应用层是找不到定义的!\n\n那怎么办呢？别急,我们先来看看Singleton的实现:\n\n```\npublic abstract class Singleton<T> {\n    private T mInstance;\n\n    protected abstract T create();\n\n    public final T get() {\n        synchronized (this) {\n            if (mInstance == null) {\n                mInstance = create();\n            }\n            return mInstance;\n        }\n    }\n}\n```\n\n其实最终的IActivityManager是保存在mInstance这个变量里面的,我们只需要替换这个变量就好,于是就绕过了Singleton没有定义的问题。但是还有这个IActivityManager的定义问题摆在我们面前。\n\n怎么办呢？答案就是我们可以用动态代理的方法去创建IActivityManager。关于动态代理我之前写过一篇博客 [《Java自定义注解和动态代理》](http://blog.islinjw.cn/2016/05/27/Java%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/) ,大家感兴趣的话可以去看看。这里就直接把代码贴上了:\n\n```\n// 获取gDefault\nClass activityManagerClass = Class.forName(\"android.app.ActivityManagerNative\");\nField gDefaultField = activityManagerClass.getDeclaredField(\"gDefault\");\ngDefaultField.setAccessible(true);\nObject gDefault = gDefaultField.get(null);\n\n//　获取mIntance\nClass singletonClass = Class.forName(\"android.util.Singleton\");\nField mInstanceField = singletonClass.getDeclaredField(\"mInstance\");\nmInstanceField.setAccessible(true);\nObject mInstance = mInstanceField.get(gDefault);\n\n// 替换mIntance\nObject proxy = Proxy.newProxyInstance(\n        mInstance.getClass().getClassLoader(),\n        new Class[]{Class.forName(\"android.app.IActivityManager\")},\n        new IActivityManagerHandler(mInstance));\nmInstanceField.set(gDefault, proxy);\n\n\npublic static class IActivityManagerHandler implements InvocationHandler {\n    private Object mOrigin;\n\n    IActivityManagerHandler(Object origin) {\n        mOrigin = origin;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        if (\"startActivity\".equals(method.getName())) {\n            int index = 0;\n            for (int i = 0; i < args.length; i++) {\n                if (args[i] instanceof Intent) {\n                    index = i;\n                    break;\n                }\n            }\n            Intent raw = (Intent) args[index];\n\n            Intent intent = new Intent();\n            intent.setClassName(raw.getComponent().getPackageName(), StubActivity.class.getName());\n            intent.putExtra(\"RawIntent\", raw);\n            args[index] = intent;\n        }\n        return method.invoke(mOrigin, args);\n    }\n}\n```\n\n上面的代码的功能就是创建一个IActivityManager的代理,代理startActivity方法,将启动的Activity的Intent换成启动StubActivity的Intent,并且将原来的Intent保存起来放到RawIntent这个Extra里。\n\n然后用它去替换ActivityManagerNative.gDefault的mInstance成员变量。\n\n\n## 将StubActivity替换会要启动的Activity\n\n\n在上面我们已经将要启动的Activity替换成了已经注册了的StubActivity,这样在AMS检查的时候就能在AndroidManifest查到,不会报ActivityNotFoundException了.\n\n然后AMS会让ActivityThread去创建Activity,这个时候就要将StubActivity替换会真正要启动的Activity了.\n\n再回顾下这部分的代码:\n\n\n```\npublic final class ActivityThread {\n    ...\n    final H mH = new H();\n\n    ...\n    @Override\n    public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,\n            ActivityInfo info, Configuration curConfig, Configuration overrideConfig,\n            CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,\n            int procState, Bundle state, PersistableBundle persistentState,\n            List<ResultInfo> pendingResults, List<ReferrerIntent> pendingNewIntents,\n            boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) {\n        ...\n        sendMessage(H.LAUNCH_ACTIVITY, r);\n    }\n\n    ...\n    private class H extends Handler {\n        public static final int LAUNCH_ACTIVITY         = 100;\n        ...\n\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case LAUNCH_ACTIVITY: {\n                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\");\n                    final ActivityClientRecord r = (ActivityClientRecord) msg.obj;\n\n                    r.packageInfo = getPackageInfoNoCheck(\n                            r.activityInfo.applicationInfo, r.compatInfo);\n                    handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\");\n                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                } break;\n                ...\n            }\n            ...\n    }\n    ...\n}\n```\n\nActivityThread的scheduleLaunchActivity方法会被调到,然后会向mH发送LAUNCH_ACTIVITY消息.\n\n所以关键点就是将这个mH变量替换成我们的代理对象,将Intent替换回之前保存的RawIntent.\n\n但是这里有个问题,H是个内部类,我们是没有办法用动态代理的方式创建内部类的,也就是说我们没有办法替换掉mH这个对象.\n\n于是只好继续挖一挖Handler内部有没有机会了,其实在Handler.dispatchMessage里面是会先判断mCallback是不是有赋值的,如果有就会将消息交给它去处理.\n\n```\npublic class Handler {\n    ...\n    final Callback mCallback;\n    ...\n    public void dispatchMessage(Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n    ...\n}\n```\n\n所以我们可以从这个mCallback入手,将mH的mCallback设置成我们的代理对象:\n\n```\n//　获取ActivityThread实例\nClass activityThreadClass = Class.forName(\"android.app.ActivityThread\");\nField threadField = activityThreadClass.getDeclaredField(\"sCurrentActivityThread\");\nthreadField.setAccessible(true);\nObject sCurrentActivityThread = threadField.get(null);\n\n//　获取mH变量\nField mHField = activityThreadClass.getDeclaredField(\"mH\");\nmHField.setAccessible(true);\nObject mH = mHField.get(sCurrentActivityThread);\n\n//　设置mCallback变量\nField mCallbackField = Handler.class.getDeclaredField(\"mCallback\");\nmCallbackField.setAccessible(true);\nHandler.Callback callback = new Handler.Callback() {\n   @Override\n   public boolean handleMessage(Message msg) {\n       if (msg.what == 100) {\n           try {\n               Field intentField = msg.obj.getClass().getDeclaredField(\"intent\");\n               intentField.setAccessible(true);\n               Intent intent = (Intent) intentField.get(msg.obj);\n               Intent raw = intent.getParcelableExtra(\"RawIntent\");\n               intent.setComponent(raw.getComponent());\n           } catch (Exception e) {\n               Log.e(\"hook\", \"get intent err\", e);\n           }\n\n       }\n       return false;\n   }\n};\nmCallbackField.set(mH, callback);\n```\n\nActivityThread的实例保存在sCurrentActivityThread这个静态成员变量里,代码我就不贴了,然后我们在mCallback这里将要启动的Activity设置回来.\n\n\n# 处理Android 8.0的情况\n\n上面的代码运行在8.0的系统上会崩溃,原因是8.0对Activity的启动这块做了些改动,不再使用ActivityManagerNative.getDefault()了,改成了ActivityManager.getService():\n\n\n```\npublic ActivityResult execStartActivity(\n            Context who, IBinder contextThread, IBinder token, Activity target,\n            Intent intent, int requestCode, Bundle options) {\n    ...\n    int result = ActivityManager.getService()\n        .startActivity(whoThread, who.getBasePackageName(), intent,\n                intent.resolveTypeIfNeeded(who.getContentResolver()),\n                token, target != null ? target.mEmbeddedID : null,\n                requestCode, 0, null, options);\n    checkStartActivityResult(result, intent);\n    ...\n}\n```\n\n\nActivityManager其实和ActivityManagerNative很像:\n\n```\npublic class ActivityManager {\n    ...\n    public static IActivityManager getService() {\n        return IActivityManagerSingleton.get();\n    }\n    ...\n    private static final Singleton<IActivityManager> IActivityManagerSingleton =\n          new Singleton<IActivityManager>() {\n              @Override\n              protected IActivityManager create() {\n                  final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);\n                  final IActivityManager am = IActivityManager.Stub.asInterface(b);\n                  return am;\n              }\n          };\n    ...\n}\n```\n\n所以我们类似的去替换IActivityManagerSingleton就好了:\n\n```\n// 获取IActivityManagerSingleton\nClass activityManagerClass = Class.forName(\"android.app.ActivityManager\");\nField singletonField = activityManagerClass.getDeclaredField(\"IActivityManagerSingleton\");\nsingletonField.setAccessible(true);\nObject gDefault = singletonField.get(null);\n\n//　获取mIntance\nClass singletonClass = Class.forName(\"android.util.Singleton\");\nField mInstanceField = singletonClass.getDeclaredField(\"mInstance\");\nmInstanceField.setAccessible(true);\nObject mInstance = mInstanceField.get(gDefault);\n\n// 替换mIntance\nObject proxy = Proxy.newProxyInstance(\n        mInstance.getClass().getClassLoader(),\n        new Class[]{Class.forName(\"android.app.IActivityManager\")},\n        new IActivityManagerHandler(mInstance));\nmInstanceField.set(gDefault, proxy);\n```\n\n# 处理AppCompatActivity的情况\n\n\n到目前为止,我们已经可以正常启动没有注册的Activity了,但是其实还有一个BUG:如果启动的是没有注册的AppCompatActivity就会崩溃。\n\n```\n10-25 19:32:30.867  8754  8754 E AndroidRuntime: Caused by: java.lang.IllegalArgumentException: android.content.pm.PackageManager$NameNotFoundException: ComponentInfo{me.linjw.plugindemo/me.linjw.plugindemo.HideActivity}\n10-25 19:32:30.867  8754  8754 E AndroidRuntime:        at android.support.v4.app.NavUtils.getParentActivityName(NavUtils.java:285)\n10-25 19:32:30.867  8754  8754 E AndroidRuntime:        at android.support.v7.app.AppCompatDelegateImplV9.onCreate(AppCompatDelegateImplV9.java:158)\n10-25 19:32:30.867  8754  8754 E AndroidRuntime:        at android.support.v7.app.AppCompatDelegateImplV14.onCreate(AppCompatDelegateImplV14.java:58)\n10-25 19:32:30.867  8754  8754 E AndroidRuntime:        at android.support.v7.app.AppCompatActivity.onCreate(AppCompatActivity.java:72)\n10-25 19:32:30.867  8754  8754 E AndroidRuntime:        at com.cvte.tv.speech.TestActivity.onCreate(TestActivity.java:14)\n10-25 19:32:30.867  8754  8754 E AndroidRuntime:        at android.app.Activity.performCreate(Activity.java:6664)\n10-25 19:32:30.867  8754  8754 E AndroidRuntime:        at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1118)\n10-25 19:32:30.867  8754  8754 E AndroidRuntime:        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2599)\n```\n\n网上很多讲启动未注册的Activity的文章要不就没有讲这个,要不就没有详细讲如何处理,直接一笔带过了.这里我手把手带大家解BUG.\n\n遇到问题先不要慌,先看看打印找到崩溃的代码在哪:\n\n```\n@Nullable\npublic static String getParentActivityName(Activity sourceActivity) {\n    try {\n        return getParentActivityName(sourceActivity, sourceActivity.getComponentName());\n    } catch (NameNotFoundException e) {\n        // Component name of supplied activity does not exist...?\n        throw new IllegalArgumentException(e);\n    }\n}\n\n@Nullable\npublic static String getParentActivityName(Context context, ComponentName componentName)\n        throws NameNotFoundException {\n    PackageManager pm = context.getPackageManager();\n    ActivityInfo info = pm.getActivityInfo(componentName, PackageManager.GET_META_DATA);\n    String parentActivity = IMPL.getParentActivityName(context, info);\n    return parentActivity;\n}\n```\n\n很明显是PackageManager.getActivityInfo在AndroidManifest里面找不到Activity抛出了NameNotFoundException.\n\n所以我们看看有没有办法替换一下这个Context.getPackageManager()拿到的PackageManager:\n\n\n```\nclass ContextImpl extends Context {\n\t...\n\t@Override\n\tpublic PackageManager getPackageManager() {\n\t    if (mPackageManager != null) {\n\t        return mPackageManager;\n\t    }\n\n\t    IPackageManager pm = ActivityThread.getPackageManager();\n\t    if (pm != null) {\n\t        // Doesn't matter if we make more than one instance.\n\t        return (mPackageManager = new ApplicationPackageManager(this, pm));\n\t    }\n\n\t    return null;\n\t}\n\t...\n}\n```\n\nContextImpl会从ActivityThread.getPackageManager获取IPackageManager,让我们继续挖:\n\n\n```\npublic final class ActivityThread {\n\t...\n\tstatic volatile IPackageManager sPackageManager;\n\t...\n\tpublic static IPackageManager getPackageManager() {\n\t    if (sPackageManager != null) {\n\t        //Slog.v(\"PackageManager\", \"returning cur default = \" + sPackageManager);\n\t        return sPackageManager;\n\t    }\n\t    IBinder b = ServiceManager.getService(\"package\");\n\t    //Slog.v(\"PackageManager\", \"default service binder = \" + b);\n\t    sPackageManager = IPackageManager.Stub.asInterface(b);\n\t    //Slog.v(\"PackageManager\", \"default service = \" + sPackageManager);\n\t    return sPackageManager;\n\t}\n\t...\n}\n```\n\n所以sPackageManager就是我们的突破点,让我们来把它换掉:\n\n```\ntry {\n    //要先获取一下,保证它初始化\n    context.getPackageManager();\n\n    Class activityThread = Class.forName(\"android.app.ActivityThread\");\n    Field pmField = activityThread.getDeclaredField(\"sPackageManager\");\n    pmField.setAccessible(true);\n    final Object origin = pmField.get(null);\n    Object handler = Proxy.newProxyInstance(activityThread.getClassLoader(),\n            new Class[]{Class.forName(\"android.content.pm.IPackageManager\")},\n            new PackageManagerHandler(context, origin));\n    pmField.set(null, handler);\n} catch (Exception e) {\n    Log.e(\"hook\", \"hook IPackageManager err\", e);\n}\n\nstatic class PackageManagerHandler implements InvocationHandler {\n        private Context mContext;\n        private Object mOrigin;\n\n        PackageManagerHandler(Context context, Object origin) {\n            mContext = context;\n            mOrigin = origin;\n        }\n\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            if (!method.getName().equals(\"getActivityInfo\")) {\n                return method.invoke(mOrigin, args);\n            }\n\n            //如果没有注册,并不会抛出异常,而是会直接返回null\n            Object ret = method.invoke(mOrigin, args);\n            if (ret == null) {\n                for (int i = 0; i < args.length; i++) {\n                    if (args[i] instanceof ComponentName) {\n                        ComponentName componentName = (ComponentName) args[i];\n                        componentName.getClassName();\n                        args[i] = new ComponentName(\n                        \tmContext.getPackageName(),\n                        \tStubActivity.class.getName()\n                        );\n                        return method.invoke(mOrigin, args);\n                    }\n                }\n            }\n            return ret;\n\n        }\n    }\n```\n\n在IPackageManager.getActivityInfo方法抛出异常的时候invoke会返回null,就代表这个Activity没有注册,我们直接将他换成StubActivity就好。\n\n大功告成!\n\n# 完整Demo\n\n完整Demo见我的[Github](https://github.com/bluesky466/PluginDemo)\n","tags":["技术相关","Android"]},{"title":"浅谈SurfaceView与GLSurfaceView","url":"/2018/09/21/浅谈SurfaceView与GLSurfaceView/","content":"\n# 什么是Surface\n\n让我们看看Surface的官方介绍:\n\n> Handle onto a raw buffer that is being managed by the screen compositor.\n\nSurface是一个raw buffer的句柄,我们可以通过它在raw buffer上进行绘制．\n\n对应到代码其实就是可以通过Surface获得一个Canvas:\n\n```\nCanvas canvas = mSurface.lockCanvas(null);\n//使用Canvas进行绘制\nmSurface.unlockCanvasAndPost(canvas);\n```\n\n# SurfaceView\n\nSurface可能大家比较陌生,但是SurfaceView和GLSurfaceView相信大家或多或少都会听说过．\n\nSurfaceView其实就是对Surface进行了一次封装,它内部帮我们管理了一个Surface．我们使用SurfaceView其实最终都是获取到这个Surface去绘制．\n\n这里开门见山,直接抛出一个简单的SurfaceView的用法,下面的Demo用SurfaceView画了一个１００*１００的红色矩形\n\n```\npublic class MySurfaceView extends SurfaceView implements SurfaceHolder.Callback {\n    private DrawThread mDrawThread;\n\n    public MySurfaceView(Context context) {\n        this(context, null);\n    }\n\n    public MySurfaceView(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public MySurfaceView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        getHolder().addCallback(this);\n    }\n\n    @Override\n    public void surfaceCreated(SurfaceHolder holder) {\n        mDrawThread = new DrawThread(holder.getSurface());\n        mDrawThread.start();\n    }\n\n    @Override\n    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {\n\n    }\n\n    @Override\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        mDrawThread.stopDraw();\n        try {\n            mDrawThread.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static class DrawThread extends Thread {\n        private Surface mSurface;\n        private boolean mRunning = true;\n        private Paint mPaint = new Paint();\n\n        DrawThread(Surface surface) {\n            mSurface = surface;\n            mPaint.setColor(Color.RED);\n        }\n\n        void stopDraw() {\n            mRunning = false;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n\n            while (mRunning) {\n                Canvas canvas = mSurface.lockCanvas(null);\n                canvas.drawColor(Color.WHITE);\n                canvas.drawRect(0, 0, 100, 100, mPaint);\n                mSurface.unlockCanvasAndPost(canvas);\n\n                try {\n                    Thread.sleep(50);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n运行效果如下:\n\n{% img /浅谈SurfaceView与GLSurfaceView/1.jpg %}\n\n这个Demo有几个关键代码,第一个是在构造函数里面使用getHolder()获取到SurfaceHolder,然后使用addCallback注册了个监听．这样就能监听SurfaceView内部Surface的生命周期．\n\n接着我们在surfaceCreated回调里面开启了一个DrawThread线程．它的主要工作就是在一个while循环里面不停的绘制．\n\n通过代码我们可以看到这个绘制的过程:\n\n1. 通过SurfaceHolder．getSurface可以获取到Surface\n2. 通过Surface.lockCanvas可以获取到Surface的Canvas\n3. 使用Canvas去绘制图像\n4. 使用Surface.unlockCanvasAndPost可以释放Canvas\n\n相信这个Demo代码不用再多说,大家都可以很快理解．从中我们可以看到,SurfaceView最大的特点就是可以在子线程中绘制图像．\n\n在子线程中绘制图像有什么好处呢？\n\n我们都知道一般情况下View都是在主线程中绘制的,而且需要通过measure、layout、draw三个步骤．当布局越复杂,绘制的效率就越低,而且主线程中的一些耗时操作也会进一步降低效率．\n\n如果使用SurfaceView的话我们就能越过measure、layout操作,而且不会被主线程的运算减低绘制性能．这样的特性十分适合于一些频繁更新且对刷新率有一定要求的程序,如相机的预览、画笔书写等．\n\n# GLSurfaceView\n\n而GLSurfaceView继承自SurfaceView,其实是对SurfaceView再做了一次封装,方便我们在安卓中使用OpenGL.\n\n我们都知道OpenGL是一个跨平台的图形库.它提供了一些全平台统一的图形接口.但是各个平台其实都有一些很难统一的差异,所以为了跨平台的兼容性,OpenGL不负责窗口管理及上下文管理.这部分由各个平台自己实现．EGL就是安卓平台上的实现它是 OpenGL ES 和底层 Native 平台视窗系统之间的接口．\n\n所以在安卓上使用OpenGL,都需要先用EGL进行一些初始化操作,结束的时候再用EGL做一些清理工作．\n\nGLSurfaceView已经帮我们用SurfaceHolder做了EGL的初始化和清理操作,所以我们不需要再去关心EGL．\n\n和我们上面写的SurfaceView的Demo一样,GLSurface的绘制也是在子线程中进行的,它为我们开启了一个GLThread，对一些处理事件进行了处理.我们只需要实现Renderer接口进行绘制即可,GLSurfaceView就会在GLThread中调用我们的Renderer进行绘制:\n\n```\npublic class GLSurfaceView extends SurfaceView implements SurfaceHolder.Callback2 {\n  ...\n  private Renderer mRenderer\n  ...\n  static class GLThread extends Thread {\n    ...\n    @Override\n    public void run() {\n      ...\n      guardedRun();\n      ...\n    }\n    ...\n    private void guardedRun() throws InterruptedException {\n      ...\n      while(true){\n        ...\n        view.mRenderer.onSurfaceCreated(gl, mEglHelper.mEglConfig);\n        ...\n        view.mRenderer.onSurfaceChanged(gl, w, h);\n        ...\n        view.mRenderer.onDrawFrame(gl);\n        ...\n      }\n      ...\n    }\n    ...\n  }\n  ...\n}\n```\n\n一个简单的Demo如下:\n\n```\npublic class MyGLSurfaceView extends GLSurfaceView {\n    public MyGLSurfaceView(Context context) {\n        this(context, null);\n    }\n\n    public MyGLSurfaceView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n\n        setRenderer(new MyRender());\n    }\n\n    private static class MyRender implements Renderer {\n        private FloatBuffer mVB;\n\n        MyRender() {\n            float coords[] = {\n                    -0.5f, 0.5f, 0.0f,\n                    -0.5f, -0.5f, 0.0f,\n                    0.5f, -0.5f, 0.0f,\n                    0.5f, -0.5f, 0.0f,\n                    0.5f, 0.5f, 0.0f,\n                    -0.5f, 0.5f, 0.0f\n            };\n\n            ByteBuffer vbb = ByteBuffer.allocateDirect(coords.length * 4);\n            vbb.order(ByteOrder.nativeOrder());\n            mVB = vbb.asFloatBuffer();\n            mVB.put(coords);\n            mVB.position(0);\n        }\n\n        @Override\n        public void onSurfaceCreated(GL10 gl, EGLConfig config) {\n            gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);\n        }\n\n        @Override\n        public void onSurfaceChanged(GL10 gl, int width, int height) {\n            gl.glViewport(0, 0, width, height);\n        }\n\n        @Override\n        public void onDrawFrame(GL10 gl) {\n            gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);\n            gl.glClearColor(1.0f, 1.0f, 1.0f, 1.0f);\n            gl.glColor4f(1.0f, 0.0f, 0.0f, 1.0f);\n            gl.glVertexPointer(3, GL10.GL_FLOAT, 0, mVB);\n            gl.glDrawArrays(GL10.GL_TRIANGLES, 0, 6);\n        }\n    }\n}\n```\n\n可以看到,我们实现了Renderer去画一个红色矩形,然后使用setRenderer设置给GLSurfaceView就可以了,运行效果如下:\n\n{% img /浅谈SurfaceView与GLSurfaceView/2.jpg %}\n\n","tags":["技术相关","Android"]},{"title":"OpenSL ES 学习笔记","url":"/2018/09/01/OpenSLES学习笔记/","content":"\n一般来讲在安卓中常使用AudioRecord、MediaRecorder对音频进行采集,使用SoundPool、MediaPlayer、AudioTrack进行音频播放。\n\n但是这些接口都是java层的,而NDK其实也提供了一个叫做OpenSL的C语言引擎用于声音的处理。\n\nOpenSL入门难度比较大,而且网上也没有什么特别好的教程,我这里把自己了解到的一些知识记录下来,希望以后忘记的时候可以快速回忆起来,也希望对大家有用。\n\n这篇笔记的很多内容都参考了OpenSL的官方文档OpenSL\\_ES\\_Specification\\_1.0.1.pdf,它是全英文的,可以在NDK的安装目录下找到,大家可以大概浏览一下,具体路径为:\n\n> $NDK_ROOT/docs/Additional\\_library\\_docs/opensles\n\n为什么要学OpenSL呢?除了C/C++的性能优势(不过其实java的效率也不低)之外,最主要是因为最近入坑FFmpeg,如果使用java层的接口,还需要通过一层JNI,比较复杂,性能消耗也大。如果用OpenSL的话就能直接在C/C++里面把事情都处理了。\n\n# 基本概念\n\n## Object和Interface\n\n在OpenSL里面,Object和Interface是两个很重要的概念,基本上所有的操作都是通过它们两个去执行的。\n\nObject和Interface是包含关系,一个Object里面包含了多个Interface:\n\n{% img /OpenSLES学习笔记/1.png %}\n\n### Object\n\nObject是一个资源的抽象集合,可以通过它获取各种资源。\n\n例如我们可以通过Object的GetInterface方法获取Interface。\n\n所有的Object在OpenSL里面我们拿到的都是一个SLObjectItf:\n\n```\nstruct SLObjectItf_ {\n\tSLresult (*Realize) (SLObjectItf self,SLboolean async);\n\n\tSLresult (*Resume) (SLObjectItf self,SLboolean async);\n\n\tSLresult (*GetState) (SLObjectItf self,SLuint32 * pState);\n\n\tSLresult (*GetInterface) (SLObjectItf self, const SLInterfaceID iid, void * pInterface);\n\n\tSLresult (*RegisterCallback) (SLObjectItf self, slObjectCallback callback, void * pContext);\n\n\tvoid (*AbortAsyncOperation) (SLObjectItf self);\n\n\tvoid (*Destroy) (SLObjectItf self);\n\n\tSLresult (*SetPriority) (SLObjectItf self, SLint32 priority, SLboolean preemptable);\n\n\tSLresult (*GetPriority) (SLObjectItf self, SLint32 *pPriority, SLboolean *pPreemptable);\n\n\tSLresult (*SetLossOfControlInterfaces) (SLObjectItf self, SLint16 numInterfaces, SLInterfaceID * pInterfaceIDs, SLboolean enabled);\n};\n\ntypedef const struct SLObjectItf_ * const * SLObjectItf;\n```\n\n在创建出来之后必须先调用Realize方法做初始化。在不需要使用的时候调用Destroy方法释放资源。\n\n#### GetInterface\n\nGetInterface可以说是OpenSL里使用频率最高的方法,通过它我们可以获取Object里面的Interface。\n\n由于一个Object里面可能包含了多个Interface,所以GetInterface方法有个SLInterfaceID参数来指定到的需要获取Object里面的那个Interface。\n\n例如下面代码我们通过EngineObject去获取SL_IID_ENGINE这个id的Interface,而这个id对应的Interface就是SLEngineItf:\n\n```\n//create EngineObject\nSLObjectItf engineObject;\nslCreateEngine(&engineObject, 0, NULL, 0, NULL, NULL);\n(*engineObject)->Realize(engineObject, SL_BOOLEAN_FALSE);\n\n//get SLEngineItf\nSLEngineItf engineInterface;\n(*engineObject)->GetInterface(engineObject, SL_IID_ENGINE, &engineInterface);\n```\n\n\n## Interface\n\nInterface则是方法的集合,例如SLRecordItf里面包含了和录音相关的方法,SLPlayItf包含了和播放相关的方法。我们功能都是通过调用Interfaces的方法去实现的。\n\n#### SLEngineItf\n\nSLEngineItf是OpenSL里面最重要的一个Interface,我们可以通过它去创建各种Object,例如播放器、录音器、混音器的Object,然后在用这些Object去获取各种Interface去实现各种功能。\n\n\n```\nstruct SLEngineItf_ {\n\tSLresult (*CreateAudioPlayer) (SLEngineItf self, SLObjectItf * pPlayer, SLDataSource *pAudioSrc, SLDataSink *pAudioSnk, SLuint32 numInterfaces, const SLInterfaceID * pInterfaceIds, const SLboolean * pInterfaceRequired);\n\n\tSLresult (*CreateAudioRecorder) (SLEngineItf self, SLObjectItf * pRecorder, SLDataSource *pAudioSrc, SLDataSink *pAudioSnk, SLuint32 numInterfaces, const SLInterfaceID * pInterfaceIds, const SLboolean * pInterfaceRequired);\n\n\tSLresult (*CreateOutputMix) (SLEngineItf self, SLObjectItf * pMix, SLuint32 numInterfaces, const SLInterfaceID * pInterfaceIds, const SLboolean * pInterfaceRequired);\n\n\t...\n};\n```\n\n# 录音\n\nOpenSL的录音功能是通过AudioRecorder来实现的,而AudioRecorder是通过SLEngineItf.CreateAudioRecorder方法创建的:\n\n```\nSLresult (*CreateAudioRecorder) (\n        SLEngineItf self,\n        SLObjectItf * pRecorder,\n        SLDataSource * pAudioSrc,\n        SLDataSink * pAudioSnk,\n        SLuint32 numInterfaces,\n        const SLInterfaceID * pInterfaceIds,\n        const SLboolean * pInterfaceRequired\n    );\n```\n\n各个参数的意义如下:\n\n- SLEngineItf C语言不像c++,没有this指针,只能每次调用SLEngineItf的方法的时候手动传入\n- SLObjectItf 用于保存创建出来的AudioRecorderObject\n- SLDataSource 数据的来源\n- SLDataSink 数据的去处\n- numInterfaces 与下面的SLInterfaceID和SLboolean配合使用,用于标记SLInterfaceID数组和SLboolean的大小\n- SLInterfaceID 这里需要传入一个数组,指定创建的AudioRecorderObject会包含哪些Interface\n- SLboolean 这里也是一个数组,用来标记每个需要包含的Interface,如果AudioRecorderObject不支持,是不是需要直接创建AudioRecorderObject失败。\n\n最后的三个参数用于指定AudioRecorderObject需要包含哪些Interface,如果不包含,是不是要直接创建失败。如果成功的话我们就能使用AudioRecorderObject的GetInterface方法获取到这些Interface了。\n\nSLDataSource和SLDataSink可能比较难理解。我们可以看下OpenSL录音的原理:\n\n{% img /OpenSLES学习笔记/2.png %}\n\n简而言之, AudioRecorder会从SLDataSource指定的数据源获取数据,然后将数据保存到SLDataSink指定的接收器。\n\nSLDataSource很明显就是录音设备(SL\\_IODEVICE\\_AUDIOINPUT):\n\n```\nSLDataLocator_IODevice device;\ndevice.locatorType = SL_DATALOCATOR_IODEVICE;\ndevice.deviceType = SL_IODEVICE_AUDIOINPUT;\ndevice.deviceID = SL_DEFAULTDEVICEID_AUDIOINPUT;\ndevice.device = NULL; //Must be NULL if deviceID parameter is to be used.\n\nSLDataSource source;\nsource.pLocator = &device;\nsource.pFormat = NULL; //This parameter is ignored if pLocator is SLDataLocator_IODevice.\n```\n\n而SLDataSink就可以任由我们指定了,它官方支持下面的类型:\n\n```\nSLDataLocator_Address\nSLDataLocator_IODevice\nSLDataLocator_OutputMix\nSLDataLocator_URI\nSLDataLocator_BufferQueue\nSLDataLocator_MIDIBufferQueue\n```\n\nAndroid又拓展了下面几种类型:\n\n```\nSLDataLocator_AndroidFD\nSLDataLocator_AndroidBufferQueue\nSLDataLocator_AndroidSimpleBufferQueue\n```\n\n我这边把它设置成SLDataLocator_AndroidSimpleBufferQueue,它比较通用, AudioRecorder把数据放到这个队列中,我们再可以从这个队列中拿出来使用:\n\n```\nSLDataLocator_AndroidSimpleBufferQueue queue;\nqueue.locatorType = SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE;\nqueue.numBuffers = 2;\n\nSLDataFormat_PCM format;\nformat.formatType = SL_DATAFORMAT_PCM;\nformat.numChannels = numChannels;\nformat.samplesPerSec = samplingRate;\nformat.bitsPerSample = SL_PCMSAMPLEFORMAT_FIXED_16;\nformat.containerSize = SL_PCMSAMPLEFORMAT_FIXED_16;\nformat.channelMask = getChannelMask(numChannels);\nformat.endianness = SL_BYTEORDER_LITTLEENDIAN;\n\nSLDataSink sink;\nsink.pLocator = &queue;\nsink.pFormat = &format;\n```\n\n同时在创建的时候需要检测下SL\\_DATALOCATOR\\_ANDROIDSIMPLEBUFFERQUEUE是不是支持:\n\n```\nSLInterfaceID id[] = {SL_IID_ANDROIDSIMPLEBUFFERQUEUE};\nSLboolean required[] = {SL_BOOLEAN_TRUE};\n\nSLObjectItf recorderObject;\n(engineInterface)->CreateAudioRecorder(\n        engineInterface,\n        &(recorderObject),\n        &source,\n        &sink,\n        1,\n        id,\n        required\n);\n(*recorderObject)->Realize(recorderObject, SL_BOOLEAN_FALSE);\n```\n\n所以我们可以通过GetInterface获取SLAndroidSimpleBufferQueueItf,然后注册个队列满的监听回调:\n\n```\nSLAndroidSimpleBufferQueueItf queueInterface;\n(*recorderObject)->GetInterface(\n        recorderObject,\n        SL_IID_ANDROIDSIMPLEBUFFERQUEUE,\n        &(queueInterface)\n);\n\n(*queueInterface)->RegisterCallback(\n        queueInterface,\n        bufferQueueCallback,\n        NULL\n);\n```\n\n回调函数如下,我们可以在这个时候从队列里面读取下来的音频数据:\n\n```\nstatic void bufferQueueCallback(SLAndroidSimpleBufferQueueItf queue, void *pContext) {\n\t...\n}\n```\n\n最后需要打开录音设备开始录音:\n\n```\nSLRecordItf recorderInterface;\n(*recorderObject)->GetInterface(\n        recorderObject,\n        SL_IID_RECORD,\n        &(recorderInterface)\n);\n\n(*recorderInterface)->SetRecordState(\n        recorderInterface,\n        SL_RECORDSTATE_RECORDING\n);\n```\n\n这里需要注意的是我们必须在队列满的时候将数据取出来,如果不取,那队列里面就没有空间可以继续存储音频数据了:\n\n```\n(*queueInterface)->Enqueue(queueInterface, buffer, BUFFER_SIZE*sizeof(short));\n```\n\n# 播放\n\n播放的代码和录音很类似。我们需要先创建AudioPlayer:\n\n```\nSLresult (*CreateAudioPlayer) (\n    SLEngineItf self,\n    SLObjectItf * pPlayer,\n    SLDataSource *pAudioSrc,\n    SLDataSink *pAudioSnk,\n    SLuint32 numInterfaces,\n    const SLInterfaceID * pInterfaceIds,\n    const SLboolean * pInterfaceRequired\n);\n```\n\n它的参数和CreateAudioRecorder一样,我就不再一个个去解释了,可以看看播放的过程:\n\n{% img /OpenSLES学习笔记/3.png %}\n\nSLDataSource我也用SLDataLocator_AndroidSimpleBufferQueue,这样我们可以往队列中不断写入音频数据,AudioRecorder会从队列中不断获取数据传递到混音器中:\n\n```\nSLDataLocator_AndroidSimpleBufferQueue queue;\nqueue.locatorType = SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE;\nqueue.numBuffers = 2;\n\nSLDataFormat_PCM format;\nformat.formatType = SL_DATAFORMAT_PCM;\nformat.numChannels = numChannels;\nformat.samplesPerSec = samplingRate;\nformat.bitsPerSample = SL_PCMSAMPLEFORMAT_FIXED_16;\nformat.containerSize = SL_PCMSAMPLEFORMAT_FIXED_16;\nformat.channelMask = getChannelMask(numChannels);\nformat.endianness = SL_BYTEORDER_LITTLEENDIAN;\n\nSLDataSource source;\nsource.pLocator = &queue;\nsource.pFormat = &format;\n```\n\n而SLDataSink需要配置成混音器。混音器用于将多个音频混合并且输出到喇叭:\n\n```\nSLObjectItf outputMixObject;\n(*engineInterface)->CreateOutputMix(\n        engineInterface,\n        &(outputMixObject),\n        0,\n        NULL,\n        NULL\n);\n(*outputMixObject)->Realize(\n        outputMixObject,\n        SL_BOOLEAN_FALSE\n);\n\nSLDataLocator_OutputMix outputMix;\noutputMix.locatorType = SL_DATALOCATOR_OUTPUTMIX;\noutputMix.outputMix = outputMixObject;\n\nSLDataSink sink;\nsink.pLocator = &outputMix;\nsink.pFormat = NULL; //This parameter is ignored if pLocator is SLDataLocator_IODevice or SLDataLocator_OutputMix.\n```\n\n同样的我们在创建AudioPlayer的时候会检查是不是支持SL\\_IID_ANDROIDSIMPLEBUFFERQUEUE:\n\n```\nSLObjectItf playerObject;\nSLInterfaceID id[] = {SL_IID_ANDROIDSIMPLEBUFFERQUEUE};\nSLboolean required[] = {SL_BOOLEAN_TRUE};\n(*engineInterface)->CreateAudioPlayer(\n        engineInterface,\n        &(playerObject),\n        &source,\n        &sink,\n        1,\n        id,\n        required\n);\n(*playerObject)->Realize(playerObject, SL_BOOLEAN_FALSE);\n```\n\n最后我们需要注册队列空的监听和打开播放器开始播放:\n\n```\nSLAndroidSimpleBufferQueueItf queueInterface;\n(*playerObject)->GetInterface(\n        playerObject,\n        SL_IID_ANDROIDSIMPLEBUFFERQUEUE,\n        &(queueInterface)\n);\n(*queueInterface)->RegisterCallback(\n        queueInterface,\n        bufferQueueCallback,\n        NULL\n);\n\n//////Begin Playing//////\nSLPlayItf playInterface;\n(*playerObject)->GetInterface(\n        playerObject,\n        SL_IID_PLAY,\n        &(playInterface)\n);\n(*playInterface)->SetPlayState(\n        playInterface,\n        SL_PLAYSTATE_PLAYING\n);\n```\n\n# Demo\n\n这里有个简单的录音和播放的[demo](https://github.com/bluesky466/OpenSLDemo),按兴趣的同学可以参考一下。\n","tags":["技术相关","Android","音视频"]},{"title":"写给安卓程序员的C/C++编译入门","url":"/2018/07/29/写给安卓程序员的cc-编译入门/","content":"\n最近部门新入职了几个小鲜肉,打算给他们分享下一些C/C++编译的基础知识,于是整理了一些资料写了这篇博客.由于已经有差不多一年没有写c++了,可能会有一些不太正确的地方,希望哪位同学看到能够帮忙指出,免得误人子弟.\n\n首先需要声明的是,我用的是Ubuntu系统,也是基于Linux去讲的,当然大家如果是用的Mac系统,其实可以无缝切换,用几乎完全一样的命令去跑.但是如果是Windows的同学,可能就不太适用了.\n\n不过其实我还是鼓励大家用Linux系统或者Mac系统去编译C/C++程序.因为大多数流行库都是在linux下面写的,使用Linux或者Mac交叉编译出安卓的可用程序都比较方便.\n\n# 为什么要学C/C++编译\n\n很多的安卓程序员可能都会用Android Studio写一些简单的C/C++代码,然后通过jni去调用,但是对C/C++是如何编译的其实并没有什么概念.有人可能会问,为什么安卓程序员会需要了解C/C++是如何编译的呢?我一直都认为,要成为一个真正的高级安卓应用开发工程师,安卓源码和C/C++是两座绕不过的大山.安卓源码自然不必多说,而C/C++流行了几十年,存在着许多优秀的开源项目,我们在处理一些特定的需求的时候,可能会需要使用到它们.如脚本语言Lua,计算机视觉库OpenCV,音视频编解码库ffmpeg,谷歌的gRPC,国产游戏引擎Cocos2dx...有些库提供了完整的安卓接口,有些提供了部分安卓接口,有些则没有.在做一些高级功能时,我们常常需要使用源码,通过裁剪和交叉编译,才能编译出可以在安卓上使用的so库.总之,安卓做深做精总避不开C/C++交叉编译.\n\n# C/C++编译器\n\n类似java编译器javac可以将java代码编译成class文件,C/C++也有gcc、g++、clang等多种编译器可以用于编译C/C++代码.这里我们用gcc来举例.\n\ngcc原名为GNU C 语言编译器(GNU C Compiler),因为它原本只能处理C语言.但GCC很快地扩展,变得可处理C++。后来又扩展能够支持更多编程语言,如Fortran、Pascal、Objective-C、Java、Ada、Go以及各类处理器架构上的汇编语言等,所以改名GNU编译器套件(GNU Compiler Collection).\n\n我这篇文章的例子都是Ubuntu上编译的.使用Ubuntu系统的同学可以使用下面命令安装gcc:\n\n> sudo apt-get install gcc\n\n如果是CentOS使用yum去安装:\n\n> yum install gcc\n\nMac系统的话可以用HomeBrew来安装,HomeBrew的安装方法我就不说了,大家可以自己搜索:\n\n> brew install gcc\n\n而使用Windows的同学,需要自己搜索下MinGw是如何安装的,MinGw 是 Minimal GNU on Windows 的缩写.\n\n使用gcc其实只需要一个命令就能将一个c文件编译成可运行程序了:\n\n> gcc test.c -o test\n\n通过上面这条命令可以将test.c编译成可运行程序test.但是其实C/C++的编译是经过了好几个步骤的,我这边先给大家大概的讲一讲.\n\n# C/C++的编译流程\n\nC/C++的编译可以分为下面几个步骤:\n\n{% img /写给安卓程序员的cc-编译入门/1.png %}\n\n## 预处理\n\n相信学过C/C++的同学都知道\"宏\"这个东西,它在编译的时候会被展开替换成实际的代码,这个展开的步骤就是在预处理的时候进行的.当然,预处理并不仅仅只是做宏的展开,它还做了类似头文件插入、删除注释等操作.\n\n预处理之后的产品依然还是C/C++代码,它在代码的逻辑上和输入的C/C++源代码是完全一样的.\n\n我们来举一个简单的例子,写一个test.h文件和一个test.c文件:\n\n```\n//test.h\n#ifndef TEST_H            \n#define TEST_H\n\n#define A 1     \n#define B 2        \n\n/**\n * add 方法的声明\n */               \nint add(int a, int b);\n\n#endif\n```\n\n```\n//test.c\n#include \"test.h\"\n\n/**\n * add 方法定义\n */\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint main(int argc,char* argv[]) {\n    add(A, B);\n    return 0;                 \n}\n```\n\n然后可以通过下面这个gcc命令预处理test.c文件,并且把预处理结果写到test.i:\n\n> gcc -E test.c -o test.i\n\n然后就能看到预处理之后的test.c到底长什么样子了:\n\n```\n# 1 \"test.c\"\n# 1 \"<built-in>\"\n# 1 \"<command-line>\"\n# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n# 1 \"<command-line>\" 2\n# 1 \"test.c\"\n# 1 \"test.h\" 1\n# 11 \"test.h\"\nint add(int a, int b);\n# 2 \"test.c\" 2\n\nint add(int a, int b){\n return a + b;\n}\n\nint main(int argc,char* argv[]) {\n add(1, 2);\n return 0;\n}\n```\n\n可以看到这里它把test.h的内容(add方法的声明)插入到了test.c的代码中,然后将A、B两个宏展开成了1和2,将注释去掉了,还在头部加上了一些信息.\n\n但是光看代码逻辑,和之前我们写的代码是完全一样的.\n\n## 汇编\n\n可能大家都听过汇编语言这个东西,但是年轻一点的同学不一定真正见过.简单来说汇编语言是将机器语言符号化了的语言,是机器不能直接识别的低级语言.我们可以通过下面的命令,将预处理后的代码编译成汇编语言:\n\n> gcc -S test.i -o test.s\n\n然后就能看到生成的test.s文件了,里面就是我们写的c语言代码翻译而成的汇编代码:\n\n```\n        .file   \"test.c\"\n        .text\n        .globl  add\n        .type   add, @function\nadd:\n.LFB0:\n        .cfi_startproc\n        pushq   %rbp\n        .cfi_def_cfa_offset 16\n        .cfi_offset 6, -16\n        movq    %rsp, %rbp\n        .cfi_def_cfa_register 6\n        movl    %edi, -4(%rbp)\n        movl    %esi, -8(%rbp)\n        movl    -4(%rbp), %edx\n        movl    -8(%rbp), %eax\n        addl    %edx, %eax\n        popq    %rbp\n        .cfi_def_cfa 7, 8\n        ret\n        .cfi_endproc\n.LFE0:\n        .size   add, .-add\n        .globl  main\n        .type   main, @function\nmain:\n.LFB1:\n        .cfi_startproc\n        pushq   %rbp\n        .cfi_def_cfa_offset 16\n        .cfi_offset 6, -16\n        movq    %rsp, %rbp\n        .cfi_def_cfa_register 6\n        subq    $16, %rsp\n        movl    %edi, -4(%rbp)\n        movq    %rsi, -16(%rbp)\n        movl    $2, %esi\n        movl    $1, %edi\n        call    add\n        movl    $0, %eax\n        leave\n        .cfi_def_cfa 7, 8\n        ret\n        .cfi_endproc\n.LFE1:\n        .size   main, .-main\n        .ident  \"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.10) 5.4.0 20160609\"\n        .section        .note.GNU-stack,\"\",@progbits\n```\n\n## 汇编\n\n汇编这一步是将汇编代码编译成机器语言:\n\n> gcc -c test.s -o test.o\n\n生成的test.o文件里面就是机器代码了,我们可以通过nm命令来列出test.o里面的符号:\n\n> nm test.o\n\n得到的结果如下:\n\n```\n0000000000000000 T add\n0000000000000014 T main\n```\n\n## 链接\n\n由于我们的例子代码比较简单只有一个test.h和test.h,所以只生成了一个.o文件,其实一般的程序都是由多个模块组合成的.链接这一步就是将多个模块的代码组合成一个可执行程序.我们可以用gcc命令将多个.o文件或者静态库、动态库链接成一个可执行文件:\n\n> gcc test.o -o test\n\n得到的就是可执行文件test了,可以直接用下面命令运行\n\n> ./test\n\n当然是没有任何输出的,因为我们就没有做任何的打印\n\n## 编译so库\n\n当然,在安卓中我们一般不会直接使用C/C++编译出来的可运行文件.用的更多的应该是so库.那要如何编译so库呢?\n\n首先我们需要将test.c中的main函数去掉,因为so库中是不会带有main函数的:\n\n```\n#include \"test.h\"\n\n/**\n * add 方法定义\n */\nint add(int a, int b){\n        return a + b;\n}\n```\n\n然后可以使用下面命令将test.c编译成test.so:\n\n> gcc -shared test.c -o test.so\n\n其实也就是多了个-shared参数,指定编译的结果为动态链接库.\n\n这里是直接将.c文件编译成so,当然也能像之前的例子一样先编译出.o文件再通过链接生成so文件.\n\n当然一般编译动态链接库,我们还会带上-fPIC参数.\n\nfPIC (Position-Independent Code)告诉编译器产生与位置无关代码,即产生的代码中没有绝对地址,全部使用相对地址.故而代码可以被加载器加载到内存的任意位置,都可以正确的执行.不加fPIC编译出来的so,是要再加载时根据加载到的位置再次重定位的.因为它里面的代码并不是位置无关代码.如果被多个应用程序共同使用,那么它们必须每个程序维护一份.so的代码副本了.因为.so被每个程序加载的位置都不同,显然这些重定位后的代码也不同,当然不能共享.\n\n# 交叉编译\n\n通过上面的例子,我们知道了一个C/C++程序是怎么从源代码一步步编译成可运行程序或者so库的.但是我们编译出来的程序或者so库只能在相同系统的电脑上使用.\n\n例如我使用的电脑是Linux系统的,那它编译出来的程序也就只能在Linux上运行,不能在安卓或者Windows上运行.\n\n当然正常情况下不会有人专门去到android系统下编译出程序来给安卓去用.一般我们都是在PC上编译出安卓可用的程序,在给到安卓去跑的.这种是在一个平台上生成另一个平台上的可执行代码的编译方式就叫做交叉编译.\n\n交叉编译有是三个比较重要的概念要先说明一下:\n\n- build : 当前你使用的计算机\n- host : 你的目的是编译出来的程序可以在host上运行\n- target : 普通程序没有这个概念。对于想编译出编译器的人来说此属性决定了新编译器编译出的程序可以运行在哪\n\n如果我们想要交叉编译出安卓可运行的程序或者库的话就不能直接使用gcc去编译了.而需要使用Android NDK提供了的一套交叉编译工具链.\n\n我们首先要下载Android NDK,然后配置好环境变量NDK_ROOT指向NDK的根目录.\n\n然后可以通过下面命令安装交叉编译工具链:\n\n> $NDK_ROOT/build/tools/make-standalone-toolchain.sh \\\n\t--platform=android-19 \\\n\t--install-dir=$HOME/Android/standalone-toolchains/android-toolchain-arm \\\n\t--toolchain=arm-linux-androideabi-4.9 \\\n\t--stl=gnustl\n\n然后我们就能在$HOME/Android/目录下看到安装好的工具链了.进到$HOME/Android/standalone-toolchains/android-toolchain-arm/bin/目录下我们可以看到有arm-linux-androideabi-gcc这个程序.\n\n它就是gcc的安卓交叉编译版本.我们将之前使用gcc去编译的例子全部换成使用它去编译就能编译出运行在安卓上的程序了:\n\n如下面命令生成的so库就能在安卓上通过jni调用了:\n\n>  $HOME/Android/standalone-toolchains/android-toolchain-arm/bin/arm-linux-androideabi-gcc -shared -fPIC test.c -o test.so\n\n我们会将定义下面几个环境变量,将$HOME/Android/standalone-toolchains/放到PATH变量中,这样就可以直接使用arm-linux-androideabi-gcc命令,而不需要输入它的全路径去使用了:\n\n```\nexport TOOLCHAIN_HOME=$HOME/Android/standalone-toolchains/android-toolchain-arm\nexport TOOLCHAIN_SYSROOT=$TOOLCHAIN_HOME/sysroot\nexport PATH=$PATH:$TOOLCHAIN_HOME/bin\n```\n\n设定好之后可以直接用下面命令去编译:\n\n```\narm-linux-androideabi-gcc -shared -fPIC test.c -o test.so\n```\n\n## 不同CPU架构的编译方式\n\n当然安卓也有很多不同的CPU架构,不同CPU架构的程序也是不一定兼容的,相信大家之前在使用Android Studio去编译so的时候也有看到编译出来的库有很多个版本像armeabi、armeabi-v7a、mips、x86等.\n\n那这些不同CPU架构的程序又要如何编译了.\n\n我们可以在$NDK_ROOT/toolchains目录下看到者几个目录:\n\n```\narm-linux-androideabi-4.9\naarch64-linux-android-4.9\nmipsel-linux-android-4.9\nmips64el-linux-android-4.9\nx86-4.9\nx86_64-4.9\n```\n\n这就是不同CPU架构的交叉编译工具链了.还记得我们安装工具链的命令吗?\n\n> $NDK_ROOT/build/tools/make-standalone-toolchain.sh \\\n\t--platform=android-19 \\\n\t--install-dir=$HOME/Android/standalone-toolchains/android-toolchain-arm \\\n\t--toolchain=arm-linux-androideabi-4.9 \\\n\t--stl=gnustl\n\ntoolchain参数就能指定使用哪个工具链,然后就能使用该工具链去编译该架构版本的程序了.\n\n但是,我们看到这下面并没有armeabi-v7a的工具链,那armeabi-v7a的程序要如何编译呢?\n\n其实armeabi-v7a的程序也是用arm-linux-androideabi-4.9去编译的,只不过在编译的时候可以带上-march=armv7-a:\n\n> arm-linux-androideabi-gcc -march=armv7-a -shared -fPIC test.c -o test.so\n\n## 官方文档\n\n我这边其实只是简要的介绍了下NDK的基本用法而已,更多的用法大家可以到[官方文档](https://developer.android.com/ndk/guides/standalone_toolchain?hl=zh-cn)上查找.\n\n# Makefile\n\n理解完C/C++编译的原理之后,还有个十分重要的东西还要了解,这个东西就是Makefile.\n\n我们前面的例子都是直接用gcc或着各个交叉编译的版本的gcc去编译C/C++代码的.在代码量不多的时候这么做还是可行的,但是如果软件一旦复杂一些,代码量一多,那么编译的命令就会十分的复杂,而且还需要考虑到多个模块之间的依赖关系.\n\nMakefile就是一个帮助我们解决这些问题的工具.它的基本原理十分简单,先让我们看看它最最基本的用法:\n\n```\n目标文件 : 依赖文件\n\t命令1\n  命令2\n  命令3\n  ...\n```\n\n还是举我们的例子代码,首先创建一个文件,名字叫Makefile,然后写上:\n\n```\ntest.so : test.c test.h                                                          \n    arm-linux-androideabi-gcc -march=armv7-a -shared -fPIC test.c -o test.so\n```\n\n然后就可以用make命令去编译了.make命令会找到当前目录下的Makefile,然后比较目标文件文件和依赖文件的修改时间,如果依赖文件的修改时间比较晚,或者干脆就还没有目标文件.就会执行命令.\n\n如我们的例子,如果还没有test.so,或者test.c、test.h的修改时间比test.so要晚,那么就会执行arm-linux-androideabi-gcc -march=armv7-a -shared -fPIC test.c -o test.so,然后生成test.so文件.\n\n而如果是目标文件比较新,就不会执行,它会告诉你目标文件已经是最新的了:\n\n```\nmake: 'test.so' is up to date.\n```\n\n## 没有依赖的目标文件\n\n然后可能有同学还有见过make clean,make install,make uninstall...这些命令,它们又是怎么一回事呢?\n\n这里以make clean举例,我们在Makefile中加入目标文件clean:\n\n```\ntest.so : test.c test.h\n    arm-linux-androideabi-gcc -march=armv7-a -shared -fPIC test.c -o test.so\n\nclean :\n    rm test.so\n```\n\n现在除了test.so这个目标文件之后,还多了个目标文件clean,它下面的命令是tm test.so.而且特殊的是clean这个目标文件,它没有任何的依赖文件.\n\n然后我们就能使用make clean命令了,因为clean文件不存在,所以就会执行下面的rm test.so.所以就会将test.so删除了.\n\n刚刚我们说的时候clean存在的时候会执行命令,那如果我们自己创建了个文件名字叫做clean又会发生什么事情?\n\n```\nmake: 'clean' is up to date.\n```\n\n由于没有依赖文件,所以不用比较时间,它会直接告诉你clean文件已经是最新的了,而不会执行命令.\n\n那要如果规避这个问题呢?例如当前目录下的确需要有个clean文件,但是我又需要make clean这个功能.方法很简单,只需要加上\".PHONY : clean\"就可以了:\n\n```\ntest.so : test.c test.h\n    arm-linux-androideabi-gcc -march=armv7-a -shared -fPIC test.c -o test.so\n\nclean :\n    rm test.so\n\n.PHONY : clean\n```\n\n## Makefile自动生成工具\n\nMakefile,这里我也只是简单代过,其实它还有许多强大的功能,感兴趣的同学可以自行搜索.\n\n但是如果我们的项目都是手动去写makefile的话也会十分的麻烦,那有没有办法可以根据我们的代码,自动生成makefile呢?\n\n答案肯定是有的.比如现在安卓使用的CMake还有经典的AutoMake工具.\n\n相信大家在用JNI的时候肯定都有配过CMakeLists.txt这个文件,CMake就是通过读取这个文件的配置去生成代码的.\n\n而一些比较早期的库如ffmpeg,就是用automake去生成Makefile的,我之前写过四篇博客专门将如何使用AutoMake,如果感兴趣可以去看看.\n\n- [automake学习笔记 - helloworld](http://blog.islinjw.cn/2017/03/17/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-helloworld/)\n- [automake学习笔记 - 模块化编译](http://blog.islinjw.cn/2017/03/21/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E8%AF%91/)\n- [automake学习笔记 - 安装与发布](http://blog.islinjw.cn/2017/03/26/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8F%91%E5%B8%83/)\n- [automake学习笔记 - 交叉编译](http://blog.islinjw.cn/2017/04/02/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/)\n\n自动生成工具这块内容比较多我就不详细讲了,它们其实并不是很难,大家自行找资料学习就好.\n","tags":["技术相关","Android","C/C++"]},{"title":"安卓嵌套滚动NestedScroll了解一下","url":"/2018/06/04/安卓嵌套滚动NestedScroll了解一下/","content":"\n\n其实嵌套滚动已经算一个比较常见的特效了,下面这个动图就是嵌套滚动的一个例子:\n\n{% img /安卓嵌套滚动NestedScroll了解一下/1.gif %}\n\n看到这个动效,大家可能都知道可以用CoordinatorLayout去实现.其实CoordinatorLayout是基于NestedScroll机制去实现的,而我们直接通过NestedScroll机制也能很方便的实现这个动效.\n\n\n# 原理\n\nNestedScroll的其实很简单.\n\n一般的触摸消息的分发都是从外向内的,由外层的ViewGroup的dispatchTouchEvent方法调用到内层的View的dispatchTouchEvent方法.\n\n而NestedScroll提供了一个反向的机制,内层的view在接收到ACTION_MOVE的时候,将滚动消息先传回给外层的ViewGroup,看外层的ViewGroup是不是需要消耗一部分的移动,然后内层的View再去消耗剩下的移动.内层view可以消耗剩下的滚动的一部分,如果还没有消耗完,外层的view可以再选择把最后剩下的滚动消耗掉.\n\n上面的描述可能有点绕,可以看下面的图来帮助理解:\n\n{% img /安卓嵌套滚动NestedScroll了解一下/2.png %}\n\n# 具体实现\n\nNestedScroll机制会涉及到四个类:\n\nNestedScrollingChild， NestedScrollingChildHelper 和 NestedScrollingParent ， NestedScrollingParentHelper\n\nNestedScrollingChild和NestedScrollingParent是两个接口,我们先看看他们的声明:\n\n```\npublic interface NestedScrollingChild {\n    public void setNestedScrollingEnabled(boolean enabled);\n\n    public boolean isNestedScrollingEnabled();\n\n    public boolean startNestedScroll(int axes);\n\n    public void stopNestedScroll();\n\n    public boolean hasNestedScrollingParent();\n\n    public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed,\n            int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow);\n\n    public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow);\n\n    public boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed);\n\n    public boolean dispatchNestedPreFling(float velocityX, float velocityY);\n}\n\npublic interface NestedScrollingParent {\n    public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes);\n\n    public void onNestedScrollAccepted(View child, View target, int nestedScrollAxes);\n\n    public void onStopNestedScroll(View target);\n\n    public void onNestedScroll(View target, int dxConsumed, int dyConsumed,\n            int dxUnconsumed, int dyUnconsumed);\n\n    public void onNestedPreScroll(View target, int dx, int dy, int[] consumed);\n\n    public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed);\n\n    public boolean onNestedPreFling(View target, float velocityX, float velocityY);\n\n    public int getNestedScrollAxes();\n}\n```\n\n这里真正重要的其实是NestedScrollingParent的几个方法,因为其他方法都能直接让NestedScrollingChildHelper或者NestedScrollingParentHelper去代理:\n\n- onStartNestedScroll 是否接受嵌套滚动,只有它返回true,后面的其他方法才会被调用\n- onNestedPreScroll 在内层view处理滚动事件前先被调用,可以让外层view先消耗部分滚动\n- onNestedScroll 在内层view将剩下的滚动消耗完之后调用,可以在这里处理最后剩下的滚动\n- onNestedPreFling 在内层view的Fling事件处理之前被调用\n- onNestedFling 在内层view的Fling事件处理完之后调用\n\n我们只要让子view和父view分别实现NestedScrollingChild和NestedScrollingParent接口,然后分别调用NestedScrollingChildHelper和NestedScrollingParentHelper的对应方法去代理一些具体功能,然后在NestedScrollingChild的onTouchEvent那里根据需求调用startNestedScroll/dispatchNestedPreScroll/stopNestedScroll就能实现嵌套滚动了:\n\n```\n//NestedScrollingChild\nprivate NestedScrollingChildHelper mHelper = new NestedScrollingChildHelper(this);\n\npublic boolean startNestedScroll(int axes) {\n  return mHelper.startNestedScroll(axes);\n}\npublic boolean dispatchNestedScroll(int dxConsumed, int dyConsumed,\n            int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow) {\n  return mHelper.dispatchNestedScroll(dxConsumed,  dyConsumed,\n             dxUnconsumed,  dyUnconsumed, offsetInWindow);\n}\n...\n```\n\n```\n//NestedScrollingParent\nprivate NestedScrollingParentHelper mHelper = new NestedScrollingParentHelper(this);\n\npublic void onNestedScrollAccepted(View child, View target, int axes) {\n  mHelper.onNestedScrollAccepted(child, target, axes);\n}\n\npublic int getNestedScrollAxes() {\n  return mHelper.getNestedScrollAxes();\n}\n...\n```\n\n但是如果你使用sdk21及以上的版本,NestedScroll机制已经直接集成到了View中了,你只需要直接重写View的对应方法就好\n\n## 布局\n\n我们先看布局文件\n\n```\n<me.linjw.nestedscrolldemo.NestedScrollParentView xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\">\n\n    <FrameLayout\n        android:id=\"@+id/header\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\">\n\n        <ImageView\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"200dp\"\n            android:src=\"@mipmap/ic_launcher\" />\n    </FrameLayout>\n\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:background=\"@color/colorAccent\"\n        android:text=\"Title\"\n        android:textAlignment=\"center\"\n        android:textSize=\"20dp\" />\n\n    <android.support.v7.widget.RecyclerView\n        android:id=\"@+id/list\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\" />\n</me.linjw.nestedscrolldemo.NestedScrollParentView>\n```\n\n最外层是我们自定义的NestedScrollParentView,其实它是一个LinearLayout,内部竖直排列了三个子view:\n\n- 一个由FrameLayout包裹的ImageView\n- 一个TextView\n- 一个RecyclerView\n\n## 代码\n\n为了简便起见,我们先直接用sdk22的版本用重写View方法的方式去实现它.\n\nNestedScrollParentView中有两个方法比较重要,嵌套滚动基本上就是由这两个方法实现的:\n\n```\n  @Override\n    public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes) {\n        return true;\n    }\n\n    @Override\n    public void onNestedPreScroll(View target, int dx, int dy, int[] consumed) {\n        super.onNestedPreScroll(target, dx, dy, consumed);\n\n        boolean headerScrollUp = dy > 0 && getScrollY() < mHeaderHeight;\n        boolean headerScrollDown = dy < 0 && getScrollY() > 0 && !target.canScrollVertically(-1);\n        if (headerScrollUp || headerScrollDown) {\n            scrollBy(0, dy);\n            consumed[1] = dy;\n        }\n    }\n```\n\n- onStartNestedScroll 这个方法如果返回true的话代表接受由内层传来的滚动消息,我们直接返回true就好,否则后面的消息都接受不到\n\n- onNestedPreScroll 这个方法用于消耗内层view的一部分滚动.我们需要将消耗掉的滚动存到counsumed中让consumed知道.例如我们这里在顶部的FrameLayout需要移动的情况下会消耗掉所有的dy,这样内层的view(即RecyclerView)就不会滚动了.\n\n这里的mHeaderHeight保存的是顶部的FrameLayout的高度:\n\n```\n @Override\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        super.onSizeChanged(w, h, oldw, oldh);\n        mHeaderHeight = mHeader.getMeasuredHeight();\n    }\n```\n\n到这里基本上就实现了动图的效果,是不是很简单?\n\n完整代码可以参考 https://github.com/bluesky466/NestedScrollDemo/tree/sdk22\n","tags":["技术相关","Android"]},{"title":"从源码看安卓应用的启动过程","url":"/2018/03/08/从源码看安卓应用的启动过程/","content":"\n\n一般来讲安卓中的每个应用都是在一个单独的进程中运行的(当然也能使用android:process指定不同组件运行在不同进程中)。\n\n{% img /从源码看安卓应用的启动过程/1.png %}\n\n我们在上图中可以看到，每一个进程都有一个java虚拟机(Dalvik虚拟机/ART虚拟机)实例。如果每次启动一个应用都需要启动一个新的虚拟机，然后初始化一堆的东西，那应用的启动时间将会变得无比漫长。\n\n那有什么办法优化呢？\n\n假设我们有一个模板进程，每次不需要重新启动，只需要重这个模板进程中拷贝一份出来，是不是就能节省一部分初始化的时间了？Zygote 进程就是这个模板进程。\n\nZygote是受精卵的意思，十分形象的一个比喻。app的进程就是通过fork的方式从Zygote进程克隆出来的，而且使用了写时拷贝的方法，尽可能的复用Zygote进程的资源。fork是UNIX关于进程管理的一个术语,本质是新开一个进程,但是不从磁盘加载代码,而是从内存现有进程复制一份。而写时拷贝是一直只有在修改的时候才会拷贝的策略，这里我就不详细展开他们了，有兴趣的同学可以在网上搜索一下。\n\n说回Zygote进程，他是系统在启动的时候创建的，在启动之后会打开/dev/socket/zygote使用LocalSocket去监听启动应用进程的请求。当接收到启动请求的时候就会fork一个子进程出来：\n\n{% img /从源码看安卓应用的启动过程/2.png %}\n\n应用进程是在 ActivityManagerService.startProcessLocked方法里面启动的:\n\n```\nprivate final void startProcessLocked(ProcessRecord app,  String hostingType, String hostingNameStr) {\n    ...\n    Process.ProcessStartResult startResult = Process.start(\"android.app.ActivityThread\",\n                                                          app.processName, uid, uid, gids, debugFlags, mountExternal,\n                                                          app.info.targetSdkVersion, app.info.seinfo, null);\n    ...\n}\n```\n\n我们可以在Process里面看到，它的确是通过LocalSocket与Zygote进行交互的:\n\n```\npublic class Process {\n    ...\n    private static final String ZYGOTE_SOCKET = \"zygote\";\n    ...     \n    public static final ProcessStartResult start(final String processClass,\n                                                final String niceName,\n                                                int uid, int gid, int[] gids,\n                                                int debugFlags, int mountExternal,\n                                                int targetSdkVersion,\n                                                String seInfo,\n                                                String[] zygoteArgs) {\n        ...                                          \n        return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, zygoteArgs);\n        ...\n    }\n    ...\n    private static ProcessStartResult startViaZygote(final String processClass,\n                                                    final String niceName,\n                                                    final int uid, final int gid,\n                                                    final int[] gids,\n                                                    int debugFlags, int mountExternal,\n                                                    int targetSdkVersion,\n                                                    String seInfo,\n                                                    String[] extraArgs)\n                                                    throws ZygoteStartFailedEx {\n        ...\n        return zygoteSendArgsAndGetResult(argsForZygote);\n    }\n    ...\n    private static ProcessStartResult zygoteSendArgsAndGetResult(ArrayList<String> args) throws ZygoteStartFailedEx {\n        openZygoteSocketIfNeeded();\n        ...\n        sZygoteWriter.write(Integer.toString(args.size())); 、\n        sZygoteWriter.newLine();\n        int sz = args.size();\n        for (int i = 0; i < sz; i++) {\n            String arg = args.get(i);\n            if (arg.indexOf('\\n') >= 0) {\n                throw new ZygoteStartFailedEx(\"embedded newlines not allowed\");\n            }\n            sZygoteWriter.write(arg);\n            sZygoteWriter.newLine();\n        }\n\n        sZygoteWriter.flush();\n\n        // Should there be a timeout on this?\n        ProcessStartResult result = new ProcessStartResult();\n        result.pid = sZygoteInputStream.readInt();\n        if (result.pid < 0) {\n            throw new ZygoteStartFailedEx(\"fork() failed\");\n        }\n        result.usingWrapper = sZygoteInputStream.readBoolean();\n        ...\n    }\n    ...\n    private static void openZygoteSocketIfNeeded() throws ZygoteStartFailedEx {\n        ...\n        sZygoteSocket = new LocalSocket();\n        sZygoteSocket.connect(new LocalSocketAddress(ZYGOTE_SOCKET,\n        LocalSocketAddress.Namespace.RESERVED));\n        ...\n    }\n}\n```\n\n那zygote进程通过LocalSocket监听到请求之后又做了什么呢？ZygoteInit.runSelectLoop就是用来监听LocalSocket请求我们看看源码，其实它是在一个while死循环里不断select LocalSocket消息:\n\n```\nprivate static void runSelectLoop() throws MethodAndArgsCaller {\n    ArrayList<FileDescriptor> fds = new ArrayList<FileDescriptor>();\n    ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();\n    FileDescriptor[] fdArray = new FileDescriptor[4];\n\n    fds.add(sServerSocket.getFileDescriptor());\n    peers.add(null);\n\n    int loopCount = GC_LOOP_COUNT;\n    while (true) {\n        int index;\n\n        /*\n        * Call gc() before we block in select().\n        * It's work that has to be done anyway, and it's better\n        * to avoid making every child do it. It will also\n        * madvise() any free memory as a side-effect.\n        *\n        * Don't call it every time, because walking the entire\n        * heap is a lot of overhead to free a few hundred bytes.\n        */\n        if (loopCount <= 0) {\n            gc();\n            loopCount = GC_LOOP_COUNT;\n        } else {\n            loopCount--;   \n        }\n\n\n        try {\n            fdArray = fds.toArray(fdArray);\n            index = selectReadable(fdArray);\n        } catch (IOException ex) {\n            throw new RuntimeException(\"Error in select()\", ex);\n        }\n\n        if (index < 0) {\n            throw new RuntimeException(\"Error in select()\");\n        } else if (index == 0) {\n            ZygoteConnection newPeer = acceptCommandPeer();\n            peers.add(newPeer);\n            fds.add(newPeer.getFileDesciptor());\n        } else {\n            boolean done;\n            done = peers.get(index).runOnce();\n\n            if (done) {\n                peers.remove(index);\n                fds.remove(index);\n            }\n        }\n    }\n}\n```\n\n接收到消息之后会调ZygoteConnection.runOnce，在这个方法里面调用了Zygote.forkAndSpecialize方法去fork一个进程，这里我们就不再深入了。我们继续跟踪下去发现他又调了ZygoteInit.invokeStaticMain:\n\n```\nboolean runOnce() throws ZygoteInit.MethodAndArgsCaller {\n    ...\n    pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,\n    parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,\n    parsedArgs.niceName);\n    ...\n    handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);\n    ...\n}\n\nprivate void handleChildProc(Arguments parsedArgs,\n                            FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)\n                            throws ZygoteInit.MethodAndArgsCaller {\n    ...\n    ZygoteInit.invokeStaticMain(cloader, className, mainArgs);\n    ...\n}\n```\n\nZygoteInit.invokeStaticMain的方法比较短，我就全部复制上来了，可以看到，这里用反射的方式调用了main方法，也就是ActivityThread.main:\n\n```\nstatic void invokeStaticMain(ClassLoader loader,\n                            String className, String[] argv)\n                            throws ZygoteInit.MethodAndArgsCaller {\n    Class<?> cl;\n\n    try {\n        cl = loader.loadClass(className);\n    } catch (ClassNotFoundException ex) {\n        throw new RuntimeException(\n                          \"Missing class when invoking static main \" + className,\n                          ex);\n    }\n\n    Method m;\n    try {\n        m = cl.getMethod(\"main\", new Class[] { String[].class });\n    } catch (NoSuchMethodException ex) {\n        throw new RuntimeException(\n                          \"Missing static main on \" + className, ex);\n    } catch (SecurityException ex) {\n        throw new RuntimeException(\n                          \"Problem getting static main on \" + className, ex);\n    }\n\n    int modifiers = m.getModifiers();\n    if (! (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers))) {\n        throw new RuntimeException(\n                          \"Main method is not public and static on \" + className);\n    }\n\n    /*\n    * This throw gets caught in ZygoteInit.main(), which responds\n    * by invoking the exception's run() method. This arrangement\n    * clears up all the stack frames that were required in setting\n    * up the process.\n    */\n    throw new ZygoteInit.MethodAndArgsCaller(m, argv);\n}\n```\n\n然后就到了ActivityThread.main方法，可以看到在这个方法里面初始化了sMainThreadHandler和Looper。这个就是主线程Handler对应的Looper了:\n\n```\npublic static void main(String[] args) {\n    SamplingProfilerIntegration.start();\n\n    // CloseGuard defaults to true and can be quite spammy. We\n    // disable it here, but selectively enable it later (via\n    // StrictMode) on debug builds, but using DropBox, not logs.\n    CloseGuard.setEnabled(false);\n\n    Environment.initForCurrentUser();\n\n    // Set the reporter for event logging in libcore\n    EventLogger.setReporter(new EventLoggingReporter());\n\n    Security.addProvider(new AndroidKeyStoreProvider());\n\n    Process.setArgV0(\"<pre-initialized>\");\n\n    Looper.prepareMainLooper();\n\n    ActivityThread thread = new ActivityThread();\n    thread.attach(false);\n\n    if (sMainThreadHandler == null) {\n        sMainThreadHandler = thread.getHandler();\n    }\n\n    AsyncTask.init();\n\n    if (false) {\n        Looper.myLooper().setMessageLogging(new\n        LogPrinter(Log.DEBUG, \"ActivityThread\"));\n    }\n\n    Looper.loop();\n\n    throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n}\n```\n\n于是乎一个应用的主线程就这样启动了，接下来就是ActivityManagerService通过Binder机制去让ActivityThread用Hander同步创建主Activity，并且调用Activity生命周期了。这部分最近有写过一篇博客[《从源码看Activity生命周期》](http://blog.islinjw.cn/2018/03/07/%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9C%8BActivity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/)感兴趣的同学可以去看看。\n","tags":["技术相关","Android"]},{"title":"从源码看Activity生命周期","url":"/2018/03/07/从源码看Activity生命周期/","content":"\n# Activity是如何创建的\n\n我们都知道在手机上点击应用的图标，系统会通过ActivityManagerService去启动它的主Activity，接下来我们就来一步步看看在它究竟是如何启动应用的。\n\n首先手机开机的时候我们看到的界面其实是Launcher应用的主Activity,Launcher其实就是一个会被系统默认启动的安卓应用。在上面点击已装应用的图标，就会调用Actvity.startActivity去启动其他的应用。而Activity实际上是继承ContextWrapper的,所以调的是ContextWrapper.startActivity方法:\n\n```\npublic class ContextWrapper extends Context {\n     ...\n     Context mBase;\n     ...\n     public ContextWrapper(Context base) {\n         mBase = base;\n     }\n     ...\n     @Override\n     public void startActivity(Intent intent) {\n         mBase.startActivity(intent);\n     }\n     ...\n}\n```\n\n可以看到这里使用了委托的方式，实际上是调了mBase.startActivity。那这个mBase到底是什么呢？让我们来看看Context的继承关系图:\n\n{% img /从源码看Activity生命周期/1.png %}\n\n\nContext只有两个直接的子类,一个ContextImpl，一个ContextWrapper。ContextWrapper类如其名仅仅是一个包装的功能，它的成员变量mBase其实就是ContextImpl，所有实际的工作都是由ContextImpl去实现的。\n\n\n于是我们就去看看ContextImpl.startActivity:\n\n\n```\nclass ContextImpl extends Context {\n    ...\n    @Override\n    public void startActivity(Intent intent) {\n        ...\n        startActivity(intent, null);\n    }\n\n    @Override\n    public void startActivity(Intent intent, Bundle options) {\n      ...\n      mMainThread.getInstrumentation().execStartActivity(\n                            getOuterContext(), mMainThread.getApplicationThread(), null,\n                            (Activity)null, intent, -1, options);\n    }\n    ...\n}\n\npublic final class ActivityThread {\n    ...\n    Instrumentation mInstrumentation;\n    ...\n    public Instrumentation getInstrumentation()  {\n        return mInstrumentation;\n    }\n    ...\n}\n```\n\n好吧，这里又将锅甩给了Instrumentation。Instrumentation其实也是一个比较偏但是很有作用的东西(通过它我们能做到很多神奇的事情，例如[Hook 应用入口 Activity](https://www.jianshu.com/p/53c9e8641e57))，主要用于监控Activity，这里我就不详细讲了，感兴趣的同学可以直接去搜索一下。我们直接看启动activity相关的代码:\n\n\n```\npublic ActivityResult execStartActivity(\n                Context who, IBinder contextThread, IBinder token, Activity target,\n                Intent intent, int requestCode, Bundle options) {\n   ...\n   int result = ActivityManagerNative.getDefault()\n                             .startActivity(whoThread, who.getBasePackageName(), intent,\n                                          intent.resolveTypeIfNeeded(who.getContentResolver()),\n                                          token, target != null ? target.mEmbeddedID : null,\n                                          requestCode, 0, null, null, options);\n   ...\n}\n```\n\n这里的ActivityManagerNative最后拿到的就是ActivtyManagerService的IBinder,所以最后会使用Binder机制调用系统端的ActivityManagerService去创建Activity。\n\n但是我们知道ActivityManagerService和我们的应用是在两个进程的，如果在ActivityManagerService中创建了Activity的话我们的应用也是获取不了的。\n\n其实ActivityManagerService主要功能不是创建Activity，而是管理Activity栈。它在创建新的Activity的时候还是会通过Binder机制调回应用进程的ActivityThread去处理。最后ActivityManagerService只保存Activity的token。由于中间代码过于曲折，我这里就不贴出来了.这里直接看ActivityThread的代码吧：\n\n\n```\npublic final class ActivityThread {\n    final ArrayMap<IBinder, ActivityClientRecord> mActivities\n                    = new ArrayMap<IBinder, ActivityClientRecord>();\n    ...\n    private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n        ...\n        Activity a = performLaunchActivity(r, customIntent);\n        ...\n    }\n    ...\n    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n        ...\n        activity = mInstrumentation.newActivity(\n                            cl, component.getClassName(), r.intent);\n        ...\n        r.activity = activity;\n        ...\n        mActivities.put(r.token, r);\n    }\n}\n```\n\n\n可以看到这里也是用Instrumentation去创建Activity的，创建完之后就将它丢到一个Map里面。而Instrumentation.newActivity则很简单，通过反射去创建Activity:\n\n```\npublic class Instrumentation {\n    ...\n    public Activity newActivity(ClassLoader cl, String className, Intent intent)\n                                throws InstantiationException, IllegalAccessException,\n                                ClassNotFoundException {\n        return (Activity)cl.loadClass(className).newInstance();\n    }\n    ...\n}\n```\n\n总结下来，上面讲的的方法的调用时序图如下:\n\n{% img /从源码看Activity生命周期/2.png %}\n\n\n# Activity的生命周期是如何被调用的\n\n这里涉及到几个类：ActivityManagerService、ActivityStackSupervisor、ActivityStack、ActivityThread。\n\nActivityManagerService负责通过binder机制接收启动应用的请求，它内部有各个ActivityStackSupervisor成员变量，用于管理Activity栈：\n\n\n```\npublic final class ActivityManagerService extends ActivityManagerNative\nimplements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {\n    ...\n    /** Run all ActivityStacks through this */\n    ActivityStackSupervisor mStackSupervisor;\n    ...\n}\n```\n\nActivityStackSupervisor管理用于Activity栈列表，它负责将Activity压入对应的Activity栈中:\n\n```\npublic final class ActivityStackSupervisor {\n    ...\n    /** All the non-launcher stacks */\n    private ArrayList<ActivityStack> mStacks = new ArrayList<ActivityStack>();\n    ...\n}\n```\n\nActivityStack用于管理Activity的生命周期，例如在新Activity被压入的时候调用旧栈顶Activity的onPasuse和onStop还有新activity的onStart和onResume。\n\n```\nfinal class ActivityStack {\n    ...\n    final void startPausingLocked(boolean userLeaving, boolean uiSleeping) {\n        ...\n        prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags);\n        ...\n    }\n    ...\n}\n```\n\nActivityStack并不会直接调用Activity的生命周期方法，而是通过ActivityThread间接调用。由于ActivityStack在系统进程中,而ActivityThread在应用进程中，所以通过Binder机制调用之后去到ActivityThread那里不是主线程，于是ActivityThread内部就使用了Handler机制同步到主线程中调用:\n\n\n```\npublic final class ActivityThread {\n    ...\n    public final void schedulePauseActivity(IBinder token, boolean finished,  boolean userLeaving, int configChanges) {\n        queueOrSendMessage(\n            finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY,\n            token,\n            (userLeaving ? 1 : 0),\n            configChanges);\n    }\n    ...\n    private void queueOrSendMessage(int what, Object obj, int arg1, int arg2) {\n        synchronized (this) {\n            Message msg = Message.obtain();\n            msg.what = what;\n            msg.obj = obj;\n            msg.arg1 = arg1;\n            msg.arg2 = arg2;\n            mH.sendMessage(msg);\n        }\n    }\n    ...\n    private class H extends Handler {\n        ...\n        public void handleMessage(Message msg) {\n            ...\n            switch (msg.what) {\n                ...\n                case PAUSE_ACTIVITY:\n                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityPause\");\n                    handlePauseActivity((IBinder)msg.obj, false, msg.arg1 != 0, msg.arg2);\n                    maybeSnapshot();\n                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                    break;\n                ...\n                case RESUME_ACTIVITY:\n                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityResume\");\n                    handleResumeActivity((IBinder)msg.obj, true,\n                    msg.arg1 != 0, true);\n                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                    break;\n                ...\n            }\n            ...\n        }\n        ...\n    }\n    ...\n    private void handlePauseActivity(IBinder token, boolean finished,boolean userLeaving, int configChanges) {\n        ActivityClientRecord r = mActivities.get(token);\n        ...\n    }\n}\n```\n\n这里需要提的一点是AcvitiyThread里面可能有不止一个activity。所以需要传一个token去指定调用哪个activity。handlePauseActivity方法最终会调用mInstrumentation.callActivityOnPause再调用到Activity.onPause。这里就不继续展示代码了。\n\n总结一下，上面讲到的这些类之间的关系是这样的:\n\n{% img /从源码看Activity生命周期/3.png %}\n\nActivityThread通过handler机制将activity的生命周期同步到主线程中调用:\n\n{% img /从源码看Activity生命周期/4.png %}\n","tags":["技术相关","Android"]},{"title":"Activity是如何画到屏幕上的","url":"/2018/02/28/Activity是如何画到屏幕上的/","content":"\n# Activity是如何管理布局的\n\n一切从setContentView说起。安卓中最常用的代码可能就是setContentView了，但大家有没有想过这个方法的背后到底做了些什么？\n\n```\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n}\n```\n\n直接跳转到Activity的源码我们可以看到,Activity.setContentView实际上调用了PhoneWindow.setContentView:\n\n```\nfinal void attach(Context context, ActivityThread aThread,\n        Instrumentation instr, IBinder token, int ident,\n        Application application, Intent intent, ActivityInfo info,\n        CharSequence title, Activity parent, String id,\n        NonConfigurationInstances lastNonConfigurationInstances,\n        Configuration config, String referrer, IVoiceInteractor voiceInteractor,\n        Window window) {\n     ...\n     mWindow = new PhoneWindow(this, window);\n     ...\n}\n\npublic Window getWindow() {\n    return mWindow;\n}\n\npublic void setContentView(@LayoutRes int layoutResID) {\n    getWindow().setContentView(layoutResID);\n    initWindowDecorActionBar();\n}\n```\n\n我们继续跟踪PhoneWindow的源码,可以发现最终layoutResID被inflate出来之后是成为了mDecor这个DecorView的子view。而DecorView实际上是一个FrameLayout:\n\n```\npublic void setContentView(int layoutResID) {\n     if (mContentParent == null) {\n          installDecor();\n     } else {\n          mContentParent.removeAllViews();\n     }\n     mLayoutInflater.inflate(layoutResID, mContentParent);\n     final Callback cb = getCallback();\n     if (cb != null && !isDestroyed()) {\n          cb.onContentChanged();\n     }\n}\n\nprivate void installDecor() {\n     if (mDecor == null) {\n          mDecor = generateDecor();\n          ...\n     }\n     if (mContentParent == null) {\n          //mContentParent 实际上是mDecor的一个子view\n          mContentParent = generateLayout(mDecor);\n          ...\n     }\n     ...\n}\n\nprotected DecorView generateDecor() {\n     return new DecorView(getContext(), -1);\n}\n\nprivate final class DecorView extends FrameLayout implements RootViewSurfaceTaker {\n     ...\n}\n```\n\n\n这里的generateLayout比较重要，它实际上是根据window的各种属性inflate出不同的layout挂到DecorView下面,而mContentParent是这个layout中的一个子ViewGroup。如果我们没有对window的属性进行设置就会使用默认的com.android.internal.R.layout.screen_simple这个layout:\n\n```\nprotected ViewGroup generateLayout(DecorView decor) {    \n     ...\n     if ((features & ((1 << FEATURE_LEFT_ICON) | (1 << FEATURE_RIGHT_ICON))) != 0) {\n          ...\n          layoutResource = com.android.internal.R.layout.screen_title_icons;\n          ...\n     } else if ((features & ((1 << FEATURE_PROGRESS) | (1 << FEATURE_INDETERMINATE_PROGRESS))) != 0\n  && (features & (1 << FEATURE_ACTION_BAR)) == 0) {\n          layoutResource = com.android.internal.R.layout.screen_progress;\n     } else if ((features & (1 << FEATURE_CUSTOM_TITLE)) != 0) {\n          ...\n          layoutResource = com.android.internal.R.layout.screen_custom_title;\n          ...\n     } ... else{\n          layoutResource = com.android.internal.R.layout.screen_simple;\n     }\n     ...\n     View in = mLayoutInflater.inflate(layoutResource, null);\n     decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));\n     ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);\n     ...\n     return contentParent;\n}\n```\n\n我们可以在AndroidSdk根目录/platforms/android-19/data/res/layout/下面找到这些layout xml,例如screen_simple,这是个竖直的LinearLayout,由上方的ActionBar和下方的content FrameLayout组成。它就是我们最常见的带ActionBar的activity样式:\n\n```\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:fitsSystemWindows=\"true\"\n  android:orientation=\"vertical\">\n  <ViewStub android:id=\"@+id/action_mode_bar_stub\"\n    android:inflatedId=\"@+id/action_mode_bar\"\n    android:layout=\"@layout/action_mode_bar\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\" />\n  <FrameLayout\n    android:id=\"@android:id/content\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:foregroundInsidePadding=\"false\"\n    android:foregroundGravity=\"fill_horizontal|top\"\n    android:foreground=\"?android:attr/windowContentOverlay\" />\n</LinearLayout>\n```\n\n我们可以用一张图片来总结下Activity是如何管理布局的(这里假设DecorView里面添加了screen_simple这个布局):\n\n{% img /Activity是如何画到屏幕上的/1.png %}\n\n# Activity的布局是怎样被系统渲染的\n\n在上一节中我们已经知道了Activity是怎样管理布局的。接着我们来看看Activity中的布局是如何渲染到系统的。\n\nActivityThread用于管理Activity的声明周期,之后我会专门写一篇文章来讲它。我们直接看ActivityThread.handleResumeActivity方法:\n\n```\nfinal void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) {\n  ...\n  //performResumeActivity方法会调用Activity.onResume\n  ActivityClientRecord r = performResumeActivity(token, clearHide);\n  ...\n  r.window = r.activity.getWindow();\n  View decor = r.window.getDecorView();\n  decor.setVisibility(View.INVISIBLE);\n  ViewManager wm = a.getWindowManager();\n  WindowManager.LayoutParams l = r.window.getAttributes();\n  a.mDecor = decor;\n  l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;\n  l.softInputMode |= forwardBit;\n  if (a.mVisibleFromClient) {\n    a.mWindowAdded = true;\n    wm.addView(decor, l);\n  }\n  ...\n}\n```\n\n可以看到它在Activity.onResume之后从Activity中获取了Window,然后又从window中获取了DecorView。最后使用WindowManager.addView将DecorView添加到了WindowManager中。这样就将DecorView在手机上渲染了出来。\n\nWindowManager.addView方法可以将一个view渲染到手机界面上。不知道大家有没有做过类似悬浮球的应用,就是用WindowManager.addView去实现的。这里就不再展开了，大家有兴趣的话可以自己去搜索一下。\n\n\n# 为什么不能在子线程中操作view\n\n我们都知道,在安卓中必须在ui线程中操作ui,不能在子线程中对view进行操作,否则或抛出CalledFromWrongThreadException异常。但是在子线程中操作view是不是真的就一定会出现异常呢?让我们运行下面的代码:\n\n```\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                ((TextView)findViewById(R.id.textView)).setText(\"子线程中操作view\");\n            }\n        }).start();\n    }\n}\n```\n\n我们可以看到实际上在onCreate的时候直接启动子线程去修改TextView的文字是可以正常运行的,且文字也是显示正常的:\n\n\n{% img /Activity是如何画到屏幕上的/2.png %}\n\n\n让我们加1秒的延迟再试一下:\n\n```\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                ((TextView)findViewById(R.id.textView)).setText(\"子线程中操作view\");\n            }\n        }).start();\n    }\n}\n```\n\n运行之后就能看到熟悉的崩溃日志了:\n\n```\n02-28 22:36:48.550  3780  3817 E AndroidRuntime: FATAL EXCEPTION: Thread-5\n02-28 22:36:48.550  3780  3817 E AndroidRuntime: Process: com.example.linjw.myapplication, PID: 3780\n02-28 22:36:48.550  3780  3817 E AndroidRuntime: android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:6987)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.view.ViewRootImpl.requestLayout(ViewRootImpl.java:1104)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.view.View.requestLayout(View.java:19807)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.view.View.requestLayout(View.java:19807)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.view.View.requestLayout(View.java:19807)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.view.View.requestLayout(View.java:19807)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.support.constraint.ConstraintLayout.requestLayout(ConstraintLayout.java:874)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.view.View.requestLayout(View.java:19807)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.widget.TextView.checkForRelayout(TextView.java:7375)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.widget.TextView.setText(TextView.java:4487)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.widget.TextView.setText(TextView.java:4344)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at android.widget.TextView.setText(TextView.java:4319)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at com.example.linjw.myapplication.MainActivity$1.run(MainActivity.java:20)\n02-28 22:36:48.550  3780  3817 E AndroidRuntime:        at java.lang.Thread.run(Thread.java:760)\n```\n\n为什么延迟1秒之后就能看到异常被抛出了呢?本着寻根问底的精神,我们直接扣ViewRootImpl的源码看看CalledFromWrongThreadException异常是怎么被抛出的:\n\n```\npublic ViewRootImpl(Context context, Display display) {\n    ...\n    mThread = Thread.currentThread();\n    ...\n}\n\nvoid checkThread() {\n    if (mThread != Thread.currentThread()) {\n        throw new CalledFromWrongThreadException(\n                \"Only the original thread that created a view hierarchy can touch its views.\");\n    }\n}\n\npublic void requestLayout() {\n   if (!mHandlingLayoutInLayoutRequest) {\n       checkThread();\n       mLayoutRequested = true;\n       scheduleTraversals();\n   }\n}\n```\n\n在View.requestLayout方法中会调用ViewRootImpl.requestLayout,然后在ViewRootImpl.requestLayout里面会调用ViewRootImpl.checkThread去判断当前线程和创建ViewRootImpl的线程是不是同一个线程。如果不是的话就抛出CalledFromWrongThreadException异常。\n\n那ViewRootImpl又是在哪个线程中被创建的呢?还记得上一节中讲到的ActivityThread.handleResumeActivity方法中将DecorView添加到WindowManager中吗?WindowManager实际上是WindowManagerImpl实例:\n\n```\npublic final class WindowManagerImpl implements WindowManager {\n  private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();\n  ...\n  public void addView(View view, ViewGroup.LayoutParams params) {\n      mGlobal.addView(view, params, mDisplay, mParentWindow);\n  }\n  ...\n}\n```\n\n我们可以看到WindowManagerImpl.addView实际上是调到了WindowManagerGlobal.addView:\n\n```\npublic final class WindowManagerGlobal {\n  public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) {\n    ...\n    ViewRootImpl root;\n    ...\n    root = new ViewRootImpl(view.getContext(), display);\n    ...\n  }    \n}          \n```\n\n所以ViewRootImpl是在handleResumeActivity的线程中被创建的,我们都知道onResume是在主线程中被调用的,所以ViewRootImpl是在主线程中被调用的。所以只要在非主线程中调用ViewRootImpl.requestLayout就会抛出CalledFromWrongThreadException异常。\n\n\n那回到最初的问题,为什么我们在onCreate的时候直接起子线程去修改TextView的文字,不会抛出CalledFromWrongThreadException异常?因为ViewRootImpl是在onResume中创建的,在onCreate的时候它就还没有被创建,所以就不会抛出CalledFromWrongThreadException异常。\n\n等到onResume的时候ViewRootImpl被创建,会进行第一次layout,这个时候才会检查是否在主线程中操作ui。\n","tags":["技术相关","Android"]},{"title":"kotlin到底好在哪里","url":"/2018/02/20/kotlin到底好在哪里/","content":"\n最近在学kotlin,虽然还没有像其他博主一样立马就爱上它.但是不得不说,kotlin对比起java还是有不少优势的.\n\n# 1、语法简洁\n\n首先是语法比较简洁,能不简单处理的就不啰嗦.\n\n## 1.1、变量与常量\n\n变量通过var关键字定义,常量通过val关键字定义.既支持类型推倒也支持显示声明类型.这样的话定义变量和常量写起来会比java简洁一些:\n\n```\nvar intVar = 1 // 通过取值可以自动推倒出变量的类型\nvar stringVar: String = \"abc\" // 也可以显式声明变量类型\nval INT_VALUE = 1 // 使用val关键字定义常量\n```\n\n## 1.2、类\n\n在kotlin中,类可以通过class关键字定义.支持在主构造方法中用var或者val关键字直接定义成员变量,例如下面的name和author,当然也支持在类结构体中定义成员变量,如price.\n\n```\n// 类,这个类有name,author和price三个成员变量\nclass Book(var name: String, val author: String, p: Int) {\n    var price = p\n        private set // 将price的set操作设置为私有,只能在类内部赋值,外部只能读取\n\n    fun isTheSameAuthor(other: Book): Boolean {\n        return author == other.author\n    }\n}\n```\n\n与java中不同的是,kotlin中所有的类成员变量都是通过类访问器get和set去访问成员变量的,例如下面的代码中对price的调用并不是直接操作price变量,而是通过get/set访问器去访问的.所以我们可以将price的set访问器设置为私有的,这样的话就不能在外部去设置price的值了:\n\n```\nvar book = Book(\"book\", \"author\", 100)\nprintln(book.price) // 调用price的get访问器获取price的值\nbook.price = 123 // error,通过price的set访问器设置price的值,但是我们已经将它声明为私有了所以外部不能调用\n```\n\n假设我们用java去实现上面的Book类,我们需要写成下面这个样子.是不是感觉java的语法会啰嗦很多?实际上下面的java代码我还去掉了空指针处理和final关键字修饰.所以实际上代码量会更大.kotlin中短短的七行代码,java中要实现完全一模一样的功能,起码需要数十行代码.\n\n```\npublic class Book {\n   private int price;\n   private String name;\n   private String author;\n\n   public Book(String name, String author, int p) {\n      this.name = name;\n      this.author = author;\n      this.price = p;\n   }\n\n   public boolean isTheSameAuthor(Book other) {\n      return Intrinsics.areEqual(this.author, other.author);\n   }\n\n   public int getPrice() {\n      return this.price;\n   }\n\n   private void setPrice(int var1) {\n      this.price = var1;\n   }\n\n   public String getName() {\n      return this.name;\n   }\n\n   public void setName(String var1) {\n      this.name = var1;\n   }\n\n   public String getAuthor() {\n      return this.author;\n   }\n}\n```\n\n## 1.3、数据类\n\n在kotlin中,我们还有可以用data class去定义单纯只是保存数据的数据类:\n\n```\n// 数据类,除了有name和age两个成员变量之外还自动生成了equals,hashCode,toString等方法\ndata class Person(var name: String, var age: Int)\n```\n\n有的同学可能会会,数据类和普通的类有什么区别呢?让我们看下下面的代码就一目了然了:\n\n```\ndata class PersonData(var name: String, var age: Int)\nclass PersonClass(var name: String, var age: Int)\n\nvar dataA = PersonData(\"jack\", 18)\nvar dataB = PersonData(\"jack\", 18)\nprintln(dataA) // PersonData(name=jack, age=18)\nprintln(dataB) // PersonData(name=jack, age=18)\nprintln(dataA == dataB) // true\n\nvar classA = PersonClass(\"peter\", 20)\nvar classB = PersonClass(\"peter\", 20)\nprintln(classA) // me.linjw.demo.TestKotlin.PersonClass@5fcfe4b2\nprintln(classB) // me.linjw.demo.TestKotlin.PersonClass@6bf2d08e\nprintln(classA == classB) // false\n```\n\n假设用java去实现的话就不知道这一行的kotlin代码需要多少行才能实现了.\n\n## 1.4、object 对象\n\n我们能使用object关键字直接实现单例模式:\n\n```\nobject DataBaseHelper {\n  ...\n}\n```\n\n它翻译成java是这样的:\n\n```\npublic class DataBaseHelper {\n  public static final DataBaseHelper INSTANCE;\n\n  private DataBaseHelper() {\n\n  }\n\n  static {\n    INSTANCE = new DataBaseHelper();\n  }\n}\n```\n\n\n# 2、命名参数\n\nkotlin支持命名参数。当一个方法的参数数目特别多的时候,命名参数就很有用了。例如String.regionMatches方法有五个参数:\n\n```\npublic boolean regionMatches(boolean ignoreCase, int toffset,\n            String other, int ooffset, int len) {\n\t...\n}\n```\n\n在调用的时候一眼很难看出哪个实参有什么作用:\n\n```\nString str = new String(\"hello world!\");\nString sub = new String(\"WORLD\");\nSystem.out.println(str.regionMatches(true, 6, sub, 0, 5));\n```\n\n而在kotlin中可以用命名参数将每个实参对应的形参注明出来,简直一目了然:\n\n```\nval str = \"hello world!\"\nval sub = \"WORLD\"\nprintln(str.regionMatches(thisOffset = 6, other = sub, otherOffset = 0, length = 5, ignoreCase = true))\n\n//命名参数可以用不同于函数声明的参数顺序传参\nprintln(str.regionMatches(ignoreCase = true, thisOffset = 6, other = sub, otherOffset = 0, length = 5))\n```\n\n而且使用命名参数的话可以不遵循方法声明的时候的参数顺序传参,因为我们已经将哪个实参传给哪个形参都标明了.\n\n\n# 3、空指针安全\n\n在kotlin中,每个类型都有其对应的可空类型,只有可空类型才能被赋值为null:\n\n```\nvar a: Int = 1 // 非空类型需要初始化为非null\nvar b: Int? // 可空类型可以不初始化,默认为null\nvar c: String = \"\" // 非空类型需要初始化为非null\nvar d: String? = null // 可空类型也可以显式赋值为null\nvar e: Float = 1.0f // 非空类型需要初始化为非null\nvar f: Float? = 2.0f // 可空类型也可以显式赋值为非null\n\na = null // error类型不能赋值为null,编译不通过\nb = null // ok\nc = null // error类型不能赋值为null,编译不通过\nd = null // ok\ne = null // error类型不能赋值为null,编译不通过\nf = null // ok\n```\n\n非空类型不可能为null,所以不用考虑空指针的问题.只有可空类型有可能为null,这个时候必须指定它为null的时候的行为.\n\n可以用\"?.\"做判空处理,或者使用\"!!.\"在空指针的情况下抛出空指针异常:\n\n```\nfun foo(str : String?){\n    println(str?.length) // str?.length表达式结果为null,可以正常运行\n    println(str!!.length) // 抛出空指针异常\n}\n```\n\nfoo方法翻译成java是这样的:\n\n```\npublic final void foo(@Nullable String str) {\n  Integer var2 = str != null?Integer.valueOf(str.length()):null;\n  System.out.println(var2);\n  if(str == null) {\n    Intrinsics.throwNpe(); // 抛出空指针异常\n  }\n\n  int var3 = str.length();\n  System.out.println(var3);\n}\n```\n\n很多文章在介绍kotlin的可空类型的时候都是以简化了判空处理的优点来介绍的.例如下面java方法中的判空处理,用kotlin只需要一行代码就可以了:\n\n```\n// java中需要自己判空\npublic Character front(String str) {\n    if (str != null){\n        return str.charAt(0);\n    }\n    return null;\n}\n\n// kotlin中用可空类型只需要一行代码\nfun front(str: String?): Char? {\n   return str?.get(0);\n}\n```\n\n但是在我看来,可空类型非空类型的意义并不在帮我们做简化了判空处理的代码.更重要的一点是明确指出了哪些变量是可能为空的,同时明确了为空的时候的调用应该怎么处理.\n\n对于非空类型,它永远不可能为空,我们不需要考虑它的空指针问题.而对于可空类型,我们需要明确指定在它为空的时候的调用抛出异常亦或进行执行.这样其实缩小了空指针异常的范围,同时也减小了空指针对程序稳定安全的破坏性.\n\n# 4、字符串模板\n\n在kotlin字符串中可以用\"$\"符号标识一个表达式,该表达式的值会被计算出来放到字符串中:\n\n```\nval str = \"abc\"\nprintln(\"$str.length is ${str.length}\") // 结果为 \"abc.length is 3\"\n```\n\n比起java用字符串拼接或者String.format的方式去处理都要优雅得多.\n\n# 5、高阶函数和Lambda表达式的支持\n\n\n在java中实现观察者模式,我们往往需要额外定义一个监听者的接口,这种监听者接口往往也只有一个方法,其实实际上属于比较冗余的代码,没有很大的实际价值:\n\n```\npublic class Button {\n    private OnClickListener mListener;\n\n    public void setOnClickListener(OnClickListener listener) {\n        mListener = listener;\n    }\n\n    public interface OnClickListener {\n        void onClick(Button button);\n    }\n}\n```\n\n而在kotlin中我们可以将函数直接作为一个对象保存起来,再也不用为监听者单独定义一个接口了:\n\n```\nclass Button {\n  var listener: ((Button) -> Unit)? = null\n\n  fun click() {\n    listener?.invoke(this)\n  }\n}\n\nvar btn = Button()\nbtn.listener = { print(\"on click\") }\nbtn.click()\n```\n\n# 6、泛型\n\n在java泛型中存在类型通配符,用\"? extends T\"指定类参数的上限,用\"? super T\"指定类型参数的下限.\n\n至于什么时候使用哪一种,在《Effect java》 中给出了PECS原则:\n\n> PECS: producer-extends,consumer-super\n\n在生产者中使用\"? extends T\",在消费者中使用\"? super T\".\n\njava中使用类型的关系去设计了通配符,这样做的确在实现上是比较清晰的.但是我个人其实更加喜欢kotlin中直接通过功能去规定类型安全的类型上下界.\n\n```\npublic <T> void copy(List<? super T> dest, List<? extends T> src) {\n  ...\n}\n```\n\nList<? super T> dest 是消费者,数据将会放到这里.而List<? extends T> src是生产者,数据从这里提供.\n\n实际上看copy这个java方法,在定义的时候需要稍微思考一下才能确定哪个用super哪个用extends.但是如果你用kotlin的话想都不用想,消费者用in,生产者用out:\n\n```\nfun <T> copy(dest: Array<in T>, src: Array<out T>) {\n  ...\n}\n```\n\n直接用in/out这种功能描述是不是比java用super/extends这种类型描述直接了很多?\n\n泛型这部分参考了《Kotlin极简教程》,这本书真的不错,强烈推荐.而大家如果对java泛型有兴趣的话可以去可空《Effect java》的相关章节或者也可以去看看我之前写的两篇文章 [《java泛型那些事》](http://blog.islinjw.cn/2018/01/06/java%E6%B3%9B%E5%9E%8B%E9%82%A3%E4%BA%9B%E4%BA%8B/)、[《再谈Java泛型》](http://blog.islinjw.cn/2018/02/04/%E5%86%8D%E8%B0%88Java%E6%B3%9B%E5%9E%8B/)\n\n# 7、无缝调用java\n\n当然,一个语言就算做的再好,但是没有一个健全的生态的话是很难被大众接受的.kotlin能够火起来,甚至被谷歌爸爸钦定为安卓的官方推荐语言.一个很重要的原因就是它可以无缝与java相互调用.以前写的java代码不用任何处理就能直接在kotlin中使用,而java也能无缝调用kotlin代码.\n\n实际上在安卓中,编译的时候kotlin代码就会被编译成java代码,所以它们其实是等价的.\n","tags":["技术相关","kotlin"]},{"title":"安卓广播的底层实现原理","url":"/2018/02/10/安卓广播的底层实现原理/","content":"\n\n相信广播大家都有用过,也知道安卓广播的一些基础知识,如静态广播、动态广播、粘性广播等等,但相信很多人都不知道系统层面是怎样实现这些广播特性的,这篇文章就让我们来聊一聊安卓广播机制的系统实现原理.\n\n# 静态广播的注册\n\n静态广播是通过PackageManagerService在启动的时候扫描已安装的应用去注册的.\n\n在PackageManagerService的构造方法中,会去扫描应用安装目录,顺序是先扫描系统应用安装目录再扫描第三方应用安装目录.\n\nPackageManagerService.scanDirLI就是用于扫描目录的方法,由于代码比较少,这里我们直接把它贴了上来:\n\n```\nprivate void scanDirLI(File dir, int flags, int scanMode, long currentTime) {\n   String[] files = dir.list();\n   if (files == null) {\n       return;\n   }\n\n   int i;\n   for (i=0; i<files.length; i++) {\n       File file = new File(dir, files[i]);\n       if (!isPackageFilename(files[i])) {\n           continue;\n       }\n       PackageParser.Package pkg = scanPackageLI(file,\n               flags|PackageParser.PARSE_MUST_BE_APK, scanMode, currentTime, null);\n       if (pkg == null && (flags & PackageParser.PARSE_IS_SYSTEM) == 0 &&\n               mLastScanError == PackageManager.INSTALL_FAILED_INVALID_APK) {\n           file.delete();\n       }\n   }\n}\n\nprivate static final boolean isPackageFilename(String name) {\n   return name != null && name.endsWith(\".apk\");\n}\n```\n\n可以看到,它通过File.list方法列出目录下的所有后缀为\".apk\"的文件传给scanPackageLI去处理.\n而scanPackageLI(File scanFile,int parseFlags, int scanMode, long currentTime, UserHandle user)内部会调用它的重载方法scanPackageLI(PackageParser.Package pkg,int parseFlags, int scanMode, long currentTime, UserHandle user):\n\n```\nprivate PackageParser.Package scanPackageLI(File scanFile,int parseFlags, int scanMode, long currentTime, UserHandle user) {\n  ...\n  final PackageParser.Package pkg = pp.parsePackage(scanFile,scanPath, mMetrics, parseFlags);\n  ...\n  PackageParser.Package scannedPkg = scanPackageLI(pkg, parseFlags, scanMode | SCAN_UPDATE_SIGNATURE, currentTime, user);\n  ...\n}\n```\n\n\n在这个scanPackageLIl里面会解析Package并且将AndroidManifest.xml中注册的BroadcastReceiver保存下来:\n\n```\n...\nN = pkg.receivers.size();\nr = null;\nfor (i=0; i<N; i++) {\n   PackageParser.Activity a = pkg.receivers.get(i);\n   a.info.processName = fixProcessName(pkg.applicationInfo.processName,\n           a.info.processName, pkg.applicationInfo.uid);\n   mReceivers.addActivity(a, \"receiver\");\n   ...\n}\n...\n```\n\n所以从上面获取静态广播的流程可以看出来:系统应用的广播先于第三方应用的广播注册,而安装在同一个目录下的应用的静态广播的注册顺序是按照File.list列出来的apk的顺序注册的.他们的注册顺序就决定了它们接收广播的顺序.\n\n通过静态广播的注册流程,我们已经将静态广播注册到了PackageManagerService的mReceivers中,而我们可以使用PackageManagerService.queryIntentReceivers方法查询intent对应的静态广播\n\n```\npublic List<ResolveInfo> queryIntentReceivers(Intent intent, String resolvedType, int flags, int userId) {\n   if (!sUserManager.exists(userId)) return Collections.emptyList();\n   ComponentName comp = intent.getComponent();\n   if (comp == null) {\n       if (intent.getSelector() != null) {\n           intent = intent.getSelector();\n           comp = intent.getComponent();\n       }\n   }\n   if (comp != null) {\n       List<ResolveInfo> list = new ArrayList<ResolveInfo>(1);\n       ActivityInfo ai = getReceiverInfo(comp, flags, userId);\n       if (ai != null) {\n           ResolveInfo ri = new ResolveInfo();\n           ri.activityInfo = ai;\n           list.add(ri);\n       }\n       return list;\n   }\n\n   synchronized (mPackages) {\n       String pkgName = intent.getPackage();\n       if (pkgName == null) {\n           return mReceivers.queryIntent(intent, resolvedType, flags, userId);\n       }\n       final PackageParser.Package pkg = mPackages.get(pkgName);\n       if (pkg != null) {\n           return mReceivers.queryIntentForPackage(intent, resolvedType, flags, pkg.receivers,\n                   userId);\n       }\n       return null;\n   }\n}\n```\n\n# 动态广播的注册\n\n我们调用Context.registerReceiver最后会调到ActivityManagerService.registerReceiver:\n\n```\npublic Intent registerReceiver(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, int userId) {\n  ...\n  ReceiverList rl = (ReceiverList)mRegisteredReceivers.get(receiver.asBinder());\n  ...\n  BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage, permission, callingUid, userId);\n  ...\n  mReceiverResolver.addFilter(bf);\n  ...\n}\n```\n\n所以通过mReceiverResolver.queryIntent就能获得intent对应的动态广播了.\n\n# 发送广播\n\nContextImpl.sendBroadcast中会调用ActivityManagerNative.getDefault().broadcastIntent()\n\n\n```\npublic void sendBroadcast(Intent intent) {\n    warnIfCallingFromSystemProcess();\n    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());\n    try {\n        intent.prepareToLeaveProcess();\n        ActivityManagerNative.getDefault().broadcastIntent(\n            mMainThread.getApplicationThread(), intent, resolvedType, null,\n            Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, false, false,getUserId());\n    } catch (RemoteException e) {\n    }\n}\n```\n\n实际是调用ActivityManagerService.broadcastIntent:\n\n```\npublic final int broadcastIntent(IApplicationThread caller,\n        Intent intent, String resolvedType, IIntentReceiver resultTo,\n        int resultCode, String resultData, Bundle map,\n        String requiredPermission, int appOp, boolean serialized, boolean sticky, int userId) {\n    enforceNotIsolatedCaller(\"broadcastIntent\");\n    synchronized(this) {\n        intent = verifyBroadcastLocked(intent);\n        final ProcessRecord callerApp = getRecordForAppLocked(caller);\n        final int callingPid = Binder.getCallingPid();\n        final int callingUid = Binder.getCallingUid();\n        final long origId = Binder.clearCallingIdentity();\n        int res = broadcastIntentLocked(callerApp,\n                callerApp != null ? callerApp.info.packageName : null,\n                intent, resolvedType, resultTo,\n                resultCode, resultData, map, requiredPermission, appOp, serialized, sticky,\n                callingPid, callingUid, userId);\n        Binder.restoreCallingIdentity(origId);\n        return res;\n    }\n}\n```\n\nActivityManagerService.broadcastIntent中又会调用ActivityManagerService.broadcastIntentLocked,而broadcastIntentLocked中的关键代码如下:\n\n```\n// 静态广播\nList receivers = null;\n// 动态广播\nList<BroadcastFilter> registeredReceivers = null;\nif ((intent.getFlags()&Intent.FLAG_RECEIVER_REGISTERED_ONLY)\n      == 0) {\n   // 查询静态广播\n   receivers = collectReceiverComponents(intent, resolvedType, users);\n}\nif (intent.getComponent() == null) {\n   // 查询动态广播\n   registeredReceivers = mReceiverResolver.queryIntent(intent,\n           resolvedType, false, userId);\n}\n\nfinal boolean replacePending =\n       (intent.getFlags()&Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;\n\nint NR = registeredReceivers != null ? registeredReceivers.size() : 0;\nif (!ordered && NR > 0) {\n   final BroadcastQueue queue = broadcastQueueForIntent(intent);\n   BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,\n           callerPackage, callingPid, callingUid, resolvedType, requiredPermission,\n           appOp, registeredReceivers, resultTo, resultCode, resultData, map,\n           ordered, sticky, false, userId);\n   final boolean replaced = replacePending && queue.replaceParallelBroadcastLocked(r);\n   if (!replaced) {\n       // 发送动态广播\n       queue.enqueueParallelBroadcastLocked(r);\n       queue.scheduleBroadcastsLocked();\n   }\n   registeredReceivers = null;\n   NR = 0;\n}\n...\nif ((receivers != null && receivers.size() > 0)\n    || resultTo != null) {\n   BroadcastQueue queue = broadcastQueueForIntent(intent);\n   BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,\n           callerPackage, callingPid, callingUid, resolvedType,\n           requiredPermission, appOp, receivers, resultTo, resultCode,\n           resultData, map, ordered, sticky, false, userId);\n   boolean replaced = replacePending && queue.replaceOrderedBroadcastLocked(r);\n   if (!replaced) {\n       // 发送静态广播\n       queue.enqueueOrderedBroadcastLocked(r);\n       queue.scheduleBroadcastsLocked();\n   }\n}\n```\n\n大家应该都有听说过动态广播会优先于静态广播,从上面的代码我们可以看到,这实际是因为安卓的源代码就是按这个顺序写的...\n\n最后我们来看一下ActivityManagerService.collectReceiverComponents方法,实际上静态广播静态就是从PackageManagerService中查询的:\n\n```\nprivate List<ResolveInfo> collectReceiverComponents(Intent intent, String resolvedType,\n            int[] users) {\n    ...\n    List<ResolveInfo> newReceivers = AppGlobals.getPackageManager()\n                        .queryIntentReceivers(intent, resolvedType, STOCK_PM_FLAGS, user);\n    ...\n```\n\n# 粘性广播的实现原理\n\nActivityManagerService.broadcastIntentLocked有下面这样一段代码,它将粘性广播存到了mStickyBroadcasts中。\n\n```\nif (sticky) {\n    ...\n    ArrayMap<String, ArrayList<Intent>> stickies = mStickyBroadcasts.get(userId);\n    if (stickies == null) {\n        stickies = new ArrayMap<String, ArrayList<Intent>>();\n        mStickyBroadcasts.put(userId, stickies);\n    }\n    ArrayList<Intent> list = stickies.get(intent.getAction());\n    if (list == null) {\n        list = new ArrayList<Intent>();\n        stickies.put(intent.getAction(), list);\n    }\n    int N = list.size();\n    int i;\n    for (i=0; i<N; i++) {\n        if (intent.filterEquals(list.get(i))) {\n            // This sticky already exists, replace it.\n            list.set(i, new Intent(intent));\n            break;\n        }\n    }\n    if (i >= N) {\n        list.add(new Intent(intent));\n    }\n}\n```\n\n而ManagerService.registerReceiver会获取之前发送的粘性广播,再次发送给刚刚注册的receiver:\n\n```\n...\nList allSticky = null;\n\n// 获取符合的粘性广播\nIterator actions = filter.actionsIterator();\nif (actions != null) {\n    while (actions.hasNext()) {\n        String action = (String)actions.next();\n        allSticky = getStickiesLocked(action, filter, allSticky,\n                UserHandle.USER_ALL);\n        allSticky = getStickiesLocked(action, filter, allSticky,\n                UserHandle.getUserId(callingUid));\n    }\n} else {\n    allSticky = getStickiesLocked(null, filter, allSticky,\n            UserHandle.USER_ALL);\n    allSticky = getStickiesLocked(null, filter, allSticky,\n            UserHandle.getUserId(callingUid));\n}\n...\n//向新注册的receiver发送粘性广播\nif (allSticky != null) {\n    ArrayList receivers = new ArrayList();\n    receivers.add(bf);\n\n    int N = allSticky.size();\n    for (int i=0; i<N; i++) {\n        Intent intent = (Intent)allSticky.get(i);\n        BroadcastQueue queue = broadcastQueueForIntent(intent);\n        BroadcastRecord r = new BroadcastRecord(queue, intent, null,\n                null, -1, -1, null, null, AppOpsManager.OP_NONE, receivers, null, 0,\n                null, null, false, true, true, -1);\n        queue.enqueueParallelBroadcastLocked(r);\n        queue.scheduleBroadcastsLocked();\n    }\n}\n...\n```\n\ngetStickiesLocked即从mStickyBroadcasts中查询之前发送过的粘性广播\n\n```\nprivate final List getStickiesLocked(String action, IntentFilter filter,\n        List cur, int userId) {\n    final ContentResolver resolver = mContext.getContentResolver();\n    ArrayMap<String, ArrayList<Intent>> stickies = mStickyBroadcasts.get(userId);\n    if (stickies == null) {\n        return cur;\n    }\n    final ArrayList<Intent> list = stickies.get(action);\n    if (list == null) {\n        return cur;\n    }\n    int N = list.size();\n    for (int i=0; i<N; i++) {\n        Intent intent = list.get(i);\n        if (filter.match(resolver, intent, true, TAG) >= 0) {\n            if (cur == null) {\n                cur = new ArrayList<Intent>();\n            }\n            cur.add(intent);\n        }\n    }\n    return cur;\n}\n```\n\n# 广播队列\n\n\n从ActivityManagerService.broadcastIntentLocked中我们可以看到,实际上它不是直接将广播发送到BroadcastReceiver中的.\n\n而是将他包装到BroadcastRecord中,再放进BroadcastQueue:\n\n```\nBroadcastQueue queue = broadcastQueueForIntent(intent);\nBroadcastRecord r = new BroadcastRecord(queue, intent, null,\n        null, -1, -1, null, null, AppOpsManager.OP_NONE, receivers, null, 0,\n        null, null, false, true, true, -1);\nqueue.enqueueParallelBroadcastLocked(r);\nqueue.scheduleBroadcastsLocked();\n```\n\nenqueueParallelBroadcastLocked方法用于并发执行广播的发送.它很简单,就是将BroadcastRecord放到了mParallelBroadcasts中:\n\n```\npublic void enqueueParallelBroadcastLocked(BroadcastRecord r) {\n    mParallelBroadcasts.add(r);\n}\n```\n\nscheduleBroadcastsLocked方法同样很简单,就是向mHandler发送了个BROADCAST_INTENT_MSG消息:\n```\npublic void scheduleBroadcastsLocked() {\n   if (mBroadcastsScheduled) {\n       return;\n   }\n   mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));\n   mBroadcastsScheduled = true;\n}\n```\n\n这个时候我们就需要再去看看mHandler在接收到BROADCAST_INTENT_MSG消息的时候会做些什么:\n\n```\nfinal Handler mHandler = new Handler() {\n   public void handleMessage(Message msg) {\n       switch (msg.what) {\n           case BROADCAST_INTENT_MSG: {\n               processNextBroadcast(true);\n           } break;\n           case BROADCAST_TIMEOUT_MSG: {\n               synchronized (mService) {\n                   broadcastTimeoutLocked(true);\n               }\n           } break;\n       }\n   }\n};\n\n```\n\nprocessNextBroadcast方法用于从队列中获取广播消息并发送给BroadcastReceiver,它内部有两个分支,并行处理和串行处理.\n\n## 普通广播并行处理\n\n我们先看看并行处理的分支:\n\n```\n\nfinal void processNextBroadcast(boolean fromMsg) {\n  synchronized(mService) {\n      BroadcastRecord r;\n      mService.updateCpuStats();\n      if (fromMsg) {\n         mBroadcastsScheduled = false;\n      }\n      while (mParallelBroadcasts.size() > 0) {\n         r = mParallelBroadcasts.remove(0);\n         r.dispatchTime = SystemClock.uptimeMillis();\n         r.dispatchClockTime = System.currentTimeMillis();\n         final int N = r.receivers.size();\n         for (int i=0; i<N; i++) {\n             Object target = r.receivers.get(i);\n             // 发送消息给Receiver\n             deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false);\n         }\n         addBroadcastToHistoryLocked(r);\n      }\n      ...\n   }\n   ...\n}\n\nprivate final void deliverToRegisteredReceiverLocked(BroadcastRecord r,\n            BroadcastFilter filter, boolean ordered) {\n    ...\n    // 获取BroadcastReceiver的Binder\n    r.receiver = filter.receiverList.receiver.asBinder();\n    ...\n    // 使用Binder机制将消息传递给BroadcastReceiver\n    performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver,\n                    new Intent(r.intent), r.resultCode, r.resultData,\n                    r.resultExtras, r.ordered, r.initialSticky, r.userId);\n    ...\n}\n\nvoid performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,\n        Intent intent, int resultCode, String data, Bundle extras,\n        boolean ordered, boolean sticky, int sendingUser) throws RemoteException {\n    ......\n        //通过Binder将消息处理传到应用进程,应用进程内部再使用Handler机制,将消息处理放到主线程中\n        app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,\n                        data, extras, ordered, sticky, sendingUser, app.repProcState);\n    ......\n    }\n}\n```\n\n## 有序广播串行处理\n\n例如有序广播,会通过enqueueOrderedBroadcastLocked传给BroadcastQueue:\n\n```\npublic void enqueueOrderedBroadcastLocked(BroadcastRecord r) {\n   mOrderedBroadcasts.add(r);\n}\n```\n\n然后在processNextBroadcast里面会对mOrderedBroadcasts进行特殊处理,但是恕我愚钝,这部分代码比较复杂,我现在还没有搞懂它实际的怎么运行的.这块就留下来之后再讲了.\n\n\n# 总结\n\n广播队列传送广播给Receiver的原理其实就是将BroadcastReceiver和消息都放到BroadcastRecord里面,然后通过Handler机制遍历BroadcastQueue里面的BroadcastRecord,将消息发送给BroadcastReceiver:\n\n\n\n{% img /安卓广播的底层实现原理/1.png %}\n\n所以整个广播的机制可以总结成下面这张图:\n\n{% img /安卓广播的底层实现原理/2.png %}\n","tags":["技术相关","Android"]},{"title":"再谈Java泛型","url":"/2018/02/04/再谈Java泛型/","content":"\n\n之前其实已经写过一篇泛型的文章[《java泛型那些事》](http://blog.islinjw.cn/2018/01/06/java%E6%B3%9B%E5%9E%8B%E9%82%A3%E4%BA%9B%E4%BA%8B/),但是最近在看《Kotlin极简教程》泛型部分拿java和Kotlin对比泛型机制异同的时候,又发现了一些关于java泛型的,我之前不知道的知识。这里再把它们记录下来。\n\n# 关于泛型通配符\n\n## 关于<? extends T>\n\n首先假设有下面的一个list:\n\n```\nList<? extends Number> list = new ArrayList<>();\n```\n\n我们是不能向它添加除null以外的任意对象的,即使是Number的子类:\n\n```\nlist.add(null); // ok\nlist.add(new Integer(1)); // error\nlist.add(new Float(1.0f)); // error\n```\n\n这是为什么呢?我们来再来看下面的代码:\n\n```\nList<Integer> listOri = new ArrayList<>();\nList<? extends Number> list = listOri;\n```\n\nlistOri中只能存放Integer。\n\n但是假设我们能向List<? extends Number>中添加Number的子类,那么我们就能将Float、Double这样的非Integer的类放到list中。\n\n这样的话我们就会打破listOri中的类型一致性。而只有将null,放到list中不会打破listOri的类型一致性。\n\n## 关于<? super T>\n\n和上面的<? extends T>不同,我们可以向List<? super Number>中加入null和Number的任意子对象:\n\n```\nList<? super Number> list = listOri;\nlist.add(null); // ok\nlist.add(new Integer(1)); // ok\nlist.add(new Float(1.0f)); // ok\nlist.add(new Object()); // error\n```\n\n因为List<? super Number>中存放的都是Number的父类,而Number的子类都可以转化成Number,也就可以转化成Number的这个父类。所以就能保证list中类型的一致性。\n\n# Collection方法中的Object参数\n\n我有注意到Map的一些方法的参数并不是泛型参数,而是Object：\n\n```\nboolean containsKey(Object key);\nboolean containsValue(Object value);\nV get(Object key);\nV remove(Object key);\n...\n```\n\n其实不止Map包括其他的容器其实都是一样的,我们能在Collectiond接口中看到下面的方法:\n\n```\nboolean remove(Object o);\nboolean contains(Object o);\n...\n```\n\n它们都不是用泛型参数,而是直接用的Object,这是为什么呢?\n\nJava 集合框架创办人，Josh Bloch 是这么说的:\n\n> Josh Bloch says (6:41) that they attempted to generify the get method of Map, remove method and some other, but \"it simply didn't work\". There are too many reasonable programs that could not be generified if you only allow the generic type of the collection as parameter type. The example given by him is an intersection of a List of Numbers and a List of Longs.\n\n他们其实有想过用泛型参数去实现Map的get方法,但是出现了一些状况导致它出问题了,比如说用List<Number>做Key,但却想用List<Long>来get。\n\nstackoverflow上也有大神这么说:\n\n```\nActually, it's very simple! If add() took a wrong object, it would break the collection. It would contain things it's not supposed to! That is not the case for remove(), or contains(). – Kevin Bourrillion Nov 7 '09 at 3:46\n\nIncidentally, that basic rule -- using type parameters to prevent actual damage to the collection only -- is followed absolutely consistently in the whole library.  – Kevin Bourrillion Nov 7 '09 at 3:49\n```\n\n因为像add方法这样的往集合中添加元素的方法,如果用Object参数的话,会破坏集合中的类型安全性。但是像remove(),contains()这些方法其实只需要equals成立即可,不需要限制类型。java库的原则就是只用类型参数去保护集合的类型安全性不会被破坏,不做多余的事情。\n","tags":["技术相关","java"]},{"title":"小米笔记本pro 15.6寸安装ubuntu16.04无法使用wifi的解决方法","url":"/2018/01/06/小米笔记本pro 15.6寸安装ubuntu16.04无法使用wifi的解决方法/","content":"\n\n前不久买了台15.6寸的小米pro,顺利安装win10、ubuntu 16.04双系统之后发现ubuntu的wifi一直不能启动。\n\n在小米社区上搜索找到的解决方法基本都是在/etc/modprobe.d/blacklist.conf文件后面加上acer-wmi或者在/etc/modprobe.d/ 下创建文件 xiaomi.conf并写入blacklist acer_wmi。\n\n据说在小米13.3上面是可行的。但是我这边一直失败。而且也找不到15.6寸的小米pro解决方法。难道是还没有人用15.6寸的小米笔记本去装ubuntu 16.04吗？\n\n# 原因\n\n折腾了好几天,终于在ubuntu社区上找到解决方法。这里做下笔记,希望可以让有需要的人看到。\n\n社区上具体的回答可以在[这里](https://askubuntu.com/questions/910934/intel-wifi-card-not-recognised-in-ubuntu-16-04)查看。\n\n\n# 解决方法\n\nchili555大神给出的解释是Ubuntu 16.04没有覆盖8086:24fd这个wifi设备的驱动,需要自己安装。或者直接安装Ubuntu 17.04,这个版本的ubuntu已经覆盖了这个驱动。\n\n\n自己安装wifi驱动的方法也很简单,首先下载下面链接的软件:\n\n- [linux-firmware_1.169_all.deb](https://github.com/bluesky466/filesave/blob/master/miwifi/linux-firmware_1.169_all.deb)\n- [linux-headers-4.10.14-041014-generic_4.10.14-041014.201705031501_amd64.deb](https://github.com/bluesky466/filesave/blob/master/miwifi/linux-headers-4.10.14-041014-generic_4.10.14-041014.201705031501_amd64.deb)\n- [linux-headers-4.10.14-041014_4.10.14-041014.201705031501_all.deb](https://github.com/bluesky466/filesave/blob/master/miwifi/linux-headers-4.10.14-041014_4.10.14-041014.201705031501_all.deb)\n- [linux-image-4.10.14-041014-generic_4.10.14-041014.201705031501_amd64.deb](https://github.com/bluesky466/filesave/blob/master/miwifi/linux-image-4.10.14-041014-generic_4.10.14-041014.201705031501_amd64.deb)\n\n\n然后执行命令将它们全部安装,接着重启电脑就可以了:\n\n```\nsudo dpkg -i *.deb\n```\n\n## 关闭secure boot\n\n这个步骤可能不需要。因为我之前在搜索其他解决方式的时候就已经将它关闭了\n\n如果你按照我上面的方法安装驱动之后还是不能使用wifi的话。进入bois查看是否位于UEFI且开启了secure boot,是的话将它关闭。\n\n小米笔记本进入bois的方法是开机的时候狂按F2。进入之后找到secure boot关闭它就可以了。\n","tags":["技术相关"]},{"title":"java泛型那些事","url":"/2018/01/06/java泛型那些事/","content":"\n# 泛型的类型安全性\n\n有许多原因促成了泛型的出现，而最引人注意的一个原因，就是为了创建容器类。\n\n如果没有泛型,如果我们需要实现一个通用的队列,那么只能使用Obejct数组去实现,并且add方法的参数和get方法的返回值都为Object:\n\n```\npublic class MyList {\n    private Object[] mData;\n\n    public void add(Object obj) {\n        ...\n    }\n\n    public Object get(int index) {\n        ...\n    }\n    ...\n}\n```\n\n但是这样的话其实是很不安全的,类型安全需要靠用户去自己维护。但用户往往都是愚蠢的:\n\n```\nMyList myList = new MyList();\nmyList.add(\"1\");\nmyList.add(\"2\");\nmyList.add(3);\n\nString val1 = (String) myList.get(0);\nString val2 = (String) myList.get(1);\nString val3 = (String) myList.get(2);\n```\n\n上面的代码在编译的时候没有问题,但是真正运行的时候程序跑着跑着就挂了,这就叫做类型不安全的设计。\n\n使用泛型的意义在于它是类型安全的,如果使用泛型规定了参数和返回值的类型的话,上面的代码在编译的时候就会失败:\n\n\n```\npublic class MyList<E> {\n  private Object[] mData;\n\n  ...\n\n  public void add(E obj) {\n    ...\n  }\n\n  public E get(int index) {\n    ...\n    return (E) mData[index];\n  }\n}\n\nMyList<String> myList = new MyList<>();\nmyList.add(\"1\");\nmyList.add(\"2\");\nmyList.add(3); //这里会编译失败\n\nString val1 = myList.get(0);\nString val2 = myList.get(1);\nString val3 = myList.get(0);\n```\n\n# 类型标识符\n\n在MyList&lt;E&gt;声明尖括号里面的就是类型标识符,它其实是一个占位符,代表了某个类型,我们在类里面就能用这个占位符代表某种类型。例如add方法的参数或者get的返回值,当然也能用来声明一个成员变量。\n\n可能有人会说经常看到都是用T泛型作为泛型标识符,为什么这里我们用E呢?\n\n其实用什么字母做标识符在java里面并没有硬性规定,甚至你也可以不用仅一个字符，用一个单词也是可以的。\n\n不过我们通常会按照习惯在不同场景下用不同的字母标识符:\n\n- E - Element (在集合中使用)\n- T - Type（Java 类）\n- K - Key（键）\n- V - Value（值）\n\n# 泛型通配符\n\n在泛型中有个很重要的知识点就是__泛型类型之间是不具有继承关系的__,也就是说List&lt;Object&gt;并不是List&lt;String&gt;的父类:\n\n```\npublic void printList(List<Object> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}\n\n\nList<String> strList = Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\");\nprintList(strList); //错误,List<Object>不是List<String>的父类\n```\n\n为了实现上面的printList方法,类型通配符就出现了:\n\n\n```\npublic void printList(List<?> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}\n\nList<String> strList = Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\");\nprintList(strList);\n```\n\nList&lt;?&gt;可以匹配List&lt;String&gt;、List&lt;Integer&gt;等等的各种类型。\n\n大家有可能会听过类型通配符上限和下限,这两个东西是怎样的概念呢？有时候我们会需要限定只能传入某些型的子类或者父类的容器:\n\n\n- 上限：<? extends T> 只能匹配T和T的子类\n\n- 下限：<? super T> 只能匹配T和T的父类\n\n```\n//只能传入ClassA的子类的容器\npublic void printList(List<? extends ClassA> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}\n\n//只能传入ClassA的父类的容器\npublic void printList(List<? super ClassA> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}\n```\n\n除了上面的通配符\"?\"，我们还可以直接用泛型方法去实现printListde,可以指定所有类型的列表或者ClassA的子类的列表:\n\n```\npublic <T> void printList(List<T> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}\n\npublic <T extends ClassA> void printList(List<T> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}\n```\n\n当然我们也能使用泛型的方式直接指定参数的上限,比如下面的foo方法就只能接收Number的子类:\n\n```\npublic <T extends Number> void foo(T arg){\n    ...\n}\n```\n\n但是如果直接使用泛型的方式的话我们不能指定指定它的下限,例如下面两种写法都是__不能通过编译__的:\n\n```\n//错误.不能直接指定泛型的下限\npublic <T super Number> void printList(List<T> list) {\n    ...\n}\n\n//错误.不能直接指定泛型的下限\npublic <T super Number> void foo(T arg){\n    ...\n}\n```\n\n# 类型擦除\n\n可能很多同学都会听说过泛型类型擦除的概念,这个类型擦除具体指的是怎样一回事？\n\n可以看看下面的foo方法,它本来想实现的功能是:如果传入的参数非空,就将它返回。否则,就创建一个同类型的实例返回。但是这段代码是不能通过编译的:\n\n```\n//错误,泛型的类型被擦除了,不能直接new出来\npublic <T> void foo(T arg) {\n    return arg != null ? arg : new T();\n}\n```\n\n原因在于java的泛型实现中有个叫做类型擦除的机制。简单来讲就是运行的时候是无法获取到泛型使用的实际类型的。\n\n例如上面的T类型,因为我们在运行时不能知道它到底是什么类型,所以也就无法将它new出来。\n\njava代码生成的Java字节代码中是不包含泛型中的类型信息的,所有泛型类的类型参数在编译时都会被擦除。虚拟机中没有泛型,只有普通类和普通方法。因此泛型的类型安全是在编译的时候去检测的。\n\n所以我们创建泛型对象时需要指明类型，让编译器尽早的做参数检查。\n\n像下面的代码可以顺利通过,甚至可以正常运行,直到将获取到的数值类型的数据强转成字符串的时候才报ClassCastException异常:\n\n```\nList list = new ArrayList<String>();\nlist.add(\"abc\");\nlist.add(123);\nString elemt1 = (String) list.get(0);\nString elemt2 = (String) list.get(1); // java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String\n```\n\n我们可以用反射的方法的验证一下类型擦除:\n\n```\nList<Integer> list = new ArrayList<Integer>();\nSystem.out.println(\"type : \" + Arrays.toString(list.getClass().getTypeParameters()));\n```\n\n它得到的类型仅仅是一个占位符而已:\n\n> type : [E]\n\n# 类型擦除机制的历史原因\n\n有人会问,为什么java会在编译的时候将类型擦除,而不像ｃ++一样通过在编译的时候将泛型类实例化为多个具体的类去实现泛型呢？\n\n其实“实例化为多个具体的类”这样的实现方式也是比较容易实现的,但是为了保持兼容性,所以java在泛型的实现上选取类型擦除的方式。实际上是做了一定的取舍的。\n\n为什么说选用类型擦除是为了保持兼容性呢?因为泛型并不是java与生俱来的。实际上到了java５的时候才引入了泛型。\n\n要让以前编译的程序在新版本的JRE还能正常运行，就意味着以前没有的限制不能突然冒出来。\n\n例如在泛型出来之前java就已经有了容器的存在,而且它具有可以存储不同类型的的特性:\n\n```\nArrayList things = new ArrayList();\nthings.add(Integer.valueOf(123));\nthings.add(\"abc\");\n```\n\n那么这段代码在Java 5引入泛型之后还必须要继续可以运行。\n\n这里有两种设计思路：\n\n1. 需要泛型化的类型（主要是容器（Collections）类型），以前有的就保持不变，然后平行地加一套泛型化版本的新类型；\n\n2. 直接把已有的类型泛型化，让所有需要泛型化的已有类型都原地泛型化，不添加任何平行于已有类型的泛型版。\n\n.NET在1.1 -> 2.0的时候选择了上面选项的1，而Java则选择了2。\n\n从Java设计者的角度看，这个取舍很明白：.NET在1.1 -> 2.0的时候，实际的应用代码量还很少（相对Java来说），而且整个体系都在微软的控制下，要做变更比较容易；\n\n而在Java 1.4.2 -> 5.0的时候，Java已经有大量程序部署在生产环境中，已经有很多应用和库程序的代码。如果这些代码在新版本的Java中，为了使用Java的新功能（例如泛型）而必须做大量源码层修改，那么新功能的普及速度就会大受影响，而且新功能会被吐槽。\n\n在原地泛型化后，java.util.ArrayList这个类型变成了java.util.ArrayList&lt;E&gt;。但是以前的代码直接用ArrayList，在新版本里必须还能继续用，所以就引出了“raw type”的概念——一个类型虽然被泛型化了，但还可以把它当作非泛型化的类型用。\n\n```\nArrayList         - raw type\nArrayList<E>      - open generic type (assuming E is type variable)\nArrayList<String> - closed generic type\nArrayList<?>      - unbounded wildcard type\n```\n\n下面这样的代码必须可以编译运行：\n\n```\nArrayList<Integer> ilist = new ArrayList<Integer>();\nArrayList<String> slist = new ArrayList<String>();\nArrayList list; // raw type\nlist = ilist;   // assigning closed generic type to raw type\nlist = slist;   // ditto\n```\n\n所以java的设计者在考虑了这一点之后选用类型擦除也就显而易见了。类型擦除实际上是将泛型类型转换了Obejct。由于所有的java类都是Object的子类,所以实现起来就很简单了。只需要在编译的时候将所有的泛型占位符都换成Object就可以了:\n\n```\n//源码的泛型代码\npublic <T> void foo(T arg){\n    ...\n}\n\n//编译时转换成的代码\npublic void foo(Object arg){\n    ...\n}\n```\n\n而在擦除类型的同时,java编译器会对该方法的调用进行类型检查,防止非法类型的调用。\n\n但如果在编写代码的时候就已经用raw type的话,编译器就不会做类型的安全性检查了。\n\n这样的实现导致了一个问题,List<E>泛型参数E被擦除后就变成了Object,那么就不能在泛型中使用int、long等原生数据类型了,因为它们并不是Object的子类。\n\n据说当时设计java语言的程序员和产品经理打了一架,并且在打赢之后成功劝服产品经理在提出兼容性这样奇葩的需求之后做出一点小小的让步。（虽然只是我胡说八道的脑补,但谁知道当时的实际情形是不是这样的呢?）\n\n于是乎我们现在在泛型中只能使用Integer、Long等封箱类型而不能用int、long等原生类型了。\n\n\nps: 上面这段类型擦除机制的历史原因参考了RednaxelaFX大神知乎上的一个回答,有兴趣的同学可以去知乎看看原来的[完整回答](https://www.zhihu.com/question/28665443/answer/118148143)\n","tags":["技术相关","java"]},{"title":"OkHttp源码解析","url":"/2017/12/30/OkHttp源码解析/","content":"\n# 应用拦截器和网络拦截器\n\n以前其实就有一直在使用okhttp,也有听说过拦截器这东西,但是一直没有去深入了解。最近看《安卓进阶之光》刚好看到okhttp拦截器的内容,然后自己也去挖了下源码,才发现其巧妙之处。\n\n拦截器有两种,应用拦截器和网络拦截器。用法可以看下面的代码:\n\n```\nclass LogInterceptor implements Interceptor {\n    private String mName;\n\n    LogInterceptor(String name) {\n        mName = name;\n    }\n\n    @Override\n    public Response intercept(Chain chain) throws IOException {\n        Response response = chain.proceed(chain.request());\n        Log.d(\"LogInterceptor\", \"[\" + mName + \"] : request url = \" + response.request().url() + \", \" + response.headers().toString());\n        return response;\n    }\n}\n\nOkHttpClient client = new OkHttpClient.Builder()\n        .addInterceptor(new LogInterceptor(\"ApplicationInterceptor\"))\n        .addNetworkInterceptor(new LogInterceptor(\"NetworkInterceptor\"))\n        .build();\n\nRequest request = new Request.Builder()\n        .url(\"http://www.github.com\")\n        .build();\n\nclient.newCall(request).enqueue(null);\n```\n\n运行之后的打印如下:\n\n```\n12-29 00:07:02.378 12641-12859/com.example.okhttp D/LogInterceptor: [NetworkInterceptor] : request url = http://www.github.com/, Content-length: 0\n    Location: https://www.github.com/\n12-29 00:07:03.653 12641-12859/com.example.okhttp D/LogInterceptor: [NetworkInterceptor] : request url = https://www.github.com/, Content-length: 0\n    Location: https://github.com/\n12-29 00:07:04.889 12641-12859/com.example.okhttp D/LogInterceptor: [NetworkInterceptor] : request url = https://github.com/, Date: Thu, 28 Dec 2017 16:07:05 GMT\n    Content-Type: text/html; charset=utf-8\n    Transfer-Encoding: chunked\n    Server: GitHub.com\n    Status: 200 OK\n    ...(省略部分打印)\n12-29 00:07:04.896 12641-12859/com.example.okhttp D/LogInterceptor: [ApplicationInterceptor] : request url = https://github.com/, Date: Thu, 28 Dec 2017 16:07:05 GMT\n    Content-Type: text/html; charset=utf-8\n    Transfer-Encoding: chunked\n    Server: GitHub.com\n    Status: 200 OK\n    ...(省略部分打印)\n```\n\n拦截器是一种强大的机制,可以在拦截器中进行监视、重写和重试调用。像我们上面的代码就对请求进行了监视。\n\n从打印可以看到,网络拦截器拦截到了三个请求,同时拦截到了重定向的访问。而应用拦截器只拦截到了一个请求,同时我们可以看到它拦截到的请求的url是 __https://github.com/__ 和我们在代码中的请求 __http://www.github.com__ 并不一致。\n\n简单来讲,网络拦截器在每一次网络访问的时候都会拦截到请求,而应用拦截器只会在OkHttpClient.newCall返回的Call执行的时候被调用一次。\n\n# okhttp的运行流程\n\n在讲拦截器的实现之前我们先来简单介绍一下okhttp的运行流程。\n\n首先通过OkHttpClient.newCall我们可以获得一个RealCall:\n\n```\npublic class OkHttpClient implements Cloneable, Call.Factory {\n  ...\n  public Call newCall(Request request) {\n    return new RealCall(this, request);\n  }\n  ...\n}\n```\n\n## 异步访问\n\nRealCall实现了Call。接口,我们通过调用enqueue方法可以实现异步网络访问。让我们直接看看RealCall.enqueue吧:\n\n```\nfinal class RealCall implements Call {\n  ...\n  public void enqueue(Callback responseCallback) {\n    enqueue(responseCallback, false);\n  }\n\n  void enqueue(Callback responseCallback, boolean forWebSocket) {\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already Executed\");\n      executed = true;\n    }\n    client.dispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));\n  }\n  ...\n}\n```\n\nclient.dispatcher()可以获得一个Dispatcher,它用于网络访问任务的调度,我们的异步并发网络访问就是通过Dispatcher实现的。这里创建了一个AsyncCall,然后将它传入Dispatcher.enqueue。AsyncCall是RealCall的内部类,而且它实际上是一个Runnable：\n\n```\nfinal class RealCall implements Call {\n  ...\n  final class AsyncCall extends NamedRunnable {\n    ...\n  }\n  ...\n}\n```\n\n```\npublic abstract class NamedRunnable implements Runnable {\n  ...\n  @Override public final void run() {\n    String oldName = Thread.currentThread().getName();\n    Thread.currentThread().setName(name);\n    try {\n      execute();\n    } finally {\n      Thread.currentThread().setName(oldName);\n    }\n  }\n\n  protected abstract void execute();\n}\n```\n\nNamedRunnable在run方法里面会调用抽象的execute方法,在这个方法内部就会进行实际的网络访问。那Dispatcher.enqueue又做了写什么呢？其实Dispatcher.enqueue实际上将AsyncCall这个Runnable放到了一个线程池中：\n\n```\npublic final class Dispatcher {\n  ...\n  synchronized void enqueue(AsyncCall call) {\n    if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {\n      runningAsyncCalls.add(call);\n      executorService().execute(call);\n    } else {\n      readyAsyncCalls.add(call);\n    }\n  }\n  ...\n  public synchronized ExecutorService executorService() {\n    if (executorService == null) {\n      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,\n          new SynchronousQueue<Runnable>(), Util.threadFactory(\"OkHttp Dispatcher\", false));\n    }\n    return executorService;\n  }\n  ...\n}\n```\n\n一切明了,Call.enqueue实际上是将AsyncCall这个Runnable放到了线程池中执行去访问网络,而AsyncCall是RealCall的一个内部类,它持有RealCall的引用,所以在被线程池调用的时候可以获得Request的信息。\n\n所以将okhttp的异步流程简化之后实际上就是Dispatcher中的线程池对Runnable的执行:\n\n{% img /OkHttp源码解析/1.png %}\n\n然后我们看看AsyncCall.execute的具体实现:\n\n```\nfinal class AsyncCall extends NamedRunnable {\n  ...\n  @Override protected void execute() {\n   boolean signalledCallback = false;\n   try {\n     Response response = getResponseWithInterceptorChain(forWebSocket);\n     if (canceled) {\n       signalledCallback = true;\n       responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n     } else {\n       signalledCallback = true;\n       responseCallback.onResponse(RealCall.this, response);\n     }\n   } catch (IOException e) {\n     if (signalledCallback) {\n       // Do not signal the callback twice!\n       Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n     } else {\n       responseCallback.onFailure(RealCall.this, e);\n     }\n   } finally {\n     client.dispatcher().finished(this);\n   }\n  }\n  ...\n}\n```\n\n可以看到它是通过getResponseWithInterceptorChain来访问网络获取Response的。\n\n# 同步访问\n\n如果想用OkHttp去阻塞是的访问网络我们可以这样调用:\n\n```\nResponse response = client.newCall(request).execute();\n```\n\n这个execute是不是有点眼熟,但它是Call的一个方法,并不是我们上面异步访问中提到的NamedRunnable.execute:\n\n```\npublic interface Call {\n  ...\n  Response execute() throws IOException;\n  ..\n}\n```\n\n现在我们来看看具体实现:\n\n```\nfinal class RealCall implements Call {\n  ...\n  @Override public Response execute() throws IOException {\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already Executed\");\n      executed = true;\n    }\n    try {\n      client.dispatcher().executed(this);\n      Response result = getResponseWithInterceptorChain(false);\n      if (result == null) throw new IOException(\"Canceled\");\n      return result;\n    } finally {\n      client.dispatcher().finished(this);\n    }\n  }\n  ...\n}\n```\n\n它也是通过getResponseWithInterceptorChain来访问网络获取Response的。\n\n\n# 拦截器的实现\n\n我们在前面的小节中已经知道了,无论是同步还是异步,最终都是通过RealCall.getResponseWithInterceptorChain方法去访问网络的。但是在查看具体源代码的时候发现在okhttp3.4.0-RC1开始其具体的实现细节有了一些不一样的地方。所以我这边分开两部分来讲一讲okhttp3.4.0-RC1之前和之后拦截器的具体实现细节。\n\n## okhttp3.4.0-RC1之前的实现\n\nokhttp3.4.0-RC1之前的RealCall.getResponseWithInterceptorChain 中实际上是调用了ApplicationInterceptorChain.proceed方法去访问网络获取Response:\n\n```\nprivate Response getResponseWithInterceptorChain(boolean forWebSocket) throws IOException {\n  Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket);\n  return chain.proceed(originalRequest);\n}\n```\n\n然后继续看源码,可以发现proceed内部会从OkHttpClient获取序号为index的拦截器,并且创建新的序号加一的ApplicationInterceptorChain传递给拦截器去执行。于是有多少个拦截器就创建了多少个ApplicationInterceptorChain,他们会按照自己的序号调用对应的拦截器。这其实就是一种责任链模式的实现方式:\n\n```\n@Override public Response proceed(Request request) throws IOException {\n  // If there's another interceptor in the chain, call that.\n  if (index < client.interceptors().size()) {\n    Interceptor.Chain chain = new ApplicationInterceptorChain(index + 1, request, forWebSocket);\n    Interceptor interceptor = client.interceptors().get(index);\n    Response interceptedResponse = interceptor.intercept(chain);\n\n    if (interceptedResponse == null) {\n      throw new NullPointerException(\"application interceptor \" + interceptor\n          + \" returned null\");\n    }\n\n    return interceptedResponse;\n  }\n\n  // No more interceptors. Do HTTP.\n  return getResponse(request, forWebSocket);\n}\n```\n\n如果ApplicationInterceptorChain的序号大于OkHttpClient中注册的拦截器的数量,则调用getResponse方法。这里ApplicationInterceptorChain是RealCall的内部类,getResponse调用的是RealCall.getResponse方法。\n\n再看RealCall.getResponse方法,它内部有个while true的死循环,调用HttpEngine.sendRequest和HttpEngine.readResponse去发送请求和接收响应,如果出现了RouteException异常或者IOException异常则重新尝试访问:\n\n```\nResponse getResponse(Request request, boolean forWebSocket) throws IOException {\n    ...\n    while (true) {\n    ...\n    try {\n        engine.sendRequest();\n        engine.readResponse();\n        releaseConnection = false;\n    } catch (RouteException e) {\n        HttpEngine retryEngine = engine.recover(e.getLastConnectException(), true, null);\n        if (retryEngine != null) {\n            releaseConnection = false;\n            engine = retryEngine;\n            continue;\n        }\n        throw e.getLastConnectException();\n    }catch (IOException e) {\n        HttpEngine retryEngine = engine.recover(e, false, null);\n        if (retryEngine != null) {\n            releaseConnection = false;\n            engine = retryEngine;\n            continue;\n        }\n        throw e;\n    }\n    ...\n}\n```\n\n我们继续看engine.readResponse的实现,可以看到它调用了NetworkInterceptorChain.proceed方法去获取响应:\n\n```\npublic void readResponse() throws IOException {\n...\nResponse networkResponse;\n...\nnetworkResponse = new NetworkInterceptorChain(0, networkRequest,\n    \t\t\tstreamAllocation.connection()).proceed(networkRequest);\n...\n}\n```\n\nNetworkInterceptorChain.proceed和ApplicationInterceptorChain.proceed类似,也会不断的创建新的NetworkInterceptorChain并且调用网络拦截器,如果没有网络拦截器可以调用了,则会调用readNetworkResponse方法读取响应:\n\n```\n@Override public Response proceed(Request request) throws IOException {\n...\nif (index < client.networkInterceptors().size()) {\n    NetworkInterceptorChain chain = new NetworkInterceptorChain(index + 1, request, connection);\n    Interceptor interceptor = client.networkInterceptors().get(index);\n    Response interceptedResponse = interceptor.intercept(chain);\n    ...\n    return interceptedResponse;\n}\nResponse response = readNetworkResponse();\n...\nreturn response;\n}\n```\n\n这里还有一点需要说明的是NetworkInterceptorChain是HttpEngine的内部类,它调用的readNetworkResponse方法实际上是HttpEngine.readNetworkResponse。现在我们就对OkHttp拦截器的请求流程和拦截器的实现原理有了比较全面的了解,下面这张图对整个流程做一个总结:\n\n{% img /OkHttp源码解析/2.png %}\n\n\n## okhttp3.4.0-RC1之后的实现\n\n然后让我们再来看一下3.4.0-RC1之后的实现:\n\n```\nResponse getResponseWithInterceptorChain() throws IOException {\n  // Build a full stack of interceptors.\n  List<Interceptor> interceptors = new ArrayList<>();\n  interceptors.addAll(client.interceptors());\n  interceptors.add(retryAndFollowUpInterceptor);\n  interceptors.add(new BridgeInterceptor(client.cookieJar()));\n  interceptors.add(new CacheInterceptor(client.internalCache()));\n  interceptors.add(new ConnectInterceptor(client));\n  if (!forWebSocket) {\n    interceptors.addAll(client.networkInterceptors());\n  }\n  interceptors.add(new CallServerInterceptor(forWebSocket));\n\n  Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,\n      originalRequest, this, eventListener, client.connectTimeoutMillis(),\n      client.readTimeoutMillis(), client.writeTimeoutMillis());\n\n  return chain.proceed(originalRequest);\n}\n```\n\n这里已经不再区分ApplicationInterceptorChain和NetworkInterceptorChain了，统一用RealInterceptorChain去处理:\n\n```\npublic Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,\n    RealConnection connection) throws IOException {\n  ...\n\n  // Call the next interceptor in the chain.\n  RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,\n      connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,\n      writeTimeout);\n  Interceptor interceptor = interceptors.get(index);\n  Response response = interceptor.intercept(next);\n\n  ...\n\n  return response;\n}\n```\n\n这里将cookie处理、缓存处理、网络连接都作为责任链的一部分，比起3.4.0.RC-1之前更加完全的实现了责任链模式。这里有必要讲一下的就是retryAndFollowUpInterceptor, 它是一个RetryAndFollowUpInterceptor实例，它负责重连和重定向我们之前在3.4.0.RC-1之前看到的getResponse的while true就放到了这里来实现。\n\n让我们看看它的整个流程:\n\n\n{% img /OkHttp源码解析/3.png %}\n\n\n这样的实现是不是以前要清晰很多？所有的步骤一目了然，看过原来的版本再看看3.4.0.RC-1重构后的版本，的确有一种眼前一亮的惊艳之感。果然好代码都是需要一点点优化出来的。\n","tags":["技术相关","Android"]},{"title":"如何实现安卓消息推送","url":"/2017/12/14/如何实现安卓消息推送/","content":"\n最近突然对安卓消息推送的原理感兴趣,找了不少资料,实现了一个包括服务端和客户端的简单Demo。\n\n在具体实现的时候踩了不少坑,这里做一下笔记,防止以后忘记。\n\n安卓消息推送的实现方案有下面几种:\n\n- MQTT协议实现\n- XMPP协议实现\n- C2DM云端推送功能(google官方提供,系统内置,但是国内用不了......)\n- [中国统一推送](http://www.chinaupa.com/)(工信部牵头成立,但是目前只是开了几次会议,并没有什么实际的接口出来,不过以后应该会是中国境内的首选方案)\n\n我这里选择了MQTT协议去实现。\n\n# MQTT协议\n\nMQTT是一个客户端服务端架构的发布/订阅模式的消息传输协议。它的设计思想是轻巧、开放、简单、规范，因此易于实现。这些特点使得它对很多场景来说都是很好的选择，包括受限的环境如机器与机器的通信（M2M）以及物联网环境（IoT），这些场景要求很小的代码封装或者网络带宽非常昂贵。\n\n本协议运行在TCP/IP，或其它提供了有序、可靠、双向连接的网络连接上。它有以下特点：\n\n使用发布/订阅消息模式，提供了一对多的消息分发和应用之间的解耦。\n\n消息传输不需要知道负载内容。\n\n提供三种等级的服务质量：.\n\n“最多一次”，尽操作环境所能提供的最大努力分发消息。消息可能会丢失。例如，这个等级可用于环境传感器数据，单次的数据丢失没关系，因为不久之后会再次发送。\n“至少一次”，保证消息可以到达，但是可能会重复。\n“仅一次”，保证消息只到达一次。例如，这个等级可用在一个计费系统中，这里如果消息重复或丢失会导致不正确的收费。\n很小的传输消耗和协议数据交换，最大限度减少网络流量\n\n异常连接断开发生时，能通知到相关各方。\n\n上面这一段话是从网友翻译的MQTT中文文档直接复制的。有兴趣的同学可以直接访问[MQTT协议中文版](https://github.com/mcxiaoke/mqtt)查看具体的协议细节。\n\n## MQTT原理\n\nMQTT协议原理的原理简单说来就是客户端与服务端通过心跳包来保持连接。客户接收端向服务端订阅消息,客户发布端向服务端发布消息。服务端再将消息分发给订阅了该消息的客户接收端。\n\n原理图如下:\n\n{% img /如何实现安卓消息推送/1.png %}\n\n# 实现库的选择\n\n因为[MQTT协议中文版](https://github.com/mcxiaoke/mqtt)上面已经有了整个QMTT的协议细节,所以理论上如果你够厉害的话,完全可以自己从零开始实现服务端和客户端。\n\n但是从实际项目中,我还是倾向选择官方提供或者第三方开源的项目直接使用。\n\n其实官方已经给我们提供了一些推荐实现:\n\n[https://github.com/mqtt/mqtt.github.io/wiki/software?id=software](https://github.com/mqtt/mqtt.github.io/wiki/software?id=software)\n\n# MQTT 服务器搭建\n\n我这边选择使用[apache-apollo](http://activemq.apache.org/apollo/)这个开源的MQTT服务器。\n\n网上有不少的博客都有讲它的配置方法的,但是我按着做之后都出现了一些问题。\n\n## 1、安装jdk\n\n首先需要去安装jdk:\n\n```\nsudo apt-get install default-jdk\n```\n\n## 2、下载apache-apollo\n\n然后到[官网](http://www.apache.org/dyn/closer.cgi?path=activemq/activemq-apollo/1.7.1/apache-apollo-1.7.1-windows-distro.zip)下载最新的软件。我这边使用的是腾讯云的ubuntu服务器,所以就下载了linux的版本。\n\n下载完之后解压到/opt目录下(其实任意目录均可,只不过我用linux习惯放这里):\n\n> /opt/apache-apollo-1.7.1\n\n\n## 3、创建项目\n\n然后进入任意目录使用下面命令创建一个项目(官方管它叫broker):\n\n```\n/opt/apache-apollo-1.7.1/bin/apollo create mybroker\n```\n\n它会在当前目录创建一个mybroker目录,里面就是你的项目。\n\n## 4、编辑admin ip配置\n\n可以编辑mybroker/etc/apollo.xml进行一些配置。\n\nadmin后台会默认被绑定到127.0.0.1,这样你是不能通过你电脑的浏览器去访问服务器的admin后台的:\n\n```\n<web_admin bind=\"http://127.0.0.1:61680\"/>\n<web_admin bind=\"https://127.0.0.1:61681\"/>\n```\n\n我们将它改成0.0.0.0:\n\n```\n<web_admin bind=\"http://0.0.0.0:61680\"/>\n<web_admin bind=\"https://0.0.0.0:61681\"/>\n```\n注意这里的61680和61681端口,之后需要访问该端口去登陆admin后台\n\n## 5、启动MQTT服务\n\n你可以进到mybroker/bin/目录中使用下面两种方式中的一种去启动服务:\n\n- 当前进程阻塞启动:\n\n```\n./apollo-broker run\n```\n\n- 启动后台服务:\n\n```\n./apollo-broker-service start\n```\n\n然后你就可以在你的电脑打开浏览器输入网址访问MQTT后台了:\n\n- 如果你的服务是跑在阿里云、腾讯云这样的服务器上:\n\n```\nhttp://服务器ip:61680\n```\n\n- 如果你的服务就是跑在你自己的电脑上:\n\n```\nhttp://0.0.0.0:61680\n```\n\n它的需要输入账号密码才能登陆。默认账号是admin、密码是password\n\n\n{% img /如何实现安卓消息推送/2.png %}\n\n\n{% img /如何实现安卓消息推送/3.png %}\n\n# Python paho-mqtt\n\n我们可以用python写一个客户端去验证搭建的mqtt服务器是否可用。\n\n首先需要下载paho-mqtt:\n\n```\npip install paho-mqtt\n```\n\n## Python paho-mqtt 简单收发端Demo\n\n接收端代码:\n\n```\nimport paho.mqtt.client as mqtt                                                  \n\ndef on_connect(client, userdata, flags, rc):                                     \n    print(\"Connected with result code \"+str(rc))                                 \n    client.subscribe(\"topic/test\")                                               \n\ndef on_message(client, userdata, msg):                                           \n    print(\"on_message \"+msg.topic+\" \"+str(msg.payload))                          \n\nclient = mqtt.Client(client_id=\"\", clean_session=True, userdata=None, protocol=mqtt.MQTTv31, transport=\"tcp\")\nclient.username_pw_set(\"admin\", \"password\")                                      \nclient.on_connect = on_connect                                                   \nclient.on_message = on_message                                                   \n\nclient.connect(\"www.islinjw.cn\", 61613, 60)                                      \nclient.loop_forever()\n```\n\n发送端代码:\n\n```\nimport paho.mqtt.client as mqtt                                                  \n\ndef on_connect(client, userdata, flags, rc):                                     \n    print(\"Connected with result code \"+str(rc))                                 \n\nclient = mqtt.Client(client_id=\"\", clean_session=True, userdata=None, protocol=mqtt.MQTTv31, transport=\"tcp\")\nclient.username_pw_set(\"admin\", \"password\")                                      \nclient.on_connect = on_connect                                                         \n\nclient.connect(\"www.islinjw.cn\", 61613, 60)                                                                     \nclient.publish(\"topic/test\", \"hello world\")\n```\n\n我们先运行接收端,再运行发送端,就可以在接收端看到\"hello world\"的打印\n\n## 常见错误\n\n这里需要注意的是一定要配置协议版本为MQTTv31,网上的demo代码都没有配置,没有的话python这就会报错:\n\n> [Errno 104] Connection reset by peer\n\n服务器则会报空指针,我们可以在mybroker/log/stacktrace.log中看到:\n\n```\njava.lang.NullPointerException\n        at org.apache.activemq.apollo.mqtt.MqttProtocolHandler.on_mqtt_connect(MqttProtocolHandler.java:443)\n        at org.apache.activemq.apollo.mqtt.MqttProtocolHandler$9.call(MqttProtocolHandler.java:410)\n        at org.apache.activemq.apollo.util.UnitFn1.apply(Scala2JavaHelper.scala:41)\n        at org.apache.activemq.apollo.mqtt.MqttProtocolHandler.on_transport_command(MqttProtocolHandler.java:377)\n        at org.apache.activemq.apollo.broker.BrokerConnection.on_transport_command(Connection.scala:144)\n        at org.apache.activemq.apollo.broker.Connection$$anon$1.onTransportCommand(Connection.scala:71)\n        at org.fusesource.hawtdispatch.transport.TcpTransport.drainInbound(TcpTransport.java:709)\n        at org.fusesource.hawtdispatch.transport.TcpTransport$9.run(TcpTransport.java:770)\n        at org.fusesource.hawtdispatch.internal.SerialDispatchQueue.run(SerialDispatchQueue.java:100)\n        at org.fusesource.hawtdispatch.internal.pool.SimpleThread.run(SimpleThread.java:77)\n```\n\n而如果没有设置账号密码的话就收到result code 4:\n\n> Connected with result code 4\n\n我们可以从[官方文档](https://pypi.python.org/pypi/paho-mqtt/#single)看到result code 4代表用户名或者密码错误:\n\n> 0: Connection successful  \n> 1: Connection refused - incorrect protocol version  \n> 2: Connection refused - invalid client identifier  \n> 3: Connection refused - server unavailable  \n> 4: Connection refused - bad username or password  \n> 5: Connection refused - not authorised 6-255: Currently unused.\n\n# 权限配置\n\n我们设想一下,如果没有账户系统,那么只要知道服务器的ip和端口,就能随便发送消息了,这样谁都能给你的应用推送消息,十分危险。\n\n所以mqtt是需要用账户密码去建权的,有些账户只能发送,有些账户只能接收,而有些账户全部都能做。\n\n## 创建用户\n\n我们可以编辑mybroker/etc/users.properties添加user1和user2:\n\n```\nadmin=password\nuser1=123456\nuser2=654321\n```\n\n等号的左边是账户,右边是密码。所以我们也能在这里改admin的密码\n\n## 创建用户组\n\n创建完用用户,我们还需要编辑mybroker/etc/groups.properties给用户指定用户组:\n\n```\nadmins=admin\ngroupsend=user1\ngrouprecv=user2\n\n# 还可以用下面的方式将多个用户指定到一个用户组\n# groupdemo = user1|user2\n```\n\n## 设置用户组权限\n\n最后我们就能在mybroker/etc/apollo.xml设置用户组权限了:\n\n```\n<access_rule allow=\"admins\" action=\"*\"/>\n<access_rule allow=\"*\" action=\"connect\" kind=\"connector\"/>\n<access_rule allow=\"groupsend\" action=\"connect create send\"/>\n<access_rule allow=\"grouprecv\" action=\"connect receive\"/>\n```\n\n可以给一个用户组设置多个权限,多个权限之间用空格分割。从[官方文档](http://activemq.apache.org/apollo/versions/1.7.1/website/documentation/user-manual.html#Resource_Actions)可以看到权限有下面的类别:\n\n- admin : use of the administrative web interface\n- monitor : read only use of the administrative web interface\n- config : use of the administrative web interface to  access and change the broker configuration.\n- connect : allows connections to the connector or virtual host\n- create : allows creation\n- destroy : allows destruction\n- send : allows the user to send to the destination\n- receive : allows the user to send to do non-destructive reads from the destination\n- consume : allows the user to do destructive reads against a destination\n-  \\* : All actions\n\n配置好之后我们的user1就只能发送消息,user2就只能接收消息了。\n\n# 安卓端实现\n\n官方推荐的qatja-android我看了一下，它的实现太挫了,所以在github上搜索了下,发现了个不错的库[mqtt-client](https://github.com/fusesource/mqtt-client)。\n\n添加依赖：\n\n> compile 'org.fusesource.mqtt-client:mqtt-client:1.14'\n\n因为代码比较简单,所以我就直接贴上来了:\n\n```\npublic class MainActivity extends AppCompatActivity {\n    public static final String TAG = \"MainActivity\";\n    public static final String TOPIC = \"topic/test\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        try {\n            testMqtt();\n        } catch (URISyntaxException e) {\n            Log.e(TAG, \"testMqtt failed\", e);\n        }\n    }\n\n    private void testMqtt() throws URISyntaxException {\n        MQTT mqtt = new MQTT();\n        mqtt.setHost(\"www.islinjw.cn\", 61613);\n        mqtt.setVersion(\"3.1\");\n        mqtt.setUserName(\"admin\");\n        mqtt.setPassword(\"password\");\n\n        final CallbackConnection connection = mqtt.callbackConnection();\n\n        //设置监听\n        connection.listener(new ExtendedListener() {\n            @Override\n            public void onPublish(UTF8Buffer topic, Buffer body, Callback<Callback<Void>> ack) {\n                Log.d(TAG, \"onPublish \" + topic.toString() + \" \" + body.toString());\n\n                NotificationManager notifyManager\n                        = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n                NotificationCompat.Builder builder = new NotificationCompat\n                        .Builder(MainActivity.this)\n                        .setSmallIcon(R.mipmap.ic_launcher)\n                        .setContentTitle(topic.toString())\n                        .setContentText(body.ascii().toString());\n                notifyManager.notify(1, builder.build());\n            }\n\n            @Override\n            public void onConnected() {\n                Log.d(TAG, \"onConnected\");\n            }\n\n            @Override\n            public void onDisconnected() {\n                Log.d(TAG, \"onDisconnected\");\n            }\n\n            @Override\n            public void onPublish(UTF8Buffer topic, Buffer body, Runnable ack) {\n                Log.d(TAG, \"onPublish \" + topic.toString() + \" \" + body);\n                ack.run();\n            }\n\n            @Override\n            public void onFailure(Throwable value) {\n                Log.d(TAG, \"onFailure\");\n            }\n        });\n\n        //连接服务器\n        connection.connect(new Callback<Void>() {\n            public void onFailure(Throwable value) {\n                Log.d(TAG, \"connect failure\");\n            }\n\n            public void onSuccess(Void v) {\n                //订阅消息\n                Topic[] topics = {new Topic(TOPIC, QoS.AT_LEAST_ONCE)};\n                connection.subscribe(topics, new Callback<byte[]>() {\n                    public void onSuccess(byte[] qoses) {\n                        Log.d(TAG, \"subscribe success\");\n                    }\n\n                    public void onFailure(Throwable value) {\n                        Log.e(TAG, \"subscribe failure\", value);\n                        connection.disconnect(null); //断开连接\n                    }\n                });\n\n                //发布一个消息\n                byte[] payload = \"hello world\".getBytes();\n                connection.publish(TOPIC, payload, QoS.AT_LEAST_ONCE, false, new Callback<Void>() {\n                    public void onSuccess(Void v) {\n                        Log.d(TAG, \"publish success\");\n                    }\n\n                    public void onFailure(Throwable value) {\n                        Log.e(TAG, \"publish failure\", value);\n                        connection.disconnect(null); //断开连接\n                    }\n                });\n\n//                //断开连接\n//                connection.disconnect(new Callback<Void>() {\n//                    public void onSuccess(Void v) {\n//                        Log.d(TAG, \"disconnect success\");\n//                    }\n//\n//                    public void onFailure(Throwable value) {\n//                        Log.d(TAG, \"disconnect failure\");\n//                        // disconnects是不会失败的,也就是这里永远不会被调到\n//                    }\n//                });\n            }\n        });\n    }\n}\n```\n\n然后我们就可以用发送端的py脚本将消息推送给安卓客户端了。\n\n{% img /如何实现安卓消息推送/4.png %}\n\n# 主题名和主题通配符\n\n发布的消息都有一个主题名,例如我们之前作为例子的\"topic/test\"。客户端向服务端订阅感兴趣的主题。当有某主题的消息被发布的时候,服务端就会将消息分发给订阅了该主题的客户端。\n\n主题名可以用分割符\"/\"如果存在的话就会将主题分割为多个主题层级。\n\n有了主题层级的概念之后我们就可以用主题通配符去过滤不同的主题。\n\n我这里只做简单介绍,详细的信息可以参考[文档](https://github.com/mcxiaoke/mqtt/blob/master/mqtt/04-OperationalBehavior.md)\n\n\n## 多层通配符\n\n数字标志（\"#\"）是用于匹配主题中任意层级的通配符。多层通配符表示它的父级和任意数量的子层级。多层通配符必须位于它自己的层级或者跟在主题层级分隔符后面。不管哪种情况，它都必须是主题过滤器的最后一个字符。\n\n例如，如果客户端订阅主题 \"sport/tennis/player1/#\"，它会收到使用下列主题名发布的消息：\n\n- \"sport/tennis/player1\"\n- \"sport/tennis/player1/ranking\"\n- \"sport/tennis/player1/score/wimbledon\"\n- \"sport/#\"也匹配单独的 \"sport\" ，因为 # 包括它的父级。\n- \"#\"也是有效的，会收到所有的应用消息。\n\n\n多层通配符用法举例:\n\n- \"sport/tennis/#\"也是有效的。\n- \"sport/tennis#\"是无效的。\n- \"sport/tennis/#/ranking\"是无效的。\n\n## 单层通配符\n\n加号 (\"+\") 是只能用于单个主题层级匹配的通配符。在主题过滤器的任意层级都可以使用单层通配符，包括第一个和最后一个层级。然而它必须占据过滤器的整个层级。可以在主题过滤器中的多个层级中使用它，也可以和多层通配符一起使用。\n\n例如， \"sport/tennis/+\" 匹配 \"sport/tennis/player1\" 和 \"sport/tennis/player2\",但是不匹配 \"sport/tennis/player1/ranking\" 。同时，由于单层通配符只能匹配一个层级， \"sport/+\" 不匹配 \"sport\" 但是却匹配 \"sport/\"。\n\n单层通配符的一些使用情况:\n\n- \"+\" 是有效的。\n- \"+/tennis/#\" 是有效的。\n- \"sport+\" 是无效的。\n- \"sport/+/player1\" 也是有效的。\n- \"/finance\" 匹配 \"+/+\" 和 \"/+\" ，但是不匹配 \"+\"。\n\n## 开始通配符\n\n美元符号(\"$\") 用于匹配起始主题,如\"$SYS/\" 被广泛用作包含服务器特定信息或控制接口的主题的前缀。\n\n开始通配符的一些用法:\n\n- 订阅 \"#\" 的客户端不会收到任何发布到以 \"$\" 开头主题的消息。\n- 订阅 \"+/monitor/Clients\" 的客户端不会收到任何发布到 \"$SYS/monitor/Clients\" 的消息。\n- 订阅 \"$SYS/#\" 的客户端会收到发布到以 “$SYS/” 开头主题的消息。\n- 订阅 \"$SYS/monitor/+\" 的客户端会收到发布到 \"$SYS/monitor/Clients\" 主题的消息。\n- 如果客户端想同时接受以 \"$SYS/\" 开头主题的消息和不以 \"$\" 开头主题的消息，它需要同时订阅 \"#\" 和 \"$SYS/#\"。\n","tags":["技术相关","Android"]},{"title":"我也来谈一谈Java GC","url":"/2017/11/10/我也来谈一谈Java-GC/","content":"\n以前写c/c++的时候虽然也有shared_ptr这样的自动内存管理机制,但是它内部其实是通过引用计数的原理进行内存管理的,容易产生循环应用的问题,也没有什么实际意义上的内存收集器。和java的内存收集机制差别很大,所以一直对java的内存收集机制抱有很强的好奇心。\n\n最近在看《深入理解 Java 虚拟机-Jvm 高级特性与最佳实践》,里面对java垃圾收集讲的挺不错的。然后再将书中没有讲透的知识在网上搜索了下,整理成了这篇博客,哪天一时半会记不起来的时候还能回来瞧一瞧。\n\n# GC Roots\n\n在Java虚拟机中，存在自动内存管理和垃圾回收机制,能自动回收没有用的对象的内存。\n\n那怎么去判定一个对象是否还有用呢？java中是通过可达性分析来判定的。\n\n具体的做法就是从__一系列__被称作\"GC Roots\"的对象作为起始点,从这些对象开始通过引用关系进行搜索。当GC Roots到某个对象没有任何引用链相连,则证明此对象是不可用的,是不需要存活,可以被清理的。\n\n例如下图的object1、object2、object3、object4就是从GC Roots可达的,不能被回收。而object5、object6、object7虽然相互引用,但从GC Roots不可达,证明程序中无法访问到它们,所以它们是无用的,可以被回收。\n\n{% img /我也来谈一谈Java-GC/1.png %}\n\n在Java中,可以作为GC Roots的对象包括下面几种:\n\n- 虚拟机栈(栈帧中的本地变量表)中引用的对象\n- 方法区中类静态属性引用的对象\n- 方法去中常量引用的对象\n- 本地方法栈中JNI引用的对象\n\n# Java 堆中的内存分配与回收\n\n对于大多数应用来说,Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域,在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例,几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是:所有的对象实例以及数组都要在堆上分配。\n\n由于现在收集器基本都是采用的分代收集算法,所以Java堆中还可以细分为新生代和老年代。\n\n## 新生代中的Minor GC\n\n大部分对象被创建时,内存的分配首先发生在年轻代(占用内存比较大的对象如数组,会被直接分配到老年带)。大部分的对象在创建之后很快就不再使用了,因此很快变成不可达的状态,于是被新生代的GC机制清理掉。这个GC机制被称为Minor GC或叫Young GC。\n\n新生代可以分为3个区域:一个Eden区和两个Survivor区。两个Survivor中总有一个是空的,我们叫他Survivor To区,还有一个非空的,我们叫他Survivor From区。Eden区和两个Survivor区的大小为8:1:1。\n\n对象被创建的时候,绝大部分都是被分配在Eden区。Eden区是连续的内存空间，因此在其上分配内存极快。__当Eden区满的时候,就会执行Minor GC__。\n\n### 复制算法\nMinor GC时Eden区和Survivor From区还存活着的对象会一次性被复制到Survivor To区。然后Eden区和Survivor From区的内存会被清空。\n\n之后原来的Survivor From区就空了,而原来的Survivor To区就非空。这个时候它们的角色就调换了,空的叫做Survivor To区,非空的叫做Survivor From区。\n\n这种垃圾收集算法叫做__复制算法__,整个过程如下图所示:\n\n{% img /我也来谈一谈Java-GC/2.png %}\n\n### 为什么需要两个Survivor区\n\n复制算法的优点在于,gc完成之后占用的内存会被整理到一个连续的空间中。而空闲的内存也是连续的区域,不会造成内存碎片。\n\n如果只有一个Eden区和一个Survivor区,在Minor GC的时候,Eden区的存活对象可以被复制到Survivor区,这样Eden区可以被清空出一个完整的空闲内存区域。\n\n而Survivor区存活的对象要怎么办呢:\n\n- 如果直接进入老年代。可能有些对象经过少数的几次GC就能被释放。但在老年代中GC发生的频率比新生代低很多。这样的话就会导致老年代的内存很快被占满。\n\n- 如果不管存活的对象,只是简单的清除不可达的对象。那么Survivor区就会产生内存碎片\n\n- 如果进行压缩整理,与从新生代复制过来的存活对象一起整理到Survivor中某个连续的区域的话,消耗的计算资源会比较高。\n\n所以最简单的做法就是拿多一个Survivor To区出来,Eden区和Survivor From区存活的对象会被连续的复制到Survivor To区的一个连续区域中。然后将Eden区和Survivor From区清空就好。\n\n由于新生代大部分的对象生命周期都很短,所以需要复制的对象的数目也不会很多,所以这是比较高效的做法。\n\n### 对象进入老年代\n\n对象在下面三种情况下,对象进入到老年代:\n\n- 占用内存比较大的对象如数组,在创建的时候不会分配到Eden区,而会被直接分配到老年代\n\n- 当Minor GC时Survivor To区已经放不下还存活的对象的时候,这些对象就会被放到老年代中。\n\n- 每经历一次Minor GC,对象的年龄会大一岁。当对象的年龄到达某一个值,Minor GC的时候就不会去到Survivor To区,而会进入老年代。\n\n## 老年代\n\n在新生代中经历了N次垃圾回收后仍然存活的对象,就会被放到年老代中。因此,可以认为年老代中存放的都是一些生命周期较长的对象。\n\n在新生代中,每次垃圾收集时都发现有大批对象死去,只有少量存活,所以选用复制算法,只需要付出少量对象的复制成本就能完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保,就需要使用\"标记-清理\"或者\"标记-整理\"算法来进行回收。\n\n### 标记-清理算法\n\n标记-清除算法顾名思义,主要就是两个动作,一个是标记,另一个就是清除。首先标记出所有需要回收的对象,在标记完成后统一回收所有被标记的对象。\n\n它的缺点有两个\n\n1. 标记与清除的效率都比较低\n2. 标记清除之后会产生大量不连续的内存碎片\n\n它的执行过程如下图所示:\n\n{% img /我也来谈一谈Java-GC/3.png %}\n\n发生在老年代的GC叫做Major GC,通常当Minor GC晋升到老年代的大小大于老年代的剩余空间时,Major GC就会被触发。\n\n出现了Major GC,通常会伴随着至少一次的Minor GC(不是绝对的,有些收集器有直接进行Major GC的策略)。Major GC的速度一般会比Minor GC慢10倍以上。\n\n\n除了Minor GC和Major GC之外,还有一个Full GC的概念,它们的区别如下:\n\n1. Minor GC : 回收新生代的垃圾\n2. Major GC : 回收老年代的垃圾\n3. Full GC : 回收整个堆的垃圾,包括新生代、老年代、持久代等\n\n### 标记-整理算法\n\n标记过程仍和标记-清理算法一样,但是后续的步骤不是直接对可回收的对象进行清理,而是让所有存活的对象往一端移动,然后再清理掉边界以外的内存。它的过程如下图所示:\n\n{% img /我也来谈一谈Java-GC/4.png %}\n\n# 垃圾搜集器\n\n如果说收集算法是内存回收的方法论,那么垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定,所以不同的厂商、不同版本的虚拟机提供的垃圾收集器都可能有很大差别。\n\n下面这张图列出了JDK1.7 Update 14之后HotSpot虚拟机所包含的垃圾收集器:\n\n{% img /我也来谈一谈Java-GC/5.png %}\n\n每种收集器具体的实现方法这里我就不罗列了,感兴趣的同学可以自行搜索。\n\n# finalize方法\n\n即使在可达性分析中不可达的对象,也并非是\"非死不可\"的。这时它们只是处于\"缓刑\"阶段,要宣布一个对象死亡,至少要经历两次标记过程:\n\n1. 第一次可达性分析之后,不可达的对象会被标记出来放到一个\"即将回收\"的集合中。\n\n2. 被标记的对象会进行一次筛选,__覆盖了finalize方法__并且__finalize方法没有被调用过__的对象会放到一个叫做F-Queue的队列中。虚拟机会创建一个低优先级的Finalizer线程去执行它。如果一个对象想逃脱死亡的命运,只需要在finalize方法中将自己重新连接上引用链就可以了,例如将自己赋给某个类变量或对象的成员变量。\n\n3. 第二次可达性分析会将被重新连接上引用链的对象移出\"即将回收\"的集合。\n\n4. 最后将不可达的对象内存回收\n\n\n这里有两点需要注意的是:\n\n- \"执行\"finalize方法指的是虚拟机会触发这个方法,但不承诺等待它运行结束,这样做的原因是防止某个对象的finalize方法运行缓慢或者发生死循环,导致F-Queue的队列其他对象永久等待甚至导致内存回收系统崩溃。\n\n- finalize只有一次被调用的机会。如果在finalize中将对象重新连接上引用链,只有在对象在第一次即将被回收的时候,finalize方法会被调用。在下一次GC的标记过程中,因为finalize方法已经被调用过了,所以就不会被放到F-Queue的队列中。","tags":["技术相关","java"]},{"title":"Android温故而知新 - ClassLoader","url":"/2017/09/28/Android温故而知新-ClassLoader/","content":"\n安卓插件化越来越流行,其中用到的技术不外乎加载外部的资源和加载外部的代码,关于加载外部资源我之前写过一篇文章[《安卓皮肤包机制的原理》](http://blog.islinjw.cn/2017/08/01/%E5%AE%89%E5%8D%93%E7%9A%AE%E8%82%A4%E5%8C%85%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86/),感兴趣的同学可以去看一下。\n\n加载外部代码的作用在于热更新。程序主体定义接口,具体实现放在外部。只需要替换外部代码,就能修复bug甚至是更新功能。相比传统的ota手段更加省流量,用户体验也更加的好,毕竟有很多的用户是不喜欢更新的。\n\n这篇文章我想复习一下ClassLoader的相关知识,它是加载外部代码的核心原理。\n\n虽然android自己实现了一个特殊的虚拟机,它的类加载机制和普通的java程序有点区别。但是我还是想从普通的java程序讲起,一方面多知道点东西总是好的,另一方面它们的基本原理是一样的,对我们理解安卓的类加载机制也有很大的帮助。\n\n# 普通java程序的类加载机制\n\n我们都知道java代码需要先编译成class文件才能被jvm加载运行。那jvm又是如何加载class文件的呢?\n\n其实class文件是通过ClassLoader加载到jvm的。java自带了三个ClassLoader,分别是:\n\n- BootstrapClassLoader 用于加载核心类库\n- ExtClassLoader 用于加载拓展库\n- AppClassLoader 用于加载当前应用的类\n\n然后需要说明的是java类不是一次性全部加载的,而是只有在用到的时候才会去加载。\n\n因为全部加载的话会加载一些没有用到的类,造成资源的浪费。所以当程序需要用到某个类时,才会通过ClassLoader在系统的特定路径搜索这个类的class文件并将它加载到jvm去执行。\n\nExtClassLoader和AppClassLoader都是URLClassLoader的子类,他们内部保存了URL列表用于指定搜索路径。我们可以通过URLClassLoader.getURLs()方法获取到这个URL列表。\n\nBootstrapClassLoader虽然不是URLClassLoader的子类,但我们也可以从sun.misc.Launcher.getBootstrapClassPath().getURLs()方法获取到BootstrapClassLoader的搜索路径。\n\n下面的代码打印了各个ClassLoader的搜索路径:\n\n```\nimport java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class ClassLoaderURLs {\n    public static void main(String[] args) {\n        System.out.println(\"BootstrapClassLoader urls :\");\n        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();\n        for (URL url : urls) {\n            System.out.println(url);\n        }\n\n        URLClassLoader extClassLoader = (URLClassLoader) ClassLoader.getSystemClassLoader().getParent();\n        System.out.println(\"\\n\" + extClassLoader + \" urls :\");\n        urls = extClassLoader.getURLs();\n        for (URL url : urls) {\n            System.out.println(url);\n        }\n\n        URLClassLoader appClassLoader = (URLClassLoader) ClassLoader.getSystemClassLoader();\n        System.out.println(\"\\n\" + appClassLoader + \" urls :\");\n        urls = appClassLoader.getURLs();\n        for (URL url : urls) {\n            System.out.println(url);\n        }\n    }\n}\n```\n\n打印如下:\n\n```\nBootstrapClassLoader urls :\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/resources.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/rt.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/sunrsasign.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/jsse.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/jce.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/charsets.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/jfr.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/classes\n\nsun.misc.Launcher$ExtClassLoader@74a14482 urls :\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/cldrdata.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/dnsns.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/jfxrt.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/localedata.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/nashorn.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/sunec.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar\nfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/zipfs.jar\nfile:/System/Library/Java/Extensions/AppleScriptEngine.jar\nfile:/System/Library/Java/Extensions/dns_sd.jar\nfile:/System/Library/Java/Extensions/j3daudio.jar\nfile:/System/Library/Java/Extensions/j3dcore.jar\nfile:/System/Library/Java/Extensions/j3dutils.jar\nfile:/System/Library/Java/Extensions/jai_codec.jar\nfile:/System/Library/Java/Extensions/jai_core.jar\nfile:/System/Library/Java/Extensions/libAppleScriptEngine.jnilib\nfile:/System/Library/Java/Extensions/libJ3D.jnilib\nfile:/System/Library/Java/Extensions/libJ3DAudio.jnilib\nfile:/System/Library/Java/Extensions/libJ3DUtils.jnilib\nfile:/System/Library/Java/Extensions/libmlib_jai.jnilib\nfile:/System/Library/Java/Extensions/mlibwrapper_jai.jar\nfile:/System/Library/Java/Extensions/MRJToolkit.jar\nfile:/System/Library/Java/Extensions/vecmath.jar\nfile:/usr/lib/java/libjdns_sd.jnilib\n\nsun.misc.Launcher$AppClassLoader@28d93b30 urls :\nfile:/Users/linjw/workspace/class_loader_demo/\n```\n\n我们可以看到这些url有指向jar包的,也有指向一个目录的(还有指向.jnilib文件的,这个我们可以不用管)。\n\nClassLoader从指定的路径下搜索class文件。而jar包其实是一个压缩包,将class文件打包在一起,所以ClassLoader也可以从jar包中搜索需要用到的class。\n\n## Java类的加载流程\n\n### ClassLoader的创建\n\n我们先从ClassLoader的创建开始说起。我们可以直接看[sun.misc.Launcher](http://www.grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/sun/misc/Launcher.java)的源码,它在构造函数中创建了ExtClassLoader和AppClassLoader:\n\n```\npublic Launcher() {\n    // Create the extension class loader\n    ClassLoader extcl;\n    try {\n        extcl = ExtClassLoader.getExtClassLoader();\n    } catch (IOException e) {\n        throw new InternalError(\n            \"Could not create extension class loader\", e);\n    }\n\n    // Now create the class loader to use to launch the application\n    try {\n        loader = AppClassLoader.getAppClassLoader(extcl);\n    } catch (IOException e) {\n        throw new InternalError(\n            \"Could not create application class loader\", e);\n    }\n\n    // Also set the context class loader for the primordial thread.\n    Thread.currentThread().setContextClassLoader(loader);\n\n\t...\n}\n```\n\nExtClassLoader.getExtClassLoader()是一个工厂方法:\n\n```\npublic static ExtClassLoader getExtClassLoader() throws IOException\n{\n    final File[] dirs = getExtDirs();\n\n    try {\n        // Prior implementations of this doPrivileged() block supplied\n        // aa synthesized ACC via a call to the private method\n        // ExtClassLoader.getContext().\n\n        return AccessController.doPrivileged(\n            new PrivilegedExceptionAction<ExtClassLoader>() {\n                public ExtClassLoader run() throws IOException {\n                    int len = dirs.length;\n                    for (int i = 0; i < len; i++) {\n                        MetaIndex.registerDirectory(dirs[i]);\n                    }\n                    return new ExtClassLoader(dirs);\n                }\n            });\n    } catch (java.security.PrivilegedActionException e) {\n        throw (IOException) e.getException();\n    }\n}\n```\n\nAppClassLoader.getAppClassLoader(final ClassLoader extcl)也是一个工厂方法,它需要传入一个ClassLoader作为AppClassLoader的父ClassLoader。而我们将ExtClassLoader传了进去,也就是说ExtClassLoader是AppClassLoader的父ClassLoader:\n\n```\npublic static ClassLoader getAppClassLoader(final ClassLoader extcl)\n    throws IOException\n{\n    final String s = System.getProperty(\"java.class.path\");\n    final File[] path = (s == null) ? new File[0] : getClassPath(s);\n\n    // Note: on bugid 4256530\n    // Prior implementations of this doPrivileged() block supplied\n    // a rather restrictive ACC via a call to the private method\n    // AppClassLoader.getContext(). This proved overly restrictive\n    // when loading  classes. Specifically it prevent\n    // accessClassInPackage.sun.* grants from being honored.\n    //\n    return AccessController.doPrivileged(\n        new PrivilegedAction<AppClassLoader>() {\n            public AppClassLoader run() {\n            URL[] urls =\n                (s == null) ? new URL[0] : pathToURLs(path);\n            return new AppClassLoader(urls, extcl);\n        }\n    });\n}\n```\n\n每一个ClassLoader都有一个父ClassLoader,我们可以通过ClassLoader.getParent()方法获取。同时我们也能使用Class.getClassLoader()获取加载这个类的ClassLoader。所以让我们来看看下面的代码:\n\n```\npublic class GetClassLoader {\n    public static void main(String[] args) {\n        ClassLoader loader = GetClassLoader.class.getClassLoader();\n        do {\n            System.out.println(loader);\n        } while ((loader = loader.getParent()) != null);\n    }\n}\n```\n\n查看打印我们可以知道, GetClassLoader是AppClassLoader加载的,而AppClassLoader的父ClassLoader是ExtClassLoader:\n\n```\nsun.misc.Launcher$AppClassLoader@28d93b30\nsun.misc.Launcher$ExtClassLoader@74a14482\n```\n\n但是如果我们查看String的ClassLoader又会发现它是null的:\n\n```\npublic class GetClassLoader {\n    public static void main(String[] args) {\n        ClassLoader loader = String.class.getClassLoader();\n        System.out.println(\"loader : \" + loader);\n    }\n}\n```\n\n```\nloader : null\n```\n\n那是不是说String不是由ClassLoader加载的?当然不是!其实String是BootstrapClassLoader加载的。BootstrapClassLoader负责加载java的核心类。\n\n但是为什么String.class.getClassLoader()拿到的是null呢？\n\n原因是BootstrapClassLoader实际上不是一个java类,它是由C/C++编写的,它本身是虚拟机的一部分。所以在java中当然没有办法获取到它的引用。\n\n### 双亲委托\n\n相信大家如果知道ClassLoader的话应该有听说过双亲委托,那下面我们就来讲一下双亲委托究竟是怎么一回事。\n\n我们知道ClassLoader.loadClass()的方法可以加载一个类,所以研究一个类的加载流程,最好的方法当然还是去看源码啦:\n\n```\nprotected Class<?> loadClass(String name, boolean resolve)\n    throws ClassNotFoundException\n{\n    synchronized (getClassLoadingLock(name)) {\n        // 首先,从缓存中查询该类是不是被加载过,如果加载过就可以直接返回\n        Class<?> c = findLoadedClass(name);\n        if (c == null) {\n            long t0 = System.nanoTime();\n            try {\n                if (parent != null) {\n            \t\t//判断它的父ClassLoader是否为空,如果不为空就调用父ClassLoader的loadClass方法去加载该类\n                    c = parent.loadClass(name, false);\n                } else {\n                \t//如果它的父ClassLoader为空,则调用BootstrapClassLoader去加载该类,所以此时从逻辑上来讲BootstrapClassLoader是父ClassLoader\n                    c = findBootstrapClassOrNull(name);\n                }\n            } catch (ClassNotFoundException e) {\n                \n            }\n\n            if (c == null) {\n                long t1 = System.nanoTime();\n                \n                //如果父ClassLoader不能加载该类才由自己去加载,这个方法从本ClassLoader的搜索路径中查找该类\n                c = findClass(name);\n                \n                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                sun.misc.PerfCounter.getFindClasses().increment();\n            }\n        }\n        if (resolve) {\n            resolveClass(c);\n        }\n        return c;\n    }\n}\n```\n\n从代码中我们可以看到,加载一个类的时候,ClassLoader先会让父类去加载,如果父类加载失败,才会由它自己去加载,这就是我们说的双亲委托。\n\n为什么类加载需要设计成双亲委托的方式呢？原因就在于双亲委托可以防止类被重复加载。如果父ClassLoader已经加载过一个类了,子ClassLoader就不会再次加载,可以防止同一个类被两个ClassLoader重复加载的问题。\n\n这里还需要说的是,当我们自定义一个ClassLoader的时候,最好将AppClassLoader设为父ClassLoader。这样的话可以保证我们自定义的ClassLoader找加载类失败的时候还能从父ClassLoader中加载这个类。\n\n双亲委托模式的流程如下图所示:\n\n\n{% img /Android温故而知新-ClassLoader/1.png %}\n\n\n## 自定义ClassLoader\n\n有时候我们可以继承ClassLoader实现自己的类加载器。自定义ClassLoader有两种方式:\n\n1. 重写loadClass方法 \n2. 重写findClass方法\n\n他们有什么区别呢,还记得上一级ClassLoader.loadClass()的源码吗？loadClass方法内会先调用父ClassLoader的loadClass方法,如果父ClassLoader没有加载过该类才会调用本ClassLoader的findClass方法去加载类。\n\n所以如果想要打破双亲委托机制的话就可以loadClass(),而如果还想继续沿用双亲委托机制的话就只需要重写findClass就好了。\n\n我们写个小例子:\n\n```\npublic class MyClassLoader extends ClassLoader {\n    public String mClassDir;\n\n    public MyClassLoader(String classDir) {\n        this.mClassDir = classDir;\n    }\n\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        File file = new File(mClassDir, getClassFileName(name));\n        if (file.exists()) {\n            try {\n                FileInputStream is = new FileInputStream(file);\n\n                ByteArrayOutputStream buf = new ByteArrayOutputStream();\n                int len;\n                while ((len = is.read()) != -1) {\n                    buf.write(len);\n                }\n\n                byte[] data = buf.toByteArray();\n                is.close();\n                buf.close();\n\n                return defineClass(name, data, 0, data.length);\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        return super.findClass(name);\n    }\n\n    private String getClassFileName(String fullName) {\n        int index = fullName.lastIndexOf(\".\");\n        if (index == -1) {\n            return fullName + \".class\";\n        } else {\n            return fullName.substring(index + 1) + \".class\";\n        }\n    }\n}\n```\n\n因为我们不需要打破双亲委托机制所以只需要重写findClass方法就可以了。我们自定义的ClassLoader会从指定的路径中搜索class文件,将它读入内存,然后通过调用ClassLoader.defineClass()方法去加载这个类。\n\n我们在/Users/linjw/workspace/class\\_loader\\_demo目录下创建了一个Test.java:\n\n```\npackage linjw.demo.classloader;\npublic class Test {\n    public String getData() {\n        return \"Hello World\";\n    }\n}\n```\n\n然后通过javac命令编译出Test.class文件,同样放在/Users/linjw/workspace/class\\_loader\\_demo目录下。\n\n然后用我们的MyClassLoader去加载它:\n\n```\nMyClassLoader loader = new MyClassLoader(\"/Users/linjw/workspace/class_loader_demo\");\nClass clazz = loader.loadClass(\"linjw.demo.classloader.Test\");\nif (clazz != null) {\n    Object obj = clazz.newInstance();\n    Method method = clazz.getDeclaredMethod(\"getData\");\n    String result = (String) method.invoke(obj);\n    System.out.println(result);\n    System.out.println(\"ClassLoader : \" + clazz.getClassLoader());\n} else {\n    System.out.println(\"can't load class\");\n}\n```\n\n可以看到下面的打印,说明我们已经成功用MyClassLoader加载了Test这个类:\n\n```\nHello World\nClassLoader : linjw.demo.classloader.MyClassLoader@66cd51c3\n```\n\n这里还有一个小的知识点,如果一个类是由某个ClassLoader加载的,那么它import的类也会由这个ClassLoader去加载。这里我们可以做一个实验:\n\n```\npackage linjw.demo.classloader;\n\nimport linjw.demo.classloader.Test;\n\npublic class Test2 {\n    public String getData(){\n        return \"Test ClassLoader : \" + Test.class.getClassLoader();\n    }\n}\n```\n\n我们写一个Test2类,它会import Test并返回Test的ClassLoader。让我们写个demo看看这个Test的ClassLoader:\n\n```\nMyClassLoader loader = new MyClassLoader(\"/Users/linjw/workspace/class_loader_demo\");\nClass clazz = loader.loadClass(\"linjw.demo.classloader.Test2\");\nif (clazz != null) {\n    Object obj = clazz.newInstance();\n    Method method = clazz.getDeclaredMethod(\"getData\");\n    String result = (String) method.invoke(obj);\n    System.out.println(result);\n} else {\n    System.out.println(\"can't load class\");\n}\n```\n\n通过打印可以知道Test也是由MyClassLoader加载的:\n\n```\nlinjw.demo.classloader.MyClassLoader@66cd51c3\n```\n\n## Context ClassLoader\n\nContext ClassLoader并不是一个实际的类,它只是Thread的一个成员变量:\n\n```\npublic class Thread implements Runnable {\n\tprivate ClassLoader contextClassLoader;\n\n\tprivate void init2(Thread parent) {\n        this.contextClassLoader = parent.getContextClassLoader();\n        ...\n    }\n\n    public ClassLoader getContextClassLoader() {\n        return contextClassLoader;\n    }\n\n    public void setContextClassLoader(ClassLoader cl) {\n        contextClassLoader = cl;\n    }\n    \n    ...\n}\n```\n\n每个Thread都有一个相关联的ClassLoader,子线程默认使用父线程的ClassLoader。\n\n而线程的默认ClassLoader是AppClassLoader:\n\n```\npublic Launcher() {\n    ...\n    \n    try {\n        loader = AppClassLoader.getAppClassLoader(extcl);\n    } catch (IOException e) {\n        throw new InternalError(\n            \"Could not create application class loader\", e);\n    }\n    \n    //设置AppClassLoader为当前线程的Context ClassLoader\n    Thread.currentThread().setContextClassLoader(loader);\n\n\t...\n}\n```\n\nContext ClassLoader的存在是为了解决使用双亲委托机制下父ClassLoader无法找到子ClassLoader的问题。假如有下面的委托链:\n\nClassLoaderA -> AppClassLoader -> ExtClassLoader -> BootstrapClassLoader\n\n那么委派链左边的ClassLoader就可以很自然的使用右边的ClassLoader所加载的类。 \n\n但如果是右边的ClassLoader想要反过来使用左边的ClassLoader所加载的类就无能为力了。\n\n这个时候如果使用Context ClassLoader就能从线程中获得左边的ClassLoader了。\n\n那什么时候会出现右边的ClassLoader想要反过来使用左边的ClassLoader所加载的类的情况呢？\n\n我们上一节刚刚说过:“如果一个类是由某个ClassLoader加载的,那么它import的类也会由这个ClassLoader去加载”。\n\n举个例子,Java 提供了很多服务提供者接口（Service Provider Interface，SPI）,允许第三方为这些接口提供实现。如JAXP(XML处理的Java API)的SPI__接口__定义包含在 javax.xml.parsers包中，它是由BootstrapClassLoader加载的。\n\n但是它的实现代码很可能是作为Java应用所依赖的jar包被包含进来,如实现了JAXP SPI的Apache Xerces所包含的jar包,它由AppClassLoader加载。\n\n我们用javax.xml.parsers.DocumentBuilderFactory类中的newInstance()方法用来生成一个新的DocumentBuilderFactory的实例, DocumentBuilderFactory是一个抽象类,它定是java核心库的一部分,由BootstrapClassLoader去加载。因此,DocumentBuilderFactory里面import的类都由BootstrapClassLoader去加载。\n\n但是DocumentBuilderFactory的实现类却是在org.apache.xerces.jaxp.DocumentBuilderFactoryImpl中定义的, BootstrapClassLoader无法加载它。这个时候就需要在DocumentBuilderFactory. newInstance()的代码中使用Context ClassLoader，找到AppClassLoader去加载DocumentBuilderFactoryImpl这个实现类。\n\n\n# 安卓中的ClassLoader\n\n安卓的的类也是通过ClassLoader加载的,但是并不是java中的BootstrapClassLoader、 ExtClassLoader或者AppClassLoader。写个小demo看看安卓中加载类的是哪些ClassLoader:\n\n```\nLog.d(\"DxClassLoader\", \"BootClassLoader :\" + String.class.getClassLoader());\n\nClassLoader loader = MainActivity.class.getClassLoader();\ndo {\n\tLog.d(\"DxClassLoader\", \"loader :\" + loader);\n} while ((loader = loader.getParent()) != null);\n```\n\n打印如下:\n\n```\n09-27 23:11:03.432 21151-21151/? D/DxClassLoader: BootClassLoader :java.lang.BootClassLoader@ad96016\n09-27 23:11:03.432 21151-21151/? D/DxClassLoader: loader :dalvik.system.PathClassLoader[DexPathList[[zip file \"/data/app/linjw.demo.classloader-2/base.apk\"],nativeLibraryDirectories=[/data/app/linjw.demo.classloader-2/lib/arm64, /vendor/lib64, /system/lib64]]]\n09-27 23:11:03.433 21151-21151/? D/DxClassLoader: loader :java.lang.BootClassLoader@ad96016\n```\n\n我们可以看到安卓中用的了PathClassLoader和BootClassLoader两个ClassLoader,其中BootClassLoader是PathClassLoader的parent。\n\n而和在java程序不同的是String是由BootClassLoader加载的。安卓的BootClassLoader其实就相当于java的BootstrapClassLoader,只不过它是由java实现的而不是由c/c++实现的。\n\n## PathClassLoader\n\n我们在上一节中将PathClassLoader打印出来的时候可以看到一个apk路径:\n\n```\n[zip file \"/data/app/linjw.demo.classloader-2/base.apk\"]\n```\n\napk其实是一个也是一个zip压缩包,我们可以将一个apk文件后缀改成.zip然后就可以直接解压了。PathClassLoader的作用其实就是在这个zip包中加载dex文件,我们通过它甚至可以加载其他应用的代码,但它只能加载已安装的应用。\n\n例如我们可以新建一个ext工程,它的包名为linjw.demo.classloader.ext,然后在里面创建Test类:\n\n```\npackage linjw.demo.classloader.ext;\n\npublic class Test {\n    public String getData() {\n        return \"Hello World\";\n    }\n}\n```\n\n然后编译出apk来,并且安装。之后就能从这个apk中加载出Test类了:\n\n```\nString path = null;\nPackageManager pm = getPackageManager();\ntry {\n    path = pm.getApplicationInfo(\"linjw.demo.classloader.ext\", 0).sourceDir;\n} catch (PackageManager.NameNotFoundException e) {\n    e.printStackTrace();\n}\n\nPathClassLoader loader = new PathClassLoader(path, ClassLoader.getSystemClassLoader());\n\ntry {\n    Class clazz = loader.loadClass(\"linjw.demo.classloader.ext.Test\");\n\n    if (clazz != null) {\n        Object obj = clazz.newInstance();\n        Method method = clazz.getDeclaredMethod(\"getData\");\n        String result = (String) method.invoke(obj);\n        Log.d(\"DxClassLoader\", result);\n    } else {\n        Log.d(\"DxClassLoader\", \"can't load class\");\n    }\n} catch (ClassNotFoundException e) {\n    e.printStackTrace();\n} catch (NoSuchMethodException e) {\n    e.printStackTrace();\n} catch (InstantiationException e) {\n    e.printStackTrace();\n} catch (IllegalAccessException e) {\n    e.printStackTrace();\n} catch (InvocationTargetException e) {\n    e.printStackTrace();\n}\n```\n\n可以得到打印:\n\n```\n09-27 23:39:16.571 24077-24077/? D/DxClassLoader: Hello World\n```\n\n## DexClassLoader\n\nPathClassLoader只能加载已经安装的应用里面的类,但是DexClassLoader却能加载未安装的应用里面的类。例如我们将apk放到存储卡目录下而不去安装它:\n\n```\nString dir = Environment.getExternalStorageDirectory().getAbsolutePath();\nFile apk = new File(dir, \"Ext.apk\");\nFile dexOutputDir = this.getDir(\"dex\", 0);\nDexClassLoader loader = new DexClassLoader(\n        apk.getAbsolutePath(),\n        dexOutputDir.getAbsolutePath(),\n        null, getClassLoader());\n\ntry {\n    Class clazz = loader.loadClass(\"linjw.demo.classloader.ext.Test\");\n\n    if (clazz != null) {\n        Object obj = clazz.newInstance();\n        Method method = clazz.getDeclaredMethod(\"getData\");\n        String result = (String) method.invoke(obj);\n        Log.d(\"DxClassLoader\", result);\n    } else {\n        Log.d(\"DxClassLoader\", \"can't load class\");\n    }\n} catch (ClassNotFoundException e) {\n    e.printStackTrace();\n} catch (NoSuchMethodException e) {\n    e.printStackTrace();\n} catch (InstantiationException e) {\n    e.printStackTrace();\n} catch (IllegalAccessException e) {\n    e.printStackTrace();\n} catch (InvocationTargetException e) {\n    e.printStackTrace();\n}\n```\n\n同样可以得到打印:\n\n```\n09-27 23:54:29.206 25472-25472/? D/DxClassLoader: Hello World\n```\n\n我们可以看到, DexClassLoader的构造函数的参数比PathClassLoader的要多出一个optimizedDirectory:\n\n```\npublic class DexClassLoader extends BaseDexClassLoader {\n    public DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) {\n        super((String)null, (File)null, (String)null, (ClassLoader)null);\n        throw new RuntimeException(\"Stub!\");\n    }\n}\n```\n\n```\npublic class PathClassLoader extends BaseDexClassLoader {\n    public PathClassLoader(String dexPath, ClassLoader parent) {\n        super((String)null, (File)null, (String)null, (ClassLoader)null);\n        throw new RuntimeException(\"Stub!\");\n    }\n\n    public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) {\n        super((String)null, (File)null, (String)null, (ClassLoader)null);\n        throw new RuntimeException(\"Stub!\");\n    }\n}\n```\n\n那这个optimizedDirectory到底有什么作用呢?其实optimizedDirectory是用来存放从apk中解压出来的dex文件的。\n\nDexClassLoader和PathClassLoader其实归根结底都是通过DexFile这个类去加载的dex文件,并不是直接读取的apk。因为如果每次都需要解压才能加载代码的话效率实在太低了。\n\nDexClassLoader可以主动解压apk,所以可以加载未安装的应用中的代码。但PathClassLoader不会主动解压apk,它是读取的已经安装的apk在cache中存在缓存的dex文件,所以它只能加载已安装应用中的代码。\n\n## 生成dex文件\n\nDexClassLoader和PathClassLoader最后都是加载的dex文件。所以我们可以直接将dex文件的路径传给他们去加载。但dex文件又是个什么东西呢？\n\n普通的java程序中,JVM虚拟机可以通过ClassLoader去加载jar到的加载类的目的。但是android使用的Dalvik/ART虚拟机不能直接加载jar包,需要把.jar文件优化成.dex文件才能加载。所以实际上dex文件是优化过的jar包。\n\n我们可以用Android SDK提供的DX工具把.jar文件优化成.dex文件。我们用之前的Test.java做例子,具体步骤如下:\n\n1.使用javac命令编译Test.java得到Test.class文件(我这边的java环境是1.8的,如果不指定用1.7的话生成dex也会失败,报__com.android.dx.cf.iface.ParseException: bad class file magic (cafebabe) or version (0034.0000)__)\n\n```\njavac -source 1.7 -target 1.7 Test.java\n```\n\n2.将创建目录子目录linjw/demo/classloader/ext并将Test.class移动到子目录中(因为Test的package是linjw.demo.classloader.ext,所以要根据它生成同样的目录,要不然生成dex会失败)\n\n```\nmkdir -p linjw/demo/classloader/ext\nmv Test.class linjw/demo/classloader/ext\n```\n\n3.使用jar命令将linjw目录打包成jar包\n\n```\njar -cf Test.jar linjw\n```\n\n4.用dx工具将jar包优化成dex包\n\n```\n/Users/linjw/androidsdk/android-sdk-macosx/build-tools/19.1.0/dx --dex --output=Test.dex Test.jar\n```\n\n## 动态加载dex文件\n\n然后我们就能将它放到存储卡中用DexClassLoader或者PathClassLoader去加载了。\n\n### 使用反射的反射加载\n\n```\n\nString dir = Environment.getExternalStorageDirectory().getAbsolutePath();\nFile dex = new File(dir, \"Test.dex\");\nFile dexOutputDir = this.getDir(\"dex\", 0);\n\n//使用PathClassLoader加载dex\n//PathClassLoader loader = new PathClassLoader(dex.getAbsolutePath(), getClassLoader());\n\n//使用DexClassLoader加载dex\nDexClassLoader loader = new DexClassLoader(\n        dex.getAbsolutePath(),\n        dexOutputDir.getAbsolutePath(),\n        null,\n        getClassLoader());\n\ntry {\n    Class clazz = loader.loadClass(\"linjw.demo.classloader.ext.Test\");\n\n    if (clazz != null) {\n        Object obj = clazz.newInstance();\n        Method method = clazz.getDeclaredMethod(\"getData\");\n        String result = (String) method.invoke(obj);\n        Log.d(\"DxClassLoader\", result);\n    } else {\n        Log.d(\"DxClassLoader\", \"can't load class\");\n    }\n} catch (ClassNotFoundException e) {\n    e.printStackTrace();\n} catch (NoSuchMethodException e) {\n    e.printStackTrace();\n} catch (InstantiationException e) {\n    e.printStackTrace();\n} catch (IllegalAccessException e) {\n    e.printStackTrace();\n} catch (InvocationTargetException e) {\n    e.printStackTrace();\n}\n```\n\n\n### 使用接口的方式加载\n\n或者我们也可以使用接口的方式:\n\n1.添加ITest接口:\n\n```\npackage linjw.demo.classloader.ext;\n\npublic interface ITest {\n    String getData();\n}\n```\n\n2.Test类实现ITest接口:\n\n```\npackage linjw.demo.classloader.ext;\n\npublic class Test implements ITest {\n    @Override\n    public String getData() {\n        return \"Hello World\";\n    }\n}\n```\n\n3.将它们一起打包到Test.dex\n\n```\njavac -source 1.7 -target 1.7 Test.java ITest.java\n\nmkdir -p linjw/demo/classloader/ext\n\nmv Test.class linjw/demo/classloader/ext\n\nmv Test.class linjw/demo/classloader\n\njar -cf Test.jar linjw\n\n/Users/linjw/androidsdk/android-sdk-macosx/build-tools/19.1.0/dx --dex --output=Test.dex Test.jar\n```\n\n4.在安卓项目中导入ITest接口并调整代码:\n\n```\nString dir = Environment.getExternalStorageDirectory().getAbsolutePath();\nFile dex = new File(dir, \"Test.dex\");\nFile dexOutputDir = this.getDir(\"dex\", 0);\n\n//使用PathClassLoader加载dex\n//PathClassLoader loader = new PathClassLoader(dex.getAbsolutePath(), getClassLoader());\n\n//使用DexClassLoader加载dex\nDexClassLoader loader = new DexClassLoader(\n    dex.getAbsolutePath(),\n    dexOutputDir.getAbsolutePath(),\n    null,\n    getClassLoader());\n\ntry {\nClass clazz = loader.loadClass(\"linjw.demo.classloader.ext.Test\");\n\nif (clazz != null) {\n    //注意这里,使用的是ITest\n    ITest obj = (ITest) clazz.newInstance();\n    String result = obj.getData();\n    Log.d(\"DxClassLoader\", result);\n} else {\n    Log.d(\"DxClassLoader\", \"can't load class\");\n}\n} catch (ClassNotFoundException e) {\ne.printStackTrace();\n} catch (InstantiationException e) {\ne.printStackTrace();\n} catch (IllegalAccessException e) {\ne.printStackTrace();\n}\n```\n\n其实我比较推荐使用在程序主体中定义接口,加载外部实现代码的这种方法。一方面它比反射的效率高,另一方面也比较容易阅读。\n","tags":["技术相关","Android"]},{"title":"Android温故而知新 - AIDL","url":"/2017/09/26/Android温故而知新-AIDL/","content":"\n这篇文章让我们一起来复习一下aidl\n\n# aidl的简单用法\n\naidl的用法是很简单的。首先创建IDemoAidlInterface.aidl文件(在服务端工程和客户端工程中需要分别定义一个相同的aidl文件):\n\n```\npackage linjw.demo.aidldemo;\n\ninterface IDemoAidlInterface {\n    int add(int a, int b);\n}\n```\n\n然后在service.onBind()中创建一个IDemoAidlInterface.Stub返回:\n\n```\npublic class DemoService extends Service {\n    @Nullable\n    @Override\n    public IBinder onBind(Intent intent) {\n        return new IDemoAidlInterface.Stub() {\n            @Override\n            public int add(int a, int b) throws RemoteException {\n                return a + b;\n            }\n        };\n    }\n}\n```\n\n这样在bindService的时候就能获得一个IDemoAidlInterface,就可以通过它去调用其他进程中的方法获取数据了:\n\n```\npublic class MainActivity extends AppCompatActivity {\n    public static final String TAG = \"AIDLDemo\";\n    private ServiceConnection mConnection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            IDemoAidlInterface aidl = IDemoAidlInterface.Stub.asInterface(service);\n            try {\n                Log.d(TAG, \"1 + 2 = \" + aidl.add(1, 2));\n            } catch (RemoteException e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n\n        }\n    };\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Intent intent = new Intent(this, DemoService.class);\n        bindService(intent, mConnection, BIND_AUTO_CREATE);\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        unbindService(mConnection);\n    }\n}\n```\n\n# aidl的原理\n\n但是aidl文件又是个什么东西？aidl又到底是怎样工作的呢？\n\naidl是Android Interface definition language的缩写,实际上它是一中领域特定语言即domain-specific languages，简称DSL,aidl的作用领域是定义安卓接口。感兴趣的同学可以自己去找一下DSL的相关概念,这里就不展开讨论了。\n\naidl底层是通过binder机制实现的,而且不同需求的binder通信实际上代码是有很大的相似性的。厉害的程序员通常是懒惰的程序员,好的ide通常也会提供各种强大的功能帮助程序员去偷懒。\n\naidl就是一种帮助我们简化安卓进程间通信代码的工具。android studio会根据aidl定义的接口,帮我们自动生成安卓进程间通信的代码,而我们只需要直接使用它生成的代码就好了,而不用自己去写。\n\n让我们看看aidl究竟帮我们生成了什么样的代码:\n\n```\npublic interface IDemoAidlInterface extends android.os.IInterface {\n    /**\n     * Local-side IPC implementation stub class.\n     */\n    public static abstract class Stub extends android.os.Binder implements linjw.demo.aidldemo.IDemoAidlInterface {\n        private static final java.lang.String DESCRIPTOR = \"linjw.demo.aidldemo.IDemoAidlInterface\";\n\n        /**\n         * Construct the stub at attach it to the interface.\n         */\n        public Stub() {\n            this.attachInterface(this, DESCRIPTOR);\n        }\n\n        /**\n         * Cast an IBinder object into an linjw.demo.aidldemo.IDemoAidlInterface interface,\n         * generating a proxy if needed.\n         */\n        public static linjw.demo.aidldemo.IDemoAidlInterface asInterface(android.os.IBinder obj) {\n            if ((obj == null)) {\n                return null;\n            }\n            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);\n            if (((iin != null) && (iin instanceof linjw.demo.aidldemo.IDemoAidlInterface))) {\n                return ((linjw.demo.aidldemo.IDemoAidlInterface) iin);\n            }\n            return new linjw.demo.aidldemo.IDemoAidlInterface.Stub.Proxy(obj);\n        }\n\n        @Override\n        public android.os.IBinder asBinder() {\n            return this;\n        }\n\n        @Override\n        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {\n            switch (code) {\n                case INTERFACE_TRANSACTION: {\n                    reply.writeString(DESCRIPTOR);\n                    return true;\n                }\n                case TRANSACTION_add: {\n                    data.enforceInterface(DESCRIPTOR);\n                    int _arg0;\n                    _arg0 = data.readInt();\n                    int _arg1;\n                    _arg1 = data.readInt();\n                    int _result = this.add(_arg0, _arg1);\n                    reply.writeNoException();\n                    reply.writeInt(_result);\n                    return true;\n                }\n            }\n            return super.onTransact(code, data, reply, flags);\n        }\n\n        private static class Proxy implements linjw.demo.aidldemo.IDemoAidlInterface {\n            private android.os.IBinder mRemote;\n\n            Proxy(android.os.IBinder remote) {\n                mRemote = remote;\n            }\n\n            @Override\n            public android.os.IBinder asBinder() {\n                return mRemote;\n            }\n\n            public java.lang.String getInterfaceDescriptor() {\n                return DESCRIPTOR;\n            }\n\n            @Override\n            public int add(int a, int b) throws android.os.RemoteException {\n                android.os.Parcel _data = android.os.Parcel.obtain();\n                android.os.Parcel _reply = android.os.Parcel.obtain();\n                int _result;\n                try {\n                    _data.writeInterfaceToken(DESCRIPTOR);\n                    _data.writeInt(a);\n                    _data.writeInt(b);\n                    mRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0);\n                    _reply.readException();\n                    _result = _reply.readInt();\n                } finally {\n                    _reply.recycle();\n                    _data.recycle();\n                }\n                return _result;\n            }\n        }\n\n        static final int TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);\n    }\n\n    public int add(int a, int b) throws android.os.RemoteException;\n}\n```\n\n它帮忙我们生成了我们在aidl中定义的IDemoAidlInterface接口,并且生成了一个抽象内部类IDemoAidlInterface.Stub去实现和安卓进程间通信相关的代码。而我们只需要继承IDemoAidlInterface.Stub实现具体的业务代码(add方法)就好:\n\n```\npublic interface IDemoAidlInterface extends android.os.IInterface {\n    public static abstract class Stub\n            extends android.os.Binder\n            implements linjw.demo.aidldemo.IDemoAidlInterface {\n    \t...\n    }\n    public int add(int a, int b) throws android.os.RemoteException;\n}\n\n```\n\n## 服务端通信原理\n\n在服务端,我们只需要继承IDemoAidlInterface.Stub并完成add方法的功能代码就可以了。当客户端通过aidl调用服务端代码的时候,服务端的add方法就会被调用:\n\n```\npublic IBinder onBind(Intent intent) {\n    return new IDemoAidlInterface.Stub() {\n        @Override\n        public int add(int a, int b) throws RemoteException {\n            return a + b;\n        }\n    };\n}\n```\n\n但是add究竟是为什么会被调用的呢？奥秘就在IDemoAidlInterface.Stub.onTransact()方法中。onTransact是android.os.Binder的一个方法。客户端将想要调用的服务端的方法、参数等序列化之后通过系统级别的Binder驱动程序传给服务端,然后服务端在将它们反序列化获取想要调用的方法还有传入的参数。而onTransact就是这个反序列化的方法:\n\n```\npublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {\n    switch (code) {\n        case INTERFACE_TRANSACTION: {\n            reply.writeString(DESCRIPTOR);\n            return true;\n        }\n        case TRANSACTION_add: {\n            data.enforceInterface(DESCRIPTOR);\n            int _arg0;\n            _arg0 = data.readInt();\n            int _arg1;\n            _arg1 = data.readInt();\n            int _result = this.add(_arg0, _arg1);\n            reply.writeNoException();\n            reply.writeInt(_result);\n            return true;\n        }\n    }\n    return super.onTransact(code, data, reply, flags);\n}\n```\n\ncode就代表了客户端想要执行的操作,当它是TRANSACTION_add的时候就代表客户端想调用服务端的add方法。可以从传过来的Parcel中反序列化出传入的两个相加数,然后调用实际的add方法,即this.add(\\_arg0, \\_arg1),最后将计算出来的值写入reply中序列化之后传回给客户端。客户端就可以从这个reply中反序列化中出计算的结果。\n\nTRANSACTION_add是一个int,是IDemoAidlInterface接口定义的第一个方法:\n\n```\nstatic final int TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);\n```\n\n## 客户端原理\n\n客户端的代码比服务端会复杂一点点。首先从IDemoAidlInterface.Stub.asInterface方法开始看,我们可以通过它获取到一个IDemoAidlInterface:\n\n```\nIDemoAidlInterface aidl = IDemoAidlInterface.Stub.asInterface(service);\n```\n\n它的代码是这样的:\n\n```\npublic static linjw.demo.aidldemo.IDemoAidlInterface asInterface(android.os.IBinder obj) {\n    if ((obj == null)) {\n        return null;\n    }\n    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);\n    if (((iin != null) && (iin instanceof linjw.demo.aidldemo.IDemoAidlInterface))) {\n        return ((linjw.demo.aidldemo.IDemoAidlInterface) iin);\n    }\n    return new linjw.demo.aidldemo.IDemoAidlInterface.Stub.Proxy(obj);\n}\n```\n\n它会判断传进来的IBinder是不是IDemoAidlInterface的一个实例,如果是的话就直接将它返回,不是的会就会用它去创建一个代理。\n\n但这个判断有什么用呢？什么时候IBinder它会是一个IDemoAidlInterface的实例什么时候又不是呢？\n\n我们写的service不外乎给其他应用使用和给应用内部使用。给其他应用使用的service因为进程不同不能直接传递对象,所以需要将一个对象先序列化再反序列化去实现进程间的传递。但是有一些服务比如播放器的播放服务,很多时候就只是应用内部在使用而已,是进程内的通信(或者说只是线程间的通信)。其实不涉及跨进程通信,可以直接传递,不用经过序列化和反序列化这样耗时的操作。\n\n如果是进程内的通信,传入的IBinder其实是IDemoAidlInterface的一个实例,所以直接返回将它返回就好。但如果是进程间的通信,就不会是是IDemoAidlInterface的实例了,而是一个用于进程间通信的对象了(具体是什么我们可以不用关心)。这个对象没有实现IDemoAidlInterface.add()方法,所以需要通过一些特殊的手段调用到服务端的add方法:\n\n```\nprivate static class Proxy implements linjw.demo.aidldemo.IDemoAidlInterface {\n        private android.os.IBinder mRemote;\n\n        Proxy(android.os.IBinder remote) {\n            mRemote = remote;\n        }\n\n        @Override\n        public android.os.IBinder asBinder() {\n            return mRemote;\n        }\n\n        public java.lang.String getInterfaceDescriptor() {\n            return DESCRIPTOR;\n        }\n\n        @Override\n        public int add(int a, int b) throws android.os.RemoteException {\n            android.os.Parcel _data = android.os.Parcel.obtain();\n            android.os.Parcel _reply = android.os.Parcel.obtain();\n            int _result;\n            try {\n                _data.writeInterfaceToken(DESCRIPTOR);\n                _data.writeInt(a);\n                _data.writeInt(b);\n                mRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0);\n                _reply.readException();\n                _result = _reply.readInt();\n            } finally {\n                _reply.recycle();\n                _data.recycle();\n            }\n            return _result;\n        }\n    }\n\n    static final int TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);\n}\n```\n\n它最重要的代码是IDemoAidlInterface.Stub.Proxy.add()这个方法。它将传入的a、b参数序列化到\\_data这个Parcel中,然后再通过之前传入的IBinder的transact()将它们传递到service中。注意看,我们还指定了调用Stub.TRANSACTION_add这个方法。上一节服务端获取到的code就是这里指定的。然后服务端将计算到的结果序列化到\\_reply中,客户的这里再将\\_reply反序列化得到计算结果返回。\n\n## aidl原理图\n\naidl的原理可以用下面的图来表示:\n\n{% img /Android温故而知新-AIDL/1.png %}\n\n# 使用aidl传递复杂数据类型\n\n有时候我需要传递一些复杂的数据类型比如自定义的类,aidl也是支持的。但是因为aidl传递数据都是通过序列化实现的,所以aidl要求传递的类必须实现Parcelable接口。比如我们定义一个Data类:\n\n```\npublic class Data implements Parcelable {\n    public String data;\n\n    public Data() {\n    }\n\n    public Data(String data) {\n        this.data = data;\n    }\n\n    protected Data(Parcel in) {\n        data = in.readString();\n    }\n\n    public static final Creator<Data> CREATOR = new Creator<Data>() {\n        @Override\n        public Data createFromParcel(Parcel in) {\n            return new Data(in);\n        }\n\n        @Override\n        public Data[] newArray(int size) {\n            return new Data[size];\n        }\n    };\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n    }\n\n    public void readFromParcel(Parcel in) {\n        data = in.readString();\n    }\n}\n```\n\n然后需要新建一个Data.aidl文件声明这个类:\n\n```\npackage linjw.demo.aidldemo;\nparcelable Data;\n```\n\n最后在IDemoAidlInterface.aidl中添加接口:\n\n```\npackage linjw.demo.aidldemo;\nimport linjw.demo.aidldemo.Data;\n\ninterface IDemoAidlInterface {\n    int add(int a, int b);\n\n    void setData(in Data data);\n\n    void getData(out Data data);\n}\n```\n\n## 输入参数和输出参数\n\n相信大家都看到了in、out这两个关键字了,他们是用来标识这个参数是输入参数还是输出参数的。我们直接可以看一下生成的代码可以很容易看出他们的作用,先看看服务端的Stub. onTransact()方法:\n\n```\npublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {\n    switch (code) {\n        case INTERFACE_TRANSACTION: {\n            reply.writeString(DESCRIPTOR);\n            return true;\n        }\n        case TRANSACTION_add: {\n            data.enforceInterface(DESCRIPTOR);\n            int _arg0;\n            _arg0 = data.readInt();\n            int _arg1;\n            _arg1 = data.readInt();\n            int _result = this.add(_arg0, _arg1);\n            reply.writeNoException();\n            reply.writeInt(_result);\n            return true;\n        }\n        case TRANSACTION_setData: {\n            data.enforceInterface(DESCRIPTOR);\n            linjw.demo.aidldemo.Data _arg0;\n            if ((0 != data.readInt())) {\n                _arg0 = linjw.demo.aidldemo.Data.CREATOR.createFromParcel(data);\n            } else {\n                _arg0 = null;\n            }\n            this.setData(_arg0);\n            reply.writeNoException();\n            return true;\n        }\n        case TRANSACTION_getData: {\n            data.enforceInterface(DESCRIPTOR);\n            linjw.demo.aidldemo.Data _arg0;\n            _arg0 = new linjw.demo.aidldemo.Data();\n            this.getData(_arg0);\n            reply.writeNoException();\n            if ((_arg0 != null)) {\n                reply.writeInt(1);\n                _arg0.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);\n            } else {\n                reply.writeInt(0);\n            }\n            return true;\n        }\n    }\n    return super.onTransact(code, data, reply, flags);\n}\n```\n\nsetData只是简单的将参数返序列化出来传给功能代码,但是getData除了调用功能代码之外,还会将返回值写入reply中传回给客户端。\n\n同时我们也注意到了服务端所有的调用都是在onTransact中分配的,所以需要一个code去标识客户端到底想要调用的是哪一个方法。\n\n我们再来看看客户端的生成代码,也能看到getData方法有从_reply中反序列化出Data来:\n\n``` \nprivate static class Proxy implements linjw.demo.aidldemo.IDemoAidlInterface {\n    \n    ...\n    \n    @Override\n    public void setData(linjw.demo.aidldemo.Data data) throws android.os.RemoteException {\n        android.os.Parcel _data = android.os.Parcel.obtain();\n        android.os.Parcel _reply = android.os.Parcel.obtain();\n        try {\n            _data.writeInterfaceToken(DESCRIPTOR);\n            if ((data != null)) {\n                _data.writeInt(1);\n                data.writeToParcel(_data, 0);\n            } else {\n                _data.writeInt(0);\n            }\n            mRemote.transact(Stub.TRANSACTION_setData, _data, _reply, 0);\n            _reply.readException();\n        } finally {\n            _reply.recycle();\n            _data.recycle();\n        }\n    }\n\n    @Override\n    public void getData(linjw.demo.aidldemo.Data data) throws android.os.RemoteException {\n        android.os.Parcel _data = android.os.Parcel.obtain();\n        android.os.Parcel _reply = android.os.Parcel.obtain();\n        try {\n            _data.writeInterfaceToken(DESCRIPTOR);\n            mRemote.transact(Stub.TRANSACTION_getData, _data, _reply, 0);\n            _reply.readException();\n            if ((0 != _reply.readInt())) {\n                data.readFromParcel(_reply);\n            }\n        } finally {\n            _reply.recycle();\n            _data.recycle();\n        }\n    }\n}\n```","tags":["技术相关","Android"]},{"title":"Java多线程 - Future模式","url":"/2017/09/09/Java多线程-Future模式/","content":"\n# 什么是Future模式\n\nFuture模式是多线程开发中非常常见的一种设计模式。它的核心思想是异步调用。当我们需要调用一个函数方法时。如果这个函数执行很慢,那么我们就要进行等待。但有时候,我们可能并不急着要结果。因此,我们可以让被调用者立即返回,让他在后台慢慢处理这个请求。对于调用者来说,则可以先处理一些其他任务,在真正需要数据的场合再去尝试获取需要的数据。\n\n用生活中的例子来打个比喻,就像叫外卖。比如在午休之前我们可以提前叫外卖,只需要点好食物,下个单。然后我们可以继续工作。到了中午下班的时候外卖也就到了,然后就可以吃个午餐,再美滋滋的睡个午觉。而如果你在下班的时候才叫外卖,那就只能坐在那里干等着外卖小哥,最后拿到外卖吃完午饭,午休时间也差不多结束了。\n\n使用Future模式,获取数据的时候无法立即得到需要的数据。而是先拿到一个契约,你可以再将来需要的时候再用这个契约去获取需要的数据,这个契约就好比叫外卖的例子里的外卖订单。\n\n# 用普通方式和Future模式的差别\n\n我们可以看一下使用普通模式和用Future模式的时序图。可以看出来普通模式是串行的,在遇到耗时操作的时候只能等待。而Future模式,只是发起了耗时操作,函数立马就返回了,并不会阻塞客户端线程。所以在工作线程执行耗时操作的时候客户端无需等待,可以继续做其他事情,等到需要的时候再向工作线程获取结果:\n\n{% img /Java多线程-Future模式/1.png %}\n\n# Future模式的简单实现\n\n首先是FutureData,它是只是一个包装类,创建它不需要耗时。在工作线程准备好数据之后可以使用setData方法将数据传入。而客户端线程只需要在需要的时候调用getData方法即可,如果这个时候数据还没有准备好,那么getData方法就会等待,如果已经准备好了就好直接返回。\n\n```\npublic class FutureData<T> {\n    private boolean mIsReady = false;\n    private T mData;\n\n    public synchronized void setData(T data) {\n        mIsReady = true;\n        mData = data;\n\n        notifyAll();\n    }\n\n    public synchronized T getData() {\n        while (!mIsReady) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        return mData;\n    }\n}\n```\n\n接着是服务端,客户端在向服务端请求数据的时候服务端不会实际去加载数据,它只是创建一个FutureData,然后创建子线程去加载,而它只需要直接返回FutureData就可以了。\n\n```\npublic class Server {\n    public FutureData<String> getString() {\n        final FutureData<String> data = new FutureData<>();\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                data.setData(\"world\");\n            }\n        }).start();\n\n        return data;\n    }\n}\n```\n\n客户端代码如下,整个程序只需要运行2秒多,但如果不使用Future模式的话就需要三秒了。\n\n```\nServer server = new Server();\nFutureData<String> futureData = server.getString();\n\n//先执行其他操作\nString hello = \"hello\";\ntry {\n    Thread.sleep(1000);\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n\nSystem.out.print(hello + \" \" + futureData.getData());\n```\n\n# JDK中的Future模式\n\n还记得我之前的一篇文章《Java多线程 - 线程池》中写的ExecutorService.execute()和ExecutorService.submit()的区别吗(如果没有看过的读者可以去看一下)？\n\nexecute方法其实是在Executor中定义的,而ExecutorService继承了Executor。它只是简单的提交了一个Runnable给线程池中的线程去调用:\n\n```\npublic interface Executor {\n    void execute(Runnable command);\n}\n\npublic interface ExecutorService extends Executor {\n\t...\n}\n```\n\n而submit方法是ExecutorService中定义的,它们都会返回一个Future对象。实际上submit方法就是使用的Future模式:\n\n```\npublic interface ExecutorService extends Executor {\n\t...\n\t<T> Future<T> submit(Callable<T> task);\n\t\t\n\t<T> Future<T> submit(Runnable task, T result);\n\t\t\n\tFuture<?> submit(Runnable task);\n\t...\n}\n```\n\n__Future\\<?\\> submit(Runnable task) :__\n\n它的返回值实际上是Future\\<Void\\>,子线程是不会返回数据的。\n\n__\\<T\\> Future\\<T\\> submit(Runnable task, T result) :__\n\n这个方法是不是很蛋疼,返回的结果在调用的时候已经给出了。如果我一开始就知道结果那我为什么又要发起子线程呢？\n\n其实不然,这个result可以是一个代理,它不是实际的结果,它只是存储了结果。我这里给出一个例子大家体会一下吧:\n\n```\nfinal String[] result = new String[1];\n\nRunnable r = new Runnable() {\n    public void run() {\n        result[0] = \"hello world\";\n    }\n};\n\nFuture<String[]> future = Executors.newSingleThreadExecutor().submit(r, result);\n    \ntry {\n    System.out.println(\"result[0]: \" + future.get()[0]);\n} catch (InterruptedException e) {\n    e.printStackTrace();\n} catch (ExecutionException e) {\n    e.printStackTrace();\n}\n```\n\n__\\<T\\> Future\\<T\\> submit(Callable\\<T\\> task) :__\n\n这个方法就比较好理解了, Callable.call()方法在子线程中被调用,同时它有返回值,只有将加载的数据直接return出来就好:\n\n```\nFuture<String> future = Executors.newSingleThreadExecutor()\n        .submit(new Callable<String>() {\n            @Override\n            public String call() throws Exception {\n                return \"Hello World\";\n            }\n        });\n\ntry {\n    System.out.print(future.get());\n} catch (InterruptedException e) {\n    e.printStackTrace();\n} catch (ExecutionException e) {\n    e.printStackTrace();\n}\n```\n\n# 一个实际的例子\n\n比如我们在计算两个List\\<Integer\\>中的数的总和的时候就可以用Future模式提高效率:\n\n```\npublic int getTotal(final List<Integer> a, final List<Integer> b) throws ExecutionException, InterruptedException {\n    Future<Integer> future = Executors.newCachedThreadPool().submit(new Callable<Integer>() {\n        @Override\n        public Integer call() throws Exception {\n            int r = 0;\n            for (int num : a) {\n                r += num;\n            }\n            return r;\n        }\n    });\n\n    int r = 0;\n    for (int num : b) {\n        r += num;\n    }\n    return r + future.get();\n}\n```\n","tags":["技术相关","java"]},{"title":"Java多线程 - 线程池","url":"/2017/09/05/Java多线程-线程池/","content":"\n这篇文章大部分都是直接摘抄自《实战Java高并发程序设计》,基本上就是一篇笔记,用于以后忘了的时候可以回顾。\n\n# 框架提供的ExecutorService\n\nExecutors框架提供了各种类型的线程池,主要有以下工厂方法:\n\n```\npublic static ExecutorService newFixedThreadPool(int nThreads) \npublic static ExecutorService newSingleThreadExecutor()\npublic static ExecutorService newCachedThreadPool()\npublic static ScheduledExecutorService newSingleThreadScheduledExecutor()\npublic static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)\n```\n\n- newFixedThreadPool()方法. 该方法返回一个固定线程数量的线程池,该线程池中的线程数量始终不变,当有一个新任务时,线程池中若有空闲线程,则立即执行,若没有,则新任务会被暂时存在一个队列中,得有空闲线程时,便处理在任务队列中的任务\n\n- newSingleThreadExecutor()方法,改方法返回一个只有一个线程的线程池,若多余一个任务被提交到该线程池,任务会被保存在一个队伍队列,带线程空闲,按先入先出的顺序执行队列中的任务,\n\n- newCachedThreadPool()方法,该方法返回一个可根据实际情况调整线程数量的线程池.线程池数量是不确定的,但若有空闲线程可以复用,则会优先使用可以复用的线程,若所有线程均在工作,又有新的任务提交,则会创建新的线程处理任务,所有线程在当前任务执行完毕后,将返回线程池进行复用,\n\n- newSingleThreadScheduledExecutor()方法: 改方法返回一个ScheduledExecutorService对象,线程池大小为1 这个接口在ExecutorService接口之上拓展了在给定时间执行某任务的功能,如在某个固定的延时之后执行,或者周期性执行某个任务.\n\n- newScheduledThreadPool()方法:改方法也返回一个ScheduledExecutorService对象 但改线程池可以指定线程数量\n\n前面三个工厂方法创建的ExecutorService只需要使用ExecutorService.execute()方法或者submit()方法将需要执行的任务传入即可,这里就不细讲了。关于这两个方法的差异我会在后面细说,这里也不展开讨论了。\n\n后面两个工厂方法会创建ScheduledExecutorService。它有会多出下面三个schedule方法用于延迟执行任务:\n\n```\npublic ScheduledFuture<?> schedule(Runnable command,\n                                   long delay, TimeUnit unit);\npublic ScheduledFuture<?> scheduleAtFixedRate(Runnable command,\n                                              long initialDelay,\n                                              long period,\n                                              TimeUnit unit);\npublic ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,\n                                                 long initialDelay,\n                                                 long delay,\n                                                 TimeUnit unit);\n```\n\nschedule()方法会在给定时间,对方法进行一次调度。scheduleAtFixedRate()方法和scheduleWithFixedDelay()会对任务进行周期性调度。但两者有一点小小的差别:\n\n{% img /Java多线程-线程池/1.png %}\n\n对于FixedRate方式来说,任务调度的频率是一样的。它是以上一个任务开始执行时间为起点,之后的period时间,调度下一次任务。而FixDelay则是在上一个任务结束后,再经过delay时间进行任务调度。\n\n# ThreadPoolExecutor\n\n对于Executors.newFixedThreadPool()、Executors.newSingleThreadExecutor()、Executors.newCachedThreadPool()这几个方法虽然创建的线程池的功能特点完全不一样,但是他们其实都是使用了ThreadPoolExecutor实现:\n\n```\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\n    \npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue<Runnable>()));\n}\n\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue<Runnable>());\n}\n```\n\nThreadPoolExecutor的最重要的构造函数如下:\n\n```\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler)  \n```\n\n- corePoolSize: 指定了线程池中的线程数量\n- maximumPoolSize: 指定了线程池中的最大线程数量\n- keepAliveTime: 当线程池线程数量超过corePoolSize时,多余的空闲线程的存活时间。即,超过corePoolSize的空闲线程,在多长的时间内,会被销毁。\n- unit: keepAliveTime的时间单位\n- workQueue: 被提交但未被执行的任务\n- threadFactory: 线程工厂,用于创建线程,一般用默认即可\n- handler: 拒绝策略。但任务太多来不及处理,如何拒绝任务\n\n以上参数中,大部分都很简单,只有workQueue和handler需要说一下。\n\n内置的BlockingQueue有下面几种:\n\n- SynchronousQueue: 一个没有容量的队列。使用SynchronousQueue,提交的任务不会真正的被保存,而总是将新任务提交给线程执行。如果没有空闲线程,就创建新线程,如果线程数量已经到达最大值,则执行拒绝策略\n\n- ArrayBlockingQueue: 有界任务队列,若有新的任务需要执行,如果实际线程数少于corePoolSize则创建新的线程,如果大于corePoolSize,就会放入ArrayBlockingQueue中,如果ArrayBlockingQueue已满,在总线程数不大于maximumPoolSize的情况下会创建新线程,否则就执行拒绝策略\n\n- LinkedBlockingQueue: 无界任务队列,若有新的任务需要执行,如果实际线程数少于corePoolSize则创建新的线程,如果大于corePoolSize,就会放入LinkedBlockingQueue中等待\n\n- PriorityBlockingQueue: 它是一个特殊的无界队列,可以设定任务的优先级\n\n而内置的拒绝策略又有下面几种:\n\n- AbortPolicy策略: 该策略会直接抛出异常,阻止系统正常工作\n- CallerRunsPolicy策略: 只要线程池没有关闭,该策略直接在调用者线程中运行被拒绝的任务。(使用这个策略可能导致在主线程执行耗时操作)\n- DiscardOldestPolicy策略: 该策略丢弃一个最老的任务,并尝试重新提交任务\n- DiscardPolicy策略: 该策略默默丢弃拒绝的任务,不做任何处理。\n\n\n线程池任务调度的逻辑如下图所示:\n\n\n{% img /Java多线程-线程池/2.png %}\n\n# execute和submit的区别\n\nExecutorService.execute()和ExecutorService.submit()都可以提交任务去异步执行,但是它们之间有什么区别呢？\n\n```\nvoid execute(Runnable command);\nFuture<?> submit(Runnable task);\n<T> Future<T> submit(Callable<T> task);\n```\n\n- 返回值\n\nExecutorService.execute()没有返回值,只能简单的提交Runnable给线程池去运行\n\nExecutorService.submit(),有返回值,可以获得一个Future\n\n- 异常\n\nExecutorService.execute()的异常机制和普通线程的异常机制一样,必须用try、catch来捕获异常。如果没有捕获一些运行时异常,也会打印出堆栈信息:\n\n```\nExecutors.newCachedThreadPool().execute(\n        new Runnable() {\n            @Override\n            public void run() {\n                int i = 1 / 0;\n            }\n        }\n);\n```\n```\nException in thread \"pool-1-thread-1\" java.lang.ArithmeticException: / by zero\n```\n\nExecutorService.submit()的异常会被吃掉,下面的代码的异常会被默默吃掉,没有堆栈信息的打印:\n\n```\nExecutors.newCachedThreadPool().submit(\n        new Runnable() {\n            @Override\n            public void run() {\n                int i = 1 / 0;\n            }\n        }\n);\n```\n但是我们可以调用Future.get()方法,这样当抛出异常的时候系统也会打印堆栈:\n\n```\nFuture future = Executors.newCachedThreadPool().submit(\n        new Runnable() {\n            @Override\n            public void run() {\n                int i = 1 / 0;\n            }\n        }\n);\nfuture.get();\n```\n\n需要注意的是Future.get()是阻塞的,需要需要等待线程执行完毕才会返回,所以我们可以用这个方法获得Callable.call()的返回值:\n\n```\nFuture<Integer> future = Executors.newCachedThreadPool().submit(\n        new Callable<Integer>() {\n            @Override\n            public Integer call() throws Exception {\n                return 123;\n            }\n        }\n);\nSystem.out.println(future.get());\n```","tags":["技术相关","java"]},{"title":"Java多线程 - 各种线程锁","url":"/2017/08/31/Java多线程-各种线程锁/","content":"\n多个线程同时对同一个对象进行读写操作,很容易会出现一些难以预料的问题。所以很多时候我们需要给代码块加锁,同一时刻只允许一个线程对某个对象进行操作。多线程之所以会容易引发一些难以发现的bug,很多时候是写代码的程序员对线程锁不熟悉或者干脆就没有在必要的地方给线程加锁导致的。这里我想总结一下java多线程中的各种锁的作用和用法,还有容易踩的坑。\n\n这篇文章里面有很多的文字和代码都来自于《实战Java高并发程序设计》。它真的是一本很不错的书,建议大家有空可以去看一下。\n\n# synchronized关键字\n\n## synchronized的作用\n\n关键字synchronized的作用是实现线程间的同步。它的工作是对同步的代码加锁,使得每一次,只能有一个线程进入同步块,从而保证线程间的安全性。\n\n关键字synchronized可以有多张用法,这里做一个简单的整理:\n\n> 指定加锁对象:对给定对象加锁,进入同步代码前要获取给定对象的锁。  \n> 直接作用于实例方法:相当于给当前实例加锁,进入同步代码块前要获得当前实例的锁。  \n> 直接作用于静态方法:相当于对当前类加锁,进入同步代码前要获取当前类的锁。\n\n下面来分别说一下上面的三点:\n\n假设我们有下面这样一个Runnable,在run方法里对__静态__成员变量sCount自增10000次:\n\n```\nclass Count implements Runnable {\n    private static int sCount = 0;\n\n    public static int getCount() {\n        return sCount;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10000; i++) {\n            sCount++;\n        }\n    }\n}\n```\n\n假设我们在两个Thread里面同时跑这个Runnable:\n\n```\nCount count = new Count();\nThread t1 = new Thread(count);\nThread t2 = new Thread(count);\nt1.start();\nt2.start();\ntry {\n    t1.join();\n    t2.join();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\nSystem.out.print(Count.getCount());\n```\n\n得到的结果并不是20000,而是一个比20000小的数,如14233。\n\n这是为什么呢？假设两个线程分别读取sCount为0,然后各自技术得到sCount为1,并先后写入这个结果,因此,虽然sCount++执行了2次,但是实际sCount的值只增加了1。\n\n我们可以用指定加锁对象的方法解决这个问题,这里因为两个Thread跑的是同一个Count实例,所以可以直接给this加锁:\n\n```\nclass Count implements Runnable {\n    private static int sCount = 0;\n\n    public static int getCount() {\n        return sCount;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10000; i++) {\n            synchronized (this) {\n                sCount++;\n            }\n        }\n    }\n}\n```\n\n我们也可以给实例方法加锁,这种方式和上面那一种的区别就是给this加锁,锁的区域比较小,两个线程交替执行sCount++操作,而给方法加锁的话,先拿到锁的线程会连续执行1000次sCount自增,然后再释放锁给另一个线程。\n\n```\nclass Count implements Runnable {\n    private static int sCount = 0;\n\n    public static int getCount() {\n        return sCount;\n    }\n\n    @Override\n    public synchronized void run() {\n        for (int i = 0; i < 10000; i++) {\n            sCount++;\n        }\n    }\n}\n```\n\nsynchronized直接作用于静态方法的用法和上面的给实例方法加锁类似,不过它是作用于静态方法:\n\n```\nclass Count implements Runnable {\n    private static int sCount = 0;\n\n    public static int getCount() {\n        return sCount;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10000; i++) {\n            increase();\n        }\n    }\n\n    private static synchronized void increase() {\n        sCount++;\n    }\n}\n```\n\n## 等待(wait)和通知(notify)\n\nObject有两个很重要的接口:Object.wait()和Object.notify()\n\n当在一个对象实例上调用了wait()方法后,当前线程就会在这个对象上等待。直到其他线程调用了这个对象的notify()方法或者notifyAll()方法。notifyAll()方法与notify()方法的区别是它会唤醒所有正在等待这个对象的线程,而notify()方法只会随机唤醒一个等待该对象的线程。\n\nwait()、notify()和notifyAll()都需要在synchronized语句中使用:\n\n```\nclass MyThread extends Thread {\n    private Object mLock;\n\n    public MyThread(Object lock) {\n        this.mLock = lock;\n    }\n\n    @Override\n    public void run() {\n        super.run();\n\n        synchronized (mLock) {\n            try {\n                mLock.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            System.out.println(\"in MyThread\");\n        }\n    }\n}\n```\n\n```\nObject lock = new Object();\nMyThread t = new MyThread(lock);\nt.start();\n\nSystem.out.println(\"before sleep\");\n\ntry {\n    Thread.sleep(2000);\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n\nSystem.out.println(\"after sleep\");\n\nsynchronized (lock) {\n    lock.notify();\n}\n\ntry {\n    t.join();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n```\n\n从上面的例子可以看出来,在调用wait()方法实际上已经释放了对象的锁,所以在其他线程中才能获取到这个对象的锁,从而进行notify操作。而等待的线程被唤醒后又需要重新获得对象的锁。\n\n## synchronized容易犯的隐蔽错误\n\n### 是否给同一个对象加锁\n\n在用synchronized给对象加锁的时候需要注意加锁是不是同一个,如将代码改成这样:\n\n```\nThread t1 = new Thread(new Count());\nThread t2 = new Thread(new Count());\nt1.start();\nt2.start();\ntry {\n    t1.join();\n    t2.join();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\nSystem.out.print(Count.getCount());\n```\n\n因为两个线程跑的是不同的Count实例,所以用给指定对象加锁和给实例方法加锁的方法都不能避免两个线程同时对__静态__成员变量sCount进行自增操作。\n\n但是如果用第三种作用于静态方法的写法,就能正确的加锁。\n\n### 是否给错误的对象加锁\n\n如我们将sCount的类型改成Integer,并且在sCount++的时候直接对sCount加锁会发生什么事情呢(毕竟我们会很自然的给要操作的对象加锁来实现线程同步)？\n\n```\nclass Count implements Runnable {\n    private static Integer sCount = 0;\n\n    public static int getCount() {\n        return sCount;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10000; i++) {\n            synchronized (sCount) {\n                sCount++;\n            }\n        }\n    }\n}\n```\n\n```\nCount count = new Count();\nThread t1 = new Thread(count);\nThread t2 = new Thread(count);\nt1.start();\nt2.start();\ntry {\n    t1.join();\n    t2.join();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\nSystem.out.print(Count.getCount());\n```\n\n最后的得到的结果仍然是比20000小的值。\n\n这是为什么呢？《实战Java高并发程序设计》中给出的解释是这样的:\n\n> 在Java中,Integer使用不变对象。也就是对象一旦被创建,就不可能被修改。也就是说,如果你有一个Integer代表1,那么它就永远是1,你不可能改变Integer的值,使它位。那如果你需要2怎么办呢？也很简单,新建一个Integer,并让它表示2即可。\n\n也就是说sCount在真实执行时变成了:\n\n> sCount = Integer.valueOf(sCount.intValue()+1);\n\n进一步看Integer.valueOf()，我们可以看到:\n\n```\npublic static Integer valueOf(int i) {\n    assert IntegerCache.high >= 127;\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n```\n\n所以在多个线程中,由于sCount一直在变,并不是同一个对象,所以两个线程的加锁可能加在了不同的Integer对象上,并没有真正的锁住代码块。\n\n我再举一个例子:\n\n```\npublic void increase(Integer integer){\n    integer++;\n}\n```\n\n在外面这样调用它,并不会使得传入的Integer增加:\n\n```\nInteger i = 0;\nincrease(i);\n```\n\n# 重入锁\n\nReentrantLock的意思是Re-Entrant-Lock也就是重入锁,它的特点就是在同一个线程中可以重复加锁,只需要解锁同样的次数就能真正解锁:\n\n```\nclass MyThread extends Thread {\n    private ReentrantLock mLock = new ReentrantLock();\n\n    @Override\n    public void run() {\n        super.run();\n\n        mLock.lock();\n        System.out.println(\"outside\");\n\n        mLock.lock();\n        System.out.println(\"inside\");\n        mLock.unlock();\n\n        mLock.unlock();\n    }\n}\n```\n\n事实上synchronized也是可重入的,比如下面的代码同样是可以正常退出的:\n\n```\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        super.run();\n        synchronized (this) {\n            System.out.println(\"outside\");\n            synchronized (this) {\n                System.out.println(\"inside\");\n            }\n        }\n    }\n}\n```\n\n与synchronized相比,重入锁需要程序员手动调用加锁和解锁,也因为如此,重入锁对逻辑控制的灵活性要远远好于synchronized。\n\n重入锁可以完全替代synchronized关键字。在JDK 5.0的早起版本中,重入锁的性能远远好于synchronized。但从JDK 6.0开始,JDK在synchronized做了大量优化,使得两者的性能差距并不大。\n\n## ReentrantLock是可中断的\n\n对于synchronized,如果它在等待锁,那么它就只有两个状态:获得锁继续执行或者保持等待。但是对于重入锁,就有了另外一种可能,那就是重入锁在等待的时候可以被中断:\n\n```\nclass MyThread extends Thread {\n    private ReentrantLock mLock = new ReentrantLock();\n\n    @Override\n    public void run() {\n        super.run();\n\n        try {\n            mLock.lockInterruptibly();\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }finally {\n            if(mLock.isHeldByCurrentThread()){\n                mLock.unlock();\n            }\n        }\n    }\n}\n```\n\n## ReentrantLock可以设置等待限时\n\nReentrantLock.tryLock()方法可以给等待锁设置最长等待时间,如果在设置的时间结束之前获取到锁就会返回true,否则返回false:\n\n```\nclass MyThread extends Thread {\n    private ReentrantLock mLock = new ReentrantLock();\n\n    @Override\n    public void run() {\n        super.run();\n\n        try {\n            if (mLock.tryLock(2, TimeUnit.SECONDS)) {\n                try {\n                    Thread.sleep(5000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            if (mLock.isHeldByCurrentThread()) {\n                mLock.unlock();\n            }\n        }\n    }\n}\n```\n\nReentrantLock.tryLock()也可以不带参数直接运行。在这种情况下,当前线程会尝试获得锁,如果锁并未被其他线程占用,则申请锁会成功,并立即返回true。如果锁被其他线程占用,则当前线程不会进行等待,而是立即返回false。\n\n## ReentrantLock可以设置公平锁\n\n大多数情况下,锁的申请是非公平的。也就是说,线程1首先请求了锁A，接着线程2也请求了锁A。那么当锁A可用时,是线程1可以获得锁还是线程2可以获得锁呢？这是不一定的。系统只是会从这个锁的等待队列里随机挑选一个:\n\n```\nclass MyThread extends Thread {\n    private ReentrantLock mLock;\n\n    public MyThread(String name, ReentrantLock lock) {\n        super(name);\n        this.mLock = lock;\n    }\n\n    @Override\n    public void run() {\n        super.run();\n\n        while (true) {\n            mLock.lock();\n            System.out.println(Thread.currentThread().getName() + \"获得锁\");\n            mLock.unlock();\n        }\n    }\n}\n```\n\n```\nReentrantLock lock = new ReentrantLock();\nMyThread t1 = new MyThread(\"t1\", lock);\nt1.start();\n\nMyThread t2 = new MyThread(\"t2\", lock);\nt2.start();\n\ntry {\n    t1.join();\n    t2.join();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n```\n\n打印如下:\n\n```\nt1获得锁\nt2获得锁\nt2获得锁\nt2获得锁\nt1获得锁\nt2获得锁\nt2获得锁\nt1获得锁\nt2获得锁\nt1获得锁\nt2获得锁\nt2获得锁\nt2获得锁\nt1获得锁\nt1获得锁\n```\n\nsynchronized产生的锁也是非公平的。但如果使用ReentrantLock(boolean fair)构造函数创建ReentrantLock,并且传入true。则该重入锁是公平的:\n\n```\nReentrantLock lock = new ReentrantLock(true);\nMyThread t1 = new MyThread(\"t1\", lock);\nt1.start();\n\nMyThread t2 = new MyThread(\"t2\", lock);\nt2.start();\n\ntry {\n    t1.join();\n    t2.join();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n```\n\n打印如下:\n\n```\nt1获得锁\nt2获得锁\nt1获得锁\nt2获得锁\nt1获得锁\nt2获得锁\nt1获得锁\nt2获得锁\nt1获得锁\nt2获得锁\nt1获得锁\n```\n\n需要注意的是实现公平锁必然要求系统维护一个有序队列,所以公平锁的实现成本较高,性能也相对低下,因此,默认情况下,锁是非公平的。\n\n## ReentrantLock可以与Condition配合使用\n\nCondition和之前讲过的Object.wait()还有Object.notify()的作用大致相同:\n\n```\nclass MyThread extends Thread {\n\tprivate ReentrantLock mLock;\n\tprivate Condition mCondition;\n\t\n\tpublic MyThread(ReentrantLock lock, Condition condition) {\n\t    this.mLock = lock;\n\t    this.mCondition = condition;\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t    super.run();\n\t\n\t    mLock.lock();\n\t    try {\n\t        mCondition.await();\n\t    } catch (InterruptedException e) {\n\t        e.printStackTrace();\n\t    }\n\t    mLock.unlock();\n\t\n\t    System.out.println(\"in MyThread\");\n\t}\n}\n```\n\n```\nReentrantLock lock = new ReentrantLock();\nCondition condition = lock.newCondition();\nMyThread t = new MyThread(lock, condition);\nt.start();\n\nSystem.out.println(\"before sleep\");\ntry {\n    Thread.sleep(2000);\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\nSystem.out.println(\"after sleep\");\n\nlock.lock();\ncondition.signal();\nlock.unlock();\n\ntry {\n    t.join();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n```\n\nCondition的操作需要在ReentrantLock.lock()和ReentrantLock.unlock()之间进行的。\n\nReentrantLock.newCondition()可以创建一个Condition。Condition.await()方法相当于Object.wait()方法,而Condition.signal()方法相当于Object.notify()方法。当然它也有对应的Condition.signalAll()方法。\n\n同样的在调用Condition.await()之后,线程占用的锁会被释放。这样在Condition.signal()方法调用的时候才获取到锁。\n\n需要注意的是Condition.signal()方法调用之后,被唤醒的线程因为需要重新获取锁。所以需要等到调用Condition.signal()的线程释放了锁(调用ReentrantLock.unlock())之后才能继续执行。\n\n\nCondition接口的基本方法如下,它提供了限时等待、不可中断的等待之类的操作:\n\n```\nvoid await() throws InterruptedException;\nvoid awaitUninterruptibly();\nlong awaitNanos(long nanosTimeout) throws InterruptedException;\nboolean await(long time, TimeUnit unit) throws InterruptedException;\nboolean awaitUntil(Date deadline) throws InterruptedException;\nvoid signal();\nvoid signalAll();\n```\n\n# 信号量\n\n信号量为多线程协作提供了更为强大的控制方法。广义上说,信号量是对锁的拓展。无论是synchronize还是重入锁,一次都只运行一个线程访问一个资源,而信号锁则可以指定多个线程,同时访问某一个资源。\n\n像下面的代码, MyRunnable被加锁的代码块一次会被5个线程执行:\n\n```\npublic class MyRunnable implements Runnable {\n    private Semaphore mSemaphore;\n\n    public MyRunnable(Semaphore semaphore) {\n        mSemaphore = semaphore;\n    }\n\n    @Override\n    public void run() {\n        try {\n            mSemaphore.acquire();\n            Thread.sleep(2000);\n            System.out.println(\"thread \" + Thread.currentThread().getId() + \" working\");\n            mSemaphore.release();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n```\n Semaphore semaphore = new Semaphore(5);\nfor (int i = 0; i < 19; i++) {\n    new Thread(new MyRunnable(semaphore)).start();\n}\n\nThread t = new Thread(new MyRunnable(semaphore));\nt.start();\nt.join();\n```\n\nSemaphore.acquire()方法尝试获得一个准入许可。如无法获得,线程就会等待。而Semaphore.release()则在线程访问资源结束后,释放一个许可。\n\nSemaphore有下面的一些常用方法:\n\n```\npublic Semaphore(int permits)\npublic Semaphore(int permits, boolean fair)\npublic void acquire() \npublic void acquireUninterruptibly()\npublic boolean tryAcquire()\npublic boolean tryAcquire(long timeout, TimeUnit unit)\npublic void release()\n```\n\n# 其他的一些锁\n\n## 读写锁\n\n读写锁(ReadWriteLock)是JDK5中提供的分离锁。读写分离锁可以有效的减少锁竞争。\n\n读写锁允许多个线程同时读,但是写写操作和读写操作就需要相互等待了。读写锁的访问约束如下:\n\n||读|写|\n|:-:|:-:|:-:|\n|读|非阻塞|阻塞|\n|写|阻塞|阻塞|\n\n读写操作在某些特定操作下可以提高程序的性能,如下面的代码。如果使用重入锁,需要十一秒左右才能运行完:\n\n```\npublic class Data {\n    private String mData = \"data\";\n    private ReentrantLock mLock = new ReentrantLock();\n\n    public String readData(){\n        mLock.lock();\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"read data : \" + mData);\n        String data = mData;\n        mLock.unlock();\n        return data;\n    }\n\n    public void writeData(String data){\n        mLock.lock();\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        mData = data;\n        System.out.println(\"write data : \" + mData);\n        mLock.unlock();\n    }\n}\n```\n\n```\nfinal Data data = new Data();\nfor (int i = 0; i < 10; i++) {\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            data.readData();\n        }\n    }).start();\n}\n\nThread write = new Thread(new Runnable() {\n    @Override\n    public void run() {\n       data.writeData(\"update data\");\n    }\n});\nwrite.start();\n```\n\n但是如果将重入锁改成读写锁的话只需要两秒左右就能完成:\n\n```\npublic class Data {\n    private String mData = \"data\";\n    private ReadWriteLock mLock = new ReentrantReadWriteLock();\n    private Lock mReadLock = mLock.readLock();\n    private Lock mWriteLock = mLock.writeLock();\n\n    public String readData(){\n        mReadLock.lock();\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        String data = mData;\n        System.out.println(\"read data : \" + mData);\n        mReadLock.unlock();\n        return data;\n    }\n\n    public void writeData(String data){\n        mWriteLock.lock();\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"write data : \" + mData);\n        mData = data;\n        mWriteLock.unlock();\n    }\n}\n```\n\n# 倒计时器、循环栅栏\n\n\n倒计时器(CountDownLatch)和循环栅栏(CyclicBarrier)因为比较不常用,所以这里就不讲了,有兴趣的同学可以自己去看一下《实战Java高并发程序设计》这本书。\n","tags":["技术相关","java"]},{"title":"用PowerMock进行Android单元测试与BDD行为驱动开发","url":"/2017/08/26/用PowerMock进行Android单元测试与BDD行为驱动开发/","content":"\n很久之前就有听说过mockito和PowerMock的大名了,无奈我司写单元测试的风气不浓,加上一直以来业务繁忙,惰性使我一直没有写单元测试的习惯。\n\n正好现在手头上的是一个全新的项目,可以在初期有时间也有冲动将各种需要的东西都用上。于是这几天就好好学习了一番,感觉PowerMock的确是无比强大。\n\n# 什么是mock\n\n维基百科上是这么写的:\n\n> 在面向对象程序设计中，模拟对象（英语：mock object，也译作模仿对象）是以可控的方式模拟真实对象行为的假的对象。程序员通常创造模拟对象来测试其他对象的行为，很类似汽车设计者使用碰撞测试假人来模拟车辆碰撞中人的动态行为。  \n> 在单元测试中，模拟对象可以模拟复杂的、真实的（非模拟）对象的行为， 如果真实的对象无法放入单元测试中，使用模拟对象就很有帮助。\n\n如果我们使用依赖注入的方式编写代码,例如Context通常都是外部传入的:\n\n```\nclass ClassA{\n\tpublic static boolean staticFunc(Context context, int arg) {\n\t\t...\n\t}\n}\n```\n\n这个方法如果不使用mock object的方法,我们很难脱离安卓环境去编写单元测试,因为Context是系统生成的。\n\n而使用mock技术去模拟一个Context出来,就可以在android studio中编写并且脱离安卓环境运行单元测试了。\n\n# PowerMock\n\n[powermock](https://github.com/powermock/powermock)是一个流行的java mock框架,通过它我们可以很方便的实现模拟对象。它实际上是继承并且拓展了EasyMock、Mockito等其他的流行框架。\n\n在android studio上导入powermock框架很简单,只需要在build.gradle中添加dependencies就好了:\n\n```\ndependencies {\n\t...\n    testCompile 'junit:junit:4.12'\n\n    testCompile 'org.powermock:powermock-core:1.6.1'\n    testCompile 'org.powermock:powermock-module-junit4:1.6.1'\n    testCompile 'org.powermock:powermock-module-junit4-rule:1.6.1'\n    testCompile 'org.powermock:powermock-api-mockito:1.6.1'\n}\n```\n\n这里有个坑点，之前我用的是1.5.6版本的powermock,但是我的junit是4.12版本的,于是在使用@RunWith(PowerMockRunner.class)的时候会报错:\n\n> org.powermock.reflect.exceptions.FieldNotFoundException: Field 'fTestClass' was not found in class org.junit.internal.runners.MethodValidator.\n\n到stackoverflow上搜索到国外大神的[回答](https://stackoverflow.com/questions/26192929/unable-to-run-junit-test-with-powermockrunner)是powermock小于1.6.1的版本在使用junit 4.12的一个bug,在1.6.1被修复。所以要么用junit 4.12 + powermock 1.6.1,要么使用junit 4.11 + powermock 1.5.6.\n\n# mock的简单用法\n\n先说一下最近我拿到的一个需求。我们的应用的按钮点击启动其他应用的响应需要在服务器上配置。服务器上可能配的是包名启动应用,也可能是action启动应用,还有可能是Uri启动应用。\n\n所以我这样写了一个工具类:\n\n```\npublic class AppUtils {\n\tpublic static boolean startApp(Context context, StartAppParam param) {\n\t\t...\n\t}\n\t\n\t public static class StartAppParam {\n        private String packageName;\n        private String activity;\n        private String action;\n        private String uri;\n        private List<String> categorys = new ArrayList<>();\n        ...\n    }\n}\n```\n\n在服务器上配置一个json,传到客户端解析成StartAppParam,然后调用AppUtils. startApp方法。这样就可以实现这个需求了。\n\n我们使用TDD的方式开发这个功能。首先考虑只配置Action的方式启动:\n\n```\n@Test\n    public void testOpenAppByAction() {\n\t\tContext context = Mockito.mock(Context.class);\n\t\t\n\t\tAppUtils.StartAppParam param = Mockito.mock(AppUtils.StartAppParam.class);\n\t\tPowerMockito.when(param.getAction()).thenReturn(\"package\");\n\t\t\n\t\tassertTrue(AppUtils.startApp(context, param));\n\t\t    \n\t\tMockito.verify(context, Mockito.times(1)).startActivity(Matchers.any(Intent.class));\n    }\n```\n\n首先,使用Mockito.mock方法可以创建一个模拟对象出来。我们这里使用模拟的Context就可以直接在android studio中运行单元测试了。\n\n同时param也用mock的方式创建了出来,而且还模拟了它的getAction方法,让该方法返回\"package\",表示配置了使用Action去启动应用:\n\n```\nAppUtils.StartAppParam param = Mockito.mock(AppUtils.StartAppParam .class);\nPowerMockito.when(param.getAction()).thenReturn(\"package\");\n```\n\n\n然后Mockito.verify方法可以用来验证调用了方法的调用次数,比如这里我们就验证了startActivity被调用了一次。\n\n# mock 方法内部创建的对象\n\n当然这个测试不充分,因为我们没有验证到底是不是通过Action启动的。也就是说我们还需要判断是不是通过new Intent(param.getAction())的方式创建了一个Intent出来。\n\n这就用到了PowerMock的一个很屌的功能了,它不仅可以在外部mock一个对象通过参数传给需要测试的方法,更可以直接mock方法内部创建的对象(比如这里的Intent)!\n\n```\n@RunWith(PowerMockRunner.class)\npublic class AppUtilsTest {\n\n    @Test\n    @PrepareForTest({AppUtils.class})\n    public void testOpenAppByAction() throws Exception {\n        Intent intent = Mockito.mock(Intent.class);\n        PowerMockito.whenNew(Intent.class).withArguments(\"package\").thenReturn(intent);\n\n        Context context = Mockito.mock(Context.class);\n\n        AppUtils.StartAppParam param = Mockito.mock(AppUtils.StartAppParam.class);\n        PowerMockito.when(param.getAction()).thenReturn(\"package\");\n\n        assertTrue(AppUtils.startApp(context, param));\n        \n        Mockito.verify(context, Mockito.times(1)).startActivity(intent);\n        Mockito.verify(intent, Mockito.times(0)).setData(Matchers.any(Uri.class));\n        Mockito.verify(intent, Mockito.times(0)).addCategory(Matchers.anyString());\n        Mockito.verify(intent, Mockito.times(0)).setClassName(Matchers.anyString(), Matchers.anyString());\n    }\n}\n```\n\n首先需要用@RunWith(PowerMockRunner.class)注解AppUtilsTest类,用@PrepareForTest({AppUtils.class})注解testOpenAppByAction方法,传入的AppUtils.class表示需要在AppUtils类内部实现mock操作。\n\n然后mock一个Intent出来,接着使用下面的方法使得使用new Intent(\"package\")得到的Intent是我们mock出来的intent,注意这里连传入的\"package\"参数也需要匹配才能得到我们mock出来的intent。否则只能得到null:\n\n```\nPowerMockito.whenNew(Intent.class).withArguments(\"package\").thenReturn(intent);\n```\n\n所以我们在后面只需要验证startActivity调用的intent是不是我们mock出来的对象,就可以验证是不是通过Action启动的应用了:\n\n```\nMockito.verify(context, Mockito.times(1)).startActivity(intent);\n```\n\n当然,为了保险我们可以顺便确认一下Intent的其他方法是不是没有被调用到:\n\n```\nMockito.verify(intent, Mockito.times(0)).setData(Matchers.any(Uri.class));\nMockito.verify(intent, Mockito.times(0)).addCategory(Matchers.anyString());\nMockito.verify(intent, Mockito.times(0)).setClassName(Matchers.anyString(), Matchers.anyString());\n```\n\n# 使用BDD的方式编写单元测试\n\nBDD (Behavior-driven development,行为驱动开发)通过用自然语言书写非程序员可读的测试用例扩展了测试驱动开发方法。也就是说用bdd方式写的代码就连不是程序员的人也能看得懂,这种可读性的重要性就不用我多费口舌了吧。\n\n其实Mockito的BDD方式的写法我觉得并不是特别的像自然语言。所以我想用C++的单元测试框架Catch框架来举例:\n\n```\nGIVEN(\"a enable stub publish server entry\") {\n    StubPublishServerEntry entry(true);\n\tentry.Start();\n\n    WHEN(\"publish service\") {\n        entry.PublishService(service, on_result, on_success, on_error);\n\n        THEN(\"publish successfully\") {\n            REQUIRE(service_entry != nullptr);\n            REQUIRE(service_entry->IsPublished());\n            REQUIRE(is_on_success);\n            REQUIRE_FALSE(is_on_error);\n        }\n    }\n}\n```\n\n这是我之前的半成品项目中的一个代码片段。如果将代码部分去掉,只留下GIVEN、WHEN、THEN三个宏里面的东西,基本只有是懂英语的人都能看得懂这段代码想做什么:\n\n```\nGIVEN(\"a enable stub publish server entry\") {\n    ...\n    WHEN(\"publish service\") {\n        ...\n        THEN(\"publish successfully\") {\n            ...  \n        }\n    }\n}\n```\n\nPowerMock也是支持BDD的(应该说Mockito是支持BDD的),我们可以将上面写的测试用例改成BDD的写法:\n\n```\npublic void testOpenAppByAction() throws Exception {\n    Intent intent = Mockito.mock(Intent.class);\n    PowerMockito.whenNew(Intent.class).withArguments(\"package\").thenReturn(intent);\n\n    Context context = Mockito.mock(Context.class);\n\n    AppUtils.StartAppParam param = Mockito.mock(AppUtils.StartAppParam .class);\n\n    //given\n    BDDMockito.given(param.getAction()).willReturn(\"package\");\n\n    //when\n    assertTrue(AppUtils.startApp(context, param));\n\n    //then\n    BDDMockito.then(context).should().startActivity(intent);\n    BDDMockito.then(intent).should(Mockito.never()).setData(Matchers.any(Uri.class));\n    BDDMockito.then(intent).should(Mockito.never()).addCategory(Matchers.anyString());\n    BDDMockito.then(intent).should(Mockito.never()).setClassName(Matchers.anyString(), Matchers.anyString());\n}\n```\n\n感觉是不是和自然语言还是差别蛮大的,我们改造改造,将一些方法改成通过import static的方式import:\n\n```\npublic void testOpenAppByAction() throws Exception {\n    Intent intent = mock(Intent.class);\n    whenNew(Intent.class).withArguments(\"package\").thenReturn(intent);\n\n    Context context = mock(Context.class);\n\n    AppUtils.StartAppParam param = mock(AppUtils.StartAppParam .class);\n\n    //given\n    given(param.getAction()).willReturn(\"package\");\n\n    //when\n    assertTrue(AppUtils.startApp(context, param));\n\n    //then\n    then(context).should().startActivity(intent);\n    then(intent).should(never()).setData(any(Uri.class));\n    then(intent).should(never()).addCategory(anyString());\n    then(intent).should(never()).setClassName(anyString(), anyString());\n}\n```\n\n这样是不是好多了？让我们继续改造:\n\n```\npublic class AppUtilsTest {\n    @Mock\n    private Intent mIntent;\n\n    @Mock\n    private Context mContext;\n\n    @Mock\n    private AppUtils.StartAppParam mParam;\n\n    @Before\n    public void setUp() throws Exception {\n        whenNew(Intent.class).withArguments(\"package\").thenReturn(mIntent);\n    }\n\n    @Test\n    @PrepareForTest({AppUtils.class})\n    public void testOpenAppByAction() {\n        given(mParam.getAction()).willReturn(\"package\");\n\n        //when\n        assertTrue(AppUtils.startApp(mContext, mParam));\n\n        then(mContext).should().startActivity(mIntent);\n        then(mIntent).should(never()).setData(any(Uri.class));\n        then(mIntent).should(never()).addCategory(anyString());\n        then(mIntent).should(never()).setClassName(anyString(), anyString());\n    }\n}\n```\n\n因为Intent、Context、AppUtils.StartAppParam都是需要在不同测试用例中经常被用到的,我们将它写成成员变量并且用@Mock实现自动mock,省去Mockito.mock()方法的调用。\n\n然后将whenNew方法放到由@Before注解的setUp()方法中。\n\n现在看testOpenAppByAction是不是简洁多了？只要有一点代码功底的人都能很容易看明白这个用例到底是用来验证什么的。\n\n当然,这里的BDD写法和上面Catch的写法比起来在像自然语言方面还是有点差距的。\n\n现在我们已经将测试用例写出来了，就可以开始写代码让这个测试用例通过了。像这样先写行为测试用例再写代码的开发方式就叫做BDD。\n\n\n# mock 静态方法\n\n我们下一个需要实现的功能是什么呢？就实现通过包名启动应用吧。将设只配置了包名,但没有配置Activity名。我们就需要先找到这个应用的Launch Activity,然后再去启动应用。\n\n所以我们在AppUtils中新增了一个方法,用于从包名获取Activity名:\n\n```\npublic class AppUtils {\n\tpublic static boolean startApp(Context context, StartAppParam param) {\n\t\t...\n\t}\n\t\n\tpublic static String getLaunchActivityByPackage(Context context, String packageName) {\n\t\treturn null;\n\t}\n}\n```\n\n如果是正常的开发流程我们需要写一个getLaunchActivityByPackage测试用例，再实现这个方法。这里我就省略了这步,让getLaunchActivityByPackage这个方法先不实现,直接返回null,测试的时候直接mock就好了。\n\n之后我们再去写startAppByPackage的测试用例:\n\n```\n@Test\npublic void startAppByPackage() {\n    mockStatic(AppUtils.class);\n\n    given(AppUtils.startApp(any(Context.class), any(AppUtils.StartAppParam.class)))\n            .willCallRealMethod();\n    given(AppUtils.getLaunchActivityByPackage(any(Context.class), anyString()))\n            .willReturn(\"LauncActivity\");\n    given(mParam.getPackageName()).willReturn(\"packageName\");\n\n    //when\n    assertTrue(AppUtils.startApp(mContext, mParam));\n\n    //then\n    verifyStatic(); //开启static方法的验证,需要开启才能验证AppUtils.getLaunchActivityByPackage是否被调用\n    AppUtils.getLaunchActivityByPackage(any(Context.class), eq(\"packageName\"));\n    then(mIntent).should().setClassName(mParam.getPackageName(), \"LauncActivity\");\n    then(mContext).should().startActivity(mIntent);\n}\n```\n\n首先我们使用mockStatic去模拟AppUtils,然后配置AppUtils.startApp调用实际的方法,而getLaunchActivityByPackage直接返回\"LauncActivity\"。\n\n在验证getLaunchActivityByPackage是否被调用的时候要先调用verifyStatic()。\n\n之后再用下面的方式验证是不是调用了AppUtils.getLaunchActivityByPackage并且传入了\"packageName\"\n\n```\nAppUtils.getLaunchActivityByPackage(any(Context.class), eq(\"packageName\"));\n```\n\n这里多说一点,假设getLaunchActivityByPackage是一个private的方法,我们可以用下面的方式去mock它:\n\n```\nwhen(AppUtils.class, \"getLaunchActivityByPackage\", any(Context.class), anyString())\n        .thenReturn(\"LauncActivity\");\n```\n\n\n# 完整Demo\n\n其他剩下的测试用例我就不一个一个去讲了,基本上通过之前对PowerMock用法的介绍大家也应该能自己实现了。\n\n完整的demo代码可以从[这里](https://github.com/bluesky466/UnitTestDemo)获取\n","tags":["技术相关","Android","单元测试"]},{"title":"Java多线程 - 如何正确的终止线程","url":"/2017/08/24/Java多线程-如何正确的终止线程/","content":"\n最近打算读一下《实战java高并发程序设计》，夯实一下java多线程的知识。接下来应该会写一系列的读书笔记,里面会有多处引用到书中的代码或者文字。本文就是第一篇。\n\n\n# 不推荐使用的stop方法\n\nThread.stop()是一个被废弃的方法,不被推荐使用的原因是stop方法太过于暴力，强行把执行到一半的线程终止,并且会立即释放这个线程所有的锁。会破坏了线程中引用对象的一致性。\n\n例如在数据库中维护着一张用户表，记录了用户ID和用户名，使用Thread多线程写入两条记录:\n\n```\n记录1: ID=1,NAME=小明  \n记录2: ID=2,NAME=小王\n```\n\n如果在记录1写到一半的时候被stop结束了，就可能出现各种奇怪的现象：\n\n1. 记录1被记录2覆盖，没有任何数据留下。\n2. 记录1只有一半，即只有ID，而NAME为空。\n3. 记录1和记录2混在同一条记录中，最后写入了一条一半是记录1一半是记录2的脏数据\n\n所以,除非你很确定你在做什么,否则不要轻易使用stop方法\n\n# 使用判断标志位的方法中断线程\n\n那如果的确有中断线程的需求,我们需要怎么做呢？一般我们马上就会想到设置标志位的方法,即在线程中执行每一个步骤之前都判断一下是否需要退出线程:\n\n```\nclass WorkThread extends Thread {\n    private boolean mExitThread = false;\n\n    public void exitThread() {\n        mExitThread = true;\n    }\n\n    @Override\n    public void run() {\n        if (mExitThread) {\n            return;\n        }\n        //do something\n\n        if (mExitThread) {\n            return;\n        }\n        //do something\n\n        if (mExitThread) {\n            return;\n        }\n        //do something\n    }\n}\n```\n\n其实Thread类早就帮我们实现了这个中断标志了。与Thread中断相关的方法有下面三个:\n\n\n> public void Thread.interrupt() //线程中断  \n> public native boolean Thread.isInterrupted() //判断是否被中断  \n> public static native boolean Thread.interrupted() //判断是否中断,并清除当前中断状态\n\n\n所以上面的代码可以改写成这样:\n\n```\nclass WorkThread extends Thread {\n    @Override\n    public void run() {\n        if (isInterrupted()) {\n            return;\n        }\n        //do something\n\n        if (isInterrupted()) {\n            return;\n        }\n        //do something\n\n        if (isInterrupted()) {\n            return;\n        }\n        //do something\n    }\n}\n```\n\n这个时候我们只需要调用Thread.interrupt()方法就能安全的中断线程了。\n\n需要提醒一下的是Thread.interrupt()方法并不会像Thread.stop()方法一样立即结束线程,它只是设置了一个中断标志,需要在代码实现中去手动判断这个标志并且退出。\n\n像下面这个代码就算调了Thread.interrupt()方法也不会中断线程:\n\n```\nclass WorkThread extends Thread {\n    @Override\n    public void run() {\n        while(true){\n        \t//do something\n        }\n    }\n}\n```\n\n# Thread.interrupt的优点\n\n使用Thread.interrupt去中断线程除了可以免去自己实现标志位的烦恼之外,还可以中断sleep和wait中的线程。\n\n还记得我们在调用Thread.sleep()这个方法的时候都需要catch或者在方法签名中抛出InterruptedException这个异常吗:\n\n```\ntry {\n    Thread.sleep(1000);\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n```\n\n这个InterruptedException异常就是由于我们调用了Thread.interrupt方法抛出的。所以Thread.interrupt可以打断Thread.sleep。同样Thread.wait也是可以被Thread.interrupt打断的。\n\n需要注意的是如果sleep方法由于中断而抛出异常，此时，它会__清除中断标记__。所以在catch到这个异常的时候__需要再次设置中断标记__：\n\n```\nThread t1 = new Thread() {\n    @Override\n    public void run(){\n        while(true){\n            if(Thread.currentThread().isInterrupted()){\n                break;\n            }\n\n            System.out.println(\"hello world\");\n            try{\n                Thread.sleep(1000);\n            }catch(InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n};\n```\n","tags":["技术相关","java"]},{"title":"安卓皮肤包机制的原理","url":"/2017/08/01/安卓皮肤包机制的原理/","content":"\n许多常见的应用都有换肤的功能,甚至支持用户自定义皮肤。如果将所有皮肤用到的资源都打包到apk里面不仅会使得apk的大小急剧上升,也会大大增加维护的难度。所以大部分的开发者都会选择将这些资源从apk中剥离出来放到其他地方。\n\n一种常用的方案就是将使用到的字符串、图片等资源打包到一个皮肤apk中，这个皮肤apk中只包含资源，没有任何的代码。主apk在启动之后从这个皮肤apk中加载资源，从而减少主apk的大小，同时也将不同皮肤的资源分别放到不同项目中，提高可维护性。\n\n# 获取皮肤apk的Resources\n\n我们都知道安卓应用的资源是通过Resources去管理的,只要能获取到皮肤apk的Resources,那么就能够读取到皮肤apk中的资源文件。\n\n## 方法一\n\n第一种获取Resources的方式是通过皮肤apk的Context去获取:\n\n\n```\nprivate Resources getResourcesByContext(Context context, String skinApkPackage) {\n        try {\n            return context.createPackageContext(skinApkPackage, Context.CONTEXT_IGNORE_SECURITY)\n                    .getResources();\n\n        } catch (PackageManager.NameNotFoundException e) {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n```\n\n这种方式很简单,但是却有一定的局限性。因为要使用这种方式去获取Resources,必须将皮肤apk也安装到系统。\n\n## 方法二\n\n第二种方法是通过获取皮肤apk的AssetManager,直接new一个Resources出来:\n\n\n```\nprivate Resources getResourcesByAssetManager(Context context, String skinApkPath) {\n        try {\n            Method method = AssetManager.class.getDeclaredMethod(\"addAssetPath\", String.class);\n            AssetManager assetManager = AssetManager.class.newInstance();\n            method.invoke(assetManager, skinApkPath);\n\n            return new Resources(\n                    assetManager,\n                    context.getResources().getDisplayMetrics(),\n                    context.getResources().getConfiguration()\n            );\n        } catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n```\n\n这种方向需要用到反射去调用AssetManager.addAssetPath,但是只需要将皮肤apk下载下来,并不需要安装也能读取到里面的资源。\n\n# 加载资源\n\n一般我们都是通过资源的id从Resources中加载资源的,但是当资源在其他apk里面的时候,我们没有办法直接通过R类知道资源的id,所以需要使用Resources的getIdentifier方法去获取id:\n\n```\npublic int getIdentifier(String name, String defType, String defPackage) {\n        return mResourcesImpl.getIdentifier(name, defType, defPackage);\n    }\n```\n\n获取到id之后就能直接加载资源了:\n\n```\npublic String getString(String name) {\n        int id = mResources.getIdentifier(name, \"string\", SKIN_APK_PACKAGE);\n        if (id == 0) {\n            return null;\n        }\n        return mResources.getString(id);\n    }\n\n\n    public Drawable getDrawable(String name) {\n        int id = mResources.getIdentifier(name, \"drawable\", SKIN_APK_PACKAGE);\n        if (id == 0) {\n            return null;\n        }\n        return mResources.getDrawable(id);\n    }\n```\n\n# Demo\n\n这个demo很简单\n\n首先新建一个皮肤应用项目,在皮肤应用项目中放入img.png和创建一个字符串:\n\n```\n<resources>\n    <string name=\"app_name\">Skin</string>\n    <string name=\"label\">hello world</string>\n</resources>\n```\n\n然后创建一个主应用项目在MainActivity中从皮肤apk加载图片和字符串显示出来\n\n```\npublic class MainActivity extends AppCompatActivity {\n    private final static String SKIN_APK_PACKAGE = \"demo.linjw.skin\";\n    private final static String SKIN_APK = \"skin-debug.apk\";\n\n    private SkinHelper mSkinHelper;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        //需要将皮肤apk安装到系统\n        mSkinHelper = new SkinHelper(this, SKIN_APK_PACKAGE);\n\n        //需要将皮肤apk放到存储卡根目录\n        //File skinApk = new File(Environment.getExternalStorageDirectory().getPath(), SKIN_APK);\n        //mSkinHelper = new SkinHelper(this, SKIN_APK_PACKAGE, skinApk);\n\n        TextView textView = (TextView) findViewById(R.id.textView);\n        textView.setText(mSkinHelper.getString(\"label\"));\n\n        ImageView imageView = (ImageView) findViewById(R.id.imageView);\n        imageView.setImageDrawable(mSkinHelper.getDrawable(\"img\"));\n    }\n}\n```\n\nSkinHelper代码如下:\n\n```\npublic class SkinHelper {\n    private final Resources mResources;\n    private final String mSkinApkPackage;\n\n    public SkinHelper(Context context, String skinApkPackage) {\n        mSkinApkPackage = skinApkPackage;\n        mResources = getResourcesByContext(context, skinApkPackage);\n    }\n\n    public SkinHelper(Context context, String skinApkPackage, File skinApk) {\n        mSkinApkPackage = skinApkPackage;\n        mResources = getResourcesByAssetManager(context, skinApk.getPath());\n    }\n\n    /**\n     * 使用Context.createPackageContext加载Resource\n     *\n     * @param context\n     * @return\n     */\n    private Resources getResourcesByContext(Context context, String skinApkPackage) {\n        try {\n            return context.createPackageContext(skinApkPackage, Context.CONTEXT_IGNORE_SECURITY)\n                    .getResources();\n\n        } catch (PackageManager.NameNotFoundException e) {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n\n    /**\n     * 使用反射创建AssertManager加载Resource\n     *\n     * @param context\n     * @return\n     */\n    private Resources getResourcesByAssetManager(Context context, String skinApkPath) {\n        try {\n            Method method = AssetManager.class.getDeclaredMethod(\"addAssetPath\", String.class);\n            AssetManager assetManager = AssetManager.class.newInstance();\n            method.invoke(assetManager, skinApkPath);\n\n            return new Resources(\n                    assetManager,\n                    context.getResources().getDisplayMetrics(),\n                    context.getResources().getConfiguration()\n            );\n        } catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public String getString(String name) {\n        int id = mResources.getIdentifier(name, \"string\", mSkinApkPackage);\n        if (id == 0) {\n            return null;\n        }\n        return mResources.getString(id);\n    }\n\n\n    public Drawable getDrawable(String name) {\n        int id = mResources.getIdentifier(name, \"drawable\", mSkinApkPackage);\n        if (id == 0) {\n            return null;\n        }\n        return mResources.getDrawable(id);\n    }\n}\n```\n\n效果如下:\n\n{% img /安卓皮肤包机制的原理/image.jpeg %}\n\n# 完整代码\n\n完整代码可以在[这里](https://github.com/bluesky466/SkinDemo)获取","tags":["技术相关","Android"]},{"title":"Android温故而知新 - Java的四种引用","url":"/2017/07/06/Android温故而知新-Java的四种引用/","content":"java对象的引用包括强引用，软引用，弱引用，虚引用四种\n  \n# 强引用\n\n强引用是最常用的引用,我们在代码中处处可见:\n\n```\nString str = \"hello world\";\nMap<String, String> map = new HashMap<>();\nint[] arr = new int[10];\n```\n\n上面的str、map、arr都是强引用。一个对象,只要有强引用与它关联,那么JVM就不会回收它。即使是在内存不足的情况下,JVM宁愿抛出OutOfMemory的异常也不会回收它。\n\n```\npublic void function() {\n\tObject object = new Object();\n\tObject[] array = new Object[9999];\n}\n```\n\n比如上面的方法,当运行到Object[] array = new Object[9999];的时候,如果内存不够了,JVM就好抛出OutOfMemory的异常,而不会回收object的内存。所以一个强引用的内存肯定是有效的,所以java并不像c++,需要担心野指针的问题。\n\n当然,当退出function之后,object和array就都已经不存在了,所以它们所指向的内存就可以被回收了。\n\n当一个对象使用完,不会再被用到的时候,我们可以将所有指向它的强引用都赋为null。这样JVM会在合适的时机去回收它。\n\n# 软引用\n\n软引用所管理的对象在内存不足的时候,如果没有其他强引用与之管理,就会被回收。用SoftReference来表示软引用,使用方法如下:\n\n```\npublic class DemoActivity extends AppCompatActivity {\n    SoftReference<String> mStr = new SoftReference<>(new String(\"hello world\"));\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_layout);\n    }\n\n    public void onClick(View view) {\n        Log.d(\"SoftReference\", \"mStr = \" + mStr.get());\n    }\n}\n```\n\n注意的是这里不能直接new SoftReference<>(\"hello world\");因为JVM内建字符串池机制的存在会导致字符串池强引用的存在，因此不会被垃圾回收。\n\n\nstr.get()就可以获取到管理的对象,如果对象已经被回收就会返回null。\n\n我们可以用Android Studio的Monitors强制gc,释放内存,然后这个时候就能看到它返回的是null了。\n\n{% img /Android温故而知新-Java的四种引用/1.png %}\n\n值得注意的是“SoftReference所管理的对象被回收”并不代表SoftReference的内存被回收, SoftReference此时依然是一个可以使用的对象,但它已经没有使用价值了。我们需要在合适的时候将SoftReference赋值为null,释放掉它所占用的内存,避免大量无用的SoftReference存在导致内存泄漏。\n\nSoftReference也可以和ReferenceQueue一起使用。构造SoftReference的时候将ReferenceQueue传入SoftReference的构造方法。当SoftReference所管理的对象被回收的时候SoftReference就会被放到ReferenceQueue中。\n\n\n```\npublic class DemoActivity extends AppCompatActivity {\n\n    ReferenceQueue<String> mReferenceQueue = new ReferenceQueue<>();\n    SoftReference<String> mStr = new SoftReference<>(new String(\"hello world\"), mReferenceQueue);\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_layout);\n    }\n\n    public void onClick(View view) {\n        if (mStr.get() == null) {\n            Log.d(\"SoftReference\", \"mStr = \" + mStr);\n\n            mStr = null;\n            SoftReference<String> ref;\n            do {\n                ref = (SoftReference<String>) mReferenceQueue.poll();\n                Log.d(\"SoftReference\", \"ref = \" + ref);\n\n            } while (ref != null);\n        }\n    }\n}\n```\n\n软引用的特性使得它很适合用来实现数据缓存,如图片缓存,网页缓存等。在内存紧张的时候如果没有其他的强引用关联,即该资源仅仅是放在缓存中而没有被使用,就会被释放。而当内存不紧张的时候,即使没有其他强引用与之关联,JVM的垃圾回收机制也是不会回收软引用所管理的资源的。\n\n当需要使用的时候判断获取的是不是null,如果是的话证明之前内存被回收了,直接重新加载就好了。\n\n# 弱引用\n\n弱引用所管理的对象在JVM进行垃圾回收的时候,只要没有其他强引用与之关联。不管内存是否充足,都会被回收。它用WeakReference来表示。\n\n弱引用可以用在回调函数中防止内存泄漏。我们来看个典型的例子,也是一个很多人都会犯的错误:\n\n```\npublic class DemoActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_layout);\n    }\n\n    // 可能会引入内存泄漏\n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            super.handleMessage(msg);\n        }\n    };\n}\n```\n\n不知道大家有没有看过我之前写的一篇[关于Handler的博客](http://blog.islinjw.cn/2017/07/02/Android%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0-Handler/),如果没有没有看过,而对Handler又不太熟悉的同学可以去看一下。\n\n我们知道Handler是和Looper还有MessageQueue一起工作的。当安卓应用启动之后,系统会在主线程创建一个Looper和MessageQueue,它们的生命周期贯穿整个应用的生命周期。\n\nHandler在发送Message的时候会将Message传到MessageQueue里面去,而Message里面保存着Handler的引用。这样的话如果Message还没有被处理,Handler也不会被回收。\n\n而这里的Handler是DemoActivity的一个内部类。在java中,非晶体内部匿名类会持有外部类的一个隐式引用,这样就有可能导致外部类无法被垃圾回收。\n\n如果我们代码中这样写:\n\n```\npublic class DemoActivity extends AppCompatActivity {\n    private static final int MSG_DO_SOMETHING = 1;\n    \n    // 可能会引入内存泄漏\n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n        \t...\n        }\n    };\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_layout);\n\n        // 延迟十分钟发送消息\n        mHandler.sendEmptyMessageDelayed(MSG_DO_SOMETHING, 1000 * 60 * 10);\n    }\n}\n```\n\n即使退出了DemoActivity,在消息没有被处理之前, DemoActivity的内存也是不会被回收的。\n\n那要怎样解决它呢？\n\n我们可以使用静态内部类加虚引用的方式:\n\n```\npublic class DemoActivity extends AppCompatActivity {\n    private static final int MSG_DO_SOMETHING = 1;\n    // 可能会引入内存泄漏\n    private static class InnerHandler extends Handler {\n        private final WeakReference<DemoActivity> mActivity;\n\n        InnerHandler(DemoActivity activity) {\n            mActivity = new WeakReference<>(activity);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            DemoActivity activity = mActivity.get();\n            if (activity != null) {\n                ...\n            }\n        }\n    }\n\n    private final Handler mHandler = new InnerHandler(this);\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_layout);\n\n        // 延迟十分钟发送消息\n        mHandler.sendEmptyMessageDelayed(MSG_DO_SOMETHING, 1000 * 60 * 10);\n    }\n}\n```\n\n由于静态内部类不持有外部类的引用,所以现在只有虚引用关联了DemoActivity,在垃圾回收的时候,不管是否内存不足,DemoActivity都会被回收。\n\n十分钟之后当handleMessage方法被调用的时候,用WeakReference的get方法获取DemoActivity,如果返回null的话证明DemoActivity已经被回收,就不应该再做什么处理了。\n\nWeakReference同样可以在构造方法中传入ReferenceQueue。如果它所管理的对象被JVM回收，这个WeakReference就会被加入到ReferenceQueue。\n\n# 虚引用\n\n虚引用或者叫做幽灵引用在java中用PhantomReference表示。它和前面的应用都不一样,它不影响对象的生命周期,当一个对象只有虚引用与之关联的时候,就和没有任何引用一样。\n\n而且它必须与ReferenceQueue一起使用,它只有一个构造函数:\n\n```\npublic PhantomReference(T referent, ReferenceQueue<? super T> q) {\n\tsuper(referent, q);\n}\n```\n\n而且它的get方法永远返回null:\n\n```\npublic T get() {\n\treturn null;\n}\n```\n\n如果PhantomReference管理的对象只有PhantomReference与之关联,系统就会在这个时候或者一段时间之后将PhantomReference放到ReferenceQueue中。而不用等到垃圾回收的时候(参考[PhantomReference的文档](https://docs.oracle.com/javase/7/docs/api/java/lang/ref/PhantomReference.html)):\n\n> If the garbage collector determines at a certain point in time that the referent of a phantom reference is phantom reachable, then at that time or at some later time it will enqueue the reference.\n\n[这篇文章](http://www.milletblog.com/2016/09/J2SE%E8%BF%99%E6%89%8D%E6%98%AFjava%E8%99%9A%E5%BC%95%E7%94%A8PhantomReference-4/)对虚引用做了一个详细的介绍,其中对这一点他是这样解释的:\n\n> 当一个虚引用被认为是一定会被垃圾回收器回收的时候，这个虚引用才会被注册到引用队列，而不会像软引用和弱引用必须等到垃圾回收器回收之后才会被注册到引用队列\n\n对这个虚引用我其实理解的还不是很深入,查了很多的资料对它的讲解也是很模糊的。按我的理解,它应该就是单纯的用来判断一个对象是否被回收了。如果是,就进行一些清理操作。","tags":["技术相关","Android"]},{"title":"Android温故而知新 - Handler","url":"/2017/07/02/Android温故而知新-Handler/","content":"\n我们都知道,安卓主线程(也就是ui线程)中不能做耗时操作,一旦主线程阻塞了超过5秒钟就会被系统强制关闭,甚至在主线程中访问网络都会直接抛异常。但是我们的ui操作又必须在主线程中进行。所以我们会在子线程中进行耗时的操作,完成之后将结果同步到主线程进行ui的刷新。\n\n而Handler机制就是谷歌用来方便我们进行线程同步的,我们可以很方便的通过它,在子线程中将ui刷新的操作同步回主线程中进行。\n\n# 使用Handler将ui刷新操作同步到主线程中进行\n\n我们先来看一个例子直观感受下如何使用Handler将ui刷新操作从子线程同步到主线程中进行:\n\n```\npublic class MainActivity extends AppCompatActivity {\n    private static final int MSG_UPDATE_PROGRESS_BAR_ABOVE = 1;\n    private static final int MSG_UPDATE_PROGRESS_BAR_BELOW = 2;\n    private ProgressBar mProgressBarAbove;\n    private ProgressBar mProgressBarBelow;\n\n    private Handler mHandler;\n\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mProgressBarAbove = (ProgressBar) findViewById(R.id.progressAbove);\n\n        mProgressBarBelow = (ProgressBar) findViewById(R.id.progressBelow);\n\n        mHandler = new Handler() {\n            @Override\n            public void handleMessage(Message msg) {\n                super.handleMessage(msg);\n\n                switch (msg.what) {\n                    case MSG_UPDATE_PROGRESS_BAR_ABOVE:\n                        mProgressBarAbove.setProgress(msg.arg1);\n                        break;\n                    case MSG_UPDATE_PROGRESS_BAR_BELOW:\n                        Bundle data = msg.getData();\n                        mProgressBarBelow.setProgress(data.getInt(\"progress\"));\n                        break;\n                }\n            }\n        };\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                int progressAbove = 0;\n                int progressBelow = 0;\n\n                while (progressAbove < 100 || progressBelow < 100) {\n                    if (progressAbove < 100) {\n                        progressAbove++;\n\n                        Message above = new Message();\n                        above.what = MSG_UPDATE_PROGRESS_BAR_ABOVE;\n                        above.arg1 = progressAbove;\n                        mHandler.sendMessage(above);\n                    }\n\n                    if (progressBelow < 100) {\n                        progressBelow += 2;\n\n                        Message below = mHandler.obtainMessage();\n                        below.what = MSG_UPDATE_PROGRESS_BAR_BELOW;\n                        Bundle data = new Bundle();\n                        data.putInt(\"progress\", progressBelow);\n                        below.setData(data);\n                        mHandler.sendMessage(below);\n                    }\n\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }).start();\n    }\n}\n```\n\n上面的例子很简单,界面有上下两条进度条,我们在子线程中使用Thread.sleep(100)模拟耗时操作,每隔100毫秒更新一下进度,上面的进度条进度每次加1,下面的进度条每次加2。\n\n{% img /Android温故而知新-Handler/1.png %}\n\n## 1.创建handler并重写handleMessage方法\n\n首先我们会创建一个Handler并重写它的handleMessage,这个方法就是在主线程中被调用的,我们通过传给这个方法的Message去刷新ui。\n\nMessage的what成员变量用来标识消息的类型,我们这里用来区分更新哪一个进度条。同时我们可以从Message中取得从子线程中传过来的进度,然后直接在handleMessage里面刷新进度条的进度。\n\n## 2.在子线程中发送Message给Handler\n\nMessage是在子线程中被创建的。如代码所示,我们可以直接将它new出来,也可以使用mHandler.obtainMessage()从mHandler的Message池中获取一个实例。\n\n<font color=#FF0000>一般推荐使用obtainMessage的方式</font>,因为Message池中的Message是可以被重复利用的,避免了创建对象申请内存的开销。\n\n在前面说过Message的what成员变量是用来标志消息的类型的,我们这里直接将MSG_UPDATE_PROGRESS_BAR_ABOVE或者MSG_UPDATE_PROGRESS_BAR_ABOVE赋值进去,在handleMessage的时候就能用它来区分到底更新哪个进度条了。\n\n消息的值也有多种赋值方式。\n\n第一种很简单,Message提供了arg1、arg2、obj、replyTo等public成员变量,可以直接将想保存的数据赋值給他们,在handleMessage方法中就能直接获取到他们了。\n\n第二种就是创建一个Bundle对象,在Bundle对象中存入数据,然后再通过setData方法传给Message,在handleMessage方法中通过getData可以获得Message中保存的Bundle对象,从而获得保存的数据。\n\n# 同步到主线程的各种姿势\n\n使用Handler将操作同步到主线程中进行有两种方式,一种是上面例子中的发送Message的方式。另一种是直接将一个Runnable传给Handler,Handler就会在主线程中执行它:\n\n- sendEmptyMessage(int what)\n- sendEmptyMessageDelayed(int what, long delayMillis)\n- sendEmptyMessageAtTime(int what, long uptimeMillis)\n- sendMessage(Message msg)\n- sendMessageDelayed(Message msg, long delayMillis)\n- sendMessageAtTime(Message msg, long uptimeMillis)\n- sendMessageAtFrontOfQueue(Message msg)\n- post(Runnable r)\n- postDelayed(Runnable r, long delayMillis)\n- postAtTime(Runnable r, long uptimeMillis)\n- postAtTime(Runnable r, Object token, long uptimeMillis)\n- postAtFrontOfQueue(Runnable r)\n\n上面就是可以使用的一些方法,send前缀的方法用于发送一个带数据的Message对象,post前缀的方法用于安排一个Runnable对象到主线程中执行。他们都有延迟发送,定时发送等姿势可以使用。\n\n当然你也可以在Message或者Runnable未同步到主线程的时候使用下面的remove方法将他们取消:\n\n- removeMessages(int what)\n- removeMessages(int what, Object object)\n- removeCallbacks(Runnable r)\n- removeCallbacks(Runnable r, Object token)\n- removeCallbacksAndMessages(Object token)\n\n实际上将Runnable post到Handler中的时候也是用Message去包装的:\n\n```\n\tpublic final boolean post(Runnable r)\n    {\n       return  sendMessageDelayed(getPostMessage(r), 0);\n    }\n\n    private static Message getPostMessage(Runnable r) {\n        Message m = Message.obtain();\n        m.callback = r;\n        return m;\n    }\n```\n\n在主线程分发消息的时候如果判断到Message有callback则会直接执行callback,否则就将消息传到handleMessage中进行处理:\n\n```\n\t/**\n     * Handle system messages here.\n     */\n    public void dispatchMessage(Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n```\n\n# Handler机制的基本原理\n\nHandler机制有四个重要的组件:\n\n- Handler\n- Message\n- MessageQueue\n- Looper\n\nHandler和Message通过前面的例子应该已经很清楚了,但是MessageQueue和Looper又是什么鬼？\n\nMessageQueue顾名思义,就是Message的队列,我们调用Handler的各种方法发送Message其实就是将Message放到MessageQueue中。\n\n而Looper就将Message从MessageQueue中拿出来。Looper有一个loop方法,它里面有个死循环,不断从MessageQueue中拿Message出来并且将它传给Handler去处理。\n\n我们在子线程中将Message放入MessageQueue,然后在主线程中运行Looper的loop方法,不断从MessageQueue中获取Message。这就是Message从子线程同步到主线程的原理。\n\n我画了一幅图来更加形象的展示这个机制:\n\n{% img /Android温故而知新-Handler/2.png %}\n\n# 主线程中的Looper\n\n有人会问了,我们也没有在主线程中中调用Looper的loop方法啊,而且再说了loop中不是一个死循环吗,如果在主线程中运行它的话不会被堵死吗？\n\n其实安卓在启动主线程的时候就会自动创建一个Looper和执行Looper.loop()的了,不需要自己去手动操作。\n\n至于第二个问题,我们可以直接看安卓的源码:\n\n一般来讲我们认为ActivityThread.main(String[] args)就是安卓程序运行的入口,也就是我们熟悉的main方法。它其实很短,我们在它的最后可以看到Looper.loop()这个方法的确是被调用了的。\n\n```\n\tpublic static void main(String[] args) {\n        SamplingProfilerIntegration.start();\n\n        // CloseGuard defaults to true and can be quite spammy.  We\n        // disable it here, but selectively enable it later (via\n        // StrictMode) on debug builds, but using DropBox, not logs.\n        CloseGuard.setEnabled(false);\n\n        Environment.initForCurrentUser();\n\n        // Set the reporter for event logging in libcore\n        EventLogger.setReporter(new EventLoggingReporter());\n\n        Security.addProvider(new AndroidKeyStoreProvider());\n\n        Process.setArgV0(\"<pre-initialized>\");\n\n        Looper.prepareMainLooper();\n\n        ActivityThread thread = new ActivityThread();\n        thread.attach(false);\n\n        if (sMainThreadHandler == null) {\n            sMainThreadHandler = thread.getHandler();\n        }\n\n        AsyncTask.init();\n\n        if (false) {\n            Looper.myLooper().setMessageLogging(new\n                    LogPrinter(Log.DEBUG, \"ActivityThread\"));\n        }\n\n        Looper.loop();\n\n        throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n    }\n```\n\n但是调用了loop方法之后,线程不就被堵住了吗？那主线程又是怎样接收到按键消息和调用各种生命周期方法的？我们可以看到代码里还有个sMainThreadHandler,这个sMainThreadHandler是个H类,它的定义如下:\n\n```\nprivate class H extends Handler {\n\tpublic void handleMessage(Message msg) {\n        if (DEBUG_MESSAGES) Slog.v(TAG, \">>> handling: \" + codeToString(msg.what));\n            switch (msg.what) {\n                case LAUNCH_ACTIVITY: {\n                    ...\n                } break;\n                case RELAUNCH_ACTIVITY: {\n                    ...\n                } break;\n                ...\n            }\n        }\n    }\n}\n```\n\n看Activity的各个生命周期，还有事件处理也是通过Handler机制实现的！\n\n# 使用Handler将消息同步到其他线程\n\n根据上面的原理,其实我们不仅可以使用Handler将消息同步到主线程中,也能用它来将消息从主线程同步到子线程中去执行。\n\n只需要在子线程中运行Looper的loop方法,让它不断获取Message,然后在主线程中发送Message就能在子线程中被处理了。\n\n代码如下\n\n```\n    private Handler mHandler;\n\n    private Thread mThread = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            Looper.prepare();\n\n            mHandler = new Handler() {\n                public void handleMessage(Message msg) {\n                    // process incoming messages here\n                }\n            };\n            Looper.loop();\n        }\n    });\n```\n\n我们在需要在子线程中先调用Looper.prepare()。这个是个静态方法它用来创建一个Looper并绑定到当前的线程中。\n\n然后创建Handler,Handler会自动绑定当前线程中的Looper。\n\n最后调用Looper.loop()就大功告成了。\n\n之后我们就能在主线程中使用mHandler将消息发送到子线程中处理了。\n\n# HandlerThread\n\n在上面一节中我们看到,在子线程中创建Handler还需要手动调用Looper.prepare()和Looper.loop()。为了简化操作,谷歌官方提供了HandlerThread给我们使用。\n\nHandlerThread是Thread的子类,当HandlerThread启动的时候会自动调用Looper.prepare()和Looper.loop(),它的run方法源码如下:\n\n```\n    public void run() {\n        mTid = Process.myTid();\n        Looper.prepare();\n        synchronized (this) {\n            mLooper = Looper.myLooper();\n            notifyAll();\n        }\n        Process.setThreadPriority(mPriority);\n        onLooperPrepared();\n        Looper.loop();\n        mTid = -1;\n    }\n```\n\n于是我们只需要在Handler构造的时候传入HandlerThread的Looper就行了:\n\n```\nHandlerThread handlerThread = new HandlerThread(\"HandlerThread\");\nhandlerThread.start();\n\nmHandler = new Handler(handlerThread.getLooper()) {\n\t@Override\n\tpublic void handleMessage(Message msg) {\n\t\tsuper.handleMessage(msg);\n\t}\n};\n```\n\n# IntentService\n\n我们知道Service的各个声明周期函数也是在主线程中执行的,它也不能直接执行耗时操作。需要将耗时操作放到子线程中进行。\n\n为了方便在Service中进行耗时操作,谷歌提供了Service的子类IntentService。它有和Service相同的生命周期,同时也提供了在子线程处理耗时操作的机制。\n\nIntentService是一个抽象类,使用的时候需要继承并实现它的onHandleIntent方法,这个方法是在子线程中执行的,可以直接在这里进行耗时操作。\n\n其实IntentService内部也是通过HandlerThread实现的,而且代码十分简单:\n\n```\npublic abstract class IntentService extends Service {\n    private volatile Looper mServiceLooper;\n    private volatile ServiceHandler mServiceHandler;\n    private String mName;\n    private boolean mRedelivery;\n\n    private final class ServiceHandler extends Handler {\n        public ServiceHandler(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            onHandleIntent((Intent)msg.obj);\n            stopSelf(msg.arg1);\n        }\n    }\n\n    public IntentService(String name) {\n        super();\n        mName = name;\n    }\n\n    public void setIntentRedelivery(boolean enabled) {\n        mRedelivery = enabled;\n    }\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        HandlerThread thread = new HandlerThread(\"IntentService[\" + mName + \"]\");\n        thread.start();\n\n        mServiceLooper = thread.getLooper();\n        mServiceHandler = new ServiceHandler(mServiceLooper);\n    }\n\n    @Override\n    public void onStart(@Nullable Intent intent, int startId) {\n        Message msg = mServiceHandler.obtainMessage();\n        msg.arg1 = startId;\n        msg.obj = intent;\n        mServiceHandler.sendMessage(msg);\n    }\n\n    @Override\n    public int onStartCommand(@Nullable Intent intent, int flags, int startId) {\n        onStart(intent, startId);\n        return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;\n    }\n\n    @Override\n    public void onDestroy() {\n        mServiceLooper.quit();\n    }\n\n    @Override\n    @Nullable\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n\n    @WorkerThread\n    protected abstract void onHandleIntent(@Nullable Intent intent);\n}\n\n```\n","tags":["技术相关","Android"]},{"title":"Android温故而知新 - launchMode","url":"/2017/06/30/Android温故而知新-launchMode/","content":"\nActivity有四种launchMode,[android官方文档](https://developer.android.com/guide/topics/manifest/activity-element.html?hl=zh-cn)的介绍如下:\n\n|启动模式|多个实例?|注释|\n|:-----:|:-----:|:--:|\n| “standard”|是|默认值。系统始终会在目标任务中创建新的 Activity 实例并向其传送 Intent。|\n|“singleTop”|有条件|如果目标任务的顶部已存在一个 Activity 实例，则系统会通过调用该实例的 onNewIntent() 方法向其传送 Intent，而不是创建新的 Activity 实例。|\n|“singleTask”| 否|系统在新任务的根位置创建 Activity 并向其传送 Intent。 不过，如果已存在一个 Activity 实例，则系统会通过调用该实例的 onNewIntent() 方法向其传送 Intent，而不是创建新的 Activity 实例。|\n|“singleInstance”|否|与“singleTask\"”相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。 该 Activity 始终是其任务唯一仅有的成员。|\n\n# 测试demo\n\n我们通过两个Activity之间的跳转和任务栈打印来理解launchMode的作用。\n\n这两个Activity使用同一个布局, TextView用来打印任务栈的id和activity实例，然后是两个按钮，分别用来启动两个activity:\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\">\n\n    <TextView\n        android:id=\"@+id/label\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\" />\n\n    <Button\n        android:id=\"@+id/gotoFirstActivity\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:onClick=\"onClick\"\n        android:text=\"goto first activity\" />\n\n    <Button\n        android:id=\"@+id/gotoSecondActivity\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:onClick=\"onClick\"\n        android:text=\"goto second activity\" />\n\n</LinearLayout>\n```\n\nActivty代码如下:\n\n```\npublic class FirstActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_layout);\n\n        Utils.initActivity(this);\n    }\n\n    public void onClick(View view) {\n        Utils.onClick(this, view.getId());\n    }\n}\n```\n\n```\npublic class SecondActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_layout);\n\n        Utils.initActivity(this);\n    }\n\n    public void onClick(View view) {\n        Utils.onClick(this, view.getId());\n    }\n}\n```\n\n因为两个activity的代码很相似，所以我把它们放到了静态类Utils中:\n\n```\npublic class Utils {\n    public static void initActivity(Activity activity) {\n        TextView label = (TextView) activity.findViewById(R.id.label);\n        label.setText(\"task : \" + activity.getTaskId() + \" activity : \" + activity);\n    }\n\n\n    public static void onClick(Context context, int id) {\n        Intent intent;\n        if (id == R.id.gotoFirstActivity) {\n            intent = new Intent(context, FirstActivity.class);\n        } else {\n            intent = new Intent(context, SecondActivity.class);\n        }\n        context.startActivity(intent);\n    }\n}\n```\n\n# 查看任务栈\n\n我们可以在adb shell中使用dumpsys activity可以看到任务栈。这个命令的打印会比较多,但是有两个部分是比较重要的。\n\n一个是Recent tasks,这里可以看到各个任务栈的总体信息,如我们的demo在第0个任务栈,它的Task id 是483,包名是linjw.demo.launchmodedemo,栈里面有6个Activity\n\n```\nACTIVITY MANAGER RECENT TASKS (dumpsys activity recents)\n  Recent tasks:\n  * Recent #0: TaskRecord{f69123d #483 A=linjw.demo.launchmodedemo U=0 sz=6}\n  * Recent #1: TaskRecord{b798a32 #487 A=com.android.systemui U=0 sz=0}\n  * Recent #2: TaskRecord{f874383 #486 A=com.tencent.mm U=0 sz=1}\n  * Recent #3: TaskRecord{d7bd900 #479 A=com.meizu.flyme.launcher U=0 sz=1}\n  * Recent #4: TaskRecord{8f5d797 #482 A=com.tencent.mobileqq U=0 sz=0}\n  * Recent #5: TaskRecord{fd99539 #481 A=android.task.stk.task U=0 sz=0}\n  * Recent #6: TaskRecord{7c9951e #480 A=com.android.incallui U=0 sz=1}\n  * Recent #7: TaskRecord{e32177e #478 A=com.zhihu.android U=0 sz=0}\n  * Recent #8: TaskRecord{7f094df #472 A=com.meizu.media.reader U=0 sz=0}\n```\n\n在它的下面可以看到里面的具体的activity,并且可以看到叫起它的Intent:\n\n```\nACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)\nDisplay #0 (activities from top to bottom):\n  Stack #1:\n    Task id #483\n      TaskRecord{f69123d #483 A=linjw.demo.launchmodedemo U=0 sz=6}\n      Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10100000 cmp=linjw.demo.launchmodedemo/.FirstActivity }\n        Hist #5: ActivityRecord{786c71e u0 linjw.demo.launchmodedemo/.FirstActivity t483}\n          Intent { cmp=linjw.demo.launchmodedemo/.FirstActivity }\n          ProcessRecord{245852c 7994:linjw.demo.launchmodedemo/u0a61}\n        Hist #4: ActivityRecord{6d5da5d u0 linjw.demo.launchmodedemo/.SecondActivity t483}\n          Intent { cmp=linjw.demo.launchmodedemo/.SecondActivity }\n          ProcessRecord{245852c 7994:linjw.demo.launchmodedemo/u0a61}\n        Hist #3: ActivityRecord{90b9f88 u0 linjw.demo.launchmodedemo/.FirstActivity t483}\n          Intent { cmp=linjw.demo.launchmodedemo/.FirstActivity }\n          ProcessRecord{245852c 7994:linjw.demo.launchmodedemo/u0a61}\n        Hist #2: ActivityRecord{1de66e u0 linjw.demo.launchmodedemo/.SecondActivity t483}\n          Intent { cmp=linjw.demo.launchmodedemo/.SecondActivity }\n          ProcessRecord{245852c 7994:linjw.demo.launchmodedemo/u0a61}\n        Hist #1: ActivityRecord{17dd5b1 u0 linjw.demo.launchmodedemo/.FirstActivity t483}\n          Intent { cmp=linjw.demo.launchmodedemo/.FirstActivity }\n          ProcessRecord{245852c 7994:linjw.demo.launchmodedemo/u0a61}\n        Hist #0: ActivityRecord{9f195f8 u0 linjw.demo.launchmodedemo/.FirstActivity t483}\n          Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10100000 cmp=linjw.demo.launchmodedemo/.FirstActivity }\n          ProcessRecord{245852c 7994:linjw.demo.launchmodedemo/u0a61}\n    ...\n```\n\n例如Hist #0这个Activity是从桌面点击应用图标进入的,所以它的Intent带android.intent.category.LAUNCHER这个category和FLAG_ACTIVITY\\_LAUNCHED\\_FROM\\_HISTORY(0x00100000)、 FLAG\\_RECEIVER\\_FOREGROUND(0x10000000)这两个Flag,而其他的Activity都是我们通过点击按钮叫起的,我们的Intent里面没有带任何的category和Flag,所以只有cmp标识是哪个Activity。\n\n我们可以通过Intent#setFlags(int) 设置Flag、Intent#addCategory(String) 添加category\n\n有时候可以通过这个命令查看Activity的启动模式结合各种launchMode的作用来定位一些bug\n\n# standard\n\nstandard是默认的启动模式,在没有配置android:launchMode的时候就会默认用这种启动模式,当然也可以显示指定为standard。\n\n它的特点是每次都会启动一个新的Activity实例,我们连续点击第一个按钮两次然后再连续点击两次返回键,截图如下:\n\n{% img /Android温故而知新-launchMode/standard1.png %}\n\n{% img /Android温故而知新-launchMode/standard2.png %}\n\n任务栈状态图如下:\n\n{% img /Android温故而知新-launchMode/standard3.png %}\n\n\n\n# singleTop\n\n当launchMode是singleTop的时候，如果task栈的栈顶Activity和将要启动的Activity是同一个Activity的话,就不会再启动第二个Activity。我们将FirstActivity设为singleTop,在启动demo之后无论按第一个按钮多少次,任务栈里面都只会有一个FirstActivity。\n\n{% img /Android温故而知新-launchMode/singleTop1.png %}\n\n任务栈状态图如下:\n\n{% img /Android温故而知新-launchMode/singleTop2.png %}\n\n\n但是当任务栈的栈顶Activity和将要启动的Activity不是同一个Activity的时候,就会启动新的Activity,并将它压入栈顶而不管栈里面还有没有这个Activity:\n\n{% img /Android温故而知新-launchMode/singleTop3.png %}\n\n{% img /Android温故而知新-launchMode/singleTop4.png %}\n\n任务栈状态图如下:\n\n{% img /Android温故而知新-launchMode/singleTop5.png %}\n\n# singleTask\n\n我们将FirstActivity和SecondActivity的launchMode都设置为singleTask,启动demo之后先按“GOTO SECOND ACTIVITY”再按“GOTO FIRST ACTIVITY”,截图如下:\n\n{% img /Android温故而知新-launchMode/singleTask1.png %}\n\n我们可以看到在SecondActivity中启动FirstActivity,结果就返回了第一个Activity。如果这个时候再按返回键就会推出应用。\n\nsingleTask的作用就是在任务栈中寻找将要启动的Activity,如果找到的话就将它上面的Activity都弹出栈,直到它成为栈顶。\n\n任务栈状态图如下:\n\n{% img /Android温故而知新-launchMode/singleTask2.png %}\n\n# singleInstance\n\n官方文档的介绍是:\n\n> 与“singleTask\"”相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。 该 Activity 始终是其任务唯一仅有的成员。\n\n就是说系统会为singleInstance Activity单独创建一个任务栈,这个任务栈里是这个Activity独占的,不会再压入其他的Activity。而且它是系统唯一的,当singleInstance Activity已经存在于系统的某一任务栈中,就会直接跳到那个任务栈的Activity中,而不会新启动一个Activity。\n\n我们将FirstActivity设为standard, SecondActivity设为singleInstance。启动demo之后先按“GOTO SECOND ACTIVITY”再按“GOTO FIRST ACTIVITY”。然后再一直按返回键到退出应用。截图如下:\n\n{% img /Android温故而知新-launchMode/singleInstance1.png %}\n\n{% img /Android温故而知新-launchMode/singleInstance2.png %}\n\n任务栈状态图如下:\n\n{% img /Android温故而知新-launchMode/singleInstance3.png %}\n\n\n启动应用之后先点击“GOTO SECOND ACTIVITY”,这个时候系统会新建一个任务栈(Task 20)来放SecondActivity\n\n在SecondActivity中再启动FirstActivity,因为Task 20这个任务栈是SecondActivity独占的。所以不会在这个任务栈压入其他Activity,而会回到原来的任务栈上(Task 19)。又因为FirstActivity的launchMode是standard,所以不管原来的栈里面有没有FirstActivity,都会压入一个新的FirstActivity。\n\n这个时候再按返回键就不是回到SecondActivity了,因为它在其他的任务栈里面,要先将当前任务栈清空。\n\n这个时候按返回键会将当前的Activity弹出栈,于是就跳到了一开始的FirstActivity。之后再按返回键,因为Task 19这个任务栈空了,就会去到SecondActivity的栈,于是就去到了SecondActivity。最后再按返回键就会退出应用了。\n\n要再次提醒需注意的是singleInstance的Activity是系统唯一的,也就是说你在demo这里启动了这个SecondActivity的SecondActivity,然后按home键回到桌面去启动其他应用,从其他应用再启动一个SecondActivity也是去到原来的那个SecondActivity","tags":["技术相关","Android"]},{"title":"c++模板中的class和typename","url":"/2017/06/06/c++模板中的class和typename/","content":"\n借来的《Effective STL》已经放在书架上很久了,想想这段时间不是在写lua做业务,就是在学安卓准备做业务,已经很久没有看过c++这个老伙计了。为了不把老本行丢了,也为了赶紧把书还回去给更多的人阅读。于是下定决心重头开始把它读完。\n\n# 模板中使用class和typename的区别\n\n还没翻几页,当看到这段代码的时候就楞了一下。印象中上次也是看到这里一下子没弄懂,还特地搜索过的。结果再来一遍的时候还是忘了。果然好记性不如烂笔头,赶紧写篇博客mark一下。\n\n这里讲的是作者在声明模板的时候使用typename而不是class。一般情况下,使用typename或者class只是编码风格的问题。但是在遇到从属类型(dependent type)的时候,为了避免潜在的预防解析二义性,必须用typename而不能用class。\n\n```\ntemplate<typename C>\nbool lastGreaterThanFirst(const C& container)\n{\n    if(container.empty()) return false;\n\n    typename C::const_iterator begin(container.begin());\n    typename C::const_iterator end(container.end());\n    return *--end > *begin;\n}\n```\n\n这里的重点是这两行:\n\n```\ntypename C::const_iterator begin(container.begin());\ntypename C::const_iterator end(container.end());\n```\n\n如果没有用typename关键字\n\n```\ntemplate<typename C>\nbool lastGreaterThanFirst(const C& container)\n{\n    if(container.empty()) return false;\n\n    C::const_iterator begin(container.begin());\n    C::const_iterator end(container.end());\n    return *--end > *begin;\n}\n```\n\n就会报错(《Effective STL》中指出有些编译器错误的接受了没有typename的代码,但这样的代码是不可移植的):\n\n```\ntest.cpp:6:2: error: missing 'typename' prior to dependent type name 'C::const_iterator'\n        C::const_iterator begin(container.begin());\n        ^~~~~~~~~~~~~~~~~\n        typename\ntest.cpp:7:2: error: missing 'typename' prior to dependent type name 'C::const_iterator'\n        C::const_iterator end(container.end());\n        ^~~~~~~~~~~~~~~~~\n        typename\n2 errors generated.\n```\n\n如果你在这里使用的是class而不是typename就会报错:\n\n```\ntest.cpp:8:11: error: elaborated type refers to a typedef\n        class C::const_iterator begin(container.begin());\n                 ^\ntest.cpp:15:2: note: in instantiation of function template specialization 'lastGreaterThanFirst<std::__1::vector<int, std::__1::allocator<int> > >' requested here\n        lastGreaterThanFirst(vec);\n        ^\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/vector:476:54: note: declared here\n    typedef __wrap_iter<const_pointer>               const_iterator;\n                                                     ^\n1 error generated.\n```\n\n\n# 为什么出现从属类型时需要用typename\n\n我们一步一步来解析。\n\n```\nClassA::foo\n```\n当你看到上面的代码的时候,你会觉得foo是什么？第一反应应该是ClassA的一个静态成员变量对吧？\n\n那当你继续往后看,看到下面的代码的时候,想想a是什么？\n\n```\nClassA::foo a;\n```\n\na是一个ClassA::foo类型的变量,ClassA::foo是一个内部类:\n\n```\nclass ClassA {\npublic:\n    class foo {\n    };\n};\n```\n\n或者ClassA内部的一个typedef:\n\n```\nclass ClassA {\npublic:\n    typedef int foo;\n};\n```\n\n当foo是ClassA的内部类或者是内部的一个typedef的时候,foo就是一个从属类型。\n\n而对于C::const_iterator,const_iterator可能是C的一个静态成员变量或者是C的一个从属类型,编译器默认是将它解析为一个变量的,所以需要用typename告诉编译器这是一个类型:\n\n```\ntypename C::const_iterator begin(container.begin());\n```\n\n# 出现从属类型时不需要用typename的特例\n\n在遇到从属类型出现在类模板定义中的基类列表的时候,是不需要用typename关键字指明这是一个类型的:\n\n```\nclass ClassA {\npublic:\n    class foo {\n    };\n};\n\ntemplate<typename C>\nclass ClassB : public C::foo {\n};\n```\n\n因为基类列表中的肯定是一个类型。\n","tags":["技术相关","C/C++"]},{"title":"在Android中使用注解生成Java代码 AbstractProcessor","url":"/2017/06/03/在Android中使用注解生成Java代码-AbstractProcessor/","content":"前段时间在学习Dagger2,对它生成代码的原理充满了好奇。google了之后发现原来java原生就是支持代码生成的。\n\n通过Annotation Processor可以在编译的时候处理注解,生成我们自定义的代码,这些生成的代码会和其他手写的代码一样被javac编译。注意Annotation Processor只能用来生成代码,而不能对原来的代码进行修改。\n\n实现的原理是通过继承AbstractProcessor,实现我们自己的Processor,然后把它注册给java编译器,编译器在编译之前使用我们定义的Processor去处理注解。\n\n# AbstractProcessor\n\nAbstractProcessor是一个抽象类,我们继承它需要实现一个抽象方法process,在这个方法里面去处理注解。然后它还有几个方法需要我们去重写。\n\n```\npublic class MyProcessor extends AbstractProcessor {\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnvironment) {...}\n    \n    @Override\n    public Set<String> getSupportedAnnotationTypes() {...}\n    \n    \n    @Override\n    public SourceVersion getSupportedSourceVersion() {...}\n    \n    \n    @Override\n    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {...}\n}\n```\n\n- init方法是初始化的地方,我们可以通过ProcessingEnvironment获取到很多有用的工具类\n\n- getSupportedAnnotationTypes 这个方法指定处理的注解,需要将要处理的注解的全名放到Set中返回\n\n- getSupportedSourceVersion 这个方法用来指定支持的java版本\n\n- process 是实际处理注解的地方\n\n在Java 7后多了 SupportedAnnotationTypes 和 SupportedSourceVersion 这个两个注解用来简化指定注解和java版本的操作:\n\n```\n@SupportedAnnotationTypes({\"linjw.demo.injector.InjectView\"})\n@SupportedSourceVersion(SourceVersion.RELEASE_7)\npublic class InjectorProcessor extends AbstractProcessor {\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnvironment) {...}\n        \n    @Override\n    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {...}\n```\n\n# 注册Processor\n\n编写完我们的Processor之后需要将它注册给java编译器\n\n1. 在src/main目录下创建resources/META-INF/services/javax.annotation.processing.Processor文件(即创建resources目录,在resources目录下创建META-INF目录,继续在META-INF目录下创建services目录,最后在services目录下创建javax.annotation.processing.Processor文件)。\n\n2. 在javax.annotation.processing.Processor中写入自定义的Processor的全名,如果有多个Processor的话,每一行写一个。\n\n完成后 javax.annotation.processing.Processor 内容如下\n\n>$ cat javax.annotation.processing.Processor  \n>linjw.demo.injector.InjectorProcessor\n\n# 在安卓中自定义Processor\n\n我以前在学习Java自定义注解的时候写过一个[小例子](http://blog.islinjw.cn/2016/05/27/Java%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/#u53E6_u5916_u7684_u4E00_u4E2A_u5B9E_u7528_u7684_u5C0F_u4F8B_u5B50),它是用运行时注解通过反射简化findViewById操作的。但是这种使用运行时注解的方法在效率上是有缺陷的,因为反射的效率很低。\n\n基本上学安卓的人都知道有个很火的开源库[ButterKnife](https://github.com/JakeWharton/butterknife),它也能简化findViewById操作,但它是通过编译时注解生成代码去实现的,效率比我们使用反射实现要高很多很多。\n\n其实我对ButterKnife的原理也一直很好奇,下面就让我们也用生成代码的方式高效的简化findViewById操作。\n\n## 创建配置工程\n\n首先在android项目中是找不到AbstractProcessor的,需要新建一个Java Library Module。\n\nAndroid Studio中按File -> New -> New Module... 然后选择新建Java Library, Module的名字改为libinjector。\n\n同时在安卓中使用AbstractProcessor需要apt的支持,所以需要配置一下gradle:\n\n1.在 project 的 build.gradle 的 dependencies 下加上 android-apt 支持\n\n```\n...\ndependencies {\n        classpath 'com.android.tools.build:gradle:2.2.2'\n        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'\n}\n...\n```\n\n2.在 app 的 build.gradle 的开头加上 \"apply plugin: 'com.neenbedankt.android-apt'\"\n\n```\napply plugin: 'com.android.application'\napply plugin: 'com.neenbedankt.android-apt'\n...\n```\n\n## 创建注解\n\n我们在libinjector中创建注解InjectView\n\n```\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface InjectView {\n    int value();\n}\n```\n\n这个是个修饰Field且作用于源码的自定义注解。关于自定义注解的知识可以看看我以前写的一篇文章[《Java自定义注解和动态代理》](http://blog.islinjw.cn/2016/05/27/Java%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/)。我们用它来修饰View成员变量并保持View的resource id,生成的代码通过resource id使用findViewById注入成员变量。\n\n## 创建InjectorProcessor\n\n在libinjector中创建InjectorProcessor实现代码的生成\n\n```\n@SupportedAnnotationTypes({\"linjw.demo.injector.InjectView\"})\n@SupportedSourceVersion(SourceVersion.RELEASE_7)\npublic class InjectorProcessor extends AbstractProcessor {\n    private static final String GEN_CLASS_SUFFIX = \"Injector\";\n    private static final String INJECTOR_NAME = \"ViewInjector\";\n\n    private Types mTypeUtils;\n    private Elements mElementUtils;\n    private Filer mFiler;\n    private Messager mMessager;\n\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnvironment) {\n        super.init(processingEnvironment);\n\n        mTypeUtils = processingEnv.getTypeUtils();\n        mElementUtils = processingEnv.getElementUtils();\n        mFiler = processingEnv.getFiler();\n        mMessager = processingEnv.getMessager();\n    }\n\n    @Override\n    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {\n        Set<? extends Element> elements = roundEnvironment.getElementsAnnotatedWith(InjectView.class);\n\n        //process会被调用三次，只有一次是可以处理InjectView注解的，原因不明\n        if (elements.size() == 0) {\n            return true;\n        }\n\n        Map<Element, List<Element>> elementMap = new HashMap<>();\n\n        StringBuffer buffer = new StringBuffer();\n        buffer.append(\"package linjw.demo.injector;\\n\")\n                .append(\"public class \" + INJECTOR_NAME + \" {\\n\");\n\n        //遍历所有被InjectView注释的元素\n        for (Element element : elements) {\n            //如果标注的对象不是FIELD则报错,这个错误其实不会发生因为InjectView的Target已经声明为ElementType.FIELD了\n            if (element.getKind()!= ElementKind.FIELD) {\n                mMessager.printMessage(Diagnostic.Kind.ERROR, \"is not a FIELD\", element);\n            }\n\n            //这里可以先将element转换为VariableElement,但我们这里不需要\n            //VariableElement variableElement = (VariableElement) element;\n\n            //如果不是View的子类则报错\n            if (!isView(element.asType())){\n                mMessager.printMessage(Diagnostic.Kind.ERROR, \"is not a View\", element);\n            }\n\n            //获取所在类的信息\n            Element clazz = element.getEnclosingElement();\n\n            //按类存入map中\n            addElement(elementMap, clazz, element);\n        }\n\n        for (Map.Entry<Element, List<Element>> entry : elementMap.entrySet()) {\n            Element clazz = entry.getKey();\n\n            //获取类名\n            String className = clazz.getSimpleName().toString();\n\n            //获取所在的包名\n            String packageName = mElementUtils.getPackageOf(clazz).asType().toString();\n\n            //生成注入代码\n            generateInjectorCode(packageName, className, entry.getValue());\n\n            //完整类名\n            String fullName = clazz.asType().toString();\n\n            buffer.append(\"\\tpublic static void inject(\" + fullName + \" arg) {\\n\")\n                    .append(\"\\t\\t\" + fullName + GEN_CLASS_SUFFIX + \".inject(arg);\\n\")\n                    .append(\"\\t}\\n\");\n        }\n\n        buffer.append(\"}\");\n\n        generateCode(INJECTOR_NAME, buffer.toString());\n\n        return true;\n    }\n\n    //递归判断android.view.View是不是其父类\n    private boolean isView(TypeMirror type) {\n        List<? extends TypeMirror> supers = mTypeUtils.directSupertypes(type);\n        if (supers.size() == 0) {\n            return false;\n        }\n        for (TypeMirror superType : supers) {\n            if (superType.toString().equals(\"android.view.View\") || isView(superType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void addElement(Map<Element, List<Element>> map, Element clazz, Element field) {\n        List<Element> list = map.get(clazz);\n        if (list == null) {\n            list = new ArrayList<>();\n            map.put(clazz, list);\n        }\n        list.add(field);\n    }\n\n    private void generateCode(String className, String code) {\n        try {\n            JavaFileObject file = mFiler.createSourceFile(className);\n            Writer writer = file.openWriter();\n            writer.write(code);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 生成注入代码\n     *\n     * @param packageName 包名\n     * @param className   类名\n     * @param views       需要注入的成员变量\n     */\n    private void generateInjectorCode(String packageName, String className, List<Element> views) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"package \" + packageName + \";\\n\\n\")\n                .append(\"public class \" + className + GEN_CLASS_SUFFIX + \" {\\n\")\n                .append(\"\\tpublic static void inject(\" + className + \" arg) {\\n\");\n\n        for (Element element : views) {\n            //获取变量类型\n            String type = element.asType().toString();\n\n            //获取变量名\n            String name = element.getSimpleName().toString();\n\n            //id\n            int resourceId = element.getAnnotation(InjectView.class).value();\n\n            builder.append(\"\\t\\targ.\" + name + \"=(\" + type + \")arg.findViewById(\" + resourceId + \");\\n\");\n        }\n\n        builder.append(\"\\t}\\n\")\n                .append(\"}\");\n\n        //生成代码\n        generateCode(className + GEN_CLASS_SUFFIX, builder.toString());\n    }\n}\n```\n\n## 注册InjectorProcessor\n\n在libinjector的src/main目录下创建resources/META-INF/services/javax.annotation.processing.Processor文件注册InjectorProcessor:\n\n```\n# 注册InjectorProcessor\nlinjw.demo.injector.InjectorProcessor\n```\n\n## 使用InjectView注解\n\n我们在Activity中使用InjectView修饰需要赋值的View变量并且用ViewInjector.inject(this);调用生成的掉初始化修饰的成员变量。这里有两个Activity都使用了InjectView去简化findViewById操作:\n\n```\npublic class MainActivity extends AppCompatActivity {\n    @InjectView(R.id.label)\n    TextView mLabel;\n\n    @InjectView(R.id.button)\n    Button mButton;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        //使用findViewById注入被InjectView修饰的成员变量\n        ViewInjector.inject(this);\n\n        // ViewInjector.inject(this) 已经将mLabel和mButton赋值了,可以直接使用\n        mLabel.setText(\"MainActivity\");\n\n        mButton.setText(\"jump to SecondActivity\");\n        mButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Intent intent  = new Intent(MainActivity.this, SecondActivity.class);\n                startActivity(intent);\n            }\n        });\n    }\n}\n```\n\n```\npublic class SecondActivity extends Activity {\n    @InjectView(R.id.label)\n    TextView mLabel;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_second);\n\n        //使用findViewById注入被InjectView修饰的成员变量\n        ViewInjector.inject(this);\n\n        // ViewInjector.inject(this) 已经将mLabel赋值了,可以直接使用\n        mLabel.setText(\"SecondActivity\");\n    }\n}\n```\n\n# 工具类\n\n在 AbstractProcessor.init 方法中我们可以获得几个很有用的工具类:\n\n```\nmTypeUtils = processingEnv.getTypeUtils();\nmElementUtils = processingEnv.getElementUtils();\nmFiler = processingEnv.getFiler();\nmMessager = processingEnv.getMessager();\n```\n\n它们的作用如下:\n\n## Types \n\nTypes提供了和类型相关的一些操作，如获取父类、判断两个类是不是父子关系等，我们在isView中就用它去获取父类\n\n```\n    //递归判断android.view.View是不是其父类   \n    private boolean isView(TypeMirror type) {\n        List<? extends TypeMirror> supers = mTypeUtils.directSupertypes(type);\n        if (supers.size() == 0) {\n            return false;\n        }\n        for (TypeMirror superType : supers) {\n            if (superType.toString().equals(\"android.view.View\") || isView(superType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n```\n\n## Elements\n\nElements提供了一些和元素相关的操作，如获取所在包的包名等:\n\n```\n//获取所在的包名\nString packageName = mElementUtils.getPackageOf(clazz).asType().toString();\n```\n\n## Filer\n\nFiler用于文件操作,我们用它去创建生成的代码文件\n\n```\n\tprivate void generateCode(String className, String code) {\n        try {\n            JavaFileObject file = mFiler.createSourceFile(className);\n            Writer writer = file.openWriter();\n            writer.write(code);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n## Messager\n\nMessager 顾名思义就是用于打印的,它会打印出Element所在的源代码，它还会抛出异常。靠默认的错误打印有时很难找出错误的地方,我们可以用它去添加更直观的日志打印\n\n当用InjectView标注了非View的成员变量我们就会打印错误并抛出异常(这里我们使用Diagnostic.Kind.ERROR,这个打印会抛出异常终止Processor):\n\n```\n//如果不是View的子类则报错\nif (!isView(element.asType())){\n\tmMessager.printMessage(Diagnostic.Kind.ERROR, \"is not a View\", element);\n}\n```\n\n例如我们如果在MainActivity中为一个String变量标注InjectView:\n\n```\n//在非View上使用InjectView就会报错\n@InjectView(R.id.button)\nString x;\n```\n\n则会报错:\n\n```\n  符号:   类 ViewInjector\n  位置: 程序包 linjw.demo.injector\n/Users/linjw/workspace/ProcessorDemo/app/src/main/java/linjw/demo/processordemo/MainActivity.java:22: 错误: is not a View\n    String x;\n           ^\n```\n\n如果我们不用Messager去打印,生成的代码之后也会有打印,但是就不是那么清晰了:\n\n```\n/Users/linjw/workspace/ProcessorDemo/app/build/generated/source/apt/debug/MainActivityInjector.java:7: 错误: 不兼容的类型: View无法转换为String\n                arg.x=(java.lang.String)arg.findViewById(2131427415);\n```\n\n# Element的子接口\n\n我们在process方法中使用getElementsAnnotatedWith获取到的都是Element接口,其实我们用Element.getKind获取到类型之后可以将他们强转成对应的子接口,这些子接口提供了一些针对性的操作。\n\n这些子接口有:\n\n- TypeElement：表示一个类或接口程序元素。\n- PackageElement：表示一个包程序元素。\n- VariableElement：表示一个属性、enum 常量、方法或构造方法参数、局部变量或异常参数。\n- ExecutableElement：表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注释类型元素。\n\n对应关系如下\n\n```\npackage linjw.demo;  // PackageElement\npublic class Person {  // TypeElement\n    private String mName;  // VariableElement\n    public Person () {}  // ExecutableElement\n    public void setName (String name) {mName=name;}  // ExecutableElement\n}\n```\n\n# Element的一些常用操作\n\n获取类名:\n\n- Element.getSimpleName().toString(); // 获取类名\n- Element.asType().toString(); //获取类的全名\n\n获取所在的包名:\n\n- Elements.getPackageOf(Element).asType().toString();\n\n获取所在的类:\n\n- Element.getEnclosingElement();\n\n获取父类:\n\n- Types.directSupertypes(Element.asType())\n\n获取标注对象的类型:\n\n- Element.getKind()\n\n# Demo地址\n\n可以在[这里](https://github.com/bluesky466/ProcessorDemo)查看完整代码\n","tags":["技术相关","Android"]},{"title":"Dagger2学习笔记(二)","url":"/2017/05/17/Dagger2学习笔记-二/","content":"\n在上一篇[文章](http://blog.islinjw.cn/2017/05/13/Dagger2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/)我们讲了用于搜索的SearchActivity的实现，这一篇文章我们继续以剩下的两个Activity的实现为例，讲一下Dagger2的其他特性。这两个Activity分别是用了展示SearchActivity搜索的用户的头像和用户名的UserInfoActivity和点击用户头像跳转到的展示用户followers的FollowerActivity。\n\n\n在我们的Demo中有个叫做UserInfoLoader的类，它是用来向github服务器请求用户信息和follower信息的，会在多个actiity中被使用，例如在FollowerPresenter和UserInfoPresenter中都需要注入UserInfoLoader。最简单的方式是我们可以直接使用@Inject注解标注它的构造方法，使得Dagger2可以直接创建它的实例去注入FollowerPresenter和UserInfoPresenter中。\n\n```\nclass UserInfoLoader {\n\t...\n\t@Inject\n\tUserInfoLoader() {\n\t}\n\t...\n}\n\n```\n\n# Module复用\n\n当然我们也能用复用Module的方式，这种方式虽然比直接用@Inject注解构造方法复杂，但是它还有其他十分有用的功能，接下来我会慢慢分析。\n\n首先我们把它的Module单独抽出来，放到AppModule中：\n\n```\n@Module\npublic class AppModule {\n    @Provides\n\tUserInfoLoader provideUserInfoLoader() {\n        return new UserInfoLoader();\n\t}\n}\n```\n\n## 共用Module\n\n我们复用这个Module的方式有几种，一是同时放在FollowerComponent和UserInfoComponent的modules中:\n\n```\n@Component(modules = {AppModule.class, FollowerPresenterModule.class})\npublic interface FollowerComponent {\n    void inject(FollowerPresenter presenter);\n    void inject(FollowerActivity activity);\n}\n\n```\n\n```\n@Component(modules = {AppModule.class, UserInfoPresenterModule.class})\npublic interface UserInfoComponent {\n    void inject(UserInfoPresenter presenter);\n    void inject(UserInfoActivity activity);\n}\n```\n\n## 使用dependencies\n\n第二种方式是使用dependencies，首先我们需要声明多一个AppComponent接口\n\n```\n@Component(modules = {AppModule.class})\npublic interface AppComponent {\n    UserInfoLoader provideUserInfoLoader();\n}\n\n```\n\n这个接口的provideUserInfoLoader()方法就是提供出来给子依赖获取UserInfoLoader的，因为dependencies子依赖是获取不了父依赖的modules里面的Provides的。\n\n之后声明FollowerComponent和UserInfoComponent:\n\n```\n@Component(dependencies = AppComponent.class, modules = {UserInfoPresenterModule.class})\npublic interface UserInfoComponent {\n    void inject(UserInfoPresenter presenter);\n    void inject(UserInfoActivity activity);\n}\n```\n\n```\n@Component(dependencies = AppComponent.class, modules = {FollowerPresenterModule.class})\npublic interface FollowerComponent {\n    void inject(FollowerPresenter presenter);\n    void inject(FollowerActivity activity);\n}\n\n```\n\n最后就再去实现注入:\n```\nFollowerComponent component = DaggerFollowerComponent.builder()\n\t.appComponent(getAppComponent())\n    .followerPresenterModule(new FollowerPresenterModule(this))\n    .build();\ncomponent.inject(this);\ncomponent.inject(mPresenter);\n```\n\n```\nUserInfoComponent component = DaggerUserInfoComponent.builder()\n    .appComponent(getAppComponent())\n    .userInfoPresenterModule(new UserInfoPresenterModule(this))\n    .build();\ncomponent.inject(this);\ncomponent.inject(mPresenter);\n```\n\n这里的AppComponent是公用的，所以我们放到Application中:\n\n```\npublic class AppApplication extends Application {\n    private AppComponent mAppComponent;\n\n\tpublic AppApplication() {\n        super();\n\n        mAppComponent = DaggerAppComponent.create();\n\t}\n\n\tpublic AppComponent getAppComponent() {\n        return mAppComponent;\n\t}\n}\n```\n\n然后在Activity中这样获取AppComponent:\n\n```\nAppComponent getAppComponent() {\n    return ((AppApplication)getApplication()).getAppComponent();\n}\n```\n\n我们尝试注释掉AppComponent.provideUserInfoLoader，rebuild一下，发现居然没有报错，这是怎么回事？其实是因为UserInfoLoader的构造方法使用@Inject注解标注了，所以可以直接通过构造方法创建UserInfoLoader来注入FollowerPresenter和FollowerActivity。\n\n我们再把UserInfoLoader的构造方法的@Inject注解注释掉，这时候再rebuild就可以发现报错了。\n\n然后再取消掉AppComponent.provideUserInfoLoader的注释，就能顺利编过了。因为我们的AppModule.provideUserInfoLoader是通过new 一个UserInfoLoader出来的，所以可以不依赖构造方法的@Inject注解。\n\n## 使用Subcomponent\n\n最后一种方法就是使用@Subcomponent注解，这中方法和使用dependencies有点像，他们的区别在于使用@Subcomponent方法AppComponent不需要提供一个provideUserInfoLoader方法，子依赖可以直接使用AppComponent中的modules。首先我们要这样声明AppComponent:\n\n```\n@Component(modules = {AppModule.class})\npublic interface AppComponent {\n    FollowerComponent plus(FollowerPresenterModule module);\n    UserInfoComponent plus(UserInfoPresenterModule module);\n}\n```\n\n然后FollowerComponent和UserInfoComponent的定义如下:\n\n```\n@Subcomponent(modules = {FollowerPresenterModule.class})\npublic interface FollowerComponent {\n    void inject(FollowerPresenter presenter);\n    void inject(FollowerActivity activity);\n}\n```\n\n```\n@Subcomponent(modules = {UserInfoPresenterModule.class})\npublic interface UserInfoComponent {\n    void inject(UserInfoPresenter presenter);\n    void inject(UserInfoActivity activity);\n}\n```\n\n注入的实现代码如下:\n\n```\nFollowerComponent component = getAppComponent().plus(new FollowerPresenterModule(this));\n\ncomponent.inject(this);\ncomponent.inject(mPresenter);\n```\n\n# Scope\n\n现在还有一个问题，现在FollowerComponent和UserInfoComponent虽然都往Presenter注入了UserInfoLoader，但他们是不同的实例:\n\n> D/UserInfoPresenter: mUserInfoLoader : com.example.linjw.dagger2demo.model.UserInfoLoader@31e117c\n> D/FollowerPresenter: mUserInfoLoader : com.example.linjw.dagger2demo.model.UserInfoLoader@c9ad63b\n\n如果我想他们使用的就是同一个UserInfoLoader实例呢？需要怎么做？\n\nDagger2中有作用域的概念，可以规定几个Component在同一个作用域，在同一个作用域注入的依赖就是同一个实例。\n\n首先需要声明我们的Scope:\n\n```\n@Scope\n@Retention(RUNTIME)\npublic @interface AppScope {\n}\n```\n\n然后就只需要将Module的Provides方法和Component用同一个Scope注解标注一下，就能让他们处于同一个作用域了。\n\n比如我们需要在AppModule.provideUserInfoLoader标注:\n```\n@Module\npublic class AppModule {\n    @AppScope\n    @Provides\n\tUserInfoLoader provideUserInfoLoader() {\n        return new UserInfoLoader();\n\t}\n}\n```\n\n像我们使用Subcomponent去实现依赖继承，我们就只需要在AppComponent中标注就好了，这样他们的子依赖也会处于AppScope中:\n\n```\n@AppScope\n@Component(modules = {AppModule.class})\npublic interface AppComponent {\n    FollowerComponent plus(FollowerPresenterModule module);\n    UserInfoComponent plus(UserInfoPresenterModule module);\n}\n```\n\n> D/UserInfoPresenter: mUserInfoLoader : com.example.linjw.dagger2demo.model.UserInfoLoader@31e117c\n> D/FollowerPresenter: mUserInfoLoader : com.example.linjw.dagger2demo.model.UserInfoLoader@31e117c\n\n# Demo地址\n\n可以在[这里](https://github.com/bluesky466/Dagger2Demo)查看完整代码\n","tags":["技术相关","Android"]},{"title":"Dagger2学习笔记(一)","url":"/2017/05/13/Dagger2学习笔记-一/","content":"\n依赖注入是一种十分好的技巧，它能解偶高层次模块和低层次模块，使得高层模块不用将底层模块硬编码到内部。\n所有依赖的底层模块都由外部注入，实际是一种面向接口编程。高层模块不依赖底层模块的实现细节，可以方便的做到替换底层模块。\n这种技术在编写跨平台程序的时候可以很容易的替换调依赖系统的底层模块，并且在做单元测试的时候也可以很容易的使用stub对象注入宿主类中从而方便宿主类的测试代码的编写。\n\n# 使用Dagger2实现依赖注入\n\n如果不使用DI框架，我们也可以在构造方法里传入依赖类或着用setter方法来将依赖类注入宿主类。但是这样的话就会需要我们在业务逻辑中处理依赖类的生成和注入，其实这些依赖的注入代码和业务都没有什么关系，仅仅是一些初始化的操作而已，如果可以将这些与业务逻辑无关的代码都独立出去，这样的话我们的代码逻辑就会更加的简洁和清晰。Dagger2就是一个十分强大的DI框架，它可以帮助我们轻松的在业务逻辑之外实现依赖注入。\n\n下面我将用一个小Demo来介绍一下Dagger2的用法。这个小Demo的功能是通过github帐号搜索用户头像和用户名，同时列出该用户的follower\n\n## Dagger2的引入\n\nDagger2没有使用反射，它是通过编译时生成代码来实现依赖注入的。所以需要引入apt:\n\n```\n//build.gradle(project)\n...\nbuildscript {\n\trepositories {\n\t\tjcenter()\n\t}\n\n\tdependencies {\n\t\tclasspath 'com.android.tools.build:gradle:2.3.0'\n\t\tclasspath 'com.neenbedankt.gradle.plugins:android-apt:1.8'\n\t}\n}\n...\n```\n\n```\n//build.gradle(app)\napply plugin: 'com.android.application'\napply plugin: 'com.neenbedankt.android-apt'\n...\n```\n\n之后再引入javax.annotation和dagger2:\n```\n//build.gradle(app)\n...\ndependencies {\n\t...\n\tcompile 'com.google.dagger:dagger:2.4'\n\tapt 'com.google.dagger:dagger-compiler:2.4'\n\tcompile 'org.glassfish:javax.annotation:10.0-b28'\n\t...\n}\n```\n\n## Dagger2的两个重要组件\n\nDagger2有两个十分重要的组件：Module和Component。\n\n- Module\n\n\tModule是依赖的提供者，Dagger2框架通过Module的Provides方法获取被依赖类的实例。\n\n- Component\n\n\tComponent是一个注入接口，Dagger2框架通过Component将依赖注入到高层类中。\n\n\t用一个形象的比喻来说明就是Module是装有被依赖类的针筒，Component是针头。Dagger2通过选择针筒和针头的不同组合可以将不同的被依赖实例注入到高层模块中。\n\n## 实现搜索页面\n\n### @Inject注解\n\n我们的搜索页面很简单，只有一个输入框和一个搜索安按钮，它的作用是输入要搜索的用户的账号。我们使用MVP模式去实现它,因为它不需要model层，所以只有View和Presenter:\n\n```\npublic interface SearchView {\n\t...\n}\n```\n\n```\npublic class SearchPresenter{\n\t...\n\t@Inject\n\tSearchView mSearchView;\n\n    @Inject\n    Context mContext;\n\n\t@Inject\n    public SearchPresenter() {\n        Log.d(TAG, \"SearchPresenter()\");\n    }\n\t...\n}\n```\n\n```\npublic class SearchActivity extends Activity implements SearchView {\n\t...\n\t@Inject\n\tSearchPresenter mSearchPresenter;\n\t...\n}\n```\n\n我们通过@Inject注解告诉Dagger2哪些成员变量是需要被注入的，这里需要注意的是被@Inject标注的成员变量不可以是private的，因为Dagger2没有用到反射，而是通过生成代码去完成注入的，所以一旦你将成员变量声明成private的，那Dagger2就不能访问到它，从而无法无法完成注入了。@Inject还有另外一个作用就是告诉Dagger2用哪个构造函数去创建实例，如这里Dagger2就会用SearchPresenter()去创建SearchPresenter的实例，这个构造函数的作用在接下来就会被讲到。\n\n### Module\n\n然后再让我们来看看SearchPresenterModule:\n\n```\n@Module\npublic class SearchPresenterModule {\n    private SearchActivity mSearchActivity;\n\n    public SearchPresenterModule(SearchActivity view) {\n        mSearchActivity = view;\n    }\n\n    @Provides\n    SearchView provideSearchView() {\n        return mSearchActivity;\n    }\n\n    @Provides\n    Context provideContext() {\n        return mSearchActivity;\n    }\n}\n```\n\n注入SearchPresenter所需要的SearchView和Context就是从这里提供的\n\nModule类首先需要使用@Module注解标注，让Dagger2知道这是一个Module，然后内部的使用@Provides注解标注的方法就是用来获取被依赖类的实例的方法,例如provideSearchView就可以用来提供SearchView\n\n一般我习惯@Provide方法加上provide前缀，但是这个也不是必须，可以没有这个前缀。\n\n### Component\n\n接着看看Component:\n\n```\n@Component(modules = {SearchPresenterModule.class})\npublic interface SearchComponent {\n    void inject(SearchActivity activity);\n\n    void inject(SearchPresenter presenter);\n}\n```\n\nComponent是一个被@Component注解标注的接口，Dagger2会自动生成实现这个接口的类，去完成注入的功能。我们需要用modules去告诉Component从哪个Module中获取被依赖类的实例。这里Dagger2就会自动生成实现了SearchComponent接口的DaggerSearchComponent类，它有两个方法，分别用来向SearchActivity和SearchPresenter注入依赖。\n\n向SearchPresenter注入的SearchView和Context都是SearchPresenterModule提供的这个很容易理解，但是向SearchActivity注入的SearchPresenter又是从哪里来的呢?还记得我们用@Inject标注了SearchPresenter的一个构造函数了吗？Dagger2会使用我们标注的构造函数创建出一个SearchPresenter来给SearchActivity注入使用。\n\n### 调用注入方法实现注入\n\n在SearchActivity的onCreate方法中将依赖注入到SearchActivity和SearchPresenter中:\n\n\n```\nSearchComponent component = DaggerSearchComponent.builder()\n                .searchPresenterModule(new SearchPresenterModule(this))\n                .build();\n\ncomponent.inject(this);\ncomponent.inject(mSearchPresenter);\n```\n\n它实际是通过查找SearchActivity和SearchPresenter中带有@Inject注解的成员变量知道哪个变量需要被注入，然后通过SearchPresenterModule的provide方法和SearchPresenter被标注的构造方法获取到被依赖类的实例去实现注入的。\n\n这里有一点需要注意的是调用顺序，inject(SearchActivity activity)要在inject(SearchPresenter presenter)前面调用，因为需要先将SearchActivity.this的mSearchPresenter注入，才能向mSearchPresenter中再注入SearchActivity\n\n### 指定构造函数\n\n我们在前面讲到过@Inject可以指定构造函数，其实它还有另一重意义，就是存在多个构造函数的时候选择其中一种。\n\n我们现在添加另外一种SearchPresenter构造函数,然后中添加打印:\n\n```\npublic class SearchPresenter{\n\t...\n\t@Inject\n\tSearchView mSearchView;\n\n    @Inject\n    Context mContext;\n\n\t@Inject\n    public SearchPresenter() {\n        Log.d(TAG, \"SearchPresenter()\");\n    }\n\n\tpublic SearchPresenter(Context context) {\n\t    Log.d(TAG, \"SearchPresenter(Context context)\");\n\t\tmContext = context;\n\t}\n\t...\n}\n```\n\n让我们看看运行的时候到底调的是哪个构造函数吧:\n\n> D/SearchPresenter(27333): SearchPresenter()\n\n如果我们把SearchPresenter类修改一下呢?\n\n```\npublic class SearchPresenter{\n\t...\n\t@Inject\n\tSearchView mSearchView;\n\n    // @Inject 注释掉\n    Context mContext;\n\n\t// @Inject 注释掉\n    public SearchPresenter() {\n        Log.d(TAG, \"SearchPresenter()\");\n    }\n\n\t@Inject // 添加@Inject\n\tpublic SearchPresenter(Context context) {\n\t    Log.d(TAG, \"SearchPresenter(Context context)\");\n\t\tmContext = context;\n\t}\n\t...\n}\n```\n\n现在可以看到打印:\n\n> D/SearchPresenter(27693): SearchPresenter(Context context)\n\n从打印来看，@Inject的确是可以选择构造函数的。但还有个细节不知道大家有没有注意到,我们去掉了mContext的@Inject,改由构造函数传入。这个传入构造函数的Context又是怎么来的呢？\n\n答案在SearchPresenterModule里:\n\n```\n@Module\npublic class SearchPresenterModule {\n    private SearchActivity mSearchActivity;\n\n    public SearchPresenterModule(SearchActivity view) {\n        mSearchActivity = view;\n    }\n\n    @Provides\n    SearchView provideSearchView() {\n        return mSearchActivity;\n    }\n\n\t// 是它,是它,就是它\n    @Provides\n    Context provideContext() {\n        return mSearchActivity;\n    }\n}\n```\n\n没错SearchPresenterModule.provideContext()这个方法还能创建Context出来给SearchPresenter的构造函数使用！\n\n# Demo地址\n\n可以在[这里](https://github.com/bluesky466/Dagger2Demo)查看完整代码，剩余部分的代码会在下一篇文章里介绍。\n","tags":["技术相关","Android"]},{"title":"automake学习笔记 - 交叉编译","url":"/2017/04/02/automake学习笔记-交叉编译/","content":"\n系列笔记:\n\n[1. automake学习笔记 - helloworld](https://blog.islinjw.cn/2017/03/17/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-helloworld/)\n[2. automake学习笔记 - 模块化编译](https://blog.islinjw.cn/2017/03/21/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E8%AF%91/)\n[3. automake学习笔记 - 安装与发布](https://blog.islinjw.cn/2017/03/26/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8F%91%E5%B8%83/)\n[4. automake学习笔记 - 交叉编译](https://blog.islinjw.cn/2017/04/02/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/)\n\n## 什么是交叉编译\n\n很多时候我们因为各种原因需要在一个平台上编译其他平台的程序。如在linux或者windows上编译可以在安卓使用的so库、apk等。在linux上编译windows的dll或者exe等。\n\n这种在某个系统平台下可以产生另一个系统平台的可执行文件的技术就叫做交叉编译。\n\n## 使用automake进行交叉编译\n\nautomake就提供了交叉编译的功能，但是它的[官方文档](https://www.gnu.org/software/automake/manual/html_node/Cross_002dCompilation.html)十分的简单:\n\n> 2.2.8 Cross-Compilation\n>\n> To cross-compile is to build on one platform a binary that will run on another platform. When speaking of cross-compilation, it is important to distinguish between the build platform on which the compilation is performed, and the host platform on which the resulting executable is expected to run. The following configure options are used to specify each of them:\n>\n> --build=build\nThe system on which the package is built.\n>\n> --host=host\nThe system where built programs and libraries will run.\n>\n> When the --host is used, configure will search for the cross-compiling suite for this platform. Cross-compilation tools commonly have their target architecture as prefix of their name. For instance my cross-compiler for MinGW32 has its binaries called i586-mingw32msvc-gcc, i586-mingw32msvc-ld, i586-mingw32msvc-as, etc.\n>\n> Here is how we could build amhello-1.0 for i586-mingw32msvc on a GNU/Linux PC.\n>\n> ~/amhello-1.0 % ./configure --build i686-pc-linux-gnu --host i586-mingw32msvc\nchecking for a BSD-compatible install... /usr/bin/install -c\nchecking whether build environment is sane... yes\nchecking for gawk... gawk\nchecking whether make sets $(MAKE)... yes\nchecking for i586-mingw32msvc-strip... i586-mingw32msvc-strip\nchecking for i586-mingw32msvc-gcc... i586-mingw32msvc-gcc\nchecking for C compiler default output file name... a.exe\nchecking whether the C compiler works... yes\nchecking whether we are cross compiling... yes\nchecking for suffix of executables... .exe\nchecking for suffix of object files... o\nchecking whether we are using the GNU C compiler... yes\nchecking whether i586-mingw32msvc-gcc accepts -g... yes\nchecking for i586-mingw32msvc-gcc option to accept ANSI C...\n…\n~/amhello-1.0 % make\n…\n~/amhello-1.0 % cd src; file hello.exe\nhello.exe: MS Windows PE 32-bit Intel 80386 console executable not relocatable\nThe --host and --build options are usually all we need for cross-compiling. The only exception is if the package being built is itself a cross-compiler: we need a third option to specify its target architecture.\n>\n> --target=target\nWhen building compiler tools: the system for which the tools will create output.\n>\n> For instance when installing GCC, the GNU Compiler Collection, we can use --target=target to specify that we want to build GCC as a cross-compiler for target. Mixing --build and --target, we can actually cross-compile a cross-compiler; such a three-way cross-compilation is known as a Canadian cross.\n>\n> See Specifying the System Type in The Autoconf Manual, for more information about these configure options.\n\n简单的来说就是通过在执行configure的时候通过传入下面三个参数进行配置,然后和普通的编译一样使用make命令就能编译出指定平台的程序\n\n- --build\n\n编译工程的平台\n\n- --host\n\n编译出来的程序或者库需要运行的平台\n\n- --target\n\n当构建编译器时,指定该编译器编译的程序的运行平台\n\n但是看例子，我们指定平台却并不是简单的指定windows、android这么简单。\n\n> ~/amhello-1.0 % ./configure --build i686-pc-linux-gnu --host i586-mingw32msvc\n\n这里的 i686-pc-linux-gnu和 i586-mingw32msvc-gcc其实指的是一系列的编译工具。交叉编译工具的命名其实是有一定的格式的。 例如，用来编译windows程序的MinGW32的交叉编译器的二进制文件叫做i586-mingw32msvc-gcc，i586-mingw32msvc-ld，i586-mingw32msvc-as等。\n\n> MinGW是Minimalist GNU for Windows的意思，又称mingw32，是将GCC编译器和GNU Binutils移植到Win32平台下的产物，包括一系列头文件（Win32API）、库和可执行文件。-- [维基百科](https://zh.wikipedia.org/wiki/MinGW)\n\n其实就是我们指定了编译工具的前缀，然后automake就会更加这个前缀，找到对应的编译器去编译我们的程序。\n\n## 在linux上编译windows上的程序\n\n有人可能会问，为什么需要在linux上编译这么蛋疼而不直接在windows上编译呢？\n\n就按我遇到的情况来说吧。我们部门的自动构建服务器就是liunx的，我们的项目都需要通过它来编译、检查和发布，我们也习惯于在linux上编程，最重要的是我们的项目就是跨平台的，不管是windows、linux还是android上都需要可以运行，所以没有必要为每个平台搭建一套编译环境。直接在linux上编译所有平台的软件是最好的选择。\n\n为了在linux上交叉编译windows的程序，我们先要搭建一下交叉编译的环境:\n\n1. 安装交叉编译工具\n\n```\nsudo apt-get install mingw-w64\n```\n\n2. 更新配置，使用 posix thread\n\n```\nsudo update-alternatives --config i686-w64-mingw32-g++\nsudo update-alternatives --config i686-w64-mingw32-gcc\nsudo update-alternatives --config x86_64-w64-mingw32-g++\nsudo update-alternatives --config x86_64-w64-mingw32-gcc\n```\n\n上面的选项中，选择 posix 版本。\n\n> 可移植操作系统接口（英语：Portable Operating System Interface of UNIX，缩写为POSIX），是IEEE为要在各种UNIX操作系统上运行软件，而定义API的一系列互相关联的标准的总称，其正式称呼为IEEE Std 1003，而国际标准名称为ISO/IEC 9945。此标准源于一个大约开始于1985年的项目。POSIX这个名称是由理查德·斯托曼应IEEE的要求而提议的一个易于记忆的名称。它基本上是Portable Operating System Interface（可移植操作系统接口）的缩写，而X则表明其对Unix API的传承。\nLinux基本上逐步实现了POSIX兼容，但并没有参加正式的POSIX认证。[1]\n微软的Windows NT声称部分实现了POSIX标准。[2]\n当前的POSIX主要分为四个部分[3]：Base Definitions、System Interfaces、Shell and Utilities和Rationale。 -- [维基百科](https://zh.wikipedia.org/wiki/POSIX)\n\n按道理这个时候就可以在build目录执行下面的命令去编译了\n\n```\n../configure --prefix=`pwd` --host i686-w64-mingw32\n```\n\n但是执行了configure之后却会报下面的错误:\n\n> libtool: warning: undefined symbols not allowed in i686-w64-mingw32 shared libraries; building static only\n\n本来我们的工程是需要编译动态库的，但是如果报了这个错误，就会编出静态库来，最终install之后在bin目录下面只有一个 __example.exe__ ，而没有dll。解决方法是在src/Makefile.am中加上\n\n> libeasylog_la_LDFLAGS = -no-undefined\n\n这样编译安装之后就能在bin目录下看到 __example.exe__ 和 __libeasylog-0.dll__ 了\n\n这个时候将这两个东西拷贝到windows平台上去，记得它们需要在同级目录这样 __example.exe__ 才能找到 __libeasylog-0.dll__。然后在控制台中运行 __example.exe__ 就会报下面的错误,其实就是还有几个dll没有找到：\n\n> 无法启动此程序,因为计算机中丢失libstdc++-6.dll。尝试重新安装该程序以解决此问题。  \n>\n> 无法启动此程序,因为计算机中丢失libgcc_s_sjlj-1.dll。尝试重新安装该程序以解决此问题。\n\n我们到下面的目录把缺的dll也拷贝到example的同级目录\n\n> /usr/lib/gcc/i686-w64-mingw32/5.3-posix/\n\n再次运行发现有报了下面的错误:\n\n> 无法启动此程序,因为计算机中丢失libwinpthread-1.dll。尝试重新安装该程序以解决此问题。\n\n这个dll可以到下面的目录拷贝，同样放到example的同级目录，之后再运行example:\n\n> [test] testlog\n\n看已经成功运行了。\n\n## 在linux上编译安卓上的程序\n\n搭建安卓的交叉编译环境就是生成 standalone toochain\n\n首先下载NDK，解压，假设NDK的根目录为NDK_ROOT，然后执行\n\n```\nsudo $NDK_ROOT/build/tools/make-standalone-toolchain.sh \\\n     --platform=android-19 \\\n     --install-dir=$HOME/Android/standalone-toolchains/android-toolchain-arm \\\n     --toolchain=arm-linux-androideabi-4.9 \\\n     --stl=gnustl\n```\n\n最后配置环境变量\n\n```\nexport NDK_ROOT=$HOME/Android/android-ndk-r13b\nexport TOOLCHAIN_HOME=$HOME/Android/standalone-toolchains/android-toolchain-arm\nexport TOOLCHAIN_SYSROOT=$TOOLCHAIN_HOME/sysroot\nexport PATH=$PATH:$TOOLCHAIN_HOME/bin\n```\n\n环境搭建好之后在build目录中执行\n\n```\n../configure --prefix=`pwd` --host arm-linux-androideabi\n```\n\n之后就能使用make install命令编译并安装了。\n\n在某些机器上编译时会报找不到shared_ptr的错误,解决方法是在src/Makefile.am和examples/Makefile.am的CPPFLAGS宏加上-std=c++11:\n\n```\n#src/Makefile.am\nlib_LTLIBRARIES = libeasylog.la\n\nlibeasylog_la_SOURCES = cout_log_interface.cpp \\\n\t\t\t\t\t\teasy_log.cpp\n\nlibeasylog_la_CPPFLAGS = -std=c++11\n\nlibeasylog_la_LDFLAGS = -no-undefined\n```\n\n```\n#examples/Makefile.am\nAM_CPPFLAGS = -I$(top_srcdir)/src \\\n              -std=c++11\n\nbin_PROGRAMS = example\nexample_SOURCES = example.cpp\n\nexample_LDADD = -L$(top_builddir)/src \\\n\t\t\t\t-leasylog\n\n```\n\n编译安装完成后再bin目录可以见到 __example__ ,在lib目录可以看到 __libeasylog.so__。\n\n虽然看起来和linux程序一样，但是直接运行example的话会报错:\n\n> zsh: 可执行文件格式错误: ./example\n\n因为它的运行环境是安卓，在本机(Ubuntu)上不能运行\n\n如果你有一台root了的安卓机器的话，可以使用adb将example给push到/system/bin，将libeasylog.so给push到/system/lib。这样就能在adb shell中使用example命令得到下面的输出了:\n\n> [test] testlog\n\n当然，做应用的一般都不会直接编译出可执行程序来给安卓使用。更多的是编译出so来给apk通过jni调用c/c++的方法。但是编译的过程和这里是一样的，关于jni的使用我之后会另写一篇文章来讨论。\n\n## Demo项目\n\n可以在[这里](https://github.com/bluesky466/automake-demo/tree/v0.0.4)查看完整的项目代码\n","tags":["技术相关","编译相关"]},{"title":"automake学习笔记 - 安装与发布","url":"/2017/03/26/automake学习笔记-安装与发布/","content":"\n系列笔记:\n\n[1. automake学习笔记 - helloworld](https://blog.islinjw.cn/2017/03/17/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-helloworld/)\n[2. automake学习笔记 - 模块化编译](https://blog.islinjw.cn/2017/03/21/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E8%AF%91/)\n[3. automake学习笔记 - 安装与发布](https://blog.islinjw.cn/2017/03/26/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8F%91%E5%B8%83/)\n[4. automake学习笔记 - 交叉编译](https://blog.islinjw.cn/2017/04/02/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/)\n\n辛辛苦苦写出来的代码当然是需要发布出来给自己或者别人去使用的。这篇文章就谈一谈发布相关的东西吧。\n\n## 安装\n\n软件在编译完后就需要进行安装。configure生成的Makefile支持install。使用make install 命令就可以将编译出来的软件安装到系统中。\n\n如果没有做配置，默认会安装到/usr/local中,当然如果需要的话也可以使用configure的--prefix参数指定安装的路径,如在build中执行下面的命令就可以将build目录指定为安装目录:\n\n> ../configure --prefix=\\`pwd\\`\n\n之后再执行下面的安装命令,工程在编译完后就会安装到build目录下。安装完毕之后可以看到build里面多了bin和lib两个目录\n\n> make install\n\nbin目录下是编译出来的可执行文件example,而lib目录下就是编译出来的依赖库:\n\n```\n-rw-r--r-- 1 linjw linjw 263K 3月  22 13:44 libeasylog.a\n-rwxr-xr-x 1 linjw linjw  985 3月  22 13:44 libeasylog.la\nlrwxrwxrwx 1 linjw linjw   19 3月  22 13:44 libeasylog.so -> libeasylog.so.0.0.0\nlrwxrwxrwx 1 linjw linjw   19 3月  22 13:44 libeasylog.so.0 -> libeasylog.so.0.0.0\n-rwxr-xr-x 1 linjw linjw 143K 3月  22 13:44 libeasylog.so.0.0.0\n```\n\n\n编译出来的libeasylog.so.0.0.0就可以直接拿出去给其他人使用了\n\n## 卸载\n\n卸载的话很简单，只需要执行下面的命令就行了\n\n> make uninstall\n\n当然你也可以选择手动去将安装的文件一个个删除,但是这样既麻烦又容易漏删或者错删\n\n## libtool 库版本号系统\n\n我们可以看到编译出来的so库是带版本号的，默认0.0.0,当然我们也能直接忽略版本号(某些可动态加载的的插件模块可能不需要版本号):\n\n```\nlib_LTLIBRARIES = libeasylog.la\n\nlibeasylog_la_SOURCES = cout_log_interface.cpp \\\n\t\t\t\t\t easy_log.cpp \n\nlibeasylog_la_LDFLAGS = -avoid-version\n```\n\n这样生成安装的so库就不会带版本号了:\n\n```\n-rw-r--r-- 1 linjw linjw 263K 3月  26 11:27 libeasylog.a\n-rwxr-xr-x 1 linjw linjw  975 3月  26 11:27 libeasylog.la\n-rwxr-xr-x 1 linjw linjw 143K 3月  26 11:27 libeasylog.so\n```\n\n当然，绝大部分的库都是需要带上版本号的。每个系统的库版本机制都不一样,libtool通过一种抽象的版本机制最终在创建库的时候才映射到具体的系统版本机制上。这是为了方便在交叉编译的时候可以用一种机制去管理不同平台上的各种版本机制。\n\nlibtool 库版本号系统有下面三个部分:\n\n- current\n\n接口的修改次数\n\n- revision\n\n上次修改后源码的修改次数(注意这里指的是只改动了实现,没有修改接口,如果改了接口的话应该要改current号，并且把revision置零)\n\n- age\n\n当前版本可以向前兼容的版本数\n\n[官方文档](http://www.gnu.org/software/libtool/manual/libtool.html#Updating-version-info)是这么描述这三个部分的更新规则的:\n\n> Here are a set of rules to help you update your library version information:\n1.    Start with version information of ‘0:0:0’ for each libtool library.\n2.    Update the version information only immediately before a public release of your software. More frequent updates are unnecessary, and only guarantee that the current interface number gets larger faster.\n3.    If the library source code has changed at all since the last update, then increment revision (‘c:r:a’ becomes ‘c:r+1:a’).\n4.    If any interfaces have been added, removed, or changed since the last update, increment current, and set revision to 0.\n5.    If any interfaces have been added since the last public release, then increment age.\n6.    If any interfaces have been removed or changed since the last public release, then set age to 0. \n\n翻译过来就是\n\n1. 库版本号应该开始于0.0.0\n2. 只有在正式发布库的时候才更新版本号以避免版本号增长过快\n3. 当实现代码改变的时候revision加1\n4. 当接口改变(无论是添加，删除还是修改接口声明)的时候current加1,同时revision重置为0\n5. 如果库只是增加了接口,则age加1\n6. 如果库删除或者修改了接口声明,则age重置为0\n\n这三个值可以用-version-info指定\n\n> -version-info current[:revision[:age]] \n\nrevision 和 age都可以省略,例如你这样设置:\n\n```\nlib_LTLIBRARIES = libeasylog.la\n\nlibeasylog_la_SOURCES = cout_log_interface.cpp \\\n\t\t\t\t\t easy_log.cpp \n\nlibeasylog_la_LDFLAGS = -version-info 3:12:1\n```\n\n表明接口被修改了三次,第三次修改接口之后又修改了12次源码,接口可以向前兼容1个版本\n\nmake install 后可以看到lib目录下生成的库长这样:\n\n```\n-rw-r--r-- 1 linjw linjw 263K 3月  26 12:11 libeasylog.a\n-rwxr-xr-x 1 linjw linjw  987 3月  26 12:11 libeasylog.la\nlrwxrwxrwx 1 linjw linjw   20 3月  26 12:11 libeasylog.so -> libeasylog.so.2.1.12\nlrwxrwxrwx 1 linjw linjw   20 3月  26 12:11 libeasylog.so.2 -> libeasylog.so.2.1.12\n-rwxr-xr-x 1 linjw linjw 143K 3月  26 12:11 libeasylog.so.2.1.12\n```\n\n为啥是libeasylog.so.2.1.12而不是libeasylog.so.3.12.1呢？\n\n原来这几个数字是这样计算的:\n\n库名.so.current-age.age.revision\n\n这样会引发一个问题:\n\n> 假设你的库有两个【3：0：1】【4：0：2】。 再假设在你编译程序的机器上安装了最新的【4：0：2】， 且你在程序中使用了该版本中新加的接口。当你程序编译好后， 你ldd发现你的程序依赖libraryname.so.2， 同时你将程序安装在了只安装了【3：0：1】的机器上， 你会发现你的程序能搜索到动态库， 却在运行的时候发现未定义的符号， 因为【3：0：1】中没有新添加的接口。 故你需要在运行机器上保证安装了同一主版本号最新的library， 以保证你的程序能正确运行。\n\n从 [libtool动态库版本系统之个人理解 ](http://blog.csdn.net/zlyong0018/article/details/16846325) 这篇博客引用\n\n## 手动指定版本号\n\n我之前了解到的so的命名规范其实和libtool的版本号系统的so库命名规范不一样:\n\n> 库名.so.主版本号.次版本号.发布版本号\n\n[官方文档](http://www.gnu.org/software/libtool/manual/libtool.html#Release-numbers)也有提到这一点:\n\n\n> Often, people want to encode the name of the package release into the shared library so that it is obvious to the user what package their programs are linked against. This convention is used especially on GNU/Linux:\n> \n> trick$ ls /usr/lib/libbfd*\n> /usr/lib/libbfd.a           /usr/lib/libbfd.so.2.7.0.2\n> /usr/lib/libbfd.so\n> trick$\n> \n> On ‘trick’, /usr/lib/libbfd.so is a symbolic link to libbfd.so.2.7.0.2, which was distributed as a part of ‘binutils-2.7.0.2’.\n> \n> Unfortunately, this convention conflicts directly with libtool’s idea of library interface versions, because the library interface rarely changes at the same time that the release number does, and the library suffix is never the same across all platforms.\n> \n> So, to accommodate both views, you can use the -release flag to set release information for libraries for which you do not want to use -version-info. For the libbfd example, the next release that uses libtool should be built with ‘-release 2.9.0’, which will produce the following files on GNU/Linux:\n> \n> trick$ ls /usr/lib/libbfd*\n> /usr/lib/libbfd-2.9.0.so     /usr/lib/libbfd.a\n> /usr/lib/libbfd.so\n> trick$\n> \n> In this case, /usr/lib/libbfd.so is a symbolic link to libbfd-2.9.0.so. This makes it obvious that the user is dealing with ‘binutils-2.9.0’, without compromising libtool’s idea of interface versions.\n> \n> Note that this option causes a modification of the library name, so do not use it unless you want to break binary compatibility with any past library releases. In general, you should only use -release for package-internal libraries or for ones whose interfaces change very frequently. \n\n可以使用-release去手动指定版本号,虽然官方不推荐用这种方式:\n\n```\nlib_LTLIBRARIES = libeasylog.la\n\nlibeasylog_la_SOURCES = cout_log_interface.cpp \\\n\t\t\t\t\t easy_log.cpp \n\nlibeasylog_la_LDFLAGS = -release 0.0.3\n```\n\n安装之后lib目录如下:\n\n```\n-rwxr-xr-x 1 linjw linjw 143K 3月  26 14:48 libeasylog-0.0.3.so\n-rw-r--r-- 1 linjw linjw 263K 3月  26 14:48 libeasylog.a\n-rwxr-xr-x 1 linjw linjw  993 3月  26 14:48 libeasylog.la\nlrwxrwxrwx 1 linjw linjw   19 3月  26 14:48 libeasylog.so -> libeasylog-0.0.3.so\n```\n\n可以在[这里](https://github.com/bluesky466/automake-demo/tree/v0.0.3)查看完整的项目代码\n","tags":["技术相关","编译相关"]},{"title":"automake学习笔记 - 模块化编译","url":"/2017/03/21/automake学习笔记-模块化编译/","content":"\n系列笔记:\n\n[1. automake学习笔记 - helloworld](https://blog.islinjw.cn/2017/03/17/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-helloworld/)\n[2. automake学习笔记 - 模块化编译](https://blog.islinjw.cn/2017/03/21/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E8%AF%91/)\n[3. automake学习笔记 - 安装与发布](https://blog.islinjw.cn/2017/03/26/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8F%91%E5%B8%83/)\n[4. automake学习笔记 - 交叉编译](https://blog.islinjw.cn/2017/04/02/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/)\n\n一般来说一个工程会由许多不同的模块组成。源码放在一个地方，示例代码放到另一个地方，第三方库又放到其他地方。这种时候又应该怎么去使用automake呢？\n\n这篇文章就讨论了一下如何使用automake去进行模块化编译\n\n我们还是用easylog来做例子，下面是我们修改后的easylog工程的根目录下的文件:\n\n> configure.ac  examples  Makefile.am  src\n\n## src目录\n\nsrc目录放的就是库的源代码,我们使用src中的源代码编译出一个库来给其他的程序使用easylog的功能  \n\nsrc目录中有下面几个文件log\\_interface.h，easy\\_log.h，easy\\_log.cpp，cout\\_log\\_interface.h，cout\\_log\\_interface.cpp，Makefile.am。实际上就是除了main.cpp，其他文件都放到了这里来。因为我们提供给别的是一个库而不是一个可执行程序，所以main.cpp可以不需要编译到目标文件中\n\n.h和.cpp的内容和上一篇[文章](http://blog.islinjw.cn/2017/03/17/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-helloworld/)的内容是一样的。这里的重点其实是Makefile.am。让我们先来看看它的内容:\n\n```\nlib_LTLIBRARIES = libeasylog.la                                                             \nlibeasylog_la_SOURCES = cout_log_interface.cpp \\                                            \n                     easy_log.cpp\n```\n\n其实它的内容很简单，就是指定了要编译的库的名字和库的源码。但是有一个问题，我们这里需要编译的是但为什么这里的目标文件是libeasylog.la呢?\n\nLibtool是一种属于GNU构建系统的GNU程序设计工具,它将静态库和动态库抽象成了一种统一的叫做libtool库的概念。libtool库使用la作为后缀。它可以用来构建静态库也能用来构建动态库，而最终编译出来的到底是哪一种，在最后执行configure命令的时候才能确定。同时它编译的时候产生的文件就不再是.o文件而是.lo文件。  \n\n这里lib\\_LTLIBRARIES的lib前缀表示的就是目标文件是一个动态库而不是可执行文件(bin前缀表示目标文件是可执行文件,noinst\\_LTLIBRARIES表示目标文件是静态库)。而LTLIBRARIES的LT指的就是Libtool。还有一点是一般编译库文件的话我们会在文件名钱加上lib前缀，所以我们的目标文件是libeasylog.la。\n\n而下面的libeasylog\\_la\\_SOURCES就是指定编译libeasylog.la使用的源代码\n\n\n这里顺便说一点,如果这里需要链接其他的库的话需要用 \\_LIBADD 去指定。如需要链接libpthread这个库的话就需要这样写:\n\n```\nlibeasylog_la_LIBADD = -lpthread\n```\n\n\n\n## examples目录\n\nexamples目录里面放了这个库的example代码。因为我们的库是要提供给其他人使用的，所以一般除了文档之外，还会有一些例子去帮助使用者了解应该如何去使用我们的库。这个目录中的example.cpp其实就是上一篇[文章](http://blog.islinjw.cn/2017/03/17/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-helloworld/)中的main.cpp：\n\n```\n#include \"easy_log.h\"\n#include \"cout_log_interface.h\"\n\n\nint main()\n{\n    EasyLog log(std::make_shared<COutLogInterface>());\n    log.Debug(\"test\", \"testlog\");\n\n    return 0;\n}\n```\n\n这个目录下也有一个Makefile.am，它是用来配置example程序的编译选项的:\n\n```\nAM_CPPFLAGS = -I$(top_srcdir)/src\n\nbin_PROGRAMS = example\nexample_SOURCES = example.cpp\n\nexample_LDADD = -L$(top_builddir)/src \\\n\t\t\t\t-leasylog\n```\n\nAM\\_CPPFLAGS的值在c/c++预处理的时候会当做参数传给预处理器例如我们将源码目录传给预处理器，这样预处理器才能找到easy\\_log.h和cout\\_log\\_interface.h\n\n这里的top\\_srcdir变量会在configure是被定义，它的值是工程目录的位置(也就是configure所在目录的位置)，后面的top\\_builddir也是类似的，不过它的值是编译目录的位置(也就是执行make命令是所在的目录)\n\n这里编译出来的example就是我们的demo程序\n\n\n## 根目录\n\n根目录下也有个Makefile.am,这个文件的内容很简单:\n\n```\nSUBDIRS = src examples\n```\n\n就是将src和examples指定为子目录于是在make编译的时候,编译器就会进入到这两个目录中继续编译。它们在这里的先后顺序决定了编译的先后顺序。因为examples中的example程序是依赖于easylog库的,所以要然src先编译\n\n如果不在这里指定子目录的话,在编译目录执行make命令就不会自动编译子目录中为源码,需要自己进到子目录中手动执行make命令。如果工程中的某些部分是可选编译的时候可以这么做。\n\n最后就是configure.ac文件了:\n\n```\n#                                               -*- Autoconf -*-\n# Process this file with autoconf to produce a configure script.\n\nAC_PREREQ([2.69])\nAC_INIT([easylog], [0.0.2], [466474482@qq.com])\nAM_INIT_AUTOMAKE([-Wall -Werror foreign])\nAC_CONFIG_SRCDIR([src/log_interface.h])\nAC_CONFIG_HEADERS([config.h])\n\nAM_PROG_AR\nLT_INIT\n\n# Checks for programs.\nAC_PROG_CXX\nAC_PROG_CC\nAX_CXX_COMPILE_STDCXX_11\n\n# Checks for libraries.\n\n# Checks for header files.\n\n# Checks for typedefs, structures, and compiler characteristics.\n\n# Checks for library functions.\n\nAC_CONFIG_FILES([Makefile\n                 examples/Makefile\n                 src/Makefile])\n\nAC_OUTPUT\n```\n\n它和上一篇[文章](http://blog.islinjw.cn/2017/03/17/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-helloworld/)只有一点点小的不同:\n\n一是由于将log\\_interface.h放到src中了，所以AC\\_CONFIG\\_SRCDIR需要改一下\n\n```\nAC_CONFIG_SRCDIR([src/log_interface.h])\n```\n\n二是examples和src中的Makefile.am也需要在configure.ac中指定:\n```\nAC_CONFIG_FILES([Makefile\n                 examples/Makefile\n                 src/Makefile])\n```\n\nAC\\_CONFIG\\_FILES指定了一些需要从Makefile.in中生成的Makefile。这里如果不指定的话configure就不会为其生成Makefile\n\n\n三是多了AM\\_PROG\\_AR和LT\\_INIT。如果不定义这两个宏的话,执行autoreconf --install命令得到了下面的错误日志:\n\n```\nsrc/Makefile.am:1: error: Libtool library used but 'LIBTOOL' is undefined\nsrc/Makefile.am:1:   The usual way to define 'LIBTOOL' is to add 'LT_INIT'\nsrc/Makefile.am:1:   to 'configure.ac' and run 'aclocal' and 'autoconf' again.\nsrc/Makefile.am:1:   If 'LT_INIT' is in 'configure.ac', make sure\nsrc/Makefile.am:1:   its definition is in aclocal's search path.\nautomake: warnings are treated as errors\n/usr/share/automake-1.15/am/ltlibrary.am: warning: 'libeasylog.la': linking libtool libraries using a non-POSIX\n/usr/share/automake-1.15/am/ltlibrary.am: archiver requires 'AM_PROG_AR' in 'configure.ac'\nsrc/Makefile.am:1:   while processing Libtool library 'libeasylog.la'\nautoreconf: automake failed with exit status: 1\n```\n\n注意AM\\_PROG\\_AR 要放在 LT\\_INIT 之前,要不然 autoreconf --install 的时候会报warn\n\n如果已经加上了 LT\\_INIT 但还是会报错的话就是系统中没有安装libtool了,必须先安装一下:\n\n```\nsudo apt-get install libtool\n```\n\n## 编译工程\n\n1. 在工程根目录创建子build目录用于编译\n\n2. 进入build目录\n\n3. 执行../configure\n\n4. 执行make\n\n之后进入build/examples运行example就可以看到下面输出:\n\n> [test] testlog\n\n## 静态库和动态库的区别\n\n我们之前在src/Makefile.am中生成的是动态库lib\\_LTLIBRARIES,所以如果将build/src目录删掉,build/examples/example就会因为找不到库而报错:\n\n> /home/linjw/workspace/automake-demo/build/examples/.libs/lt-example: error while loading shared libraries: libeasylog.so.0: cannot open shared object file: No such file or directory\n\n但如果将Makefile.am改成生成静态库则不会报错，因为静态库将库的代码也编译到可执行程序之中了。\n\n```\nnoinst_LTLIBRARIES = libeasylog.la                                               \nlibeasylog_la_SOURCES = cout_log_interface.cpp \\                                    \n                     easy_log.cpp\n```\n\n这里的noinst代表的其实是no install的意思\n\n## Demo项目\n\n可以在[这里](https://github.com/bluesky466/automake-demo/tree/v0.0.2)查看完整的项目代码\n","tags":["技术相关","编译相关"]},{"title":"automake学习笔记 - helloworld","url":"/2017/03/17/automake学习笔记-helloworld/","content":"\n系列笔记:\n\n[1. automake学习笔记 - helloworld](https://blog.islinjw.cn/2017/03/17/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-helloworld/)\n[2. automake学习笔记 - 模块化编译](https://blog.islinjw.cn/2017/03/21/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E8%AF%91/)\n[3. automake学习笔记 - 安装与发布](https://blog.islinjw.cn/2017/03/26/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8F%91%E5%B8%83/)\n[4. automake学习笔记 - 交叉编译](https://blog.islinjw.cn/2017/04/02/automake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/)\n\n虽然之前已经用过一段时间的automake,但是总觉得对它的理解不过充分,只是知其然而不知其所以然。于是下定决心好好啃[文档](http://www.gnu.org/software/automake/manual/automake.html),并将学的的东西记录下来。\n\n这篇文章用一个简单的log工具的编译先对automake做一个hello world级别的介绍。\n\n## 代码\n我们的demo有6个文件cout\\_log\\_interface.h, cout\\_log\\_interface.cpp, log\\_interface.h, easy\\_log.h, easy\\_log.cpp, main.cpp\n\n简单介绍下代码吧,首先有个简单的Log类:\n\n```\nclass EasyLog {\npublic:\n    EasyLog(std::shared_ptr<LogInterface> interface);\n\n    void Info(const std::string& tag, const std::string& log);\n\n    void Debug(const std::string& tag, const std::string& log);\n\n    void Warn(const std::string& tag, const std::string& log);\n\n    void Error(const std::string& tag, const std::string& log);\n\nprivate:\n    std::string GetLog(const std::string& tag, const std::string& log) const;\n\n    std::shared_ptr<LogInterface> interface_;\n};\n```\n\n它的实现十分简单，就是将所有的操作代理给LogInterface:\n\n```\nEasyLog::EasyLog(shared_ptr<LogInterface> interface)\n    : interface_(interface)\n{\n}\n\nvoid EasyLog::Info(const string& tag, const string& log)\n{\n    interface_->DoLog(kInfo, tag, GetLog(tag, log));\n}\n\nvoid EasyLog::Debug(const string& tag, const string& log)\n{\n    interface_->DoLog(kDebug, tag, GetLog(tag, log));\n}\n\nvoid EasyLog::Warn(const string& tag, const string& log)\n{\n    interface_->DoLog(kWarn, tag, GetLog(tag, log));\n}\n\nvoid EasyLog::Error(const string& tag, const string& log)\n{\n    interface_->DoLog(kError, tag, GetLog(tag, log));\n}\n\nstd::string EasyLog::GetLog(const string& tag, const string& log) const\n{\n    return \"[\" + tag + \"]\" + \" \" + log;\n}\n```\n\nLogInterface是一个纯虚类，然后LogLevel是一个枚举体:\n\n```\nenum LogLevel {\n    kInfo,\n    kDebug,\n    kWarn,\n    kError\n};\n\nclass LogInterface {\npublic:\n    virtual void DoLog(LogLevel level, const std::string& tag, const std::string& log) = 0;\n};\n```\n\n我们再写一个使用标准输出打印log的LogInterface:\n\n```\nclass COutLogInterface : public LogInterface {\npublic:\n    virtual void DoLog(LogLevel level, const std::string& tag, const std::string& log);\n};\n```\n\n它的实现就是使用cout打印log:\n\n```\nvoid COutLogInterface::DoLog(LogLevel level, const string& tag, const string& log) {\n    cout<<log<<endl;\n}\n```\n\n当然需要有个main函数:\n\n```\nint main()\n{\n    EasyLog log(std::make_shared<COutLogInterface>());\n    log.Debug(\"test\", \"testlog\");\n    return 0;\n}\n```\n\n## Makefile.am\n\nautomake使用Makefile.am配置工程的源码,它的内容如下:\n\n```\nbin_PROGRAMS = easylog\neasylog_SOURCES = cout_log_interface.cpp \\\n                  easy_log.cpp \\\n                  main.cpp\n```\n\nbin\\_PROGRAMS 指定了要编译生成的目标程序的名字,在这里我们最终编译出来的目标程序的文件名是easylog\n\n之后的 easylog\\_SOURCES 指定了需要参与编译的源代码。\n\n如果需要同时编译多个目标程序的话可以用下面的方式分别指定各个目标程序的源代码\n\n```\nbin_PROGRAMS = program_a program_b\nprogram_a_SOURCES = code_a.cpp\nprogram_b_SOURCES = code_b.cpp \n```\n\n## configure.ac\n\n指定了源代码还不够，因为automake不仅仅可以用来生成编译c/c++的makefile，还可以用来编译生成其他许许多多语言的makefile，所以还需要指定编译器和依赖文件等。automake使用configure.ac配置这些东西,本例子的configure.ac是这么写的:\n\n```\nAC_INIT([easylog], [0.0.1], [466474482@qq.com])\nAM_INIT_AUTOMAKE([-Wall -Werror foreign])\nAC_CONFIG_HEADERS([config.h])\n\nAC_PROG_CXX\nAX_CXX_COMPILE_STDCXX_11\n\nAC_CONFIG_FILES([Makefile])\n\nAC_OUTPUT\n```\n\n简单分析一下configure.ac的内容:\n\n- AC\\_INIT \n\n指定了工程的名字、版本号、和bug的报告邮箱\n\n- AM\\_INIT\\_AUTOMAKE\n\n指定了一些选项,-Wall和-Werror指定编译的时候将所有的warning当做error来报错, foreign告诉automake这里不用遵循GNU标准。GNU软件包应该包括一些附加文件去描述如修改项，作者等信息。在这里我们不需要automake去检查这些附加文件的存在。\n\n- AC\\_CONFIG\\_HEADERS \n\n我们在AC\\_INIT中配置了版本号等信息,c/c++中一般需要用宏来定义它们,这里就指定了生成的配置宏的头文件名。配置了这里,automake就会自动帮我们生成config.h头文件,里面定义了一些VERSION之类的宏\n\n- AC\\_PROG\\_CXX\n\n该宏用于检查系统中是否有g++编译器\n\n- AX\\_CXX\\_COMPILE\\_STDCXX\\_11 \n\n检查系统的c++11编译支持\n\n- AC\\_CONFIG\\_FILES \n\n指定了需要configure生成的Makefile,autoreconf的时候会通过Makefile.am生成Makefile.in。而configure的时候会通过Makefile.in生成Makefile。因为Makefile.am和configure.ac在同级目录,所以直接写Makefile就好了。在后面我会介绍当Makefile.am和configure.ac不在同级目录的时候需要怎么配置\n\n- AC\\_OUTPUT\n\n这是一个结束标志,实际上它是一个脚本命令用来创建AC\\_CONFIG\\_HEADERS和AC\\_CONFIG\\_FILES所配置的文件\n\n## 生成Makefile\n\n首先要安装autoconf\n\n> sudo apt-get install autoconf\n\n然后使用下面的命令生成configure\n\n> autoreconf --install\n\n除了configure之外，它还会生成一些其他的文件，当然现在我们不需要去管这些文件\n\n之后就能使用configure脚本去生成Makefile和config.h等\n\n> ./configure\n\n\n## 编译工程\n\nMakefile都已经生成了，现在就可以使用make命令编译工程啦  \n\n编译成功之后就能在当前目录看到easylog程序。我们可以运行它:\n\n> ./easylog\n\n得到下面输出:\n\n> [test] testlog\n\n## 在build目录中编译项目\n\n现在我们编译生成的.o文件和目标程序都混在源代码中间,看起来很不舒服。我们可以创建一个build目录。然后进入build目录执行下面命令\n\n> ../configure\n\n这样就在build目录下生成Makefile了,于是现在我们在build中使用make命令编辑工程就会发现编译产生的.o文件和目标文件都在build中而不会污染源代码了。\n\n## 使用autoscan生成configure.ac                                                  \n                                                                                 \n如果直接手写configure.ac的话是比较困难的,很容易漏掉一些依赖项没有检查。所以就出现了autoscan这个工具,它可以帮我们检查工程中的依赖项生成configure.ac的模板,然后我们只需要在它生成的模板上略加改动就可以了。\n                                                                                 \n我们在工程目录下使用autoscan命令,会得到下面的两个文件:                           \n                                                                                 \n1. autoscan.log                                                                  \n                                                                                 \n2. configure.scan                                                                \n                                                                                 \nautoscan.log是一个日志文件,通过它我们可以知道一些配置为什么会被需要              \n                                                                                 \n而configure.scan就是生成出来的configure.ac的模板了,在easylog工程目录使用autoscan,生成的configure.scan内容如下\n                                                                                 \n```                                                                              \n#                                               -*- Autoconf -*-                 \n# Process this file with autoconf to produce a configure script.                 \n                                                                                 \nAC_PREREQ([2.69])                                                                \nAC_INIT([FULL-PACKAGE-NAME], [VERSION], [BUG-REPORT-ADDRESS])                    \nAC_CONFIG_SRCDIR([log_interface.h])                                              \nAC_CONFIG_HEADERS([config.h])                                                    \n                                                                                 \n# Checks for programs.                                                           \nAC_PROG_CXX                                                                      \nAC_PROG_CC                                                                       \n                                                                                 \n# Checks for libraries.                                                          \n                                                                                 \n# Checks for header files.                                                       \n                                                                                 \n# Checks for typedefs, structures, and compiler characteristics.                 \n                                                                                 \n# Checks for library functions.                                                  \n                                                                                 \nAC_CONFIG_FILES([Makefile])                                                      \nAC_OUTPUT                                                                        \n```                                                                              \n                                                                                 \n看是不是和我们之前手写的很像?我们只有在上面进行一些小的修改就能得到最终我们需要的configure.ac了\n\n这里有两个宏我们是没有见过的\n\n- AC\\_PREREQ\n\n用于检查autoconf的最低版本\n\n- AC\\_CONFIG\\_SRCDIR\n\n用一个项目中一定存在的文件去确定源码目录的有效性,这是一个安全检查宏。configure有一个--srcdir的参数可以指定源码目录,这个宏就可以检查出源码目录是否不小心配置错了\n\n## Demo项目\n\n可以在[这里](https://github.com/bluesky466/automake-demo/tree/v0.0.1)查看完整的项目代码\n","tags":["技术相关","编译相关"]},{"title":"在android上使用grpc","url":"/2017/03/03/在android上使用grpc/","content":"\n最近的一个项目使用到了grpc实现跨平台的远程调用，在安卓端使用的时候遇到了一些坑，这里记录一下。\n\n首先根据grpc android的[官方Demo](https://github.com/grpc/grpc-java/tree/v1.0.0/examples/android)配置grpc依赖，测试它的hello world工程。\n\n# 编译谷歌官方的helloworld工程\n\n### 添加rotobuf-gradle-plugin插件\n首先添加rotobuf-gradle-plugin插件，他是用来从proto文件自动生成java代码的:\n\n```\n//Project的build.gradle中添加rotobuf-gradle-plugin插件\nbuildscript {\n    ...\n    dependencies {\n        ...\n        classpath \"com.google.protobuf:protobuf-gradle-plugin:0.8.0\"\n        ...\n    }\n    ...\n}\n```\n\n```\n//App的build.gradle中添加下面配置\napply plugin: 'com.google.protobuf'\n\nprotobuf {\n    protoc {\n        artifact = 'com.google.protobuf:protoc:3.0.0'\n    }\n    plugins {\n        javalite {\n            artifact = \"com.google.protobuf:protoc-gen-javalite:3.0.0\"\n        }\n        grpc {\n            artifact = 'io.grpc:protoc-gen-grpc-java:1.0.0' // CURRENT_GRPC_VERSION\n        }\n    }\n    generateProtoTasks {\n        all().each { task ->\n            task.plugins {\n                javalite {}\n                grpc {\n                    // Options added to --grpc_out\n                    option 'lite'\n                }\n            }\n        }\n    }\n}\n```\n\n### 添加proto文件并自动生成java代码\n\n在src/main/目录下创建一个proto目录，并将官方的[helloworld.proto](https://github.com/grpc/grpc-java/blob/v1.0.0/examples/android/helloworld/app/src/main/proto/helloworld.proto)放到proto目录下\n\n之后只需要rebuild一下就能看到build/generated/source/proto/目录下根据helloworld.proto生成了几个Java类\n\n\n{% img /在android上使用grpc/proto_gen.jpeg %}\n\n### 添加安卓端grpc的依赖\n\n```\n//App的build.gradle中添加下面配置\n dependencies {\n    ...\n    compile 'io.grpc:grpc-okhttp:1.1.2'\n    compile 'io.grpc:grpc-protobuf-lite:1.1.2'\n    compile 'io.grpc:grpc-stub:1.1.2'\n    compile 'javax.annotation:javax.annotation-api:1.2'\n    ...\n}\n```\n\n```\nconfigurations.all {\n        resolutionStrategy.force 'com.google.code.findbugs:jsr305:3.0.1'\n    }\n```\n\n我这个时候报了这个错误\n\n> Warning:Conflict with dependency 'com.google.code.findbugs:jsr305'. Resolved versions for app (3.0.0) and test app (2.0.1) differ. See http://g.co/androidstudio/app-test-app-conflict for details.\n\n这是因为com.google.code.findbugs:jsr305的版本不一致导致的\n\n可以在App的build.gradle的android标签中配置一下解决\n\n```\nandroid {\n    ...\n    configurations.all {\n        resolutionStrategy.force 'com.google.code.findbugs:jsr305:3.0.1'\n    }\n    ...\n}\n```\n\n### 编写demo代码\n\n```\npublic class MainActivity extends AppCompatActivity {\n    private static final String TAG = \"GrpcDemo\";\n\n    private static final int PROT = 55055;\n    private static final String NAME = \"linjw\";\n    private static final String HOST = \"localhost\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        startServer(PROT);\n        startClient(HOST, PROT, NAME);\n    }\n\n    private void startServer(int port){\n        try {\n            Server server = ServerBuilder.forPort(port)\n                    .addService(new GreeterImpl())\n                    .build()\n                    .start();\n        } catch (IOException e) {\n            e.printStackTrace();\n            Log.d(TAG, e.getMessage());\n        }\n    }\n\n    private void startClient(String host, int port, String name){\n        new GrpcTask(host, port, name).execute();\n    }\n\n    private class GreeterImpl extends GreeterGrpc.GreeterImplBase {\n        public void sayHello(HelloRequest request, StreamObserver<HelloReply> responseObserver) {\n            responseObserver.onNext(sayHello(request));\n            responseObserver.onCompleted();\n        }\n\n        private HelloReply sayHello(HelloRequest request) {\n            return HelloReply.newBuilder()\n                    .setMessage(\"hello \"+ request.getName())\n                    .build();\n        }\n    }\n\n    private class GrpcTask extends AsyncTask<Void, Void, String> {\n        private String mHost;\n        private String mName;\n        private int mPort;\n        private ManagedChannel mChannel;\n\n        public GrpcTask(String host, int port, String name) {\n            this.mHost = host;\n            this.mName = name;\n            this.mPort = port;\n        }\n\n        @Override\n        protected void onPreExecute() {\n        }\n\n        @Override\n        protected String doInBackground(Void... nothing) {\n            try {\n                mChannel = ManagedChannelBuilder.forAddress(mHost, mPort)\n                        .usePlaintext(true)\n                        .build();\n                GreeterGrpc.GreeterBlockingStub stub = GreeterGrpc.newBlockingStub(mChannel);\n                HelloRequest message = HelloRequest.newBuilder().setName(mName).build();\n                HelloReply reply = stub.sayHello(message);\n                return reply.getMessage();\n            } catch (Exception e) {\n                StringWriter sw = new StringWriter();\n                PrintWriter pw = new PrintWriter(sw);\n                e.printStackTrace(pw);\n                pw.flush();\n                return \"Failed... : \" + System.lineSeparator() + sw;\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            try {\n                mChannel.shutdown().awaitTermination(1, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            Log.d(TAG, result);\n        }\n    }\n}\n\n```\n\n这段代码运行会崩溃:\n\n> Caused by: io.grpc.ManagedChannelProvider$ProviderNotFoundException: No functional server found. Try adding a dependency on the grpc-netty artifact\n\n猜测google使用netty替代了okhttp，尝试换成grpc-netty的依赖:\n\n```\ndependencies {\n    ...\n    compile 'io.grpc:grpc-netty:1.1.2'\n    compile 'io.grpc:grpc-protobuf-lite:1.1.2'\n    compile 'io.grpc:grpc-stub:1.1.2'\n    compile 'javax.annotation:javax.annotation-api:1.2'\n    ...\n}\n```\n\n这么编译会报错\n\n> com.android.build.api.transform.TransformException: com.android.builder.packaging.DuplicateFileException: Duplicate files copied in APK META-INF/INDEX.LIST\n\n需要加上下面的配置解决\n\n```\nandroid {\n    ...\n    packagingOptions {\n        pickFirst 'META-INF/INDEX.LIST'\n        pickFirst 'META-INF/LICENSE'\n        pickFirst 'META-INF/io.netty.versions.properties'\n    }\n    ...\n}\n```\n\n当然，还需要加上INTERNET权限，要不然运行的时候还是会崩溃。\n\n最终就能看的下面的打印，这样安卓grpc的helloworld就成功了。\n\n> 03-03 00:04:20.000 6137-6137/linjw.com.grpcdemo D/GrpcDemo: hello linjw\n\n# 使用com.google.protobuf.Any\n\nAny可以携带任意类型的数据，用法相当于c语言的void指针。在项目中是很常用的，但是谷歌在javalite的版本不支持Any。\n\n如果在proto文件中使用了Any的话生成java代码就会有报错，例如将helloworld的proto文件改成下面的样子:\n\n```\n// Copyright 2015, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\noption java_multiple_files = true;\noption java_package = \"io.grpc.examples.helloworld\";\noption java_outer_classname = \"HelloWorldProto\";\noption objc_class_prefix = \"HLW\";\n\npackage helloworld;\n\nimport \"google/protobuf/any.proto\";\n\n// The greeting service definition.\nservice Greeter {\n  // Sends a greeting\n  rpc SayHello (google.protobuf.Any) returns (HelloReply) {}\n}\n\n// The request message containing the user's name.\nmessage HelloRequest {\n  string name = 1;\n}\n\n// The response message containing the greetings\nmessage HelloReply {\n  string message = 1;\n}\n```\n\n报错如下\n\n> google/protobuf/any.proto: File not found.\n  helloworld.proto: Import \"google/protobuf/any.proto\" was not found or had errors.\n  helloworld.proto:44:17: \"google.protobuf.Any\" is not defined.\n\n### 使用grpc-jave代替grpc-javalite\n\n但是现在做的这个项目的linux端实现已经用了Any，要改的话需要耗费比较大的精力。幸好尝试了下，发现安卓上也能跑支持Any的grpc-java。\n\n首先我们要使用grpc-protobuf依赖替换grpc-protobuf-lite依赖\n\n```\ndependencies {\n    ...\n    compile 'io.grpc:grpc-netty:1.1.2'\n    compile 'io.grpc:grpc-protobuf:1.1.2'\n    compile 'io.grpc:grpc-stub:1.1.2'\n    compile 'javax.annotation:javax.annotation-api:1.2'\n    ...\n}\n```\n\n接着修改protobuf-gradle-plugin配置使得自动生成java的代码而不是javalite的代码\n\n```\nprotobuf {\n    protoc {\n        artifact = 'com.google.protobuf:protoc:3.0.0'\n    }\n    plugins {\n        grpc {\n            artifact = 'io.grpc:protoc-gen-grpc-java:1.0.0' // CURRENT_GRPC_VERSION\n        }\n    }\n    generateProtoTasks {\n        all().each { task ->\n            task.builtins {\n                java {}\n            }\n            task.plugins {\n                grpc {}\n            }\n        }\n    }\n}\n```\n\n对应的修改helloworld的代码就能运行了\n\n```\n\npublic class MainActivity extends AppCompatActivity {\n    private static final String TAG = \"GrpcDemo\";\n\n    private static final int PROT = 55055;\n    private static final String NAME = \"linjw\";\n    private static final String HOST = \"localhost\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        startServer(PROT);\n        startClient(HOST, PROT, NAME);\n    }\n\n    private void startServer(int port){\n        try {\n            Server server = ServerBuilder.forPort(port)\n                    .addService(new GreeterImpl())\n                    .build()\n                    .start();\n        } catch (IOException e) {\n            e.printStackTrace();\n            Log.d(TAG, e.getMessage());\n        }\n    }\n\n    private void startClient(String host, int port, String name){\n        new GrpcTask(host, port, name).execute();\n    }\n\n    private class GreeterImpl extends GreeterGrpc.GreeterImplBase {\n        public void sayHello(Any request, StreamObserver<HelloReply> responseObserver) {\n            try {\n                responseObserver.onNext(sayHello(request.unpack(HelloRequest.class)));\n                responseObserver.onCompleted();\n            } catch (InvalidProtocolBufferException e) {\n                e.printStackTrace();\n            }\n        }\n\n        private HelloReply sayHello(HelloRequest request) {\n            return HelloReply.newBuilder()\n                    .setMessage(\"hello \"+ request.getName())\n                    .build();\n        }\n    }\n\n    private class GrpcTask extends AsyncTask<Void, Void, String> {\n        private String mHost;\n        private String mName;\n        private int mPort;\n        private ManagedChannel mChannel;\n\n        public GrpcTask(String host, int port, String name) {\n            this.mHost = host;\n            this.mName = name;\n            this.mPort = port;\n        }\n\n        @Override\n        protected void onPreExecute() {\n        }\n\n        @Override\n        protected String doInBackground(Void... nothing) {\n            try {\n                mChannel = ManagedChannelBuilder.forAddress(mHost, mPort)\n                        .usePlaintext(true)\n                        .build();\n                GreeterGrpc.GreeterBlockingStub stub = GreeterGrpc.newBlockingStub(mChannel);\n                HelloRequest message = HelloRequest.newBuilder().setName(mName).build();\n                HelloReply reply = stub.sayHello(Any.pack(message));\n                return reply.getMessage();\n            } catch (Exception e) {\n                StringWriter sw = new StringWriter();\n                PrintWriter pw = new PrintWriter(sw);\n                e.printStackTrace(pw);\n                pw.flush();\n                return \"Failed... : \" + System.lineSeparator() + sw;\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            try {\n                mChannel.shutdown().awaitTermination(1, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            Log.d(TAG, result);\n        }\n    }\n}\n\n```\n\n完整的demo代码可以点[这里](https://github.com/bluesky466/grpc-android-demo)在我的github中查看\n\n# Android方法数不能超过65535的问题\n\n最后使用grpc，方法数会超过65535，可以使用com.android.support:multidex去解决\n","tags":["技术相关","Android"]},{"title":"责任链模式","url":"/2016/11/18/责任链模式/","content":"# 什么是责任链模式\n\n责任链模式是一种对象的行为模式，它包含了一些命令对象和一系列的处理对象。是一种链型的结构，每个处理对象可以处理特定的命令对象，当遇到不能处理的命令对象的时候，就会把它传递给下一个处理对象，直到没有最后一个处理对象。\n\n{% img /责任链模式/链式结构.png %}\n\n# 责任链模式的实现\n\n从责任链模式的定义来看，使用单链表去实现它是一种最容易想到和最形象的做法。假设我们有一个解压程序，它可以解压多种不同的压缩格式。\n\n数据定义成下面的样子:\n\n```cpp\nstruct Data{\n    Data(unsigned char* data, int size) :data(data), size(size) {}\n\n    unsigned char* data;\n    unsigned int size;\n};\n```\n\n每个解压器类根据自己是否能够解压接收到的数据，判断应该直接解压数据还是传递给下一个解压器程序去解压。所以将这一逻辑抽象出来，我们可以得到下面的抽象基类:\n\n```cpp\nclass Decompressor{\npublic:\n    Decompressor() : mSuccessor(0){}\n    Decompressor(const Decompressor* successor) : mSuccessor(successor){}\n\n    void setSuccessor(const Decompressor* successor){\n        mSuccessor = successor;\n    }\n\n    Data decompress(const Data& data) const{\n        if(canDecompress(data)){\n            return doDecompress(data);\n        }else if(mSuccessor!=0){\n            return mSuccessor->decompress(data);\n        }\n        return Data(0, 0);\n    }\n\nprivate:\n    const Decompressor* mSuccessor;\n\n    virtual bool canDecompress(const Data& data)const = 0;\n    virtual Data doDecompress(const Data& data)const = 0;\n};\n```\n\n我们模拟三种数据的解压器:\n\n```cpp\nclass GZipDecompressor : public Decompressor{\npublic:\n    GZipDecompressor() { }\n    GZipDecompressor(Decompressor* successor):Decompressor(successor) { }\n\nprivate:\n    virtual bool canDecompress(const Data& data)const{\n        cout<<\"GZipDecompressor:canDecompress\"<<endl;\n        const char* d = (const char*)data.data;\n        return d && 0==strncmp(d, \"gzip\", strlen(\"gzip\"));\n    }\n\n    virtual Data doDecompress(const Data& data)const{\n        cout<<\"GZipDecompressor:doDecompress\"<<endl;\n        const char* d = \"doDecompress by GZipDecompressor\";\n        return Data((unsigned char*)d, strlen(d));\n    }\n};\n```\n\n```cpp\nclass RarDecompressor : public Decompressor{\npublic:\n    RarDecompressor() { }\n    RarDecompressor(Decompressor* successor):Decompressor(successor) { }\n\nprivate:\n    virtual bool canDecompress(const Data& data)const{\n        cout<<\"RarDecompressor:canDecompress\"<<endl;\n        const char* d = (const char*)data.data;\n        return d && 0==strncmp(d, \"rar\", strlen(\"rar\"));\n    }\n\n    virtual Data doDecompress(const Data& data)const{\n        cout<<\"RarDecompressor:doDecompress\"<<endl;\n        const char* d = \"doDecompress by RarDecompressor\";\n        return Data((unsigned char*)d, strlen(d));\n    }\n};\n```\n\n```cpp\nclass ZipDecompressor : public Decompressor{\npublic:\n    ZipDecompressor() { }\n    ZipDecompressor(Decompressor* successor):Decompressor(successor) { }\n\nprivate:\n    virtual bool canDecompress(const Data& data)const{\n        cout<<\"ZipDecompressor:canDecompress\"<<endl;\n        const char* d = (const char*)data.data;\n        return d && 0==strncmp(d, \"zip\", strlen(\"zip\"));\n    }\n\n    virtual Data doDecompress(const Data& data)const{\n        cout<<\"ZipDecompressor:doDecompress\"<<endl;\n        const char* d = \"doDecompress by ZipDecompressor\";\n        return Data((unsigned char*)d, strlen(d));\n    }\n};\n```\n\n嗯哼，是否直观的实现方式。最后是main函数和输出结果:\n\n```cpp\nint main(){\n    RarDecompressor rarDecompressor;\n    GZipDecompressor gzipDecompressor(&rarDecompressor);\n    ZipDecompressor zipDecompressor(&gzipDecompressor);\n\n    Data input((unsigned char*)\"gzip\",strlen(\"gzip\"));\n    Data output = zipDecompressor.decompress(input);\n\n    if(output.data){\n        const char* out = (const char*)output.data;\n        cout<<\"result : \"<<out<<endl;\n    }else{\n        cout<<\"result : null\"<<endl;\n    }\n\n    return 0;\n}\n```\n\n> ZipDecompressor:canDecompress  \n> GZipDecompressor:canDecompress  \n> GZipDecompressor:doDecompress  \n> result : doDecompress by GZipDecompressor\n\n可以看到，数据经过了ZipDecompressor和GZipDecompressor，最后由GZipDecompressor解压处理，整个过程没有经过RarDecompressor\n\n当然为了使代码可维护性更高，我们可以再编写一个SuperDecompressor类来包装解压操作:\n\n```cpp\nclass SuperDecompressor{\npublic:\n    Data decompressCompressedFile(const Data& data);\n\nprivate:\n    ZipDecompressor mZipDecompressor;\n    RarDecompressor mRarDecompressor;\n    GZipDecompressor mGZipDecompressor;\n};\n\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    mZipDecompressor.setSuccessor(&mGZipDecompressor);\n    mGZipDecompressor.setSuccessor(&mRarDecompressor);\n    mRarDecompressor.setSuccessor(0);\n\n    return mZipDecompressor.decompress(data);\n}\n```\n\n这个时候main函数会显得比较简单:\n\n```cpp\nint main(){\n    SuperDecompressor decompressor;\n\n    Data input((unsigned char*)\"gzip\",strlen(\"gzip\"));\n    Data output = decompressor.decompressCompressedFile(input);\n\n    if(output.data){\n        const char* out = (const char*)output.data;\n        cout<<\"result : \"<<out<<endl;\n    }else{\n        cout<<\"result : null\"<<endl;\n    }\n\n    return 0;\n}\n```\n\n输出的结果是一样的:\n> ZipDecompressor:canDecompress  \n> GZipDecompressor:canDecompress  \n> GZipDecompressor:doDecompress  \n> result : doDecompress by GZipDecompressor\n\n# 优化\n\n依靠我们程序员的直觉，下面两段代码都是很容易出错的，尤其是当Decompressor的数目很多的时候。\n\n```cpp\nint main(){\n\t //下面的三行代码容易出错\n    RarDecompressor rarDecompressor;\n    GZipDecompressor gzipDecompressor(&rarDecompressor);\n    ZipDecompressor zipDecompressor(&gzipDecompressor);\n\n    Data input((unsigned char*)\"gzip\",strlen(\"gzip\"));\n    Data output = zipDecompressor.decompress(input);\n\n    if(output.data){\n        const char* out = (const char*)output.data;\n        cout<<\"result : \"<<out<<endl;\n    }else{\n        cout<<\"result : null\"<<endl;\n    }\n\n    return 0;\n}\n```\n\n```cpp\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    mZipDecompressor.setSuccessor(&mGZipDecompressor);\n    mGZipDecompressor.setSuccessor(&mRarDecompressor);\n    mRarDecompressor.setSuccessor(0);\n\n    return mZipDecompressor.decompress(data);\n}\n```\n\n其实使用构造函数和setter方法设置下一个处理类有一个很大的问题，就是在编码的时候很容易就写错了，会出现一些意想不到的bug，而且比较难发现。同时，每次需要修改处理类的顺序或者删除其中的一个或几个处理类，都需要使用setter方法对处理链进行修改，不仅繁琐，而且也比较容易出错。\n\n基于以上的原因，我们会去想，有没有一种更加灵活的实现方式，使得构建处理链不容易出错，而且也能很简单而且很安全的修改处理链呢？\n\n其实我们可以用下面的链式结构去优化:\n\n```cpp\nclass Decompressor{\npublic:\n    Decompressor() : mSuccessor(0){}\n\n    Decompressor& next(Decompressor& successor){\n        mSuccessor = &successor;\n        successor.setSuccessor(0);\n        return successor;\n    }\n\n    Data decompress(const Data& data) const{\n        if(canDecompress(data)){\n            return doDecompress(data);\n        }else if(mSuccessor!=0){\n            return mSuccessor->decompress(data);\n        }\n        return Data(0, 0);\n    }\n\nprivate:\n    const Decompressor* mSuccessor;\n\n    virtual bool canDecompress(const Data& data)const = 0;\n    virtual Data doDecompress(const Data& data)const = 0;\n\n    void setSuccessor(const Decompressor* successor){\n        mSuccessor = successor;\n    }\n};\n```\n\n在这里，我们添加了一个next方法，同时把setSuccessor设为private,于是使用的方法就会变得简洁了许多。\n\n```cpp\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    mZipDecompressor.next(mGZipDecompressor).next(mRarDecompressor);\n    return mZipDecompressor.decompress(data);\n}\n```\n\n# 另一种灵活的实现方式\n\n\n联想一下linux的管道机制：__前一个命令的结果会传递给后一个命令__。\n\n是不是可以从中得到启发呢？是不是可以有一种架构可以使得通过下面的形式就能得到最终处理后的结果？\n\n```cpp\n\tData decompressedData = compressedData | mZipDecompressor | mGZipDecompressor | mRarDecompressor;\n```\n\n首先，很容易想到我们需要通过重载操作符去实现这种机制。我们可以重载 \"|\" 操作符，将Data和Decompressor作为参数传入，再将处理后或者没有处理的Data作为返回值返回，传到下一个Decompressor那里去。\n\n基本的思想是这样的，但是这里有个很重要的问题要处理：我们如何知道上一个Decompressor有没有解压过数据？\n\n当然可以直接调用Decompressor::canDecompress看看是否是可解压的就能知道上一个Decompressor有没有处理过数据。但是这样的处理模式有一些风险，而且也比较浪费资源，明明前一个Decompressor已经解压完成了，但是后面的Decompressor还回去判断是否可以解压，这个判断可能比较复杂。\n\n第二种解决方案就是拓展Data结构体，添加一个是否已经解压字段。这样能够完美的解决问题，但是Data的职责就变重了，他不仅要保存数据，还要知道保存的数据究竟是解压过的还是没有解压过的。而且这个标志字段只有在解压的过程中才有用，因为一般数据在存储的时候我们已经知道它是否被压缩过了，我们总不会会将未解压和解压过的数据混在一起存放的。\n\n其实还有第三种解决方法:\n\n```cpp\nstruct DataWrapper{\n    DataWrapper(const Data& data) : data(data),isDecompressed(false) {}\n\n    Data data;\n    bool isDecompressed;\n};\n```\n在DataWrapper添加了一个属性isDecompressed来标志数据是否已经解压。这个Wrapper可以只在解压过程中临时使用，不影响数据的存储。\n\n然后实现的重点就是重载操作符了，其实它的实现很简单:\n\n```cpp\nDataWrapper& operator | (DataWrapper& data, const Decompressor& decompressor){\n    if(!data.isDecompressed && decompressor.canDecompress(data.data)){\n        data.data = decompressor.doDecompress(data.data);\n        data.isDecompressed = true;\n    }\n\n    return data;\n}\n```\n\n现在Decompressor就只需要提供判断是否可以解压和进行解压的功能。所以我们可以将Decompressor基类简化下面这样。其实这样的Decompressor就相当于java里面的接口了，面向接口编程可以使得业务逻辑更加清晰，而且也更易于维护。\n\n```cpp\nclass Decompressor{\npublic:\n    virtual bool canDecompress(const Data& data)const = 0;\n    virtual Data doDecompress(const Data& data)const = 0;\n};\n```\n\n所以我们的SuperDecompressor类就可以写成下面的样子:\n\n```cpp\nclass SuperDecompressor{\npublic:\n    Data decompressCompressedFile(const Data& data);\n\nprivate:\n    ZipDecompressor mZipDecompressor;\n    RarDecompressor mRarDecompressor;\n    GZipDecompressor mGZipDecompressor;\n};\n\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mZipDecompressor | mGZipDecompressor | mRarDecompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n```\n\n而main函数是一样的:\n\n```cpp\nint main(){\n    SuperDecompressor decompressor;\n\n    Data input((unsigned char*)\"gzip\",strlen(\"gzip\"));\n\n    Data output = decompressor.decompressCompressedFile(input);\n\n    if(output.data){\n        const char* out = (const char*)output.data;\n        cout<<\"result : \"<<out<<endl;\n    }else{\n        cout<<\"result : null\"<<endl;\n    }\n\n    return 0;\n}\n```\n\n输出结果如下:\n\n> ZipDecompressor:canDecompress  \n> GZipDecompressor:canDecompress  \n> GZipDecompressor:doDecompress  \n> result : doDecompress by GZipDecompressor  \n\n所以如果我们现在需要将SuperDecompressor拓展成一个真正万能的解压类，不仅能解压压缩文件，也能解压图片，还能解压Base64编码的超级解压类也很简单了:\n\n```cpp\nclass SuperDecompressor{\n    Data decompressUnknowType(const Data& data);\n    Data decompressImage(const Data& data);\n    Data decompressCompressedFile(const Data& data);\n    Data decompressBase64(const Data& data);\n\nprivate:\n    ZipDecompressor mZipDecompressor;\n    RarDecompressor mRarDecompressor;\n    GZipDecompressor mGZipDecompressor;\n\n    JpgDecompressor mJpgDecompressor;\n    PngDecompressor mPngDecompressor;\n\n    Base64Decompressor mBase64Decompressor;\n};\n\nData SuperDecompressor::decompressUnknowType(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mZipDecompressor | mRarDecompressor | mGZipDecompressor\n            | mJpgDecompressor | mPngDecompressor\n            | mBase64Decompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n\nData SuperDecompressor::decompressImage(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mJpgDecompressor | mPngDecompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n\nData SuperDecompressor::decompressCompressedFile(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mZipDecompressor | mRarDecompressor | mGZipDecompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n\nData SuperDecompressor::decompressBase64(const Data& data){\n    DataWrapper wrapper(data);\n    wrapper | mBase64Decompressor;\n    return wrapper.isDecompressed ? wrapper.data : Data(0,0);\n}\n```\n\n当然，这种处理方式在数据已经被解压的情况下依然会传给下一个解压器，直到经过了整条处理链。所以会造成一定的资源浪费。\n\n# 责任链模式的实际应用场景\n\n责任链模式的实际应用，最广为人知的就是安卓View的Touch事件的传递机制了。其实这是一种双向的责任链模式。在接收到Touch事件的时候，父View会通知子View，如果子View不处理，父View才去处理。光说可能有点难懂，我们直接看源码吧:\n\n```java\npublic boolean dispatchTouchEvent(MotionEvent ev) {\n    boolean result = false;             // 默认状态为没有消费过\n\n    if (!onInterceptTouchEvent(ev)) {   // 如果没有拦截交给子View\n        result = child.dispatchTouchEvent(ev);\n    }\n\n    if (!result) {                      // 如果事件没有被消费,询问自身onTouchEvent\n        result = onTouchEvent(ev);\n    }\n\n    return result;\n}\n```\n\n代码看起来也不好懂？没关系，我用个实际的例子解释一下就明白了。首先我们有下面的一个Activity:\n\n{% img /责任链模式/Touch事件传递机制例子.png %}\n\n当我们点击最中间的那个View的时候Touch事件的传递过程如下图:\n\n{% img /责任链模式/Touch事件传递过程.png %}\n\nTouch事件通过Activity、ViewGroup1、ViewGroup2的dispatchTouchEvent方法最后到达View的dispatchTouchEvent方法，在View被处理，所以返回true。于是Activity、ViewGroup1、ViewGroup2的dispatchTouchEvent方法都会直接返回，而不会调用处理方法onTouchEvent\n\n\n# 总结\n\n这一部分本来应该讲一讲责任链模式的优缺点的，但是我自己其实不太喜欢这样的总结性的东西。所以还是留给读者自己体会吧。\n","tags":["技术相关","设计模式"]},{"title":"lua面向对象编程","url":"/2016/11/16/lua面向对象编程/","content":"\nlua也支持面向对象编程的,嗯对,就是用table和元表。lua可以在某种程度上实现面向对象的封装、继承和多态三大基本特性。\n\n## 封装\n\nlua实现封装的最简单方法就是将属性和方法放到table之中。首先我们声明一个类table,用来定义一些该类的类方法，其中的new方法就类似其他面向对象语言的new关键字,用来创建一个新的实例出来。同时为了模块化，将它放在一个单独的Position.lua文件中:\n\n```lua\nlocal Position = {}\n\nfunction Position.new(x,y)\n\tlocal instance = {x=x, y=y}\n\treturn instance\nend\n\nfunction Position.getLength(instance)\n\treturn (instance.x^2+instance.y^2)^0.5\nend\n\nreturn Position\n```\n\n这样就可以这样使用它:\n```lua\nlocal Position = require(\"Position\")\nlocal pos1 = Position.new(1,1)\nprint(Position.getLength(pos1))\n```\n\n输出如下:\n>1.4142135623731\n\n看看这个方法的定义:\n\n```lua\nfunction Position.getLength(instance)\n\treturn (instance.x^2+instance.y^2)^0.5\nend\n```\n\n它其实是一种语法糖,上面的写法和下面的写法是一样的\n\n```lua\nPosition.getLength = function(instance)\n\treturn (instance.x^2+instance.y^2)^0.5\nend\n```\n\n但是这样的写法是不是感觉很奇怪,和一般的面向对象的写法和用法都不一样？我们可以把Position.lua改成下面的这个样子:\n\n```lua\nlocal Position = {}\n\nfunction Position.new(x,y)\n\tlocal instance = {x=x, y=y}\n\tsetmetatable(instance, {__index=Position})\n\treturn instance\nend\n\nfunction Position.getLength(instance)\n\treturn (instance.x^2+instance.y^2)^0.5\nend\n\nreturn Position\n```\n\n于是用法就有点接近我们熟悉的面向对象语法了\n\n```lua\nlocal Position = require(\"Position\")\n\nlocal pos1 = Position.new(1,1)\nprint(pos1.getLength(pos1))\n\nlocal pos2 = Position.new(3,4)\nprint(pos2.getLength(pos2))\n```\n\n输出如下:\n\n>1.4142135623731\n>5\n\n但是每次调用类方法都需要把实例显示的当作参数传入,这样既麻烦又容易出错。有没有办法让lua解释器自动传入类实例呢？答案当然是有的,这就要看另一种语法糖了:\n\n```lua\nlocal Position = require(\"Position\")\n\nlocal pos1 = Position.new(1,1)\nprint(pos1:getLength())\n\nlocal pos2 = Position.new(3,4)\nprint(pos2:getLength())\n```\n\n对的，下面的两种写法是等价的:\n\n```lua\npos1.getLength(pos1)\npos1:getLength()\n```\n\n类似的,在Position.lua中也能这么写：\n\n```lua\nlocal Position = {}\n\nfunction Position.new(x,y)\n\tlocal instance = {x=x, y=y}\n\tsetmetatable(instance, {__index=Position})\n\treturn instance\nend\n\nfunction Position:getLength()\n\treturn (self.x^2+self.y^2)^0.5\nend\n\nreturn Position\n```\n\n下面两种写法也是等价的:\n```lua\nfunction Position.getLength(self)\n\treturn (self.x^2+self.y^2)^0.5\nend\n\nfunction Position:getLength()\n\treturn (self.x^2+self.y^2)^0.5\nend\n```\n\n这里的self就相当于c++的this\n\n我们还可以把new方法抽象出来,作为公共方法,而不用为每个类都写一个new方法:\n\n```lua\n-- function.lua\n\nfunction class(className)\n\tlocal cls = {}\n\tcls.__cname = className\n\tcls.new = function(...)\n\t\tlocal instance = {}\n\t\tsetmetatable(instance, {__index=cls})\n\t\tif cls.ctor then cls:ctor(...) end\n\t\treturn instance\n\tend\n\treturn cls\nend\n```\n\n这个new方法将类名保存了下来,方便运行时获取类的类型,同时如果这个类有定义构造函数(ctor)的话,它还会自动的调用类的构造函数。\n\n这个时候类的定义就可以变成下面这个样子了:\n\n```lua\n-- Position.lua\n\nlocal Position = class(\"Position\")\n\nfunction Position:ctor(x,y)\n\tself.x = x\n\tself.y = y\nend\n\nfunction Position:getLength()\n\treturn (self.x^2+self.y^2)^0.5\nend\n\nreturn Position\n```\n\n已经和一般的面向对象语言很接近了。当然,这个class方法我们必须在程序的一开始就加载进来作为全局方法使用。我们来看看main.lua是怎么使用它们的吧:\n\n```lua\nrequire(\"function\")\n\nlocal Position = require(\"Position\")\nprint(Position.__cname)\n\nlocal pos1 = Position.new(1,1)\nprint(pos1:getLength())\n\nlocal pos2 = Position.new(3,4)\nprint(pos2:getLength())\n```\n\n输出如下:\n>Position\n>1.4142135623731\n>5\n\n\n\n## 继承与多态\n\nlua的继承机制在上一篇博客《lua元表》中已经有提到了一些,原理就是使用元表机制,将子类元表的\\__index字段设置为父类。所以我们可以这样拓展我们的new方法:\n\n```lua\n-- function.lua\n\nfunction class(className, super)\n\tlocal cls = {}\n\n\tif super then \n\t\tcls.super = super\n\t\tsetmetatable(cls, {__index=super})\n\tend\n\t\n\tcls.__cname = className\n\n\tcls.new = function(...)\n\t\tlocal instance = {}\n\t\tsetmetatable(instance, {__index=cls})\n\t\tif cls.ctor then cls:ctor(...) end\n\t\treturn instance\n\tend\n\t\n\treturn cls\nend\n```\n这里我们将父类保存到子类的元表的\\__index字段中,同时为类添加了super字段用于保存父类\n\n于是基于new方法,我们可以定义Position的子类Position3D:\n\n```lua\n-- Position3D.lua\n\nlocal Position3D = class(\"Position3D\", require(\"Position\"))\n\nfunction Position3D:ctor(x,y,z)\n\tself.super:ctor(x, y)\n\tself.z = z\nend\n\nfunction Position3D:getLength()\n\treturn (self.x^2+self.y^2+self.z^2)^0.5\nend\n\nreturn Position3D\n```\n\n子类Position3D重写了Position的ctor方法和getLength方法。如果需要用父类的被重写的方法,就要用super字段显示调用,就如ctor方法中做的一样。\n\n来看看main.lua吧：\n\n```lua\nrequire(\"function\")\n\nlocal Position3D = require(\"Position3D\")\nprint(Position3D.__cname)\n\nlocal pos1 = Position3D.new(1,1,1)\nprint(pos1:getLength())\n\nlocal pos2 = Position3D.new(3,4,5)\nprint(pos2:getLength())\n```\n\n输出如下:\n>Position3D\n>1.7320508075689\n>7.0710678118655\n\n\n## 多继承\n\nlua同样可以实现多继承。由于一个多继承的子类有多个父类,所以我们不能简单的把父类设为元表的\\__index属性。但是我们可以将该类的父类保存在一个table里面,然后用一个函数去搜索父类的方法。这时,只有将这个函数赋值个于元表的\\__index就好了。\n\n于是我们可以将class函数拓展成下面的样子\n\n```lua\nfunction class(className, ...)\n\tlocal cls = {__cname = className}\n\n    local supers = {...}\n\tfor i,super in ipairs(supers) do\n        cls.__supers = cls.__supers or {}\n        table.insert(cls.__supers, super)\n\n        if cls.super==nil then\n            cls.super=super\n        end\n\tend\n\n    if cls.__supers==nil or  #cls.__supers==1 then\n        setmetatable(cls, {__index=cls.super})\n\telse\n\t\tlocal index = function(t,k)\n\t\t\tfor i,v in ipairs(cls.__supers) do\n\t\t\t\tif v[k] then return v[k] end\n\t\t\tend\n\t\tend\n        setmetatable(cls, {__index=index})\n\tend\t\n\n\tcls.new = function(...)\n\t    local instance = {}\n\t\tsetmetatable(instance, {__index=cls})\n\t\tif cls.ctor then cls:ctor(...) end\n\t\treturn instance\n\tend\n\n\treturn cls\nend\n```\n\n之后我们就能这样去使用多继承机制了:\n\n```lua\n--ClassA.lua\n\nlocal ClassA = class(\"ClassA\")\n\nfunction ClassA:ctor()\nend\n\nfunction ClassA:methodA()\n\tprint(\"ClassA:methodA\")\nend\n\nreturn ClassA\n```\n\n```lua\n--ClassB.lua\n\nlocal ClassB = class(\"ClassB\")\n\nfunction ClassB:ctor()\nend\n\nfunction ClassB:methodB()\n\tprint(\"ClassB:methodB\")\nend\n\nreturn ClassB\n```\n\n```lua\n--ClassC.lua\n\nlocal ClassC = class(\"ClassC\", require(\"ClassA\"), require(\"ClassB\"))\n\nfunction ClassC:ctor()\nend\n\nreturn ClassC\n```\n\n```lua\n--main.lua\n\nrequire(\"function\")\n\nlocal c = require(\"ClassC\").new()\nc:methodA()\nc:methodB()\n```\n\n执行结果如下:\n\n>ClassA:methodA\n>ClassB:methodB\n","tags":["技术相关","lua"]},{"title":"lua元表","url":"/2016/10/28/lua元表/","content":"\n## 元表是什么？\n\n在lua中,每个值都有一套预定义的操作集合。例如数字可以相加、比较、字符串可以连接,lua将这些操作的定义放在了元表中去描述。lua中的每个值都有一个元表。table和userdata可以有各自独立的元表,而其他类型则共享其类型所属的统一元表。(书上是这么说的，但是我用getmetatable方法只能获取到字符串的元表)lua在创建table的时候不会为它创建元表,所以,table没有加的操作,我们就可以通过给table设置我们自己写的元表,为table定义一套自定义的加的操作。\n\n\n## 如何获取元表?\n\nlua中通过getmetatable获取值得元表:\n\n```lua\nprint(\"str 1 : \"..tostring( getmetatable(\"str1\")) )\nprint(\"str 2 : \"..tostring( getmetatable(\"str1\")) )\nprint(\"nil : \"..tostring( getmetatable(nil)) )\nprint(\"number : \"..tostring( getmetatable(1)) )\nprint(\"function : \"..tostring( getmetatable(function()end)) )\nprint(\"table : \"..tostring( getmetatable({})) )\n```\n\n>str 1 : table: 009D9798\n>str 2 : table: 009D9798\n>nil : nilw\n>number : nil\n>function : nil\n>table : nil\n\n可以看到不同的字符串用的是同一个元表,而除了字符串之外其他的值的元表都是nil。这里就是我看到和书上不一样的地方，书上说每个值都有一个元表。不过这只是一个小疑点，并不影响我们对元表的理解。\n\n我们看看string的原表到底是个什么东西:\n\n```lua\nfunction dump(t)\n\tif t==nil then\n\t\tprint(t)\n\telse\n\t\tprint(\"{\")\n\t\tfor k,v in pairs(t) do\n\t\t\tprint(\"\\t\"..tostring(k)..\" = \"..tostring(v))\n\t\tend\n\t\tprint(\"}\")\n\tend\nend\ndump(getmetatable(\"str1\"))\n```\n\n输出如下:\n>{\n>        \\__index = table: 00AF9270\n>}\n\n字符串的元表里面只有一个元素:\\__index,它也是一个table,我们继续跟踪下看看它到底是什么:\n```lua\nfunction dump(t)\n\tif t==nil then\n\t\tprint(t)\n\telse\n\t\tprint(\"{\")\n\t\tfor k,v in pairs(t) do\n\t\t\tprint(\"\\t\"..tostring(k)..\" = \"..tostring(v))\n\t\tend\n\t\tprint(\"}\")\n\tend\nend\ndump(getmetatable(\"str1\").__index)\n```\n\n输出如下:\n>{\n>        sub = function: 00ABABF8\n>        upper = function: 00ABACB8\n>        len = function: 00AB9D00\n>        gfind = function: 00AB9CA0\n>        rep = function: 00ABAD58\n>        find = function: 00AB9E20\n>        match = function: 00ABA9F8\n>        char = function: 00AB9C40\n>        dump = function: 00AB9F20\n>        gmatch = function: 00AB9CA0\n>        reverse = function: 00ABAC38\n>        byte = function: 00AB9CC0\n>        format = function: 00AB9C80\n>        gsub = function: 00AB9CE0\n>        lower = function: 00AB9D40\n>}\n\n\\__index这个table定义了字符串的一些基本操作,如获取长度,查找子串等。它们的其实就定义在string这个table里,也就是说所有的字符串的元表的\\__index都是string:\n\n```lua\nfunction dump(t)\n\tif t==nil then\n\t\tprint(t)\n\telse\n\t\tprint(\"{\")\n\t\tfor k,v in pairs(t) do\n\t\t\tprint(\"\\t\"..tostring(k)..\" = \"..tostring(v))\n\t\tend\n\t\tprint(\"}\")\n\tend\nend\n\nprint(getmetatable(\"str\").__index)\nprint(string)\n```\n>table: 00C89270\n>table: 00C89270\n\n\n## 如何设置元表?\n\n在lua中,我们可以用setmetatable(table, metatable)这个方法去设置table的元表:\n\n```lua\nlocal t = {}\nprint(getmetatable(t))\nsetmetatable(t,{})\nprint(getmetatable(t))\n```\n\n输出如下:\n\n>nil\n>table: 0x7feaf1407190\n\n这样就成功为t设置了一个元表,这个元表是一个空的table。\n\n## 元表的作用\n\n那设置元表又有什么用呢？还记得元表的作用是什么吗？对定义对值得操作,例如下面的代码,我们为table设置了一个tostring的操作:\n```lua\nlocal t = {x=1,y=2}\nprint(tostring(t))\n\nlocal mt = {}\nmt.__tostring = function(t)return \"(\"..t.x..\",\"..t.y..\")\" end\nsetmetatable(t,mt)\nprint(tostring(t))\n```\n\n>table: 00B49678\n>(1,2)\n\n类似的在元表中我们可以定义下面的这些方法:\n\n|方法|作用|\n|--|--|\n|\\__add|加法|\n|\\__sub|减法|\n|\\__mul|乘法|\n|\\__div|除法|\n|\\__unm|相反数|\n|\\__mod|取模|\n|\\__pow|乘幂|\n|\\__concat|连接操作|\n|\\__eq|等于|\n|\\__lt|小于|\n|\\__le|小于等于|\n|\\__tostring|转化为字符串|\n|\\__index|读取不存在的字段|\n|\\__newindex|设置不存在的字段|\n\n注意lua会把a~=b转化为not(a==b),将a>b转化为b<a,将a>=b转化为b<=a,所以元表中并没有表示这几种操作的字段\n\n## 元表与类机制\n\n如果我们每创建一个table都要这样手动的为它创建一个元表,其实是很麻烦的一件事情,所以我们可以用下面的方法去简化操作:\n\n```lua\nlocal MyTable = {__tostring=function(t)return t.x..\",\"..t.y end}\n\nfunction MyTable.new(t)\n\tif t==nil then\n\t\tt = {}\n\tend\n\tsetmetatable(t, MyTable)\n\treturn t\nend\n\nprint(MyTable.new{x=1,y=2})\n```\n\n输出如下:\n\n>1,2\n\n\n看，这是不是有点像类？还记得\\__index吗？它用来定义访问table中没有的字段的时候的操作:\n\n```lua\nlocal mt = {}\nmt.__index = function(t,k)return \"no key [\"..k..\"] in table\" end\n\nlocal t = {x=1,y=2}\nsetmetatable(t,mt)\nprint(t.x)\nprint(t.y)\nprint(t.z)\n```\n\n输出如下:\n\n>1\n>2\n>no key [z] in table\n\n特殊的,如果\\__index是一个table的时候,在访问没有的字段的时候lua解释器就会到元表的\\__index中去找:\n\n```lua\nlocal t = {}\nprint(t.x)\n\nlocal index = {x=123}\nsetmetatable(t,{__index=index})\nprint(t.x)\n\nt.x = 321\nprint(t.x)\nprint(getmetatable(t).__index.x)\n```\n\n它的输出是这样的:\n>nil\n>123\n>321\n>123\n\n当在table中找不到字段时,解释器会去元表的\\__index字段中去找,如果\\__index中可以找到的话就用\\__index中的字段。如果table中有该字段的话,解释器就不会再去查询元表。嗯，听起来是不是有点像继承和重写?事实上lua的继承机制也是利用元表的这种特性实现的。\n","tags":["技术相关","lua"]},{"title":"lua泛型for的原理","url":"/2016/10/23/lua泛型for的原理/","content":"学习lua的时候,一直觉得泛型for是个很有用的东西,也觉得它很神奇,但因为它是语法层面就支持的东西,所以就没有去深入思考其中的原理。直到最近看《Lua程序设计》才知道它底层的工作原理原来那么巧妙。\n\n## 泛型for原理\n\n泛型for的用法如下:\n```lua\nlocal person = {name=\"Jim\", age=18}\nfor k,v in pairs(person) do\n\tprint(k,v)\nend \n```\n\n输出结果如下:\n>name    Jim\n>age     18\n\n它究竟是怎么做到通过循环,把table中的key和value通通打印出来的呢？\n\n其实泛型for语句:\n\n```lua\nfor var_1, ..., var_n in <explist> do <block> end\n```\n\n等价以下的代码:\n\n```lua\ndo \n    local _f,_s,_var = <explist>\n    while true do\n        local var_1, ..., var_n = _f(_s, _var)\n        _var = var_1\n        if _var==nil then break end\n        <block>\n    end\nend\n```\n\n## pairs函数原理\n\n这里要先介绍一个基本函数next。如果k是table t的一个key,在调用next(t,k)的时候,会返回t的下一个key和对应的值,如果key为nil,则返回t的第一组key和value,如果没有下一组key和value则返回nil。\n\n其实pairs的定义很简单:\n\n```lua\nfunction pairs(t)\n    return next, t, nil\nend\n```\n\n它只是简单的返回了next函数和原来的table,所以泛型for又能这么写:\n\n```lua\nlocal person = {name=\"Jim\", age=18}\nfor k,v in next, person do\n    print(k,v)\nend \n```\n等价于:\n\n```lua\nlocal person = {name=\"Jim\", age=18}\ndo\n\tlocal _f,_s,_var = next, person\n\twhile true do\n\t\tk,v = _f(_s, _var)\n\t\t_var = k\n\t\tif _var==nil then break end\n\t\tprint(k,v)\n\tend\nend\n```\n\n## ipairs函数原理\n\nipairs函数比pairs函数要复杂一点。如果按照pair的做法,会出现以下情况:\n\n```lua\nlocal test1 = {\"one\", \"two\", three=3}\n\nfor k,v in next, test1 do\n\tprint(k,v)\nend\n\nprint(\"================\")\n\nfor i,v in ipairs(test1) do\n\tprint(i,v)\nend\n```\n\n输出如下:\n\n>1       one\n>2       two\n>three   3\n>\\================\n>1       one\n>2       two\n\n还会出现下面的这种情况:\n\n```lua\nlocal test1 = {\"one\", nil, \"three\"}\n\nfor k,v in next, test1 do\n\tprint(k,v)\nend\n\nprint(\"================\")\n\nfor i,v in ipairs(test1) do\n\tprint(i,v)\nend\n```\n\n输出:\n>1       one\n>3       three\n>\\================\n>1       one\n\n我们在使用ipairs的时候是想以数组的方式遍历table,但pairs会把table中的所有键值对都遍历一遍。使用ipairs的时候会从下标为1开始逐一遍历table,直到遇到value等于nil的时候停止,它的工作原理如下:\n\n```lua\nfunction iter(t, index)\n\tindex = index + 1\n\tlocal var = t[index]\n\tif var then\n\t\treturn index, var\n\tend\nend\n\nfunction ipairs(t)\n\treturn iter,t,0\nend\n```\n\n或者简化成下面的形式:\n\n```lua\nlocal test1 = {\"one\", \"two\", \"three\"}\n\nfunction iter(t, index)\n\tindex = index + 1\n\tlocal var = t[index]\n\tif var then\n\t\treturn index, var\n\tend\nend\n\nfor i,v in iter,test1,0 do\n\tprint(i,v)\nend\n```","tags":["技术相关","lua"]},{"title":"Java自定义注解和动态代理","url":"/2016/05/27/Java自定义注解和动态代理/","content":"在学习Retrofit的时候就对它奇特的使用方式感到十分的好奇，为什么定义一个接口，使用\"@GET\",\"@Query\"这些奇怪的注解就能创建出能实际访问服务器的实例出来:\n\n```java\npublic interface GitHubService {\n    @GET(\"/users/{user}/repos\")\n    List<Repo> listRepos(@Path(\"user\") String user);\n}\n\nRestAdapter restAdapter = new RestAdapter.Builder()\n    .setEndpoint(\"https://api.github.com\")\n    .build();\nGitHubService service = restAdapter.create(GitHubService.class);\nList<Repo> repos = service.listRepos(\"octocat\");\n```\n\n尤其是对如何创建一个接口的实例感到万分的好奇，这几天回学校写毕设论文刚好有点空，于是就抽了点时间研究了一下。\n\n# 自定义Java注解\n\n说起Java的注解，大家都能很自然的想起\"@Override\",\"@Deprecated\",\"@Documented\"这些很常用的内置注解。但很多新手应该都不知道其实Java也是支持自定义注解的吧？(反正我以前是不知道的)\n\n## 元注解\n元注解的作用就是负责注解其他注解，Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解：\n\n- @Target\n- @Retention\n- @Documented\n- @Inherited\n\n### @Target\n\n@Target说明了自定义注解的修饰类型，也就是说可以用它来声明自定义注解可以用在什么地方，它的取值范围有：\n\n1. ElementType.CONSTRUCTOR : 用于描述构造器\n1. ElementType.FIELD : 用于描述域\n1. ElementType.LOCAL_VARIABLE : 用于描述局部变量\n1. ElementType.METHOD : 用于描述方法\n1. ElementType.PACKAGE : 用于描述包\n1. ElementType.PARAMETER : 用于描述参数\n1. ElementType.TYPE : 用于描述类、接口(包括注解类型) 或enum声明\n\n例如：\n\n```java\n@Target(ElementType.TYPE)\npublic @interface TypeAnnotation {\n}\n\n@Target(ElementType.METHOD)\npublic @interface MethodAnnotation {\n}\n\n@Target(ElementType.PARAMETER)\npublic @interface ParamAnnotation {\n}\n```\n\nTypeAnnotation可以用来修饰描述类、接口(包括注解类型) 或enum声明，MethodAnnotation可以用来修饰方法，ParamAnnotation可以用来修饰参数：\n\n```java\n@TypeAnnotation\npublic interface MyInterface {\n\t@MethodAnnotation\n\tpublic void func(@ParamAnnotation String param);\n}\n```\n\n## @Retention\n\n@Retention 定义了自定义注解的生命长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。\n\n它的取值有下面这些：\n\n1. RetentionPolicy.SOURCE : 在源文件中有效（即源文件保留）\n1. RetentionPolicy.CLASS : 在class文件中有效（即class保留）\n1. RetentionPolicy.RUNTIME : 时有效（即运行时保留）\n\n注解也是可以保存数据的，如value属性就是默认的数据保存属性:\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MethodAnnotation {\n\tString value() default \"default value\";\n}\n\npublic class ClassA{\n\t@MethodAnnotation()\n\tpublic void func1(){}\n    \n\t@MethodAnnotation(\"data\")\n\tpublic void func2(){}\n}\n\n```\n\n比如可以在程序运行的时候（因为声明了@Retention(RetentionPolicy.RUNTIME)）通过反射获取上面的ClassA.func1的注解MethodAnnotation保存的数据（默认值\"default value\"）和ClassA.func2的注解MethodAnnotation保存的数据（\"data\"）\n\n当然如果只能保持一个数据限制就太大了，你可以定义多个数据：\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MethodAnnotation {\n\tpublic enum EnumData{ DATA1, DATA2, DATA3};\n\t\n\tString data1();\n\tint data2() default 0xffff;\n\tEnumData data3() default EnumData.DATA1;\n}\n\npublic class ClassA{\n\t@MethodAnnotation(data1=\"data1\")\n\tpublic void func1(){}\n    \n\t@MethodAnnotation(data1=\"data1\", data2=0, data3=MethodAnnotation.EnumData.DATA1)\n\tpublic void func2(){}\n}\n```\n\n当属性没有用default指定默认值得时候在使用的时候必须由用户设置属性值（如这里的data1）\n\n注解参数的可支持数据类型：\n\n1.所有基本数据类型（int,float,boolean,byte,double,char,long,short)\n2.String类型\n3.Class类型\n4.enum类型\n5.Annotation类型\n6.以上所有类型的数组\n\n\n## @Inherited\n\n@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。\n\n# Java动态代理\n\n我知道可以用反射调用方法甚至创建对象，但我还真的没有想到怎样创建出一个接口的实例。用了各种形容方式之后终于找到了这种技术的专业名称:\"动态代理\"，下面是一个简单的例子：\n\n```java\npublic interface MyInterface{\n\tvoid func();\n}\n\npublic class MyHandler implements InvocationHandler{\n\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.print(\"call : \" + method.getName());\n\t\treturn null;\n\t}\n}\n\n\npublic static void main(String[] args){\n\t\tMyInterface myInterface = (MyInterface)Proxy.newProxyInstance(\n        \t\t MyInterface.class.getClassLoader(), \n\t\t\t     new Class[]{MyInterface.class}, \n\t\t\t     new MyHandler());\n\t\tmyInterface.func();\n}\n```\n\n这个例子的输出为：\n\n> call : func\n\n通过实现InvocationHandler接口，定义自己的handler类，再使用Proxy.newProxyInstance就可以实例化出一个接口的实例。当调用接口的方法的时候，InvocationHandler接口的invoke方法就会被调用，可以在这里编写实际的功能代码。\n\n当然也能将创建实例的代码抽象出来，实现复用：\n\n```java\nprivate static <T>T newProxyInstance(Class<T> c){\n\t\treturn (T)Proxy.newProxyInstance(\n\t\t\t\tc.getClassLoader(),\n\t\t\t\tnew Class<?>[]{c},\n\t\t\t\tnew DataBaseHalder(c));\n\t}\n    \npublic static void main(String[] args){\n    //使用方式\n    MyInterface myInterface = (MyInterface)newProxyInstance(MyInterface.class, new MyHandler());\n\tmyInterface.func();\n}\n```\n\n# 通过反射获取注解保存的数据\n- 通过Class.getAnnotation(XXXAnnotation.class)可以获取到方法的ElementType.METHOD或者类ElementType.TYPE类型的注解\n- 通过 Method.getParameterAnnotations()可以获取到方法各个参数的注解（ElementType.PARAMETER类型）\n\n这部分用代码来解释最直接了：\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface TypeAnnotation {\n\tString value();\n}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MethodAnnotation {\n\tString value();\n}\n\n@Target(ElementType.PARAMETER)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ParamAnnotation {\n\tString value();\n}\n\n@TypeAnnotation(\"interface MyInterface\")\npublic interface MyInterface{\n\t@MethodAnnotation(\"MyInterface.func\")\n\tvoid func(@ParamAnnotation(\"param1\") String a, @ParamAnnotation(\"param2\") int b);\n}\n\npublic class MyHandler implements InvocationHandler{\n\tprivate Class mClass;\n\t\n\tMyHandler(Class c){\n\t\tmClass = c;\n\t\tTypeAnnotation typeAnnotation = (TypeAnnotation) mClass.getAnnotation(TypeAnnotation.class);\n\t\tSystem.out.print(\"TypeAnnotation : \" + typeAnnotation.value() + \"\\n\");\n\t}\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\t\n\t\tMethodAnnotation methodAnnotation = (MethodAnnotation)method.getAnnotation(MethodAnnotation.class);\n\t\tSystem.out.print(\"MethodAnnotation : \" + methodAnnotation.value() + \"\\n\");\n\n\t\tClass[] parameterTypes = method.getParameterTypes();\n\t\tAnnotation[][] parameterAnnotations = method.getParameterAnnotations();\n\t\tfor(int i = 0; i< parameterAnnotations.length ; i++){\n\t\t\tClass type = parameterTypes[i];\n\t\t\tfor(Annotation annotation : parameterAnnotations[i]){\n\t\t\t\tif(annotation instanceof ParamAnnotation){\n\t\t\t\t\tParamAnnotation paramAnnotation = (ParamAnnotation) annotation;\n\t\t\t\t\tSystem.out.print(paramAnnotation.value() + \" - \" + args[i]  + \"[\" + type.getName() + \"]\"+ \"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n}\n\n//调用\npublic static void main(String[] args){\n\t\tMyInterface myInterface = (MyInterface)Proxy.newProxyInstance(\n\t\t\t\tMyInterface.class.getClassLoader(), \n\t\t\t\tnew Class<?>[]{MyInterface.class},\n\t\t\t\tnew MyHandler(MyInterface.class));\n\t\tmyInterface.func(\"data1\",123);\n}\n```\n\n输出如下：\n\n> TypeAnnotation : interface MyInterface\n> MethodAnnotation : MyInterface.func\n> param1 - data1[java.lang.String]\n> param2 - 123[int]\n\n这里最难理解的就是这两行代码：\n\n```java\nClass[] parameterTypes = method.getParameterTypes();\nAnnotation[][] parameterAnnotations = method.getParameterAnnotations();\n```\n\nmethod.getParameterTypes() 可以获取到参数的类型，而method.getParameterAnnotations()则获取到一个二维数组，它保存了所有变量的全部注解。\n\n# 一个简单的应用实例\n\n用过Retrofit的人都知道，这种动态代理技术在框架搭建完成之后，使用起来便十分的便利了，有兴趣的同学可以去看看Retrofit的相关资料。我这里再写一个模拟操作数据库的小例子，展示一下这种框架的便捷性。\n\n首先是接口的定义：\n\n```java\n@DataBase(database=\"SchoolSystem\", username=\"root\", password=\"123456\", ip=\"localhost\")\npublic interface IDataBaseOperation {\n\t@Table(\"Student\")\n\t@Column({\"name\",\"age\",\"sex\"})\n\tList<Map<String,String>> getStudentByName(@Condition(\"name\")String name);\n\t\n\t@Table(\"Student\")\n\t@Column({\"name\",\"age\",\"sex\"})\n\tList<Map<String,String>> getStudentOlder(@Condition(value=\"age\",compare=\">\")int age);\n\n\t@Table(\"Student\")\n\t@Column({\"name\",\"age\",\"sex\"})\n\tList<Map<String,String>> getStudentBySexAndAge(@Condition(\"sex\")String sex, @Condition(\"age\")int age);\n\t\n\t@Table(\"Teacher join Course on Teacher.id=Course.teacher\")\n\t@Column({\"Course.name\"})\n\tList<Map<String,String>> getCourseByTeacher(@Condition(\"Teacher.name\")String teacher);\n}\n```\n\n让我们先跳过实现细节，直接看它的用法：\n\n```java\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tIDataBaseOperation oprBaseOperation = newProxyInstance(IDataBaseOperation.class, new DataBaseHalder(IDataBaseOperation.class));\n\n\t\toprBaseOperation.getStudentByName(\"小红\");\n\t\toprBaseOperation.getStudentOlder(12);\n\t\toprBaseOperation.getStudentBySexAndAge(\"男\", 12);\n\t\toprBaseOperation.getCourseByTeacher(\"李老师\");\n\t}\n\t\n\tprivate static <T>T newProxyInstance(Class<T> c, InvocationHandler handler){\n\t\treturn (T)Proxy.newProxyInstance(\n\t\t\t\tc.getClassLoader(), \n\t\t\t\tnew Class<?>[]{c},\n\t\t\t\thandler);\n\t}\n}\n```\n\n这样我们就能看到这样的输出:\n\n> ===================================\n> \n> connect database : \n> ip : localhost\n> username : root\n> password : 123456\n> database : SchoolSystem\n>\n>===================================\n> select name,age,sex from Student where name = \"小红\";\n> select name,age,sex from Student where age > 12;\n> select name,age,sex from Student where sex = \"男\" and age = 12;\n> select Course.name from Teacher join Course on Teacher.id=Course.teacher where > > > Teacher.name = \"李老师\";\n\n这里没有真的去做数据库操作，只是用打印的方法模拟了一下，但如果真的要实现的话也是不难的。\n\n但从这几处使用代码来看，这个框架的是十分易用的，如果我们想要增加一个查询操作的话，只需要在IDataBaseOperation接口声明多一个方法，然后直接就能在得到实例后使用了。\n\n最后将一些细节代码也贴上来：\n\n```java\n//Column.java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Column {\n\tString[] value();\n}\n```\n\n```java\n//Condition.java\n@Target(ElementType.PARAMETER)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Condition {\n\tpublic String value();\n\tpublic String compare() default \"=\";\n}\n```\n\n```java\n//Table.java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Table {\n\tString value();\n}\n```\n\n```java\n//DataBase.java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface DataBase {\n\tString ip();\n\tString database();\n\tString username();\n\tString password();\n}\n```\n\n```java\n//DataBaseHalder.java\npublic class DataBaseHalder implements InvocationHandler{\n\tprivate Class mInterface;\n\t\n\tpublic DataBaseHalder(Class object){\n\t\tmInterface = object;\n\t\t\n\t\tDataBase db = (DataBase) mInterface.getAnnotation(DataBase.class);\n\n\t\tSystem.out.print(\"===================================\\n\");\n\t\tSystem.out.print(\"connect database : \\n\");\n\t\tSystem.out.print(\"ip : \" + db.ip() + \"\\n\");\n\t\tSystem.out.print(\"username : \" + db.username() + \"\\n\");\n\t\tSystem.out.print(\"password : \" + db.password() + \"\\n\");\n\t\tSystem.out.print(\"database : \" + db.database() + \"\\n\");\n\t\tSystem.out.print(\"===================================\\n\");\n\t\t\n\t}\n\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\t\n\t\tif(method.getName().matches(\"^get.*\")){\n\t\t\tString sql =  \"select \" + getColumns(method) + \" from \" + getTable(method) \n\t\t\t\t\t+ \" where \" + getCondition(method, args) + \";\";\n\t\t\tSystem.out.print(sql + \"\\n\");\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tprivate String getTable(Method method){\n\t\treturn method.getAnnotation(Table.class).value();\n\t}\n\t\n\tprivate String getColumns(Method method){\n\t\tString result = \"\";\n\t\tString conn = \"\";\n\t\tfor (String col : method.getAnnotation(Column.class).value()) {\n\t\t\tresult += conn + col;\n\t\t\tconn = \",\";\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate String getCondition(Method method, Object[] args) {\n\t\tString result = \"\";\n\t\tString andConnect = \"\";\n\t\tClass[] parameterTypes = method.getParameterTypes();\n\n\t\tAnnotation[][] parameterAnnotations = method.getParameterAnnotations();\n\t\tfor(int i = 0; i< parameterAnnotations.length ; i++){\n\t\t\tClass type = parameterTypes[i];\n\t\t\tfor(Annotation annotation : parameterAnnotations[i]){\n\t\t\t\tif(annotation instanceof Condition){\n\t\t\t\t\tresult += andConnect + parseCondition(type, args[i], (Condition) annotation);\n\t\t\t\t\tandConnect = \" and \";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate String parseCondition(Class argType, Object arg, Annotation annotation){\n\t\tCondition condition = (Condition) annotation;\n\t\tString result = condition.value() + \" \" + condition.compare() + \" \";\n\t\tif(argType == String.class){\n\t\t\tresult += \"\\\"\" + arg + \"\\\"\";\n\t\t}else{\n\t\t\tresult += arg;\n\t\t}\n\t\treturn result;\n\t}\n}\n```\n\n# 另外的一个实用的小例子\n\n相信做安卓的同学都遇到过在Activity.onCreate初始化的时候写一大堆的findViewById吧？这种重复性的无趣工作其实也可以用注解来简化：\n\n```java\npublic @interface ViewField {\n    int value();\n\n    public static class Processor{\n        public static void process(Activity activity) throws IllegalAccessException {\n            Field[] fields = activity.getClass().getDeclaredFields();\n            ViewField ann = null;\n            for (Field field : fields) {\n                ann = field.getAnnotation(ViewField.class);\n                if (ann!=null){\n                    field.setAccessible(true);\n                    field.set(activity, activity.findViewById(ann.value()));\n                }\n            }\n        }\n    }\n}\n```\n\n然后我们的Activity就可以这样写来让注解自动初始化View变量了：\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    @ViewField(R.id.text)\n    private TextView mTextView;\n\n    @ViewField(R.id.button)\n    private Button mButton;\n\n    @ViewField(R.id.image)\n    private ImageView mImageView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        try {\n            ViewField.Processor.process(this);\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n\n        mTextView.setText(\"text\");\n        mButton.setText(\"button\");\n        mImageView.setImageResource(R.mipmap.ic_launcher);\n    }\n}\n```\n\n当然有人说用注解，效率会很低。但我觉得这里的额外消耗其实根本不起眼，用这点小损耗换来编码的便利性是很值得的。但如果真的很在意，也能用下面的泛型方法简化findViewById操作：\n\n```java\nprotected <T extends View> T generateFindViewById(int id) {\n\t//return返回view时,加上泛型T\n\treturn (T) findViewById(id);\n}\nmButton = generateFindViewById(R.id.button);\n```\n\n这样能减少强制转换的操作，但编写效率还是不如用注解。\n","tags":["技术相关","java"]},{"title":"学习HTTP协议-用socket实现http访问","url":"/2016/03/04/学习HTTP协议-用socket实现http访问/","content":"\n相信大家都知道 http 报文这东西吧？http 报文分两种，请求报文和响应报文。\n\n## __请求报文__\n\n客户端向服务端发送的就是请求报文，它可告诉服务端自己需要什么样的资源，也可以将一些文件或者数据上传给服务端。\n\n请求报文格式如下：\n\n{% img /学习HTTP协议-用socket实现http访问/1.jpg %}\n\n请求报文分为三个部分：\n\n- 请求行，如：\n\n> GET / HTTP/1.1\n\n这个请求行表明了这次请求使用的是 GET 方法，访问的是网站的根目录，使用的 HTTP 协议版本是 1.1。\n\n- 请求头部，如：\n\n> Host: www.baidu.com\n> Connection: keep-alive\n\n- 请求包体\n\n用来携带数据\n\n### _GET 方法_\n\nGET 方法是 HTTP 中最基础的方法，我们在浏览器地址栏输入网站浏览网页使用的都是 GET 方法：\n\n> http://www.islinjw.cn/okhttp_cookie_demo/checkverifycode.php\n\n当然有时候服务器需要根据用户传递的信息去返回对应的数据，GET 方法用下面的形式传递信息给服务器：\n\n> http://www.islinjw.cn/okhttp_cookie_demo/checkverifycode.php?verifycode=qwjuy&format=json\n\n这里告诉给服务器 verifycode=qwjuy 和 format=json ，服务器会根据用户传过来的信息返回不同的数据。\n\n这个时候的请求行长这个样子，URL 上就携带了 GET 传递的数据：\n\n> GET /okhttp_cookie_demo/checkverifycode.php?verifycode=qwjuy&format=json HTTP/1.1\n\n这里再说一句题外话，并不是说如果在 URL 里面没有见到 “?” 这个符号，客户端就没有传递数据给服务器。有一种叫做网页伪静态化的技术可以实现不带问号的 URL 使用 GET 方法传递数据。\n\n### _POST 方法_\n\nGET 方法的参数都显示在 URl 上，这样对于诸如账户密码的敏感信息来说太不安全，而且也很难传递想图片这样的数据。所以就有了 POST 方法。\n\n使用 POST 方法传递的数据并不会显示在 URL 上，而是保存在请求包体中，当然 HTTP 协议是明文传输的，所以把账户密码直接用 POST 传递也是不安全的，需要程序员自己进行加密处理。\n\n### _HTTP 协议方法列表_\n\n|序号 |方法 |描述|\n|---|---|---|\n|1 |GET |请求指定的页面信息，并返回实体主体。|\n|2 |HEAD |类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头|\n|3 |POST |向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。|\n|4 |PUT |从客户端向服务器传送的数据取代指定的文档的内容。|\n|5 |DELETE |请求服务器删除指定的页面。|\n|6 |CONNECT |HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。|\n|7 |OPTIONS\t|允许客户端查看服务器的性能。|\n|8 |TRACE |回显服务器收到的请求，主要用于测试或诊断。|\n|9 |PATCH |实体中包含一个表，表中说明与该URI所表示的原内容的区别。|\n|10 |MOVE |请求服务器将指定的页面移至另一个网络地址。|\n|11\t|COPY |请求服务器将指定的页面拷贝至另一个网络地址。|\n|12\t|LINK |请求服务器建立链接关系。|\n|13\t|UNLINK |断开链接关系。|\n|14\t|WRAPPED |允许客户端发送经过封装的请求。|\n|15\t|Extension-mothed |在不改动协议的前提下，可增加另外的方法。|\n\n## __响应报文__\n\n服务端接收到请求报文之后，了解到客户端需要什么样的服务之后就会返回响应报文给客户端。\n\n响应报文格式如下：\n\n{% img /学习HTTP协议-用socket实现http访问/2.jpg %}\n\n- 状态行，如：\n\n> HTTP/1.1 200 OK\n\n- 响应头部，如：\n\n> Date: Fri, 04 Mar 2016 11:04:01 GMT\n> Server: Apache/2.4.7 (Ubuntu)\n> X-Powered-By: PHP/5.5.9-1ubuntu4.14\n> Expires: Thu, 19 Nov 1981 08:52:00 GMT\n> Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0\n> Pragma: no-cache\n> Content-Length: 20\n> Keep-Alive: timeout=5, max=100\n> Connection: Keep-Alive\n> Content-Type: text/html\n\n- 响应包体，即页面显示的内容，如：\n\n> {\"result\":\"success\"}\n\n### _状态码_\n\n状态码由三位数字组成，第一位数字表示响应的类型，常用的状态码有五大类如下所示：\n\n　　1xx：表示服务器已接收了客户端请求，客户端可继续发送请求;\n\n　　2xx：表示服务器已成功接收到请求并进行处理;\n\n　　3xx：表示服务器要求客户端重定向;\n\n　　4xx：表示客户端的请求有非法内容;\n\n　　5xx：表示服务器未能正常处理客户端的请求而出现意外错误;\n\n## __使用 Socket 发送 HTTP 请求报文__\n\n我们知道 HTTP 协议是基于 TCP 的，而我们可以使用 Socket 进行 TCP 连接，所以在充分理解 HTTP 报文之后我们就可以用 socket 实现自己的 HTTP 访问了。\n\n### _访问网页_\n\n首先我们看看怎样用 socket 实现 http 访问网页,这里我们尝试使用 GET 方法访问 [www.islinjw.cn](http://www.islinjw.cn)。\n\n流程如下：\n1. 使用 socket 连接服务器\n2. 发送请求报文\n3. 接收响应报文\n4. 断开 socket 连接\n\n重点在于发送请求报文，其他步骤和一般的 socket 程序是没有什么区别的。\n\n请求报文分为三个部分还记得吗？\n\n- 请求行\n使用 HTTP/1.1 协议的 GET 方法访问网站的根目录：\n\n> GET / HTTP/1.1\n\n- 请求头部\nHost 是请求头部唯一必须携带的数据，要不然能接收到数据，但服务器返回302、400这样的错误代码。原因是服务器可能使用了虚拟服务器技术，一台服务器托管了多个网站，即多个网站通过dns解析到同样的ip地址。像这里我们访问 www.islinjw.cn 主机：\n\n> Host: www.islinjw.cn\n\n- 请求实体：\n但我们这里因为只是单纯的获取页面，并没有传递数据给服务器，所以报文实体为空。\n\n每个部分之间使用 \"\\\\r\\\\n\" 分割。但需要在请求报文的最后加多一个 \"\\\\n\"。为什么？还记得请求头部和请求实体之间有一个什么东西吗？对，空行！因为这里没有请求实体，所以报文最后就是一个空行。如果没有它，服务器不会返回响应报文，程序就会一直阻塞在那里。\n\n所以最终发送的报文就是:\n\n> GET / HTTP/1.1\\r\\nHost: www.islinjw.cn\\r\\n\\n\n\n代码如下：\n\n```cpp\n    void TestRequest(){\n        void TestRequest(){\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string data = \"\";\n\n        //请求行\n        data += \"GET / HTTP/1.1\\r\\n\";\n\n        //请求头部\n        data += \"Host: www.islinjw.cn\\r\\n\\n\";\n\n        send(sock_client,data.c_str(),data.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n```\n\n服务器返回的响应报文如下（对，这个网站就是一个 hello world 在那里而已）：\n\n{% img /学习HTTP协议-用socket实现http访问/3.jpg %}\n\n### _使用 GET 方法_\n\n为了验证是否真的传送了数据给服务器，我写了一个 demo 页面 [www.islinjw.cn/http_packet_demo/demo.php](http://www.islinjw.cn/http_packet_demo/demo.php)。这个页面的功能很简单，就是把接收到的 GET 数据和 POST 数据通过 json 格式打印出而已：\n\n{% img /学习HTTP协议-用socket实现http访问/4.jpg %}\n\n我们首先写一个函数用来把 map 转化成 GET 方法的参数格式：\n\n```cpp\n    string MsgToString(const map<string,string>& msg){\n        string result = \"\";\n        map<string,string>::const_iterator i = msg.begin();\n        while(i!=msg.end()){\n            result += i->first + \"=\" + i->second;\n            i++;\n            if(i!=msg.end()){\n                result += \"&\";\n            }\n        }\n        return result;\n    }\n```\n\n之前提到，GET 方法的数据是通过 URL 来传递的，所以只需要把得到的 GET 方法参数拼接到请求行的 URL 后面就行了：\n\n```cpp\n\tstring url = \"/http_packet_demo/demo.php\";\n\turl += \"?\" + MsgToString(msg);\n    cout<<\"url : \"<<url<<endl;\n\n\tstring packet = \"\";\n\n\t//请求行\n\tpacket += \"GET \" + url + \" HTTP/1.1\\r\\n\";\n```\n\n其他的和刚刚讲的访问网页的方式一模一样：\n\n```cpp\n\tvoid TestGet(const map<string,string>& msg){\n        //连接服务器主机\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string url = \"/http_packet_demo/demo.php\";\n        url += \"?\" + MsgToString(msg);\n\n        cout<<\"url : \"<<url<<endl;\n\n        string packet = \"\";\n\n        //请求行\n        packet += \"GET \" + url + \" HTTP/1.1\\r\\n\";\n\n        //请求头部\n        packet += \"Host: www.baidu.com\\r\\n\";\n\n        //空行\n        packet += \"\\n\";\n\n        send(sock_client, packet.c_str(), packet.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n```\n\n我们这样调用:\n\n```cpp\n\tmap<string,string> msg;\n\tmsg[\"abc\"] = \"123\";\n\tmsg[\"def\"] = \"456\";\n\n\tTestGet(msg);\n```\n\nURL 长这个样子：\n\n{% img /学习HTTP协议-用socket实现http访问/5.jpg %}\n\n服务器返回的响应报文如下：：\n\n{% img /学习HTTP协议-用socket实现http访问/6.jpg %}\n\n### _使用 POST 方法_\n\n使用 POST 方法会复杂那么一点点。首先请求行没有什么特别的，就是指定了 POST 方法和我们的页面，而且 URL 没有带数据:\n\n```cpp\n\tstring url = \"/http_packet_demo/demo.php\";\n\n\tstring packet = \"\";\n\n\t//请求行\n\tpacket += \"POST \" + url + \" HTTP/1.1\\r\\n\";\n```\n\n但因为 POST 携带的数据不一定是字符串，有可能是图片等二进制图片，所以就需要在请求头部告诉服务器携带的数据的类型和数据的长度:\n\n```cpp\n\t//请求头部\n\tpacket += \"Host: www.islinjw.cn\\r\\n\";\n\tpacket += \"Content-Type:application/x-www-form-urlencoded\\r\\n\"; //指定post传递的数据类型\n\tpacket += \"Content-Length: \" + ss.str() + \"\\r\\n\"; //标记post传递的数据的长度\n```\n\n之后就是一个空行和携带了数据的请求实体了：\n\n```cpp\n\t//空行\n\tpacket += \"\\n\";\n\n\t//post数据\n\tpacket += data;\n```\n\n所以整个方法长这个样子:\n\n```cpp\n    void TestPost(const map<string,string>& msg){\n        string data = MsgToString(msg);\n\n        stringstream ss;\n        ss<<data.length();\n\n        //连接服务器主机\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string url = \"/http_packet_demo/demo.php\";\n\n        string packet = \"\";\n\n        //请求行\n        packet += \"POST \" + url + \" HTTP/1.1\\r\\n\";\n\n        //请求头部\n        packet += \"Host: www.islinjw.cn\\r\\n\";\n        packet += \"Content-Type:application/x-www-form-urlencoded\\r\\n\"; //指定post传递的数据类型\n        packet += \"Content-Length: \" + ss.str() + \"\\r\\n\"; //标记post传递的数据的长度\n\n        //空行\n        packet += \"\\n\";\n\n        //post数据\n        packet += data;\n\n        send(sock_client, packet.c_str(), packet.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n```\n\n发送的数据如下：\n\n```cpp\n\tmap<string,string> msg;\n\tmsg[\"abc\"] = \"123\";\n\tmsg[\"def\"] = \"456\";\n\n\tTestPost(msg);\n```\n\n服务器返回的响应实体如下：\n\n{% img /学习HTTP协议-用socket实现http访问/7.jpg %}\n\n## __demo 完整代码__\n\n```cpp\n    #include \"stdafx.h\"\n\n    #include <Winsock2.h>\n    #include <iostream>\n    #include <map>\n    #include <string>\n    #include <sstream>\n\n    #pragma comment( lib, \"ws2_32.lib\" )\n\n    using namespace std;\n\n    const string SERVER_IP = \"182.254.231.66\";\n\n    SOCKET Connect(const char* ip){\n\n        //固定格式\n        WORD wVersionRequested;\n        WSADATA wsaData;\n        int err;\n\n        wVersionRequested = MAKEWORD( 1, 1 );\n\n        err = WSAStartup( wVersionRequested, &wsaData );\n        if ( err != 0 ) {\n            return INVALID_SOCKET;\n        }\n\n\n        if ( LOBYTE( wsaData.wVersion ) != 1 ||\n            HIBYTE( wsaData.wVersion ) != 1 ) {\n            WSACleanup( );\n            return INVALID_SOCKET;\n        }\n\n        SOCKET sock_client=socket(AF_INET,SOCK_STREAM,0);\n\n        SOCKADDR_IN addrSrv;\n        addrSrv.sin_addr.S_un.S_addr=inet_addr(ip);\n        addrSrv.sin_family=AF_INET;\n        addrSrv.sin_port=htons(80);//http端口为80\n        connect(sock_client,(SOCKADDR*)&addrSrv,sizeof(SOCKADDR));\n\n        return sock_client;\n    }\n\n    void Disconnect(SOCKET sock_client){\n        closesocket(sock_client);\n        WSACleanup();\n    }\n\n    void PrintRecvData(SOCKET sock_client){\n        cout<<\"Recv data :\"<<endl;\n\n        int len = 0;\n        char recvBuf[1024];\n        while((len = recv(sock_client,recvBuf,1023,0))>0){\n            recvBuf[len] = '\\0';\n            cout<<recvBuf;\n        }\n        cout<<endl;\n    }\n\n    void TestRequest(){\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        //最后必须多一个空行（\\n），要不然会阻塞住\n        //这个空行其实是报文首部和报文主体的分割符号，但这里请求不需要报文主体，所以是请求报文的结束\n        //string data = \"GET / HTTP/1.1\\r\\nHost: www.islinjw.cn\\r\\n\";\n\n        //HOST也是必须的，要不然能接收到数据，但服务器返回302、400这样的错误代码\n        //原因是服务器可能使用了虚拟服务器技术，一台服务器托管了多个网站，即多个网站通过dns解析到同样的ip地址\n        //所以在发送http请求时必须带上HOST\n        //string data = \"GET / HTTP/1.1\\r\\n\\n\";\n\n        string data = \"\";\n\n        //请求行\n        data += \"GET / HTTP/1.1\\r\\n\";\n\n        //请求头部\n        data += \"Host: www.islinjw.cn\\r\\n\\n\";\n\n        send(sock_client,data.c_str(),data.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n\n    string MsgToString(const map<string,string>& msg){\n        string result = \"\";\n        map<string,string>::const_iterator i = msg.begin();\n        while(i!=msg.end()){\n            result += i->first + \"=\" + i->second;\n            i++;\n            if(i!=msg.end()){\n                result += \"&\";\n            }\n        }\n        return result;\n    }\n\n    void TestGet(const map<string,string>& msg){\n        //连接服务器主机\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string url = \"/http_packet_demo/demo.php\";\n        url += \"?\" + MsgToString(msg);\n\n        cout<<\"url : \"<<url<<endl;\n\n        string packet = \"\";\n\n        //请求行\n        packet += \"GET \" + url + \" HTTP/1.1\\r\\n\";\n\n        //请求头部\n        packet += \"Host: www.baidu.com\\r\\n\";\n\n        //空行\n        packet += \"\\n\";\n\n        send(sock_client, packet.c_str(), packet.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n\n    void TestPost(const map<string,string>& msg){\n        string data = MsgToString(msg);\n\n        stringstream ss;\n        ss<<data.length();\n\n        //连接服务器主机\n        SOCKET sock_client = Connect(SERVER_IP.c_str());\n\n        string url = \"/http_packet_demo/demo.php\";\n\n        string packet = \"\";\n\n        //请求行\n        packet += \"POST \" + url + \" HTTP/1.1\\r\\n\";\n\n        //请求头部\n        packet += \"Host: www.islinjw.cn\\r\\n\";\n        packet += \"Content-Type:application/x-www-form-urlencoded\\r\\n\"; //指定post传递的数据类型\n        packet += \"Content-Length: \" + ss.str() + \"\\r\\n\"; //标记post传递的数据的长度\n\n        //空行\n        packet += \"\\n\";\n\n        //post数据\n        packet += data;\n\n        send(sock_client, packet.c_str(), packet.size(),0);\n\n        PrintRecvData(sock_client);\n        Disconnect(sock_client);\n    }\n\n    int main(int argc, char* argv[])\n    {\n        map<string,string> msg;\n        msg[\"abc\"] = \"123\";\n        msg[\"def\"] = \"456\";\n\n        TestRequest();\n        cout<<\"\\n\\n\\n\"<<endl;\n        TestGet(msg);\n        cout<<\"\\n\\n\\n\"<<endl;\n        TestPost(msg);\n\n        return 0;\n    }\n\n\n\n```\n","tags":["技术相关","Http协议"]},{"title":"学习HTTP协议-在安卓上的使用Cookie与Session","url":"/2016/03/03/学习HTTP协议-在安卓上的使用Cookie与Session/","content":"\n大三的时候写过一段时间的 php ，那时候已经对 html、css、js、cookie、session 这些东西了一点认知，但基本都是浮于表面，知其然而不知其所以然。于是这几天翻了翻《图解http》，书上的知识和自己的以前的理解结合起来，感觉对于 http 协议有了一些比较深刻的理解。\n\n在这里把那些知识点整理记录一下，而因为 HTTP 协议的知识点较多，所以会有一个系列的博客去介绍。这篇文章就先讲一下 Cookie 和 Session 吧。\n\n## __Cookie & Session__\n\n毕业设计有个功能是实现用户的注册登录，而注册账号的时候需要有输入验证码的功能。\n\n众所周知，HTTP 协议是无状态协议，即协议对于事务处理没有记忆能力。但就像这里，我们需要实现一个验证码功能，我们从服务器获取验证码的图片，然后再将用户输入的验证码传回服务器进行对比，这就要求服务器记录之前随机生成的验证码了。于是，两种用于保持HTTP连接状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session。\n\n### _Cookie_\n\nCookie 是由服务器端生成，发送给 User-Agent（一般是浏览器），浏览器会将 Cookie 的 key/value 保存到某个目录下的文本文件内，下次请求同一网站时就发送该 Cookie 给服务器（前提是浏览器设置为启用 cookie ）。\n\n我们可以在 chrome 浏览器页面按 F12 打开控制台，选择 Network 标签查看与网站进行 HTTP 协议交流的数据。\n\n这里我们看看登录[B站](http://www.bilibili.tv)的时候究竟发生了什么事情：\n\n首先我们输入账号密码和验证码之后点击登陆，浏览器会发生账号密码等数据给服务器,之后服务器返回数据。我们查看返回报文的 header 可以看到一堆的 Set-Cookie 字段：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/1.jpg %}\n\n客户端会把这些 cookie 记录下来，在下次访问服务器的时候就会把它们传回给服务器，这样就能实现数据的保持：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/2.jpg %}\n\n### _Session_\n\n但 Cookie 的数据都是保存在客户端的，客户端很容易就能查看和修改 cookie，十分不安全。例如 chrome 有一个 EditThisCookie 插件，就能直接查看修改网页的 cookie：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/3.jpg %}\n\n所以就有了存放在服务器端的内存中的 sessio，session可以看作一个存放在服务器的键值对集。\n\n当服务器创建一个 session 对象的时候，就会对应的生成一个sessionId，服务器可以在 session 中写入数据，但它不会将session 的内容告诉客户端，它只会将生成的 sessionId 以 cookie 的方式传给客户端，而客户端在下次访问服务器的时候把 sessionId 又传回给服务器，这样服务器就能找到之前保存的数据了。\n\n在 php 中这个 sessionid 的名字默认叫做 PHPSESSID，当然也能在php.ini中修改。\n\n因为 session 保存在服务器中，所以安全性比 cookie 高的多。\n\n关于 Cookie 和 Session，各位有兴趣的话可以自己去网上搜索一下，或者希望对 HTTP 协议有更深入的理解的话可以去读一下《图解http》。最近就在读这本书，等读完我会写一篇博客，介绍一些 HTTP 协议的重点知识，这里就不再多说了。\n\n## __okHttp3 使用 Cookie__\n\nokHttp3 的 cookie 管理方式对比 okHttp2 有了很大的变化，这里有一篇博客专门介绍[OkHttp3实现Cookies管理及持久化](http://www.codeceo.com/article/okhttp3-cookies-manage.html)。希望各位在读我这篇博客之前先浏览一下。\n\nokHttp3 使用 CookieJar 接口来管理 Cookie：\n\n```java\n\tpublic interface CookieJar {\n  \t/** A cookie jar that never accepts any cookies. */\n  \tCookieJar NO_COOKIES = new CookieJar() {\n    @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {\n    }\n\n    @Override public List<Cookie> loadForRequest(HttpUrl url) {\n      return Collections.emptyList();\n    }\n  \t};\n```\n\n我们只要在创建 OkHttpClient 的时候指定我们自己的 CookieJar 就能让 OkHttpClient 实现 Cookie 的自动管理：\n\n```java\n\tpublic class MainActivity extends AppCompatActivity {\n    \tprivate Map<String, List<Cookie>> mCookieStore;\n        ...\n        private OkHttpClient createHttpClient() {\n            CookieJar cookieJar = new CookieJar() {\n                @Override\n                public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {\n                    mCookieStore.put(url.host(), cookies);\n                }\n\n                @Override\n                public List<Cookie> loadForRequest(HttpUrl url) {\n                    List list = mCookieStore.get(url.host());\n                    return list != null ? list : new ArrayList<Cookie>();\n                }\n            };\n            return new OkHttpClient.Builder()\n                    .cookieJar(cookieJar)\n                    .build();\n        }\n        ...\n\t}\n```\n\n这里有点要注意，我们是拿 host 作 map 的 key 值，[《OkHttp3实现Cookies管理及持久化》](http://www.codeceo.com/article/okhttp3-cookies-manage.html)这篇博文直接用 url 当 key 值，这样的话该 Cookie 就只能在当前页面可用了，而我们是整个网站可用。\n\n## __Retrofit 使用 Cookie__\n\n在 Retrofit 中使用 Cookie 就更加简单了，因为它内部使用 OkHttp3，只要把之前设置了 CookieJar 的 OkHttpClient 设置给它就可以了：\n\n```java\n\tHttpService service = new Retrofit.Builder()\n                .client(mHttpClient) //OkHttpClient 指定了 CookieJar，这样 Retrofit 也能使用 Cookie 了\n                .baseUrl(mBaseUrl)\n                .addConverterFactory(GsonConverterFactory.create())\n                .build()\n                .create(HttpService.class);\n```\n\n## __验证码小 Demo__\n\n现状我们用一个实现了验证码功能的小 Demo 来更加深刻的理解之前所讲的知识。\n\n首先我写了两个页面：\n\n- 生成验证码的页面 ： http://www.islinjw.cn/okhttp_cookie_demo/verifycode.php\n- 检查验证码的页面 ： http://www.islinjw.cn/okhttp_cookie_demo/checkverifycode.php\n\n访问第一个页面能获得一张随机的验证码图片，而第二个页面使用 GET 方法来检测验证码（键值为 verifycode）。\n\n### _获取验证码图片_\n\n首先我们使用 OkHttp3 访问第一个页面，下载一张验证码图片，将它显示在 ImageView 中：\n\n```java\n\tprivate void loadVerifyCode(final ImageView imageView, final HttpUrl url) {\n        final Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    okhttp3.Response response = mHttpClient.newCall(request).execute();\n\n                    //创建bitmap\n                    InputStream is = response.body().byteStream();\n                    final Bitmap bm = BitmapFactory.decodeStream(is);\n\n                    //加载到ImageView中\n                    runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            imageView.setImageBitmap(bm);\n                        }\n                    });\n\n                    //打印cookie信息\n                    List<Cookie> cookies = Cookie.parseAll(request.url(), response.headers());\n                    for (int i = 0; i < cookies.size(); i++) {\n                        Log.d(\"cookie\", \"request headers: \" + cookies.get(i).toString());\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n```\n\n运行程序可以看到验证码被显示出来：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/5.jpg %}\n\n我们还能能看到服务器返回的 Cookie 信息，因为我的网页使用 php 写的，所以它返回了一个 PHPSESSID ，用来标记服务器保存的 Session 对象。服务器的 Session 对象里面就保存了验证码的值。之后我们把用户输入的验证码传会服务器的时候只要把这个 PHPSESSID 一同传过去，服务器就能找到之前生成的验证码的值，并和用户所输入的进行对比了:\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/6.jpg %}\n\n### _发送用户输入的验证码_\n\n这里我们直接使用 Retrofit 将用户输入的验证码传给服务器：\n\n```java\n\tpublic void onClick(View v) {\n        HttpService service = new Retrofit.Builder()\n                .client(mHttpClient)  //OkHttpClient 指定了 CookieJar，这样 Retrofit 也能使用 Cookie 了\n                .baseUrl(mBaseUrl)\n                .addConverterFactory(GsonConverterFactory.create())\n                .build()\n                .create(HttpService.class);\n\n        String verifyCode = mEditText.getText().toString();\n        if (verifyCode == null) {\n            return;\n        }\n\n        Call<VerifyCodeResult> call = service.getResult(verifyCode);\n        call.enqueue(new Callback<VerifyCodeResult>() {\n            @Override\n            public void onResponse(Call<VerifyCodeResult> call, Response<VerifyCodeResult> response) {\n                Log.d(\"cookie\", \"request headers: \" + call.request().headers().toString());\n                Toast.makeText(MainActivity.this, response.body().getResult(), Toast.LENGTH_SHORT).show();\n            }\n\n            @Override\n            public void onFailure(Call<VerifyCodeResult> call, Throwable t) {\n            }\n        });\n```\n\n```java\n    public interface HttpService {\n        @GET(\"okhttp_cookie_demo/checkverifycode.php\")\n        Call<VerifyCodeResult> getResult(@Query(\"verifycode\") String yam);\n    }\n```\n\n```java\n    public class VerifyCodeResult {\n        private String result;\n\n        public String getResult() {\n            return result;\n        }\n\n        public void setResult(String result) {\n            this.result = result;\n        }\n    }\n```\n\n运行程序，输入验证码可以看到结果：\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/7.jpg %}\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/8.jpg %}\n\n程序正常运行，但看 log 输出，Request 并没有把 PHPSESSID 传过去。这是怎么回事？没有传 PHPSESSID，服务器又怎么能知道之前生成的验证码是什么？\n\n{% img /学习HTTP协议-在安卓上的使用Cookie与Session/9.jpg %}\n\n在 CookieJar 的 loadForRequest 方法设置断点，可以发现在发送验证码的时候确实有调用，随之运行到 HttpEngine 的源码，发现原来框架创建了个新的 Resquest 副本，将 Cookie 传入这个新的副本中去连接服务器：\n\n```java\n    public void sendRequest() throws RequestException, RouteException, IOException {\n        ...\n        Request request = networkRequest(userRequest);\n\t\t...\n    }\n\t...\n    private Request networkRequest(Request request) throws IOException {\n        Request.Builder result = request.newBuilder();\n\n        if (request.header(\"Host\") == null) {\n          result.header(\"Host\", hostHeader(request.url()));\n        }\n\n        if (request.header(\"Connection\") == null) {\n          result.header(\"Connection\", \"Keep-Alive\");\n        }\n\n        if (request.header(\"Accept-Encoding\") == null) {\n          transparentGzip = true;\n          result.header(\"Accept-Encoding\", \"gzip\");\n        }\n\n\t\t//看这里，其实是有设置 CookieJar 中的 Cookie 的\n        //也就是说 PHPSESSID 有传回去给服务器\n        List<Cookie> cookies = client.cookieJar().loadForRequest(request.url());\n        if (!cookies.isEmpty()) {\n          result.header(\"Cookie\", cookieHeader(cookies));\n        }\n\n        if (request.header(\"User-Agent\") == null) {\n          result.header(\"User-Agent\", Version.userAgent());\n        }\n\n        return result.build();\n      }\n```\n\n原来如此，操作都使用了副本 Request 去执行，怪不得我们直接用下面的代码输出，请求头部不能看到 PHPSESSID 的 Cookie 值：\n\n```java\n\t@Override\n    public void onResponse(Call<VerifyCodeResult> call, Response<VerifyCodeResult> response) {\n        Log.d(\"cookie\", \"request headers: \" + call.request().headers().toString());\n        Toast.makeText(MainActivity.this, response.body().getResult(), Toast.LENGTH_SHORT).show();\n    }\n```\n\n## __Glide 使用 Cookie__\n\nGlide 是Google推荐的图片加载库，用来加载图片十分之方便，最少只需要三行代码就能将网络图片加载到 ImageView 上。\n\n我有在 Glide 的文档上看到它也能使用 OkHttp3，理论上应该也能使用设置 OkHttpClient 的方法使用 Cookie。\n\n但弄了很久还是没有搞定，等以后有时间找到实现方法再把这一节补全。\n\n## __Demo 完整代码__\n\nMainActivity:\n\n```java\n\tpublic class MainActivity extends AppCompatActivity {\n    private static final String mBaseUrl = \"http://www.islinjw.cn\";\n    private static final String mVerifyCideUrl = \"http://www.islinjw.cn/okhttp_cookie_demo/verifycode.php\";\n\n    private OkHttpClient mHttpClient;\n    private EditText mEditText;\n    private ImageView mImageView;\n    private Map<String, List<Cookie>> mCookieStore;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mEditText = (EditText) findViewById(R.id.input);\n        mImageView = (ImageView) findViewById(R.id.yzm);\n        mCookieStore = new HashMap<>();\n        mHttpClient = createHttpClient();\n\n        loadVerifyCode(mImageView, HttpUrl.parse(mVerifyCideUrl));\n    }\n\n    private OkHttpClient createHttpClient() {\n        CookieJar cookieJar = new CookieJar() {\n            @Override\n            public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {\n                mCookieStore.put(url.host(), cookies);\n            }\n\n            @Override\n            public List<Cookie> loadForRequest(HttpUrl url) {\n                List list = mCookieStore.get(url.host());\n                return list != null ? list : new ArrayList<Cookie>();\n            }\n        };\n        return new OkHttpClient.Builder()\n                .cookieJar(cookieJar)\n                .build();\n    }\n\n    private void loadVerifyCode(final ImageView imageView, final HttpUrl url) {\n        final Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    okhttp3.Response response = mHttpClient.newCall(request).execute();\n\n                    //创建bitmap\n                    InputStream is = response.body().byteStream();\n                    final Bitmap bm = BitmapFactory.decodeStream(is);\n\n                    //加载到ImageView中\n                    runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            imageView.setImageBitmap(bm);\n                        }\n                    });\n\n                    //打印cookie信息\n                    List<Cookie> cookies = Cookie.parseAll(request.url(), response.headers());\n                    for (int i = 0; i < cookies.size(); i++) {\n                        Log.d(\"cookie\", \"response headers: \" + cookies.get(i).toString());\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n\n    public void onClick(View v) {\n        HttpService service = new Retrofit.Builder()\n                .client(mHttpClient)  //OkHttpClient 指定了 CookieJar，这样 Retrofit 也能使用 Cookie 了\n                .baseUrl(mBaseUrl)\n                .addConverterFactory(GsonConverterFactory.create())\n                .build()\n                .create(HttpService.class);\n\n        String verifyCode = mEditText.getText().toString();\n        if (verifyCode == null) {\n            return;\n        }\n\n        Call<VerifyCodeResult> call = service.getResult(verifyCode);\n        call.enqueue(new Callback<VerifyCodeResult>() {\n            @Override\n            public void onResponse(Call<VerifyCodeResult> call, Response<VerifyCodeResult> response) {\n                Log.d(\"cookie\", \"request headers: \" + call.request().headers().toString());\n                Toast.makeText(MainActivity.this, response.body().getResult(), Toast.LENGTH_SHORT).show();\n            }\n\n            @Override\n            public void onFailure(Call<VerifyCodeResult> call, Throwable t) {\n            }\n        });\n    }\n}\n```\n\nHttpService:\n\n```java\n\tpublic interface HttpService {\n        @GET(\"okhttp_cookie_demo/checkverifycode.php\")\n        Call<VerifyCodeResult> getResult(@Query(\"verifycode\") String yam);\n    }\n```\n\n```java\n\tpublic class VerifyCodeResult {\n        private String result;\n\n        public String getResult() {\n            return result;\n        }\n\n        public void setResult(String result) {\n            this.result = result;\n        }\n    }\n```\n","tags":["技术相关","Http协议"]},{"title":"Retrofit 学习笔记","url":"/2016/02/22/Retrofit-学习笔记/","content":"\n工欲善其事必先利其器，使用一些强大方便的器，可以大大的提高开发的效率，我认为 Retrofit 和 RxJava 就是这样的利器。\n\nRetrofit 是一个开源的 java http 请求库，目前已经更新到 2.0.0-beta4，官方的介绍是：\n\n> Type-safe HTTP client for Android and Java by Square, Inc.\n\n我在学习它的过程中遇到了不少问题，于是写了这篇东西把遇到的问题和解决方法都记录一下。\n\n## __android studio 导入 Retrofit__\n\n首先我使用的是 android studio，一开始搜索怎样使用第三方库的时候看到了不少的文章，有介绍导入 jar 包的，有介绍源码库的，但使用方法和我接下来介绍的都显得复杂很多。\n\n比如现在我们要使用 Retrofit ，先登录 [http://search.maven.org/](http://search.maven.org/)，搜索 Retrofit 我们可以看到搜出了不少东西，我们直接用最新的版本 2.0.0-beta4，可以看到它有两个版本，点进去看看：\n\n{% img /Retrofit-学习笔记/1.jpg %}\n\n原来一个是beta3，一个是beta4：\n\n{% img /Retrofit-学习笔记/2.jpg %}\n\n然后我们打开 android studio 项目的 build.gradle(Module: app)， 在它的 dependencies 里面加上  retrofit 的引用:\n\n```\n    dependencies {\n        compile fileTree(dir: 'libs', include: ['*.jar'])\n        testCompile 'junit:junit:4.12'\n        compile 'com.android.support:appcompat-v7:23.1.1'\n        compile 'com.squareup.retrofit2:retrofit:2.0.0-beta4'\n    }\n```\n\n要使用 [http://search.maven.org/](http://search.maven.org/)，搜索到的第三方库只需要在 dependencies 里面加上\n\n> compile 'GroupId:ArtifactId:Version'\n\n对应 retrofit 就是这句：\n\n> compile 'com.squareup.retrofit2:retrofit:2.0.0-beta4'\n\n再点击 android studio 弹出的 Sync Now，android studio 就会帮你自动下载和配置第三方库，而你就能直接使用了。\n\n{% img /Retrofit-学习笔记/3.jpg %}\n\n## __使用 Retrofit 的 Call 类获取 github 用户的信息__\n\n官方文档一开始就展示了一个简单的demo [http://square.github.io/retrofit/](http://square.github.io/retrofit/)\n\n可惜都是代码碎片，你按照它写好代码之后就会发现......报异常了。\n\n{% img /Retrofit-学习笔记/4.jpg %}\n\n{% img /Retrofit-学习笔记/5.jpg %}\n\n我先把讲讲我写的demo，最后再告诉你们官方文档到底哪里出问题了。\n\n首先定义一个 User 类用于保存获取到的用户信息：\n\n```java\n    public class User {\n        private String login;\n        private long id;\n        private String name;\n\n        @Override\n        public String toString() {\n            return \"login:\" + login + \", \"\n                    + \"id:\" + id + \", \"\n                    + \"name:\" + name;\n        }\n\n        public String getLogin() {\n            return login;\n        }\n\n        public void setLogin(String login) {\n            this.login = login;\n        }\n\n        public long getId() {\n            return id;\n        }\n\n        public void setId(long id) {\n            this.id = id;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n    }\n```\n\n接着定义一个接口用于告诉 Retrofit 怎样去获取数据，如下代码就表明使用 get 方法获取 users 路径下的 user 资源，使用的最终使用的时候，传入的 user 参数会替换 users/{user} 的 {user} 字段。\n\n不过我还真不知道它这里到底是怎么实现的，看来 java 基础还真要去补一补才行了。\n\n```java\n     public interface GitHubService {\n            @GET(\"users/{user}\")\n            Call<User> getUserInfoByCall(@Path(\"user\") String user);\n        }\n```\n\n之后就可以创建一个 GitHubService 实例了（我总觉得有点 java 黑魔法的感觉）：\n\n```java\n     GitHubService service = new Retrofit.Builder()\n                    .baseUrl(\"https://api.github.com\")\n                    .addConverterFactory(GsonConverterFactory.create())\n                    .build()\n                    .create(GitHubService.class);\n```\n\n然后调用 service 的 getUserInfoByCall 方法就能获取到一个 Call 对象了。像如下的代码，就能获取到一个用于访问 [https://api.github.com/users/bluesky466](https://api.github.com/users/bluesky466) 的 Call 对象：\n\n```java\n\tfinal Call<User> call = service.getUserInfoByCall(\"bluesky466\");\n```\n\n最后就能用 call 的 execute 方法访问服务器获取用户数据了。因为 execute 是同步的，而安卓不允许在 ui 线程访问网络，所以我们需要用一个子线程去访问。\n\n```java\n    new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        Response<User> response = call.execute();\n                        User user = response.body();\n                        Log.d(\"result\", user.toString());\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }).start();\n```\n\n结果如下：\n\n{% img /Retrofit-学习笔记/6.jpg %}\n\n当然，Retrofit 也提供了异步访问的方法：\n\n```java\n     call.enqueue(new Callback<User>() {\n                @Override\n                public void onResponse(Call<User> call, Response<User> response) {\n                    User user = response.body();\n                \tLog.d(\"result\", user.toString());\n                }\n\n                @Override\n                public void onFailure(Call<User> call, Throwable t) {\n\n                }\n            });\n```\n\nRetrofit 用获取到的数据生成了一个User对象。这是什么黑魔法？\n\n还记得我一开始说的按照官方文档的代码会报异常吗？\n\n官方文档的代码：\n\n```java\n    Retrofit retrofit = new Retrofit.Builder()\n        .baseUrl(\"https://api.github.com\")\n        .build();\n\n    GitHubService service = retrofit.create(GitHubService.class);\n```\n\n我的代码：\n\n```java\n    GitHubService service = new Retrofit.Builder()\n                        .baseUrl(\"https://api.github.com\")\n                        .addConverterFactory(GsonConverterFactory.create())\n                        .build()\n                        .create(GitHubService.class);\n```\n\n差别就在在这里：\n\n```\n\t.addConverterFactory(GsonConverterFactory.create())\n```\n\n我这里指定了一个 Gson 转换工厂，因为 [https://api.github.com](https://api.github.com) 使用josn 格式返回数据，所以我们可以使用 Gson 去解析它，然后生成一个 User 对象。\n\n不过就算你按我这样写代码又会发现找不到 GsonConverterFactory 的包......\n\n{% img /Retrofit-学习笔记/7.jpg %}\n\n原因在于 GsonConverterFactory 使用来转换json的，你也可以指定其他的 Factory 去转换 xml 之类的格式。而这些 Factory 并不包含在 Retrofit 库里面，需要用户自己去导入。\n\n{% img /Retrofit-学习笔记/8.jpg %}\n\n在 dependencies 中加入：\n\n```\n\tcompile 'com.squareup.retrofit2:converter-gson:2.0.0-beta4'\n```\n\n类似的库有下面这些：\n- __Gson__: com.squareup.retrofit2:converter-gson\n- __Jackson__: com.squareup.retrofit2:converter-jackson\n- __Moshi__: com.squareup.retrofit2:converter-moshi\n- __Protobuf__: com.squareup.retrofit2:converter-protobuf\n- __Wire__: com.squareup.retrofit2:converter-wire\n- __Simple__ XML: com.squareup.retrofit2:converter-simplexml\n- __Scalars__ (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars\n\n\n## __使用 Retrofit 配合 RxJava 获取 github 用户的信息__\n\nRxJava 在 GitHub 主页上的自我介绍是 \"a library for composing asynchronous and event-based programs using observable sequences for the Java VM\"（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。\n\n它可以用来替换 AsyncTask 之类的东西。\n\n关于 RxJava 有一篇很好的博客 -- [给 Android 开发者的 RxJava 详解](http://gank.io/post/560e15be2dca930e00da1083)。这里基本上把 RxJava 讲的很透彻了。我这里就不多说，只是讲一讲怎样在 Retrofit 中使用 RxJava。\n\n在 Retrofit 中使用 RxJava 首先需要导入 adapter-rxjava 库，而且因为是在安卓上使用，所以需要导入 RxJava 的 Android 平台的扩展 rxandroid 库：\n\n```\n\tcompile 'com.squareup.retrofit2:adapter-rxjava:2.0.0-beta4\n    compile 'io.reactivex:rxandroid:1.1.0'\n```\n\n添加 GitHubService 接口的 RxJava 获取方法：\n```java\n    public interface GitHubService {\n            @GET(\"users/{user}\")\n            Call<User> getUserInfoByCall(@Path(\"user\") String user);\n\n            @GET(\"users/{user}\")\n            Observable<User> getUserInfoByObservable(@Path(\"user\") String user);\n        }\n```\n\n然后创建 GitHubService 的时候需要指定 RxJava的适配工厂：\n\n```java\n     GitHubService service = new Retrofit.Builder()\n                    .baseUrl(\"https://api.github.com\")\n                    .addConverterFactory(GsonConverterFactory.create())//指定RxJava适配工厂\n                    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())\n                    .build()\n                    .create(GitHubService.class);\n```\n\n然后就是指定 subscribe 去输出结果了：\n\n```java\n    service.getUserInfoByObservable(\"bluesky466\")\n                    .subscribeOn(Schedulers.newThread())\n                    .observeOn(AndroidSchedulers.mainThread())\n                    .subscribe(new Subscriber<User>() {\n                        @Override\n                        public void onNext(User user) {\n                            if (user != null) {\n                                Log.d(\"result\", user.toString());\n                            }\n                        }\n\n                        @Override\n                        public void onCompleted() {\n                        }\n\n                        @Override\n                        public void onError(Throwable e) {\n                        }\n                    });\n```\n\n## __一个小 Demo__\n\n我写了一个 demo 用来展示 Retrofit 的用法，完整源码如下：\n\nMainActivity：\n\n```java\n    public class MainActivity extends AppCompatActivity {\n        private GitHubService mService;\n        private EditText mUserName;\n        private TextView mResult;\n\n        public interface GitHubService {\n            @GET(\"users/{user}\")\n            Call<User> getUserInfoByCall(@Path(\"user\") String user);\n\n            @GET(\"users/{user}\")\n            Observable<User> getUserInfoByObservable(@Path(\"user\") String user);\n        }\n\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.activity_main);\n\n            mUserName = (EditText) findViewById(R.id.username);\n            mResult = (TextView) findViewById(R.id.result);\n\n            Button btnCall = (Button) findViewById(R.id.btnCall);\n            btnCall.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    queryByCall(mUserName.getText().toString());\n                }\n            });\n\n            Button btnObservable = (Button) findViewById(R.id.btnObservable);\n            btnObservable.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    queryByObservable(mUserName.getText().toString());\n                }\n            });\n\n            mService = new Retrofit.Builder()\n                    .baseUrl(\"https://api.github.com\")\n                    .addConverterFactory(GsonConverterFactory.create())\n                    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())\n                    .build()\n                    .create(GitHubService.class);\n        }\n\n        private void queryByCall(final String username) {\n            mService.getUserInfoByCall(username).enqueue(new Callback<User>() {\n                @Override\n                public void onResponse(Call<User> call, Response<User> response) {\n                    if (response.body() != null) {\n                        mResult.setText(\"[ByCall] \" + response.body().toString());\n                    } else {\n                        mResult.setText(\"[ByCall] Not Found\");\n                    }\n                }\n\n                @Override\n                public void onFailure(Call<User> call, Throwable t) {\n                    mResult.setText(\"[ByCall] Not Found\");\n                }\n            });\n        }\n\n        private void queryByObservable(final String username) {\n            mService.getUserInfoByObservable(username)\n                    .subscribeOn(Schedulers.newThread())\n                    .observeOn(AndroidSchedulers.mainThread())\n                    .subscribe(new Subscriber<User>() {\n                        @Override\n                        public void onCompleted() {\n                        }\n\n                        @Override\n                        public void onError(Throwable e) {\n                            mResult.setText(\"[ByObservable] Not Found\");\n                        }\n\n                        @Override\n                        public void onNext(User user) {\n                            if (user != null) {\n                                mResult.setText(\"[ByObservable] \" + user.toString());\n                            }\n                        }\n                    });\n        }\n    }\n```\n\nactivity\\_main.xml:\n\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        xmlns:tools=\"http://schemas.android.com/tools\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <LinearLayout\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:orientation=\"horizontal\">\n\n            <EditText\n                android:id=\"@+id/username\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_weight=\"1\"\n                android:hint=\"user name\" />\n\n            <Button\n                android:id=\"@+id/btnCall\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"Call\" />\n\n            <Button\n                android:id=\"@+id/btnObservable\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"Observable\" />\n        </LinearLayout>\n\n        <TextView\n            android:id=\"@+id/result\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"\" />\n    </LinearLayout>\n```\n\nUser:\n\n```java\n    public class User {\n        private String login;\n        private long id;\n        private String name;\n\n        @Override\n        public String toString() {\n            return \"login:\" + login + \", \"\n                    + \"id:\" + id + \", \"\n                    + \"name:\" + name;\n        }\n\n        public String getLogin() {\n            return login;\n        }\n\n        public void setLogin(String login) {\n            this.login = login;\n        }\n\n        public long getId() {\n            return id;\n        }\n\n        public void setId(long id) {\n            this.id = id;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n    }\n\n```\n\ndependencies:\n\n```\n\tdependencies {\n        compile fileTree(dir: 'libs', include: ['*.jar'])\n        testCompile 'junit:junit:4.12'\n        compile 'com.android.support:appcompat-v7:23.1.1'\n        compile 'com.squareup.retrofit2:retrofit:2.0.0-beta4'\n        compile 'com.squareup.retrofit2:converter-gson:2.0.0-beta4'\n        compile 'com.squareup.retrofit2:adapter-rxjava:2.0.0-beta4'\n        compile 'io.reactivex:rxandroid:1.1.0'\n    }\n```\n","tags":["技术相关","Android"]},{"title":"GTest源码剖析 - 测试代码的注册","url":"/2016/02/15/GTest源码剖析-测试代码的注册/","content":"单元测试框架，最基本的功能当然就是运行用户所编写的测试用例了。\n\n## __毫无技巧的方法__\n\n一种毫无技巧的方法就是用户手动在 main 函数里面将自己编写的测试代码注册到框架中，就像下面的代码：\n```cpp\n    void test1() {...}\n    void test2() {...}\n    void test3() {...}\n    ...\n\n    int main(){\n        RegisterTestFunc(test1);\n        RegisterTestFunc(test2);\n        RegisterTestFunc(test3);\n        ...\n        return 0;\n    }\n```\n\n这样的代码虽然可以运行，但是将初始化的责任放到的用户那里，这样的代码是不够优秀的。有两种容易出现的情况：一是项目中可能拥有大量的测试代码，用户很有可能会漏掉其中的部分测试代码，忘记把它们注册到测试框架中。二是可能用户去掉了一些测试代码，却又忘了去掉注册的代码。\n\n后者编译器会报错，但前者却没有办法检测（除非对着测试结果一条条的检测，看是否所有测试代码都运行了）。\n\n## __一种有问题的方法__\n\n最好在编写测试代码的时候就能通过一种机制帮用户注册，而不用用户手动去注册。面对这个需求，我脑海里面想到的第一个方法就是利用全局变量和宏定义。\n\n首先定义一个用来管理注册的测试方法的类：\n```cpp\n\ttypedef list<function<void()>> FuncList;\n    class Test{\n    public:\n        Test(const function<void()>& test_func){\n            test_funcs_.push_back(test_func);\n        }\n\n        static void runAllTest(){\n            for (auto func : test_funcs_){\n                func();\n            }\n        }\n\n    private:\n        static FuncList test_funcs_;\n    };\n```\n\n它有一个静态的成员变量 test\\_funcs\\_ ，用来保存测试方法，同时它有一个构造函数用来将传入的测试方法插入 test\\_funcs\\_ 中\n\n接着定义一个宏：\n```cpp\n    #define TEST_FUNC(NAME) \\\n        void NAME(); \\\n        static Test register_##NAME(NAME); \\\n        void NAME()\n```\n它在帮助我们在定义一个测试方法的时候自动注册到 test\\_funcs\\_ 中。原理其实很简单，就是在声明一个函数的同时声明一个 Test 全局变量，将定义的测试方法传入，这个测试函数就会在 Test 的构造函数中被插入 test\\_funcs\\_ 。\n\n所以我们只要这样编写测试代码，就能实现自动注册了：\n```cpp\n\tTEST_FUNC(testSomething){\n        ...\n    }\n```\n\n看起来这个方法不错是吧？可惜这种方法是有问题的！至少在我的 vs2013 上会崩溃！\n\n问题就出在 Test 全局变量和 Test::test\\_funcs\\_ 的初始化顺序上。你无法保证 Test::test\\_funcs\\_ 比全局变量 Test 先初始化。很奇怪是吧？ Test 的静态成员变量居然比 Test 全局变量的初始化时间晚，也就是说在 Test 这个类还没有完全准备好的时候，就已经拿来创建一个全局变量了。书上一直强调的全局变量的初始化顺序不能确定难道也有这种含义？\n\n## __一种可能可行的方法__\n\n既然是因为初始化顺序导致了内存错误，那我们只要使用某种机制让保存测试函数的容器首先初始化就行了。\n\n让我们将 Test 类的定义修改成下面的样子：\n\n```cpp\n    class Test{\n    public:\n        virtual void run() = 0;\n\n        static void runAllTest(){\n            for (auto i : test_list){\n                i->run();\n            }\n        }\n\n    protected:\n        static void addTest(Test* test){\n            test_list.push_back(test);\n        }\n\n    private:\n        static list<Test*> test_list;\n    };\n```\n\n容器里面不再直接放测试函数，改为放 Test 的指针。而 Test 又是一个抽象类，所以事实上放的是 Test 的子类。\n\n再把 TEST_FUNC 宏的定义改成下面的样子：\n\n```cpp\n    #define TEST_FUNC(NAME) \\\n        class NAME : public Test{ \\\n        public: \\\n            virtual void run(); \\\n        private: \\\n            NAME(){ \\\n                addTest(this); \\\n            } \\\n            static NAME* instance_; \\\n        }; \\\n        NAME* NAME::instance_ = new NAME(); \\\n        void NAME::run()\n\n```\n\n现在实际上用户写的测试方法实现的是 Test 的子类的 run 方法。\n\n依然是需要在定义测试方法的时候顺便定义一个全局变量，但我们换了一种方式，定义了一个类静态变量。子类在构造函数中把自己注册到 Test 的测试容器中，而且子类还包含了一个本类指针静态成员变量（有点拗口，但看代码很容易看出来）。在子类的静态成员变量初始化的之前，父类的静态成员变量应该就已经初始化了。就是根据这种机制，达到了我们的目的。\n\n使用方法还是一样：\n\n```cpp\n    TEST_FUNC(testSomething){\n        ...\n    }\n```\n\n为什么说这是“一种可能可行的方法”呢？因为父类的静态成员变量初始化先于子类的静态成员变量初始化这个前提是我自己推论的。可能是我读的书少或者读书不仔细，至今没有在哪里见到有提及父类和子类的静态成员变量的初始化顺序的。所以虽然在我的编译器上它的确能正常的工作，但为了严谨起见，姑且称为“可能”的吧。如果有人有在哪里看到这方面的描述，请务必私信我，让我把“可能”二字去掉或者将标题改成“另一种有问题的方法”\n\n## __GTest 的做法__\n\n讲了这么久我的想法，现状让我们来看看谷歌的大神们是怎么做的吧。\n\n我们从 TEST 宏看起：\n\n```cpp\n    #if !GTEST_DONT_DEFINE_TEST\n    # define TEST(test_case_name, test_name) GTEST_TEST(test_case_name, test_name)\n    #endif\n```\n\n这里这么搞，主要是为了防止 TEST 被系统或者其他框架定义了。如果出现这种情况，只要把GTEST\\_DONT\\_DEFINE\\_TEST 定义为 1，之后编写测试用例的时候直接使用 GTEST\\_TEST 就好了。不得不说，他们考虑的真仔细。让我们继续跟踪，看 GTEST\\_TEST：\n\n```cpp\n    #define GTEST_TEST(test_case_name, test_name)\\\n      GTEST_TEST_(test_case_name, test_name, \\\n                  ::testing::Test, ::testing::internal::GetTestTypeId())\n```\n\nGTEST\\_TEST 宏又用到了另一个宏 GTEST\\_TEST\\_，但我想先说一下 GetTestTypeId，这个东西的用法真的令我眼前一亮，不得不佩服：\n\n```cpp\n    TypeId GetTestTypeId() {\n      return GetTypeId<Test>();\n    }\n\n\t...\n\n\ttemplate <typename T>\n    TypeId GetTypeId() {\n      // The compiler is required to allocate a different\n      // TypeIdHelper<T>::dummy_ variable for each T used to instantiate\n      // the template.  Therefore, the address of dummy_ is guaranteed to\n      // be unique.\n      return &(TypeIdHelper<T>::dummy_);\n    }\n\n\t...\n\n    template <typename T>\n    class TypeIdHelper {\n     public:\n      // dummy_ must not have a const type.  Otherwise an overly eager\n      // compiler (e.g. MSVC 7.1 & 8.0) may try to merge\n      // TypeIdHelper<T>::dummy_ for different Ts as an \"optimization\".\n      static bool dummy_;\n    };\n```\n\n这里直接用一个类的静态成员变量的地址当作 id 号。当时我就懵逼了，明明很简单，怎么就感觉那么玄幻呢？\n\n膜拜完我们再继续看 GTEST\\_TEST\\_：\n```cpp\n    #define GTEST_TEST_(test_case_name, test_name, parent_class, parent_id)\\\n    class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class {\\\n     public:\\\n      GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}\\\n     private:\\\n      virtual void TestBody();\\\n      static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;\\\n      GTEST_DISALLOW_COPY_AND_ASSIGN_(\\\n          GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\\\n    };\\\n    \\\n    ::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)\\\n      ::test_info_ =\\\n        ::testing::internal::MakeAndRegisterTestInfo(\\\n            #test_case_name, #test_name, NULL, NULL, \\\n            (parent_id), \\\n            parent_class::SetUpTestCase, \\\n            parent_class::TearDownTestCase, \\\n            new ::testing::internal::TestFactoryImpl<\\\n                GTEST_TEST_CLASS_NAME_(test_case_name, test_name)>);\\\n    void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()\n```\n\n这个宏的做法和我的最后一个方法的 TEST\\_FUNC 宏差不多，用户写的测试函数实际上是实现了 ::testing::Test 的子类的 TestBody 方法。也是初始化了子类的一个静态成员变量，但GTest这里没有我那么暴力，它初始化的是一个 TestInfo 类型的的静态成员变量，这里面包含了测试的很多信息。其中最重要的是 ::testing::internal::TestFactoryImpl 这个东西：\n\n```cpp\n    template <class TestClass>\n    class TestFactoryImpl : public TestFactoryBase {\n     public:\n      virtual Test* CreateTest() { return new TestClass; }\n    };\n\n    ...\n\n\tclass TestFactoryBase {\n     public:\n      virtual ~TestFactoryBase() {}\n\n      // Creates a test instance to run. The instance is both created and destroyed\n      // within TestInfoImpl::Run()\n      virtual Test* CreateTest() = 0;\n\n     protected:\n      TestFactoryBase() {}\n\n     private:\n      GTEST_DISALLOW_COPY_AND_ASSIGN_(TestFactoryBase);\n    };\n```\n\n它是一个工厂类，用来创建传入的测试类的实例，也就是 GTEST\\_TEST\\_CLASS\\_NAME\\_(test\\_case\\_name, test\\_name)> 这个类，它的 TestBody 就是用户所写的测试代码。可以看看 GTEST\\_TEST\\_CLASS\\_NAME\\_ 的定义：\n\n```cpp\n    #define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n      test_case_name##_##test_name##_Test\n```\n\nok,很简单是吧？就是字符串拼接而已。\n\n好了，让我们继续深入，看看 MakeAndRegisterTestInfo ：\n```cpp\n\t//gtest.cc\n    TestInfo* MakeAndRegisterTestInfo(\n        const char* test_case_name,\n        const char* name,\n        const char* type_param,\n        const char* value_param,\n        TypeId fixture_class_id,\n        SetUpTestCaseFunc set_up_tc,\n        TearDownTestCaseFunc tear_down_tc,\n        TestFactoryBase* factory) {\n      TestInfo* const test_info =\n          new TestInfo(test_case_name, name, type_param, value_param,\n                       fixture_class_id, factory);\n      GetUnitTestImpl()->AddTestInfo(set_up_tc, tear_down_tc, test_info);\n      return test_info;\n    }\n\n\t//gtest-internal-inl.h\n\tinline UnitTestImpl* GetUnitTestImpl() {\n      return UnitTest::GetInstance()->impl();\n    }\n\n    //gtest.h\n    class GTEST_API_ UnitTest {\n     public:\n      static UnitTest* GetInstance();\n      ...\n      internal::UnitTestImpl* impl() { return impl_; }\n      ...\n      internal::UnitTestImpl* impl_;\n      ...\n    };\n\n    //gtest.cc\n    UnitTest* UnitTest::GetInstance() {\n      // When compiled with MSVC 7.1 in optimized mode, destroying the\n      // UnitTest object upon exiting the program messes up the exit code,\n      // causing successful tests to appear failed.  We have to use a\n      // different implementation in this case to bypass the compiler bug.\n      // This implementation makes the compiler happy, at the cost of\n      // leaking the UnitTest object.\n\n      // CodeGear C++Builder insists on a public destructor for the\n      // default implementation.  Use this implementation to keep good OO\n      // design with private destructor.\n\n    #if (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)\n      static UnitTest* const instance = new UnitTest;\n      return instance;\n    #else\n      static UnitTest instance;\n      return &instance;\n    #endif  // (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)\n    }\n\n    //gtest-internal-inl.h\n    class GTEST_API_ UnitTestImpl {\n    \t...\n        void AddTestInfo(Test::SetUpTestCaseFunc set_up_tc,\n                   Test::TearDownTestCaseFunc tear_down_tc,\n                   TestInfo* test_info) {\n        // In order to support thread-safe death tests, we need to\n        // remember the original working directory when the test program\n        // was first invoked.  We cannot do this in RUN_ALL_TESTS(), as\n        // the user may have changed the current directory before calling\n        // RUN_ALL_TESTS().  Therefore we capture the current directory in\n        // AddTestInfo(), which is called to register a TEST or TEST_F\n        // before main() is reached.\n        if (original_working_dir_.IsEmpty()) {\n          original_working_dir_.Set(FilePath::GetCurrentDir());\n          GTEST_CHECK_(!original_working_dir_.IsEmpty())\n              << \"Failed to get the current working directory.\";\n        }\n\n        GetTestCase(test_info->test_case_name(),\n                    test_info->type_param(),\n                    set_up_tc,\n                    tear_down_tc)->AddTestInfo(test_info);\n      }\n      ...\n      //这个方法从test_cases_里面获取TestCase\n      TestCase* GetTestCase(const char* test_case_name,\n                        const char* type_param,\n                        Test::SetUpTestCaseFunc set_up_tc,\n                        Test::TearDownTestCaseFunc tear_down_tc);\n      ...\n      std::vector<TestCase*> test_cases_;\n      ...\n    };\n\n    //gtest.cc\n    void TestCase::AddTestInfo(TestInfo * test_info) {\n      test_info_list_.push_back(test_info);\n      test_indices_.push_back(static_cast<int>(test_indices_.size()));\n    }\n\n    //gtest.h\n    class GTEST_API_ TestCase {\n    \t...\n    \tstd::vector<TestInfo*> test_info_list_;\n        std::vector<int> test_indices_;\n        ...\n    };\n```\n\n代码很多，我简单的描述一下。UnitTest 是一个单例类，它有一个成员变量 internal::UnitTestImpl* impl\\_， impl\\_ 里面又有成员变量 test\\_info\\_list\\_。最终我们写的测试类就放在 test\\_info\\_list\\_ 里。\n\n九曲十八弯，实际 GTest 用一个单例类 UnitTest 保存了注册的测试代码（放在 ::testing::Test 子类的 TestBody 方法里面）。\n\n那他是怎么解决初始化顺序的问题的？注意看 UnitTest::GetInstance() 方法：\n\n```cpp\n\t//gtest.cc\n    UnitTest* UnitTest::GetInstance() {\n      // When compiled with MSVC 7.1 in optimized mode, destroying the\n      // UnitTest object upon exiting the program messes up the exit code,\n      // causing successful tests to appear failed.  We have to use a\n      // different implementation in this case to bypass the compiler bug.\n      // This implementation makes the compiler happy, at the cost of\n      // leaking the UnitTest object.\n\n      // CodeGear C++Builder insists on a public destructor for the\n      // default implementation.  Use this implementation to keep good OO\n      // design with private destructor.\n\n    #if (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)\n      static UnitTest* const instance = new UnitTest;\n      return instance;\n    #else\n      static UnitTest instance;\n      return &instance;\n    #endif  // (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)\n    }\n```\n\n这里使用了局部静态变量，在第一次进入这个方法的时候就会生成一个 UnitTest 实例！不需要靠人品祈祷编译器按照我们设想的顺序创建全局变量！\n\n谷歌大神们不愧是大神，在看 GTest 源码的时候我都不知道被惊艳了多少次，真心学到了不少东西。怪不得别人都说看源码才是最好的提升方式。\n","tags":["技术相关","单元测试"]},{"title":"读书笔记 -《黑客与画家》","url":"/2016/02/11/读书笔记-《黑客与画家》/","content":"这本书是一本文集，也有点像paul graham的自传。以成长的各个阶段为引子，讲到了paul graham对书呆子、优秀程序员、创业和编程语言等的观点看法。\n\n其实不太适合这个阶段的我读，创业、程序语言的设计这些离我还太遥远。不像书中的”黑客“从初中高中就开始学习编程，在大学时期甚至更早之前就能做出一些很厉害的东西。我经历的实际项目一个巴掌都数的过来，甚至还不知道书中“黑客”推崇备至的lisp代码到底长什么样子，很多东西看来了不能产生太深的感悟。\n\n但换个角度，把它当成一本闲时读物，用来拓展眼界还是极好的。\n\n以前我不明白为什么公司里面的项目组普遍在十人左右，现在才知道小团体和可测量性之间的关系，组织机构越精简往往能提供越大的生产力。\n\n书中对现存编程语言的解析还有对未来编程语言的预测也让我大开眼界，了解到了一些以前从来没有去注意的细节之处。\n\n而要说最大的收获的话，应该就是对于编写代码的方式有了和以前不太一样的理解了。刚学编程那会儿，总是直接上手敲代码，完全没有事前的思考，所以总会写出一堆不堪入目的东西。之后看受一些书本和前辈的影响，又总是喜欢做一些“完美”的设计。通常是考虑了一堆多余的东西，到了真正要编码的时候又发现能力不足以把这些东西都实现，其实就是陷入了“过早优化”。\n\n这本书和《道法自然》的建议有点类似，设计的时候只需要考虑必须实现的功能就可以了。“把整个程序想清楚的时间点，应该是在编写代码的同时，而不是在编写代码之前，这与作家、画家和建筑师的做法完全一样”。人们往往很难在没有实际编码之前就将遇到的问题和未知的需求都考虑在内，所以一开始的设计不应该是一种解决所有问题的方案，不应该太早的决定一个程序应该怎么做。而应该设计一种灵活可变的方案，类似打草稿、画轮廓，然后在编写代码的时候再慢慢修改和填充。\n\n最近看书有点急。大概是以前看的书太少了，好不容易有时间，有心情去看书，所以才看得那么匆忙，一本还没看完就开另一本，同时实际动手敲代码的时间也少的可怜。时间还剩下一个月左右，是该调整一下了，书还是得看仔细点，代码也应该敲多点。\n","tags":["读书笔记"]},{"title":"读书笔记 -《第一行代码——Android》","url":"/2016/02/10/读书笔记-《第一行代码——Android》/","content":"\n很久之前就打算学安卓了，但总被各种事情干扰，一直断断续续。这本书是我第一本真正读完的安卓入门教程。\n\n这本书不愧被称为“Android初学者的最佳入门书”。它涵盖了安卓软件开发的方方面面，不仅讲到了四大组件、UI、碎片、广播机制、数据存储、服务、多媒体、网络、定位服务、传感器这些安卓开发知识，也讲简单提到了git和安卓测试工程的使用。在书本的最后还通过一个比较完整的天气app把书中大部分的内容以实际项目的形式回顾了一遍。\n\n我觉得这本书最大的优点就是点到为止，不像之前读过的那些书，用大篇幅去把各个部件属性和控件都不厌其烦的描述一遍。因为很多东西只要知道有这个东西，知道它的部分关键属性，其他的到需要用到的时候在去查看文档就可以了。\n\n但这本书又不仅是简单的介绍安卓那些组件和类的使用方法，它还介绍了listview加载数据的优化方法、全局获取Context的技巧和制定自己的Log类等实用的安卓编程技巧。虽然由于安卓版本更新太快，有部分代码已经过时，但对于善于使用搜索引擎的程序员来说也不是什么大问题。\n\n总的来说，这本书除了每节末尾的不太相关的RPG剧情描述之外，其它都很合我口味，很幸运可以在入门的阶段遇到这本书。\n\n经过这一段时间的学习，也对安卓编程有了一点心得，接下来就可以正式开始我的毕业设计手机端部分了。边编码，边深入学习java、安卓编程和单元测试等知识。希望在大学的最后一段时间，能够学多点东西，提高自己的编程能力。","tags":["读书笔记"]},{"title":"GTest实例解析","url":"/2016/02/08/GTest实例解析/","content":"gtest是google的一套开源的c++单元测试框架，可以方便程序员对自己的代码进行单元测试。学习这套框架，除了墙外的官方文档之外，我强力推荐[玩转Google开源C\\+\\+单元测试框架Google Test系列](http://www.cnblogs.com/coderzh/archive/2009/04/06/1426755.html)。\n\n这系列的博客已经将gtest讲的十分详细了，所以我这篇博客就不再详细介绍gtest的基本使用方法了，而是通过一个简单的例子，介绍一下如何在实际的项目中使用它。同时也会通过分析gtest的源代码，使得大家能够更好的理解gtest的工作原理\n\n## __需要测试的类__\n\n首先我实现了一个简单的类TwoDimensionalMark，它的功能相当于bool二维数组，可以将二维下标标记为true或者false。只不过它内部使用位运算，一个字节可以记录八个标记数据，可以大量节省内存。它的声明如下：\n\n```cpp\n    class TwoDimensionalMark{\n        public:\n            TwoDimensionalMark(int row, int col, bool flag = false);\n            TwoDimensionalMark(const TwoDimensionalMark& cpy)；\n            ~TwoDimensionalMark();\n            const TwoDimensionalMark& operator =(const TwoDimensionalMark& cpy)；\n\n            //将所有的位置标记为true或者false\n            void clean(bool mark);\n\n            //设置(x,y)下标为true或者false\n            void set(int x, int y, bool mark);\n\n            //获取(x,y)下标的数据\n            bool check(int x, int y)const;\n\n            int getRow();\n            int getCol();\n\n            ...\n    };\n```\n\n## __完整的测试代码__\n我先把完整的测试代码放在这里，可以先简单浏览一遍。\n```cpp\n    #include \"TwoDimensionalMark.h\"\n    #include \"gtest/gtest.h\"\n    #include <cstdlib>\n    #include <vector>\n\n    using namespace std;\n\n    struct MarkSize{\n        MarkSize(int r, int c): row(r),col(c){}\n        int row, col;\n    };\n    class TestWithMarkSize : public testing::TestWithParam<MarkSize>{\n    public:\n        struct Coord{\n            int x, y;\n        };\n\n        vector<vector<bool> > CreateContrast(int row, int col, bool flag){\n            vector<vector<bool> > contrast(row);\n            for (int i = 0; i < row; i++){\n                contrast[i] = vector<bool>(col, flag);\n            }\n            return contrast;\n        }\n\n        vector<Coord> CreateRandCoords(int row, int col){\n            int yRange = row * 3;\n            int xRange = col * 3;\n            int numRandCoord = row * col / 2;\n\n            vector<Coord> coords;\n            for (int i = 0; i < numRandCoord; i++){\n                int x = (rand() % xRange) - col;\n                int y = (rand() % yRange) - row;\n                coords.push_back({ x, y });\n            }\n\n            return coords;\n        }\n\n        void SetFlag(TwoDimensionalMark* mark,  vector<vector<bool> >* contrast,  \n                    const MarkSize& size, const vector<Coord>& coords, bool flag){\n            for (auto c : coords){\n                mark->set(c.x, c.y, flag);\n                //随机位置有可能在row，col之外，要防止溢出\n                if (c.x >= 0 && c.x < size.col && c.y >= 0 && c.y < size.row){\n                    (*contrast)[c.y][c.x] = flag;\n                }\n            }\n        }\n    };\n\n    //行数多于列数的情况\n    INSTANTIATE_TEST_CASE_P(RowLTCol, TestWithMarkSize,\ttesting::Values(MarkSize(200, 100), MarkSize(50, 30)));\n    //行数少于列数的情况\n    INSTANTIATE_TEST_CASE_P(ColLTRow, TestWithMarkSize,\ttesting::Values(MarkSize(10, 100), MarkSize(3, 10)));\n    //行数等于列数的情况\n    INSTANTIATE_TEST_CASE_P(RowEQCol, TestWithMarkSize,\ttesting::Values(MarkSize(100, 100), MarkSize(3, 3)));\n\n\n    TEST_P(TestWithMarkSize,testWithTrueClean){\n        MarkSize size = GetParam();\n\n        //初始化TwoDimensionalMark和用来做对比的contrast,将他们全部用true填充\n        TwoDimensionalMark mark(size.row, size.col);\n        mark.clean(true);\n        vector<vector<bool> > contrast = CreateContrast(size.row, size.col, true);\n\n        //验证mark和contrast里面都是true\n        for (int i = 0; i < size.row; i++){\n            for (int j = 0; j < size.col; j++){\n                ASSERT_TRUE(mark.check(j, i));\n                ASSERT_TRUE(contrast[i][j]);\n            }\n        }\n\n        //随机将一些坐标位置,这个函数生成的随机位置有可能在row，col之外\n        vector<Coord> coords = CreateRandCoords(size.row, size.col);\n\n        //将mark和contrast的之前随机生成的位置设为false\n        SetFlag(&mark, &contrast, size, coords, false);\n\n        //检测随机生成的位置上的值有没有设置正确\n        //mark若位置超出范围则返回false,而contrast则需要防止溢出\n        for (auto c : coords){\n            ASSERT_FALSE(mark.check(c.x,c.y));\n            if (c.x >= 0 && c.x < size.col && c.y >= 0 && c.y < size.row){\n                ASSERT_FALSE(contrast[c.y][c.x]);\n            }\n        }\n\n        //对比contrast和mark，两者应该相等\n        for (int y = 0; y < size.row; y++)\n            for (int x = 0; x < size.col; x++){\n                ASSERT_EQ(contrast[y][x], mark.check(x, y));\n            }\n    }\n\n    TEST_P(TestWithMarkSize, testWithFalseClean){\n        MarkSize size = GetParam();\n\n        //初始化TwoDimensionalMark和用来做对比的contrast,将他们全部用false填充\n        TwoDimensionalMark mark(size.row, size.col);\n        mark.clean(false);\n        vector<vector<bool> > contrast = CreateContrast(size.row, size.col, false);\n\n        //验证mark和contrast里面都是false\n        for (int i = 0; i < size.row; i++){\n            for (int j = 0; j < size.col; j++){\n                ASSERT_FALSE(mark.check(j, i));\n                ASSERT_FALSE(contrast[i][j]);\n            }\n        }\n\n        //随机将一些坐标位置,这个函数生成的随机位置有可能在row，col之外\n        vector<Coord> coords = CreateRandCoords(size.row, size.col);\n\n        //将mark和contrast的之前随机生成的位置设为true\n        SetFlag(&mark, &contrast, size, coords, true);\n\n        //检测随机生成的位置上的值有没有设置正确\n        //mark若位置超出范围则返回false,而contrast则需要防止溢出\n        for (auto c : coords){\n            if (c.x >= 0 && c.x < size.col && c.y >= 0 && c.y < size.row){\n                ASSERT_TRUE(contrast[c.y][c.x]);\n                ASSERT_TRUE(mark.check(c.x, c.y));\n            }\n            else{\n                ASSERT_FALSE(mark.check(c.x, c.y));\n            }\n        }\n    }\n\n    int main(int argc, char* argv[])\n    {\n        testing::InitGoogleTest(&argc, argv);\n        int result =  RUN_ALL_TESTS();\n        getchar();\n        return result;\n    }\n```\n\n## __传入多个参数__\n\n为了覆盖各种大小的情况（行和列数量相等，行多于列，行少于列），需要定义多个不同行列数的TwoDimensionalMark。但如果每个测试用例都手动硬编码的话将会有许多的重复代码，这个时候就可以使用参数化的方法去将行列数作为参数传入各个测试用例中，详细的介绍看[这里](http://www.cnblogs.com/coderzh/archive/2009/04/08/1431297.html)。\n\n这篇博客只写到了一个参数的处理。但我们这里需要传入行数和列数两个参数应该怎么办？\n其实很方法也很简单，首先定义一个结构体MarkSize用于保存行数和列数\n\n```cpp\n    struct MarkSize{\n        MarkSize(int r, int c): row(r),col(c){}\n        int row, col;\n    }\n```\n\n用它作为TestWithParam的模板参数，再声明一个类继承于它。\n\n```cpp\n    class TestWithMarkSize : public testing::TestWithParam<MarkSize>{\n    }\n```\n\n然后传入参数，这里我定义了三组参数，每组两个。分别对应行数比较多，列数比较多，行数列数一样多三种情况：\n\n```cpp\n    //行数多于列数的情况\n    INSTANTIATE_TEST_CASE_P(RowLTCol, TestWithMarkSize,\ttesting::Values(MarkSize(200, 100), MarkSize(50, 30)));\n    //行数少于列数的情况\n    INSTANTIATE_TEST_CASE_P(ColLTRow, TestWithMarkSize,\ttesting::Values(MarkSize(10, 100), MarkSize(3, 10)));\n    //行数等于列数的情况\n    INSTANTIATE_TEST_CASE_P(RowEQCol, TestWithMarkSize,\ttesting::Values(MarkSize(100, 100), MarkSize(3, 3)));\n```\n\n这样一来，只要是 test_case_name 为 TestWithMarkSize 的测试用例都可以使用GetParam方法获取传入的参数了：\n\n```cpp\n    TEST_P(TestWithMarkSize,testWithTrueClean){\n        MarkSize size = GetParam();\n        ...\n    }\n\n    TEST_P(TestWithMarkSize, testWithFalseClean){\n\t\tMarkSize size = GetParam();\n\t\t...\n\t}\n```\n\n\n## __TEST\\_P源码解析__\n\nTEST\\_P 宏的定义如下\n\n```cpp\n    # define TEST_P(test_case_name, test_name) \\\n      class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n          : public test_case_name { \\\n      ...\n      }; \\\n      ...\n      void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()\n```\n\nGTEST_TEST_CLASS_NAME_又是个什么东西？其实它的功能十分简单，就是将类名拼接出来而已，它的定义如下：\n\n```cpp\n    #define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n      test_case_name##_##test_name##_Test\n```\n\n\n所以我们使用 TEST_P(TestWithMarkSize,testWithTrueClean){...} 实际上就是定义了一个 TestWithMarkSize 的子类 TestWithMarkSize_testWithTrueClean_Test。\n\n而花括号里面实际上就是void TestWithMarkSize_testWithTrueClean_Test::TestBody()的实现。\n\n也就是说，实际上我们的测试用例都是TestWithMarkSize的子类。所以我们可以将一些公共的方法和数据结构定义在TestWithMarkSize内，只要将他们声明为protected或者public，就能在TEST_P(TestWithMarkSize,testWithTrueClean){...} 和 TEST_P(TestWithMarkSize,testWithFalseClean){...} 内使用。\n\n这样既可以提炼重复代码，又能将它们的作用范围限定在测试用例中，防止提炼出来的函数或者定义的数据结构放在全局影响实际的功能代码。\n\n如我这里定义的 Coord 结构体和CreateContrast、CreateRandCoords 和 SetFlag 方法。\n\n而GetParam()的定义如下：\n\n```cpp\n    static const ParamType* parameter_;\n\n    const ParamType& GetParam() const {\n        GTEST_CHECK_(parameter_ != NULL)\n            << \"GetParam() can only be called inside a value-parameterized test \"\n            << \"-- did you intend to write TEST_P instead of TEST_F?\";\n        return *parameter_;\n    }\n```\n\n既然 const T* WithParamInterface<T>::parameter_ 是有一个类静态成员变量，那就不难理解为什么所有继承于 TestWithMarkSize 的测试用例都能拿到同样的参数了。\n\n## __测试用例分析__\n\n要知道 TwoDimensionalMark 实际上的功能是和bool二维数组基本一样的，所以我们就很自然的想到使用一个对比用的bool二维数组作为参照，去测试 TwoDimensionalMark 的功能究竟有没有bug。\n\nTEST_P(TestWithMarkSize,testWithTrueClean) 的测试分下面三个步骤：\n\n1.根据传入的数组大小，创建了一个 TwoDimensionalMark 和用两重 vector 实现的 bool 二维数组。\n\n2.将它们全部用true填充，然后验证每一个下标的数据是否均为 true，如此去测试TwoDimensionalMark::clean(true) 的功能\n\n3.随机生成一些坐标，将 TwoDimensionalMark 和 bool 二维数组对应这些坐标的数据都设为 false 。然后检测设置的位置的数据是否都为false，还有对比两者每个下标的数据是否相等。以测试 set 和 check 方法是否正确。同时因为这些下标有些是超出范围之外的，也能测试 TwoDimensionalMark 对超出范围的操作是否正确\n\n代码如下：\n\n```cpp\n    TEST_P(TestWithMarkSize,testWithTrueClean){\n        MarkSize size = GetParam();\n\n        //初始化TwoDimensionalMark和用来做对比的contrast,将他们全部用true填充\n        TwoDimensionalMark mark(size.row, size.col);\n        mark.clean(true);\n        vector<vector<bool> > contrast = CreateContrast(size.row, size.col, true);\n\n        //验证mark和contrast里面都是true\n        for (int i = 0; i < size.row; i++){\n            for (int j = 0; j < size.col; j++){\n                ASSERT_TRUE(mark.check(j, i));\n                ASSERT_TRUE(contrast[i][j]);\n            }\n        }\n\n        //随机将一些坐标位置,这个函数生成的随机位置有可能在row，col之外\n        vector<Coord> coords = CreateRandCoords(size.row, size.col);\n\n        //将mark和contrast的之前随机生成的位置设为false\n        SetFlag(&mark, &contrast, size, coords, false);\n\n        //检测随机生成的位置上的值有没有设置正确\n        //mark若位置超出范围则返回false,而contrast则需要防止溢出\n        for (auto c : coords){\n            ASSERT_FALSE(mark.check(c.x,c.y));\n            if (c.x >= 0 && c.x < size.col && c.y >= 0 && c.y < size.row){\n                ASSERT_FALSE(contrast[c.y][c.x]);\n            }\n        }\n\n        //对比contrast和mark，两者应该相等\n        for (int y = 0; y < size.row; y++)\n            for (int x = 0; x < size.col; x++){\n                ASSERT_EQ(contrast[y][x], mark.check(x, y));\n            }\n    }\n```\n\nTEST_P(TestWithMarkSize, testWithFalseClean) 和上面的差不多，只不过换成一开始用 false 填充，之后设置随机下标的数据为 true，读者可以自己查看代码，这里就不详细分析了。\n\n## __测试结果__\n\n运行测试代码得到下面的结果：\n{% img /GTest实例解析/1.jpg %}\n\n全部测试均通过！\n\n完整代码:[https://github.com/bluesky466/GTestDemo](https://github.com/bluesky466/GTestDemo)\n（为了方便，我直接将实现写在了头文件里，好孩子不要学~）\n","tags":["技术相关","单元测试"]},{"title":"读书笔记 -《代码整洁之道》","url":"/2016/01/30/读书笔记-《代码整洁之道》/","content":"\n长呼一口气，终于看完了。明明就只有300多页，但这本《代码整洁之道》还真是难啃啊。\n\n书是好书，讲的也十分细致。就连命名、方法定义的顺序、注释这些小细节都用了不少的文字去强调。虽然有些观点我不太认同（比如我觉得类成员变量就应该多一个字符m或者下划线去和临时变量做区别）但绝大部分的建议和条款我觉得都讲的十分有道理。总结了几个自认为最重要的点：\n\n1. 不管是变量还是函数，命名都应该有意义且名副其实\n1. 应该按照垂直格式摆放函数定义\n1. 注释应该正确且有用\n1. 函数应该只做一件事，且应该尽量短小\n1. 模块不应该了解它所操作的对象的内部情形\n\n\n作者对于代码的要求堪称苛刻，看他写代码的过程真的可以算是精雕细琢，最终呈现的代码可谓优雅。虽然我也不能指望自己通过读完一本书，写代码的能力就有质的飞跃。但这本书起码提醒了我一些以前没有注意到的地方，以后写代码的时候试试提醒自己，能有所提高也就不负我这几天的努力了。\n\n要说这本书难啃也是真的。中间有大量的代码实例，而且很多都是著名的开源框架的源码（如Tomcat、Spring和JUnit），在阅读这本书的过程中大部分时间我是花在理解这些代码上的。因为对java不太熟悉，这些框架更是一个都没有用过，所以读起来十分的痛苦，中间好几次都想放弃了。\n\n多亏最终坚持了下来，我还得到了一些以后的学习道路的启示：\n\n一是java还需要重新好好学一遍。毕竟现在正在学安卓，我的java基础实在弱的可以，尤其是并发编程相关的知识可以说就是一张白纸。\n\n二是需要学习一下测试驱动开发（TDD）相关的知识。我发现最近看的书，都把测试放在了很重要的位置上。以前写代码就没有做过单元测试，所以拿到测试部门的时候总会出现这样那样不应该出现的问题。java方面jUnit是一定要去学习的，而c\\+\\+其实也有类似googletest这样的测试框架。为了写出高质量的代码，这部分的知识也应该去好好补一补了。\n\n所以我下一步打算找找java还有测试相关的书籍来看看。\n","tags":["读书笔记"]},{"title":"DrawerLayout 学习笔记","url":"/2016/01/27/DrawerLayout-学习笔记/","content":"\nDrawerLayout的使用十分简单，使用android.support.v4.widget.DrawerLayout标签即可，DrawerLayout的第一个子标签就是正文，其他布局都是抽屉布局（默认隐藏在屏幕外）。可以使用android:layout_gravity属性指定是隐藏在屏幕的左边或者右边。\n\n## **一、使用DrawerLayout布局**\n\n把activity_main.xml修改成下面的样子，这里声明了一个LinearLayout作为正文布局（DrawerLayout的第一个子标签），和其他两个LinearLayout布局作为抽屉布局（将android:layout_gravity设置为left或者right）：\n\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <android.support.v4.widget.DrawerLayout\n            android:id=\"@+id/drawer_layout\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\">\n\n            <!-- 正文布局 -->\n            <LinearLayout\n                android:id=\"@+id/content\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:gravity=\"center_horizontal\"\n                android:orientation=\"horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"content\" />\n\n            </LinearLayout>\n\n            <!-- 从左边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_left\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"left\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"left\" />\n            </LinearLayout>\n\n            <!-- 从右边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_right\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"right\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"right\" />\n            </LinearLayout>\n        </android.support.v4.widget.DrawerLayout>\n    </LinearLayout>\n```\n\n运行之后就长这个样子，可以用手指从左边或者右边把抽屉布局拖出来：\n{% img /DrawerLayout-学习笔记/1.jpg %}\n\n{% img /DrawerLayout-学习笔记/3.jpg %}\n\n{% img /DrawerLayout-学习笔记/2.jpg %}\n\n当然也能在代码里面调用openDrawer来显示：\n```java \n    //打开左边的抽屉布局\n    drawerLayout.openDrawer(Gravity.LEFT);\n    //打开右边的抽屉布局\n    drawerLayout.openDrawer(Gravity.RIGHT);\n```\n  \n  \n## **二、使用ActionBarDrawerToggle**\nandroid提供了一个ActionBarDrawerToggle来简化DrawerLayout的操作，用法十分简单。\n1.自定义一个ToolBar（可以查看我之前的一篇博文）\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <android.support.v7.widget.Toolbar\n            android:id=\"@+id/toolbar\"\n            android:background=\"#3F51B5\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"?attr/actionBarSize\" />\n\n        <android.support.v4.widget.DrawerLayout\n            android:id=\"@+id/drawer_layout\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\">\n\n            <!-- 正文布局 -->\n            <LinearLayout\n                android:id=\"@+id/content\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:gravity=\"center_horizontal\"\n                android:orientation=\"horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"content\" />\n\n            </LinearLayout>\n\n            <!-- 从左边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_left\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"left\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"left\" />\n            </LinearLayout>\n\n            <!-- 从右边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_right\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"right\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"right\" />\n            </LinearLayout>\n        </android.support.v4.widget.DrawerLayout>\n    </LinearLayout>\n```\n\n2.在acvitity代码中创建ActionBarDrawerToggle并重写下面的方法就可以了\n- 在onPostCreate方法中调用ActionBarDrawerToggle.syncState()，如果不调用该方法，则ActionBarDrawerToggle不会显示 （onPostCreate在Activity完全加载成功之后调用，这个时候所有界面资源都已经创建和初始化完成）\n- 在onOptionsItemSelected方法中调用ActionBarDrawerToggle.onOptionsItemSelected()。（原本我以为这里是用来实现按下按钮打开和关闭抽屉布局的，但经测试，就算不调用也能正常运行。）\n```java\n    public class MainActivity extends AppCompatActivity {\n        ActionBarDrawerToggle mToggle;\n\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n\n            setContentView(R.layout.activity_main);\n\n            Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n            setSupportActionBar(toolbar);\n\n            DrawerLayout drawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);\n            mToggle = new ActionBarDrawerToggle(this, drawerLayout,toolbar,R.string.drawer_open, R.string.drawer_close);\n\n            drawerLayout.setDrawerListener(mToggle);\n        }\n\n        @Override\n        protected void onPostCreate(Bundle savedInstanceState) {\n        \t//onPostCreate在Activity完全加载成功之后调用\n            //这个时候所有界面资源都已经创建和初始化完成\n            super.onPostCreate(savedInstanceState);\n\n            //如果不调用该方法，则ActionBarDrawerToggle不会显示\n            mToggle.syncState();\n        }\n\n        @Override\n        public boolean onOptionsItemSelected(MenuItem item) {\n        \t//原本我以为这里是用来实现按下按钮打开和关闭抽屉布局的\n            //但经测试，就算不调用也能正常运行。\n            return mToggle.onOptionsItemSelected(item) || super.onOptionsItemSelected(item);\n        }\n    }\n```\n\n运行可以得到下面这效果，可以使用控制按钮来打开和关闭左边的抽屉布局，那个控制按钮还实现了一种特别酷炫的动画：\n{% img /DrawerLayout-学习笔记/4.jpg %}\n\n{% img /DrawerLayout-学习笔记/5.jpg %}\n\n{% img /DrawerLayout-学习笔记/6.jpg %}\n  \n  \n## **三、将抽屉布局的层级填到toolbar之上**\n知乎的安卓app也使用了DrawerLayout，但它的抽屉布局显示的时候是位于toolbar之上的。我们只要把toolbar标签放到内容布局（DrawerLayout的第一个子标签）里面就能实现这样的效果了。\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <android.support.v4.widget.DrawerLayout\n            android:id=\"@+id/drawer_layout\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\">\n\n            <!-- 正文布局 -->\n            <LinearLayout\n                android:id=\"@+id/content\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:gravity=\"center_horizontal\"\n                android:orientation=\"horizontal\">\n\n                <!-- 把toolbar放到这里，使抽屉布局层级比toolbar高 -->\n                <android.support.v7.widget.Toolbar\n                    android:id=\"@+id/toolbar\"\n                    android:background=\"#3F51B5\"\n                    android:layout_width=\"match_parent\"\n                    android:layout_height=\"?attr/actionBarSize\" />\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"content\" />\n\n            </LinearLayout>\n\n            <!-- 从左边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_left\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"left\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"left\" />\n            </LinearLayout>\n\n            <!-- 从右边抽出来的布局 -->\n            <LinearLayout\n                android:id=\"@+id/drawer_right\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"right\"\n                android:background=\"#FFFFFF\"\n                android:gravity=\"center_horizontal\">\n\n                <TextView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:text=\"right\" />\n            </LinearLayout>\n        </android.support.v4.widget.DrawerLayout>\n    </LinearLayout>\n```\n\n运行效果如下：\n\n{% img /DrawerLayout-学习笔记/7.jpg %}\n","tags":["技术相关","Android"]},{"title":"ToolBar 学习笔记","url":"/2016/01/25/ToolBar-学习笔记/","content":"\n虽然android studio在新建项目的时候就可以创建一个默认带有ToolBar的MainActivity，但是抱着学习学全套的精神，我们就从一个没有Activity的空项目入手，一步一步把ToolBar学透。\n\n## **一、创建基础ToolBar**\n\n创建完一个不带Activity的空项目之后的第一步就是创建自己的Activity了，注意这个Activity必须继承AppCompatActivity（ActionBarActivity已经被废弃了）。\n\n```java\n    public class MainActivity extends AppCompatActivity{\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.main_activity);\n        }\n    }\n```\n\n如果不能import android.support.v7.app.AppCompatActivity;的话就在build.gradle（Module：App）的dependencies里面添加\n\n    compile 'com.android.support:appcompat-v7:23.1.1'\n\n这个R.layout.main_activity也是要自己创建的，我这里创建了一个只有一个TextView的LinearLayout\n\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Hello World\"/>\n    </LinearLayout>\n```\n\n当然，不要忘了在manifests里面注册MainActivity\n```xml\n\t<activity android:name=\".MainActivity\"\n            android:label=\"@string/app_name\"\n            android:theme=\"@style/AppTheme\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\"/>\n                <category android:name=\"android.intent.category.LAUNCHER\"/>\n            </intent-filter>\n\t</activity>\n```\n然后运行程序就能就是下面这个样子：\n{% img /ToolBar-学习笔记/1.jpg %}\n\n## **二、自定义ToolBar样式**\n\n因为用上面的方法创建的ToolBar是Activity自带的，在需要自定义样式的时候不够灵活，所以我们把它去掉，换成我们自己创建的ToolBar。\n\n可以在@style/AppTheme添加如下item：\n\n```xml\n\t<!-- 去掉Activity自带的ToolBar -->\n\t<item name=\"windowNoTitle\">true</item>\n```\n\n这个时候再运行项目，就会发现ToolBar已经不见了。然后我们自己在R.layout.main_activity里面自己声明一个ToolBar:\n\n```xml\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <android.support.v7.widget.Toolbar\n            android:id=\"@+id/toolbar\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"?attr/actionBarSize\"\n            android:theme=\"@style/ToolBarTheme\"/>\n\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Hello World\"/>\n\n    </LinearLayout>\n```\n\nToolBar的Theme分离出来放在@style/Theme,可以在这里自定义ToolBar的样式:\n```xml\n \t<style name=\"ToolBarTheme\" parent=\"Theme.AppCompat\">\n        <!-- 设置ToolBar底色 -->\n        <item name=\"android:background\">#3F51B5</item>\n        <!-- 设置字体颜色 -->\n        <item name=\"android:textColorPrimary\">#FFFFFF</item>\n    </style>\n```\n\n最后在MainActivity里调用setSupportActionBar，顺便设置调用ToolBar的方法设置一些属性。注意这里的ToolBar是导的android.support.v7.widget.Toolbar的包：\n\n```java\n    public class MainActivity extends AppCompatActivity{\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.main_activity);\n\n            Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n\n            toolbar.setTitle(\"title\"); //setTile方法必须在setSupportActionBar之前调用\n            toolbar.setSubtitle(\"subtitle\");\n            toolbar.setLogo(R.mipmap.ic_launcher);\n\n            setSupportActionBar(toolbar);\n\n            //给Navigate按钮加一个默认的返回箭头\n            //也可以用toolbar.setNavigationIcon()直接给Navigate设置icon\n        \tgetSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        }\n    }\n```\n\n运行起来之后长这个样子:\n{% img /ToolBar-学习笔记/2.jpg %}\n\n## **三、添加菜单按钮**\n\n首先创建一个menu/main.xml:\n\n```xml\n    <menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n        <item\n            android:id=\"@+id/btn_ico\"\n            android:title=\"btn_ico\"\n            android:icon=\"@mipmap/ic_launcher\"\n            app:showAsAction=\"ifRoom\" />\n        <item\n            android:id=\"@+id/btn_search\"\n            android:title=\"btn_search\"\n            app:actionViewClass=\"android.support.v7.widget.SearchView\"\n            app:showAsAction=\"ifRoom\" />\n        <item\n            android:id=\"@+id/btn_1\"\n            android:title=\"btn_1\"\n            app:showAsAction=\"never\" />\n        <item\n            android:id=\"@+id/btn_2\"\n            android:title=\"btn_2\"\n            app:showAsAction=\"never\"/>\n    </menu>\n```\n\n这里的app:showAsAction就是按钮出现的位置，它可以填入以下的值:\n1. always：这个值会使菜单项一直显示在ToolBar上。\n2. ifRoom：如果有足够的空间，这个值会使菜单项显示在ToolBar上。\n3. never：这个值使菜单项永远都不出现在ToolBar上。\n4. withText：这个值使菜单项和它的图标，菜单文本一起显示。 \n\n\n然后在MainActivity覆盖onCreateOptionsMenu方法：\n```java\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.main, menu);\n        return true;\n    }\n```\n\n运行程序之后长这个样子：\n{% img /ToolBar-学习笔记/3.jpg %}\n\n## **四、监听菜单按钮消息**\n\n监听这些菜单按钮的消息有两种方法\n1.覆盖Activity的onOptionsItemSelected方法\n\n```java\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Toast.makeText(this, item.getTitle(), Toast.LENGTH_SHORT).show();\n        return true;\n    }\n```\n\n2.调用ToolBar的setOnMenuItemClickListener方法\n\n```java\n    //setOnMenuItemClickListener方法必须在setSupportActionBar之后调用才有效\n    toolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() {\n        @Override\n        public boolean onMenuItemClick(MenuItem item) {\n            Toast.makeText(MainActivity.this, item.getTitle(), Toast.LENGTH_SHORT).show();\n            return false;\n        }\n    });\n```\n\n这个时候Navigation按钮的消息也是在上面两个回调方法中处理的，当然也能直接调用ToolBar的setNavigationOnClickListener方法设置，这样只有在该listener方法里面才会收到Navigation按钮的消息：\n```java\n    //setNavigationOnClickListener方法必须在setSupportActionBar之后调用才有效\n    toolbar.setNavigationOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            finish();\n        }\n    });\n```\n\n而ToolBar上的搜索按钮可以这样设置它的回调:\n```java\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.main, menu);\n        MenuItem item = menu.findItem(R.id.btn_search);\n        SearchView searcher = (SearchView) item.getActionView();\n        searcher.setOnQueryTextListener(new SearchView.OnQueryTextListener() {\n            @Override\n            public boolean onQueryTextSubmit(String query) {\n                Toast.makeText(MainActivity.this, query, Toast.LENGTH_SHORT).show();\n                return false;\n            }\n\n            @Override\n            public boolean onQueryTextChange(String newText) {\n                return false;\n            }\n        });\n        return true;\n    }\n```\n\n## **五、设置弹出菜单的样式**\n\n弹出菜单的样式默认是和ToolBar的样式一样的:\n{% img /ToolBar-学习笔记/4.jpg %}\n\n但也可以通过下面的方法自定义\n\n1.新建样式PopupTheme\n\n```xml\n\t<style name=\"PopupTheme\" parent=\"Theme.AppCompat\">\n        <item name=\"android:background\">#FFFFFF</item>\n        <item name=\"android:textColorPrimary\">#000000</item>\n    </style>\n```\n\n2.设置ToolBar的PopupTheme,注意这里的前缀是app:\n```xml\n\t<android.support.v7.widget.Toolbar\n        android:id=\"@+id/toolbar\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"?attr/actionBarSize\"\n        android:theme=\"@style/ToolBarTheme\"\n        app:popupTheme=\"@style/PopupTheme\"/>\n```\n\n效果如下：\n{% img /ToolBar-学习笔记/5.jpg %}\n","tags":["技术相关","Android"]},{"title":"读书笔记 -《道法自然—面向对象实践指南》","url":"/2016/01/21/读书笔记-《道法自然—面向对象实践指南》/","content":"\n不可否认，我一开始是被这本书的名字吸引才去读的。《道法自然》，这名字逼格真心不要太高。但真的开始阅读，你就会发现它绝对不是标题党。依稀记得那天凌晨4点多睡不着，刷知乎看到有人推荐这本书，于是冲着标题去下载来看。结果一发不可收拾，那一天我就没干别的事，都被它吸引住了。\n\n之前也看过不少讲设计模式的书，像什么《大话设计模式》、《head first设计模式》、《设计模式之禅》等等。当然它们也是好书。尤其是《设计模式之禅》，在读《道法自然》之前我最推崇的讲设计模式的书就是它了。但相比起来，我还是觉得《道法自然》讲的更加的透彻和易于理解。\n\n《道法自然—面向对象实践指南》这本书真要算起来其实并不是严格意义上的讲设计模式的书籍。它以实际的开发案例--FishGUI项目为主线，从立项到需求分析，再到架构设计，最后到编码和优化。通过文字，将整个项目的流程一点不漏的展现在读者面前。在实际编码那几章，通过分析项目的需求，确定使用的设计模式，分析为什么要使用这种模式，有什么优缺点，又谈到怎么去应用到FishGUI这个框架中。有时候甚至会对比其他的框架的源代码讲到多种设计之间的差异和优缺点，例如书中在消息机制那里就分析了MFC、.net和java AWT的设计。相比起其他讲设计模式的书，它更加贴合实际开发，也讲到更加的透彻。毕竟是通过一个实际的项目去讲，能让人更透彻的取理解所讲到的模式。\n\n这本书还有一个吸引我的地方，之前读到的关于设计模式的书籍，要不是用的c#要不用的是java，但这本书使用的编程语言是c\\+\\+，也不是说其他语言不好，但作为一个大部分时间都在学习c\\+\\+的人来说，看c\\+\\+语言更有一种亲切感。同时这本书在最后的一章里面还讲到了在FishGUI这个项目中使用c\\+\\+时遇到的坑。对于c\\+\\+程序员来说，这本书真心不能错过。\n\n读完这本书，除了对于一些设计模式理解的更为透彻之外，我认为更重要的收获是对编程思想或者编程习惯的培养：\n\n1. 实际编码之前一定要有分析和设计的阶段\n2. 只实现你真正需要的东西 \n2. 面向接口编程而不是面向实现编程\n3. 边编码边做一些优化性的重构\n\n我想这本书我以后肯定会再读的，因为现在的项目经验还不足，相信做多几个实际的项目之后再看一遍，肯定会有不一样的见解和更多的收获。\n\n看这本书总共花了10天左右的时间吧，其实这个过程中也发现了自己在读书方面的缺点。就是后劲不足，在刚刚开始的时候每天都很有热情的去阅读，速度很快，看到也很仔细，但读了一半热情下来之后就没有之前那么入神了。这也是我接下来必须改进的地方，以前读的书太少，2016年有太多的书想要读。这是今年读完的第一本书，希望有始有终，之后的日子可以培养起看书的好习惯。  \n\n","tags":["读书笔记"]},{"title":"使用hexo搭建个人博客","url":"/2016/01/19/使用hexo搭建个人博客/","content":"\n## 一、安装hexo\n\n**1.安装Node.js**\nhexo是一款基于Node.js的静态博客框架，所以要使用它必须先安装Node.js。网上很多教程讲的都是如何编译源码安装Node.js。但我认为应该用最简单的方式取获取和使用软件或者框架，不是每个初学者都需要从一个软件的源代码编译开始学习。当然，在日后想要更深入理解它的时候，挖出它的源代码进行分析也是一种十分有效的途径。\n下面是ubuntu下使用apt-get安装Node.js的方法（源自博客[如何在Ubuntu上安装最新版本的Node.js ](http://blog.csdn.net/chszs/article/details/37521463)）\n1. apt-get update\n2. apt-get install -y python-software-properties software-properties-common\n3. add-apt-repository ppa:chris-lea/node.js\n4. apt-get update\n5. apt-get install nodejs\n\n**2.安装hexo**\n之后安装hexo就更简单了，只需要这一行代码\n\n    npm install hexo -g\n\n**3.更新hexo**\n\n    npm update hexo -g \n    \n<br>\n\n## 二、创建和配置hexo项目\n\n**1.初始化hexo项目**\n\n    hexo init [folder]\n\n如果指定 _folder_，便会在目前的资料夹建立一个名为 _folder_ 的新资料夹，否则会在当前文件夹初始化。\n执行完这条命令，会出现如下提示:\n\n> INFO  You are almost done! Don't forget to run 'npm install' before you start blogging with Hexo!\n\n所以记得执行npm install\n\n\n**2.创建新的文章**\n\n    hexo new \"文章标题\"\n\n执行完创建命令后会生成以下文件:\n\n> source/_posts/文章标题.md\n\n之后只需要在这个markdown文件里面编写自己的博客文章就可以了\n\n**3.添加主题**\n\n有很多人为hexo编写了很多漂亮的主题，可以自己去[主题列表](https://github.com/hexojs/hexo/wiki/Themes)选择\n安装的方法也很简单，这些主题都是托管在github上的，只要把它们克隆到项目文件夹的themes目录下面就可以了。当然还需要去__config.yml修改配置，选择使用哪个主题：\n\n    theme: 主题名\n\n**4.启动服务器**\n\n编写完文章之后只需要运行下面命令就可以在浏览器地址栏输入 http://0.0.0.0:4000 查看自己的博客了\n\n    hexo server\n\n<br>\n\n## 三、配置博客信息\n\n可以在项目根目录下的_config.yml文件配置博客的标题，作者，语言等相关信息\n\n<br>\n\n## 四、部署到Github\n\ngithub提供了一个名叫Github Pages的服务，我们可以免费的用它来搭建自己的博客。\n做法很简单，首先在github建立与你用户名对应的仓库，仓库名必须为 “你的github用户名.github.io” \n\n接着执行以下命令在本机安装hexo-deployer-git\n\n    npm install hexo-deployer-git --save\n\n然后在_config.yml文件，找到下面的内容\n\n    # Deployment\n    ## Docs: http://hexo.io/docs/deployment.html\n    deploy:\n      type:\n\n将它们修改为\n\n    # Deployment\n    ## Docs: http://hexo.io/docs/deployment.html\n    deploy:\n      type: git\n      repository: git@github.com:你的github用户名/你的github用户名.github.io\n      branch: master\n\n最后执行以下三条命令即可：\n\n    hexo clean\n    hexo generate\n    hexo deploy\n\n（当然你必须为你的电脑添加github ssh key才能正常执行hexo deploy命令上传代码）\n\n<br>\n\n## 五、绑定域名\n\n按照github pages的文档，是在github项目根目录下创建CNAME文件。但因为每次使用hexo更新博客再次上传，都会清除掉之前创建的CNAME文件。所以我们把CNAME放在source目录下（想上传的文件都放在该目录下）\n\n完整步骤如下:\n\n1. 在source目录下添加一个CNAM文件，没有后缀名，里面内容为你的域名(如我的是:blog.islinjw.cn)。\n\n2. ping username.github.io记录下IP地址\n\n3. 购买域名，配置域名解析username.github.io的ip地址\n","tags":["技术相关","hexo"]}]