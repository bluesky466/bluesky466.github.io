<!DOCTYPE html>


  <html class="light page-home">


<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>OpenSL ES 学习笔记 | 编程代码笔记</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="技术相关,Android,音视频,">
  

  <meta name="description" content="一般来讲在安卓中常使用AudioRecord、MediaRecorder对音频进行采集,使用SoundPool、MediaPlayer、AudioTrack进行音频播放。 但是这些接口都是java层的,而NDK其实也提供了一个叫做OpenSL的C语言引擎用于声音的处理。 OpenSL入门难度比较大,而且网上也没有什么特别好的教程,我这里把自己了解到的一些知识记录下来,希望以后忘记的时候可以快速回忆">
<meta name="keywords" content="技术相关,Android,音视频">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenSL ES 学习笔记">
<meta property="og:url" content="https://blog.islinjw.cn/2018/09/01/OpenSLES学习笔记/index.html">
<meta property="og:site_name" content="编程代码笔记">
<meta property="og:description" content="一般来讲在安卓中常使用AudioRecord、MediaRecorder对音频进行采集,使用SoundPool、MediaPlayer、AudioTrack进行音频播放。 但是这些接口都是java层的,而NDK其实也提供了一个叫做OpenSL的C语言引擎用于声音的处理。 OpenSL入门难度比较大,而且网上也没有什么特别好的教程,我这里把自己了解到的一些知识记录下来,希望以后忘记的时候可以快速回忆">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://blog.islinjw.cn/OpenSLES学习笔记/1.png">
<meta property="og:image" content="https://blog.islinjw.cn/OpenSLES学习笔记/2.png">
<meta property="og:image" content="https://blog.islinjw.cn/OpenSLES学习笔记/3.png">
<meta property="og:updated_time" content="2022-05-30T12:48:26.264Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OpenSL ES 学习笔记">
<meta name="twitter:description" content="一般来讲在安卓中常使用AudioRecord、MediaRecorder对音频进行采集,使用SoundPool、MediaPlayer、AudioTrack进行音频播放。 但是这些接口都是java层的,而NDK其实也提供了一个叫做OpenSL的C语言引擎用于声音的处理。 OpenSL入门难度比较大,而且网上也没有什么特别好的教程,我这里把自己了解到的一些知识记录下来,希望以后忘记的时候可以快速回忆">
<meta name="twitter:image" content="https://blog.islinjw.cn/OpenSLES学习笔记/1.png">

  
    <link rel="alternate" href="/atom.xml" title="编程代码笔记" type="application/atom+xml">
  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=32204ee7" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>
</html>
<body>

  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            target="_self"
            >
            搜索
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            target="_self"
            >
            RSS
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基本概念"><span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Object和Interface"><span class="toc-text">Object和Interface</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object"><span class="toc-text">Object</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GetInterface"><span class="toc-text">GetInterface</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Interface"><span class="toc-text">Interface</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SLEngineItf"><span class="toc-text">SLEngineItf</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#录音"><span class="toc-text">录音</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#播放"><span class="toc-text">播放</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Demo"><span class="toc-text">Demo</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-OpenSLES学习笔记" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">OpenSL ES 学习笔记</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2018.09.01</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>林嘉伟</span>
        </span>
      

      


      

    </div>
  </header>

  <div class="article-content">
    
      <p>一般来讲在安卓中常使用AudioRecord、MediaRecorder对音频进行采集,使用SoundPool、MediaPlayer、AudioTrack进行音频播放。</p>
<p>但是这些接口都是java层的,而NDK其实也提供了一个叫做OpenSL的C语言引擎用于声音的处理。</p>
<p>OpenSL入门难度比较大,而且网上也没有什么特别好的教程,我这里把自己了解到的一些知识记录下来,希望以后忘记的时候可以快速回忆起来,也希望对大家有用。</p>
<p>这篇笔记的很多内容都参考了OpenSL的官方文档OpenSL_ES_Specification_1.0.1.pdf,它是全英文的,可以在NDK的安装目录下找到,大家可以大概浏览一下,具体路径为:</p>
<blockquote>
<p>$NDK_ROOT/docs/Additional_library_docs/opensles</p>
</blockquote>
<p>为什么要学OpenSL呢?除了C/C++的性能优势(不过其实java的效率也不低)之外,最主要是因为最近入坑FFmpeg,如果使用java层的接口,还需要通过一层JNI,比较复杂,性能消耗也大。如果用OpenSL的话就能直接在C/C++里面把事情都处理了。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="Object和Interface"><a href="#Object和Interface" class="headerlink" title="Object和Interface"></a>Object和Interface</h2><p>在OpenSL里面,Object和Interface是两个很重要的概念,基本上所有的操作都是通过它们两个去执行的。</p>
<p>Object和Interface是包含关系,一个Object里面包含了多个Interface:</p>
<img src="/OpenSLES学习笔记/1.png">

<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>Object是一个资源的抽象集合,可以通过它获取各种资源。</p>
<p>例如我们可以通过Object的GetInterface方法获取Interface。</p>
<p>所有的Object在OpenSL里面我们拿到的都是一个SLObjectItf:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct SLObjectItf_ &#123;</span><br><span class="line">	SLresult (*Realize) (SLObjectItf self,SLboolean async);</span><br><span class="line"></span><br><span class="line">	SLresult (*Resume) (SLObjectItf self,SLboolean async);</span><br><span class="line"></span><br><span class="line">	SLresult (*GetState) (SLObjectItf self,SLuint32 * pState);</span><br><span class="line"></span><br><span class="line">	SLresult (*GetInterface) (SLObjectItf self, const SLInterfaceID iid, void * pInterface);</span><br><span class="line"></span><br><span class="line">	SLresult (*RegisterCallback) (SLObjectItf self, slObjectCallback callback, void * pContext);</span><br><span class="line"></span><br><span class="line">	void (*AbortAsyncOperation) (SLObjectItf self);</span><br><span class="line"></span><br><span class="line">	void (*Destroy) (SLObjectItf self);</span><br><span class="line"></span><br><span class="line">	SLresult (*SetPriority) (SLObjectItf self, SLint32 priority, SLboolean preemptable);</span><br><span class="line"></span><br><span class="line">	SLresult (*GetPriority) (SLObjectItf self, SLint32 *pPriority, SLboolean *pPreemptable);</span><br><span class="line"></span><br><span class="line">	SLresult (*SetLossOfControlInterfaces) (SLObjectItf self, SLint16 numInterfaces, SLInterfaceID * pInterfaceIDs, SLboolean enabled);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef const struct SLObjectItf_ * const * SLObjectItf;</span><br></pre></td></tr></table></figure>

<p>在创建出来之后必须先调用Realize方法做初始化。在不需要使用的时候调用Destroy方法释放资源。</p>
<h4 id="GetInterface"><a href="#GetInterface" class="headerlink" title="GetInterface"></a>GetInterface</h4><p>GetInterface可以说是OpenSL里使用频率最高的方法,通过它我们可以获取Object里面的Interface。</p>
<p>由于一个Object里面可能包含了多个Interface,所以GetInterface方法有个SLInterfaceID参数来指定到的需要获取Object里面的那个Interface。</p>
<p>例如下面代码我们通过EngineObject去获取SL_IID_ENGINE这个id的Interface,而这个id对应的Interface就是SLEngineItf:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//create EngineObject</span><br><span class="line">SLObjectItf engineObject;</span><br><span class="line">slCreateEngine(&amp;engineObject, 0, NULL, 0, NULL, NULL);</span><br><span class="line">(*engineObject)-&gt;Realize(engineObject, SL_BOOLEAN_FALSE);</span><br><span class="line"></span><br><span class="line">//get SLEngineItf</span><br><span class="line">SLEngineItf engineInterface;</span><br><span class="line">(*engineObject)-&gt;GetInterface(engineObject, SL_IID_ENGINE, &amp;engineInterface);</span><br></pre></td></tr></table></figure>

<h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><p>Interface则是方法的集合,例如SLRecordItf里面包含了和录音相关的方法,SLPlayItf包含了和播放相关的方法。我们功能都是通过调用Interfaces的方法去实现的。</p>
<h4 id="SLEngineItf"><a href="#SLEngineItf" class="headerlink" title="SLEngineItf"></a>SLEngineItf</h4><p>SLEngineItf是OpenSL里面最重要的一个Interface,我们可以通过它去创建各种Object,例如播放器、录音器、混音器的Object,然后在用这些Object去获取各种Interface去实现各种功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct SLEngineItf_ &#123;</span><br><span class="line">	SLresult (*CreateAudioPlayer) (SLEngineItf self, SLObjectItf * pPlayer, SLDataSource *pAudioSrc, SLDataSink *pAudioSnk, SLuint32 numInterfaces, const SLInterfaceID * pInterfaceIds, const SLboolean * pInterfaceRequired);</span><br><span class="line"></span><br><span class="line">	SLresult (*CreateAudioRecorder) (SLEngineItf self, SLObjectItf * pRecorder, SLDataSource *pAudioSrc, SLDataSink *pAudioSnk, SLuint32 numInterfaces, const SLInterfaceID * pInterfaceIds, const SLboolean * pInterfaceRequired);</span><br><span class="line"></span><br><span class="line">	SLresult (*CreateOutputMix) (SLEngineItf self, SLObjectItf * pMix, SLuint32 numInterfaces, const SLInterfaceID * pInterfaceIds, const SLboolean * pInterfaceRequired);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="录音"><a href="#录音" class="headerlink" title="录音"></a>录音</h1><p>OpenSL的录音功能是通过AudioRecorder来实现的,而AudioRecorder是通过SLEngineItf.CreateAudioRecorder方法创建的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SLresult (*CreateAudioRecorder) (</span><br><span class="line">        SLEngineItf self,</span><br><span class="line">        SLObjectItf * pRecorder,</span><br><span class="line">        SLDataSource * pAudioSrc,</span><br><span class="line">        SLDataSink * pAudioSnk,</span><br><span class="line">        SLuint32 numInterfaces,</span><br><span class="line">        const SLInterfaceID * pInterfaceIds,</span><br><span class="line">        const SLboolean * pInterfaceRequired</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>各个参数的意义如下:</p>
<ul>
<li>SLEngineItf C语言不像c++,没有this指针,只能每次调用SLEngineItf的方法的时候手动传入</li>
<li>SLObjectItf 用于保存创建出来的AudioRecorderObject</li>
<li>SLDataSource 数据的来源</li>
<li>SLDataSink 数据的去处</li>
<li>numInterfaces 与下面的SLInterfaceID和SLboolean配合使用,用于标记SLInterfaceID数组和SLboolean的大小</li>
<li>SLInterfaceID 这里需要传入一个数组,指定创建的AudioRecorderObject会包含哪些Interface</li>
<li>SLboolean 这里也是一个数组,用来标记每个需要包含的Interface,如果AudioRecorderObject不支持,是不是需要直接创建AudioRecorderObject失败。</li>
</ul>
<p>最后的三个参数用于指定AudioRecorderObject需要包含哪些Interface,如果不包含,是不是要直接创建失败。如果成功的话我们就能使用AudioRecorderObject的GetInterface方法获取到这些Interface了。</p>
<p>SLDataSource和SLDataSink可能比较难理解。我们可以看下OpenSL录音的原理:</p>
<img src="/OpenSLES学习笔记/2.png">

<p>简而言之, AudioRecorder会从SLDataSource指定的数据源获取数据,然后将数据保存到SLDataSink指定的接收器。</p>
<p>SLDataSource很明显就是录音设备(SL_IODEVICE_AUDIOINPUT):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SLDataLocator_IODevice device;</span><br><span class="line">device.locatorType = SL_DATALOCATOR_IODEVICE;</span><br><span class="line">device.deviceType = SL_IODEVICE_AUDIOINPUT;</span><br><span class="line">device.deviceID = SL_DEFAULTDEVICEID_AUDIOINPUT;</span><br><span class="line">device.device = NULL; //Must be NULL if deviceID parameter is to be used.</span><br><span class="line"></span><br><span class="line">SLDataSource source;</span><br><span class="line">source.pLocator = &amp;device;</span><br><span class="line">source.pFormat = NULL; //This parameter is ignored if pLocator is SLDataLocator_IODevice.</span><br></pre></td></tr></table></figure>

<p>而SLDataSink就可以任由我们指定了,它官方支持下面的类型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SLDataLocator_Address</span><br><span class="line">SLDataLocator_IODevice</span><br><span class="line">SLDataLocator_OutputMix</span><br><span class="line">SLDataLocator_URI</span><br><span class="line">SLDataLocator_BufferQueue</span><br><span class="line">SLDataLocator_MIDIBufferQueue</span><br></pre></td></tr></table></figure>

<p>Android又拓展了下面几种类型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SLDataLocator_AndroidFD</span><br><span class="line">SLDataLocator_AndroidBufferQueue</span><br><span class="line">SLDataLocator_AndroidSimpleBufferQueue</span><br></pre></td></tr></table></figure>

<p>我这边把它设置成SLDataLocator_AndroidSimpleBufferQueue,它比较通用, AudioRecorder把数据放到这个队列中,我们再可以从这个队列中拿出来使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SLDataLocator_AndroidSimpleBufferQueue queue;</span><br><span class="line">queue.locatorType = SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE;</span><br><span class="line">queue.numBuffers = 2;</span><br><span class="line"></span><br><span class="line">SLDataFormat_PCM format;</span><br><span class="line">format.formatType = SL_DATAFORMAT_PCM;</span><br><span class="line">format.numChannels = numChannels;</span><br><span class="line">format.samplesPerSec = samplingRate;</span><br><span class="line">format.bitsPerSample = SL_PCMSAMPLEFORMAT_FIXED_16;</span><br><span class="line">format.containerSize = SL_PCMSAMPLEFORMAT_FIXED_16;</span><br><span class="line">format.channelMask = getChannelMask(numChannels);</span><br><span class="line">format.endianness = SL_BYTEORDER_LITTLEENDIAN;</span><br><span class="line"></span><br><span class="line">SLDataSink sink;</span><br><span class="line">sink.pLocator = &amp;queue;</span><br><span class="line">sink.pFormat = &amp;format;</span><br></pre></td></tr></table></figure>

<p>同时在创建的时候需要检测下SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE是不是支持:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SLInterfaceID id[] = &#123;SL_IID_ANDROIDSIMPLEBUFFERQUEUE&#125;;</span><br><span class="line">SLboolean required[] = &#123;SL_BOOLEAN_TRUE&#125;;</span><br><span class="line"></span><br><span class="line">SLObjectItf recorderObject;</span><br><span class="line">(engineInterface)-&gt;CreateAudioRecorder(</span><br><span class="line">        engineInterface,</span><br><span class="line">        &amp;(recorderObject),</span><br><span class="line">        &amp;source,</span><br><span class="line">        &amp;sink,</span><br><span class="line">        1,</span><br><span class="line">        id,</span><br><span class="line">        required</span><br><span class="line">);</span><br><span class="line">(*recorderObject)-&gt;Realize(recorderObject, SL_BOOLEAN_FALSE);</span><br></pre></td></tr></table></figure>

<p>所以我们可以通过GetInterface获取SLAndroidSimpleBufferQueueItf,然后注册个队列满的监听回调:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SLAndroidSimpleBufferQueueItf queueInterface;</span><br><span class="line">(*recorderObject)-&gt;GetInterface(</span><br><span class="line">        recorderObject,</span><br><span class="line">        SL_IID_ANDROIDSIMPLEBUFFERQUEUE,</span><br><span class="line">        &amp;(queueInterface)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">(*queueInterface)-&gt;RegisterCallback(</span><br><span class="line">        queueInterface,</span><br><span class="line">        bufferQueueCallback,</span><br><span class="line">        NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>回调函数如下,我们可以在这个时候从队列里面读取下来的音频数据:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void bufferQueueCallback(SLAndroidSimpleBufferQueueItf queue, void *pContext) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后需要打开录音设备开始录音:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SLRecordItf recorderInterface;</span><br><span class="line">(*recorderObject)-&gt;GetInterface(</span><br><span class="line">        recorderObject,</span><br><span class="line">        SL_IID_RECORD,</span><br><span class="line">        &amp;(recorderInterface)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">(*recorderInterface)-&gt;SetRecordState(</span><br><span class="line">        recorderInterface,</span><br><span class="line">        SL_RECORDSTATE_RECORDING</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是我们必须在队列满的时候将数据取出来,如果不取,那队列里面就没有空间可以继续存储音频数据了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*queueInterface)-&gt;Enqueue(queueInterface, buffer, BUFFER_SIZE*sizeof(short));</span><br></pre></td></tr></table></figure>

<h1 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h1><p>播放的代码和录音很类似。我们需要先创建AudioPlayer:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SLresult (*CreateAudioPlayer) (</span><br><span class="line">    SLEngineItf self,</span><br><span class="line">    SLObjectItf * pPlayer,</span><br><span class="line">    SLDataSource *pAudioSrc,</span><br><span class="line">    SLDataSink *pAudioSnk,</span><br><span class="line">    SLuint32 numInterfaces,</span><br><span class="line">    const SLInterfaceID * pInterfaceIds,</span><br><span class="line">    const SLboolean * pInterfaceRequired</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>它的参数和CreateAudioRecorder一样,我就不再一个个去解释了,可以看看播放的过程:</p>
<img src="/OpenSLES学习笔记/3.png">

<p>SLDataSource我也用SLDataLocator_AndroidSimpleBufferQueue,这样我们可以往队列中不断写入音频数据,AudioRecorder会从队列中不断获取数据传递到混音器中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SLDataLocator_AndroidSimpleBufferQueue queue;</span><br><span class="line">queue.locatorType = SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE;</span><br><span class="line">queue.numBuffers = 2;</span><br><span class="line"></span><br><span class="line">SLDataFormat_PCM format;</span><br><span class="line">format.formatType = SL_DATAFORMAT_PCM;</span><br><span class="line">format.numChannels = numChannels;</span><br><span class="line">format.samplesPerSec = samplingRate;</span><br><span class="line">format.bitsPerSample = SL_PCMSAMPLEFORMAT_FIXED_16;</span><br><span class="line">format.containerSize = SL_PCMSAMPLEFORMAT_FIXED_16;</span><br><span class="line">format.channelMask = getChannelMask(numChannels);</span><br><span class="line">format.endianness = SL_BYTEORDER_LITTLEENDIAN;</span><br><span class="line"></span><br><span class="line">SLDataSource source;</span><br><span class="line">source.pLocator = &amp;queue;</span><br><span class="line">source.pFormat = &amp;format;</span><br></pre></td></tr></table></figure>

<p>而SLDataSink需要配置成混音器。混音器用于将多个音频混合并且输出到喇叭:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SLObjectItf outputMixObject;</span><br><span class="line">(*engineInterface)-&gt;CreateOutputMix(</span><br><span class="line">        engineInterface,</span><br><span class="line">        &amp;(outputMixObject),</span><br><span class="line">        0,</span><br><span class="line">        NULL,</span><br><span class="line">        NULL</span><br><span class="line">);</span><br><span class="line">(*outputMixObject)-&gt;Realize(</span><br><span class="line">        outputMixObject,</span><br><span class="line">        SL_BOOLEAN_FALSE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">SLDataLocator_OutputMix outputMix;</span><br><span class="line">outputMix.locatorType = SL_DATALOCATOR_OUTPUTMIX;</span><br><span class="line">outputMix.outputMix = outputMixObject;</span><br><span class="line"></span><br><span class="line">SLDataSink sink;</span><br><span class="line">sink.pLocator = &amp;outputMix;</span><br><span class="line">sink.pFormat = NULL; //This parameter is ignored if pLocator is SLDataLocator_IODevice or SLDataLocator_OutputMix.</span><br></pre></td></tr></table></figure>

<p>同样的我们在创建AudioPlayer的时候会检查是不是支持SL_IID_ANDROIDSIMPLEBUFFERQUEUE:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SLObjectItf playerObject;</span><br><span class="line">SLInterfaceID id[] = &#123;SL_IID_ANDROIDSIMPLEBUFFERQUEUE&#125;;</span><br><span class="line">SLboolean required[] = &#123;SL_BOOLEAN_TRUE&#125;;</span><br><span class="line">(*engineInterface)-&gt;CreateAudioPlayer(</span><br><span class="line">        engineInterface,</span><br><span class="line">        &amp;(playerObject),</span><br><span class="line">        &amp;source,</span><br><span class="line">        &amp;sink,</span><br><span class="line">        1,</span><br><span class="line">        id,</span><br><span class="line">        required</span><br><span class="line">);</span><br><span class="line">(*playerObject)-&gt;Realize(playerObject, SL_BOOLEAN_FALSE);</span><br></pre></td></tr></table></figure>

<p>最后我们需要注册队列空的监听和打开播放器开始播放:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SLAndroidSimpleBufferQueueItf queueInterface;</span><br><span class="line">(*playerObject)-&gt;GetInterface(</span><br><span class="line">        playerObject,</span><br><span class="line">        SL_IID_ANDROIDSIMPLEBUFFERQUEUE,</span><br><span class="line">        &amp;(queueInterface)</span><br><span class="line">);</span><br><span class="line">(*queueInterface)-&gt;RegisterCallback(</span><br><span class="line">        queueInterface,</span><br><span class="line">        bufferQueueCallback,</span><br><span class="line">        NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//////Begin Playing//////</span><br><span class="line">SLPlayItf playInterface;</span><br><span class="line">(*playerObject)-&gt;GetInterface(</span><br><span class="line">        playerObject,</span><br><span class="line">        SL_IID_PLAY,</span><br><span class="line">        &amp;(playInterface)</span><br><span class="line">);</span><br><span class="line">(*playInterface)-&gt;SetPlayState(</span><br><span class="line">        playInterface,</span><br><span class="line">        SL_PLAYSTATE_PLAYING</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>这里有个简单的录音和播放的<a href="https://github.com/bluesky466/OpenSLDemo" target="_blank" rel="noopener">demo</a>,按兴趣的同学可以参考一下。</p>

    
  </div>
</article>

</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              target="_self"
              >
              搜索
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              target="_self"
              >
              RSS
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    




  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235687', function() {
      // load success
    });
  }
</script>

  <footer style="flex: 0 0 auto;text-align: center;">
<a style="font-size:12px; color:#6C6C6C" target="_blank">© 2021  林嘉伟 ❤ <a style="font-size:12px; color:#6C6C6C" target="_blank" href="http://beian.miit.gov.cn/" rel="nofollow">粤ICP备2021021473号</a></footer>
</body>
</html>
