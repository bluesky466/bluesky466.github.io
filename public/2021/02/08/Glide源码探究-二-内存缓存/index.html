<!DOCTYPE html>


  <html class="light page-home">


<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>Glide源码探究(二) - 内存缓存 | LinJW</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="技术相关,Android,">
  

  <meta name="description" content="系列文章:  Glide源码探究(一) - 生命周期绑定与Request创建  Glide源码探究(二) - 内存缓存  Glide源码探究(三) - 网络资源加载  Glide源码探究(四) - Bitmap复用机制   让我们接着上一篇笔记继续讲Engine的load方法，这里面就是Glide的资源加载流程。 1234567891011121314151617public &amp;lt;R&amp;gt;">
<meta name="keywords" content="技术相关,Android">
<meta property="og:type" content="article">
<meta property="og:title" content="Glide源码探究(二) - 内存缓存">
<meta property="og:url" content="http://139.199.4.241/2021/02/08/Glide源码探究-二-内存缓存/index.html">
<meta property="og:site_name" content="LinJW">
<meta property="og:description" content="系列文章:  Glide源码探究(一) - 生命周期绑定与Request创建  Glide源码探究(二) - 内存缓存  Glide源码探究(三) - 网络资源加载  Glide源码探究(四) - Bitmap复用机制   让我们接着上一篇笔记继续讲Engine的load方法，这里面就是Glide的资源加载流程。 1234567891011121314151617public &amp;lt;R&amp;gt;">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://139.199.4.241/Glide源码探究二/1.png">
<meta property="og:image" content="http://139.199.4.241/Glide源码探究二/2.png">
<meta property="og:image" content="http://139.199.4.241/Glide源码探究二/3.png">
<meta property="og:image" content="http://139.199.4.241/Glide源码探究二/4.png">
<meta property="og:updated_time" content="2021-05-18T17:00:43.016Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Glide源码探究(二) - 内存缓存">
<meta name="twitter:description" content="系列文章:  Glide源码探究(一) - 生命周期绑定与Request创建  Glide源码探究(二) - 内存缓存  Glide源码探究(三) - 网络资源加载  Glide源码探究(四) - Bitmap复用机制   让我们接着上一篇笔记继续讲Engine的load方法，这里面就是Glide的资源加载流程。 1234567891011121314151617public &amp;lt;R&amp;gt;">
<meta name="twitter:image" content="http://139.199.4.241/Glide源码探究二/1.png">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=32204ee7" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>
</html>
<body>

  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#内存缓存"><span class="toc-text">内存缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#弱引用缓存的添加"><span class="toc-text">弱引用缓存的添加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#弱引用缓存的删除"><span class="toc-text">弱引用缓存的删除</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LRUCache"><span class="toc-text">LRUCache</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内存缓存整体流程"><span class="toc-text">内存缓存整体流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#补充-内存缓存的查询顺序"><span class="toc-text">补充: 内存缓存的查询顺序</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Glide源码探究-二-内存缓存" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Glide源码探究(二) - 内存缓存</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2021.02.08</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>林嘉伟</span>
        </span>
      

      


      

    </div>
  </header>

  <div class="article-content">
    
      <p>系列文章:</p>
<ul>
<li><p><a href="https://blog.islinjw.cn/2021/02/05/Glide%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6-%E4%B8%80-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%91%E5%AE%9A%E4%B8%8ERequest%E5%88%9B%E5%BB%BA/" target="_blank" rel="noopener">Glide源码探究(一) - 生命周期绑定与Request创建</a></p>
</li>
<li><p><a href="https://blog.islinjw.cn/2021/02/08/Glide%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6-%E4%BA%8C-%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98/" target="_blank" rel="noopener">Glide源码探究(二) - 内存缓存</a></p>
</li>
<li><p><a href="https://blog.islinjw.cn/2021/02/10/Glide%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6-%E4%B8%89-%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/" target="_blank" rel="noopener">Glide源码探究(三) - 网络资源加载</a></p>
</li>
<li><p><a href="https://blog.islinjw.cn/2021/03/27/Glide%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6-%E5%9B%9B-Bitmap%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">Glide源码探究(四) - Bitmap复用机制</a></p>
</li>
</ul>
<p>让我们接着<a href="https://blog.islinjw.cn/2021/02/05/Glide%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6-%E4%B8%80-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%91%E5%AE%9A%E4%B8%8ERequest%E5%88%9B%E5%BB%BA/" target="_blank" rel="noopener">上一篇笔记</a>继续讲Engine的load方法，这里面就是Glide的资源加载流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations, resourceClass, transcodeClass, options);</span><br><span class="line"></span><br><span class="line">    EngineResource&lt;?&gt; memoryResource;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (memoryResource == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> waitForExistingOrStartNewJob(...);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cb.onResourceReady(memoryResource, DataSource.MEMORY_CACHE, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的流程其实也挺清晰的:</p>
<ol>
<li>创建缓存的key，这个key由一系列的参数组成，其中最重要的参数model在我们的例子中就是传进去的url。</li>
<li>使用这个key从内存缓存中查询资源</li>
<li>如果内存缓存中查不到资源就开启线程去加载资源</li>
<li>如果内存缓存中可以查到资源就调用cb.onResourceReady回调</li>
</ol>
<p>流程图如下:</p>
<img src="/Glide源码探究二/1.png">

<h1 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h1><p>内存缓存的流程也比较清晰从代码上看，如果开启了内存缓存的话会先从ActiveResources中查询，查不到的话再从Cache里面查询:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromMemory( EngineKey key, <span class="keyword">boolean</span> isMemoryCacheable, <span class="keyword">long</span> startTime) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isMemoryCacheable) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EngineResource&lt;?&gt; active = loadFromActiveResources(key);</span><br><span class="line">    <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">return</span> active;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EngineResource&lt;?&gt; cached = loadFromCache(key);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">return</span> cached;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个东西同样是内存缓存，那有啥区别呢？我们先看ActiveResources:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Engine</span></span><br><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromActiveResources(Key key) &#123;</span><br><span class="line">    EngineResource&lt;?&gt; active = activeResources.get(key);</span><br><span class="line">    <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">      active.acquire();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> active;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActiveResources</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveResources</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">final</span> Map&lt;Key, ResourceWeakReference&gt; activeEngineResources = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">synchronized</span> EngineResource&lt;?&gt; get(Key key) &#123;</span><br><span class="line">    ResourceWeakReference activeRef = activeEngineResources.get(key);</span><br><span class="line">    <span class="keyword">if</span> (activeRef == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EngineResource&lt;?&gt; active = activeRef.get();</span><br><span class="line">    <span class="keyword">if</span> (active == <span class="keyword">null</span>) &#123;</span><br><span class="line">      cleanupActiveReference(activeRef);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> active;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceWeakReference</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">EngineResource</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loadFromActiveResources实际上是从弱引用缓存里面查询资源。既然是缓存当然就要讲讲它的添加和删除。</p>
<h2 id="弱引用缓存的添加"><a href="#弱引用缓存的添加" class="headerlink" title="弱引用缓存的添加"></a>弱引用缓存的添加</h2><p>首先是添加，弱引用缓存的添加基本有两个时机。</p>
<ol>
<li>从Cache里面查询到的时候如果能查到，会将查到的资源放入弱引用缓存:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key) &#123;</span><br><span class="line">    EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cached.acquire();</span><br><span class="line">      activeResources.activate(key, cached);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cached;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>子线程加载完资源后会将资源放入弱引用缓存:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onEngineJobComplete</span><span class="params">(EngineJob&lt;?&gt; engineJob, Key key, EngineResource&lt;?&gt; resource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; resource.isMemoryCacheable()) &#123;</span><br><span class="line">      activeResources.activate(key, resource);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="弱引用缓存的删除"><a href="#弱引用缓存的删除" class="headerlink" title="弱引用缓存的删除"></a>弱引用缓存的删除</h2><p>细心的同学可能会看到cached.acquire()这个操作，我们来看看它的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ++acquired;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有没有想到些啥?没错，引用计数!</p>
<p>EngineResource是通过引用计数来管理的。有引用计数增加那就有引用计数减少。减少的操作在release方法里面:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> release = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (acquired &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot release a recycled or not yet acquired resource"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (--acquired == <span class="number">0</span>) &#123;</span><br><span class="line">      release = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (release) &#123;</span><br><span class="line">    listener.onResourceReleased(key, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果引用计数降到了0就会调用listener的onResourceReleased回调回去，在onResourceReleased里面Engine会将资源从弱引用缓存删除然后移到cache里:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Engine</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReleased</span><span class="params">(Key cacheKey, EngineResource&lt;?&gt; resource)</span> </span>&#123;</span><br><span class="line">    activeResources.deactivate(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (resource.isMemoryCacheable()) &#123;</span><br><span class="line">      cache.put(cacheKey, resource);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resourceRecycler.recycle(resource, <span class="comment">/*forceNextFrame=*/</span> <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActiveResources</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deactivate</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    ResourceWeakReference removed = activeEngineResources.remove(key);</span><br><span class="line">    <span class="keyword">if</span> (removed != <span class="keyword">null</span>) &#123;</span><br><span class="line">      removed.reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EngineResource.release又是什么时候被调用的呢?其实调用的地方有好几处，但是最重要的两处是</p>
<ol>
<li>我们手动调Glide的clear清理资源的时候:</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动清理资源</span></span><br><span class="line">Glide.with(context)</span><br><span class="line">    .clear(img)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>绑定的生命LifecycleListener.onDestroy的时候:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RequestManager</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (Target&lt;?&gt; target : targetTracker.getAll()) &#123;</span><br><span class="line">    clear(target);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(@Nullable <span class="keyword">final</span> Target&lt;?&gt; target)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  untrackOrDelegate(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">untrackOrDelegate</span><span class="params">(@NonNull Target&lt;?&gt; target)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  Request request = target.getRequest();</span><br><span class="line">  <span class="keyword">if</span> (!isOwnedByUs &amp;&amp; !glide.removeFromManagers(target) &amp;&amp; request != <span class="keyword">null</span>) &#123;</span><br><span class="line">    target.setRequest(<span class="keyword">null</span>);</span><br><span class="line">    request.clear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SingleRequest</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  engine.release(toRelease);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Engine</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(Resource&lt;?&gt; resource)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (resource <span class="keyword">instanceof</span> EngineResource) &#123;</span><br><span class="line">    ((EngineResource&lt;?&gt;) resource).release();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单来讲就是加载资源的时候会把资源放入弱引用缓存，但资源不需要的时候会从弱引用缓存里面拿出移到另一个内存缓存里面。所以这些资源都是正在使用的，这个弱引用缓存Glide把它叫做ActiveResources也是比较准确的。</p>
<p><strong>这个缓存使用弱引用的意义在于: 资源是保存在request里面的，而根据我们<a href="https://www.jianshu.com/p/85da220d8442" target="_blank" rel="noopener">上篇笔记</a>的知识，request是以setTag的方式保存在view里面的。所以当view被回收之后，resource也就没有别的强引用可以连接到gc root，可以被java垃圾回收机制回收</strong></p>
<h1 id="LRUCache"><a href="#LRUCache" class="headerlink" title="LRUCache"></a>LRUCache</h1><p>Engine.load会先从ActiveResources中查询，查不到的话再从Cache里面查询，这个Cache其实是一个LruResourceCache:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruResourceCache</span> <span class="keyword">extends</span> <span class="title">LruCache</span>&lt;<span class="title">Key</span>, <span class="title">Resource</span>&lt;?&gt;&gt; <span class="keyword">implements</span> <span class="title">MemoryCache</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个lru cache里面加载资源意味着把资源从lru cache里面移出，放到弱引用缓存中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key) &#123;</span><br><span class="line">  EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</span><br><span class="line">  <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">    cached.acquire();</span><br><span class="line">    activeResources.activate(key, cached);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cached;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;</span><br><span class="line">  Resource&lt;?&gt; cached = cache.remove(key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> EngineResource&lt;?&gt; result;</span><br><span class="line">  <span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cached <span class="keyword">instanceof</span> EngineResource) &#123;</span><br><span class="line">    result = (EngineResource&lt;?&gt;) cached;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = <span class="keyword">new</span> EngineResource&lt;&gt;(cached, <span class="comment">/*isMemoryCacheable=*/</span> <span class="keyword">true</span>, <span class="comment">/*isRecyclable=*/</span> <span class="keyword">true</span>, key, <span class="comment">/*listener=*/</span> <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而正如上节我们讲的资源的引用计数被清零的时候就会从弱引用缓存中删除，加入lru cache中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Engine</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReleased</span><span class="params">(Key cacheKey, EngineResource&lt;?&gt; resource)</span> </span>&#123;</span><br><span class="line">    activeResources.deactivate(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (resource.isMemoryCacheable()) &#123;</span><br><span class="line">      cache.put(cacheKey, resource);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resourceRecycler.recycle(resource, <span class="comment">/*forceNextFrame=*/</span> <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActiveResources</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deactivate</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    ResourceWeakReference removed = activeEngineResources.remove(key);</span><br><span class="line">    <span class="keyword">if</span> (removed != <span class="keyword">null</span>) &#123;</span><br><span class="line">      removed.reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="内存缓存整体流程"><a href="#内存缓存整体流程" class="headerlink" title="内存缓存整体流程"></a>内存缓存整体流程</h1><p>至此整个内存缓存的架构就大体完整了，当资源被使用的时候会被放到弱引用缓存，当资源不再被使用的时候就会被放入LRU Cache(注意这里放的是强引用，因为是从view里面getTage拿到Resource强引用进行release的):</p>
<img src="/Glide源码探究二/2.png">

<h1 id="补充-内存缓存的查询顺序"><a href="#补充-内存缓存的查询顺序" class="headerlink" title="补充: 内存缓存的查询顺序"></a>补充: 内存缓存的查询顺序</h1><p>先查弱引用缓存再查lru cache这个顺序并不是一开始就这样的，我刚看glide源码的时候看的是比较旧的版本，那个时候是先查lru cahe，查不到再查弱引用缓存。</p>
<p>这个顺序在2017年11月<a href="https://github.com/bumptech/glide/commit/02096625b38f5c5fd6c820752a2fc4f0ae2b07ea" target="_blank" rel="noopener">这个commit</a>之后修改的:</p>
<img src="/Glide源码探究二/3.png">

<p>这个修改是为了修复资源被重复加载的bug，但实际上我看这部分修改的时候，感觉交换查询顺序应该和解这个bug没有直接关系，它更像是作者在重构之后觉得先查lru cache再查弱引用缓存的顺序怪怪的(我那个时候也有这种感觉)，顺手改了下:</p>
<img src="/Glide源码探究二/4.png">

<p>这里它将原本写在Engine的弱引用Map封装成了ActiveResources。</p>
<p>那为啥顺序不是一开始就是先查弱引用缓存呢?原因可能是<a href="https://github.com/bumptech/glide/blob/fe7154fc88d47c779aec395af7020a69d61f6392/library/src/com/bumptech/glide/load/engine/Engine.java" target="_blank" rel="noopener">一开始的代码</a>内存缓存就没有弱引用缓存:</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T, Z&gt; LoadStatus load(<span class="keyword">String</span> id, <span class="built_in">int</span> <span class="built_in">width</span>, <span class="built_in">int</span> <span class="built_in">height</span>, ResourceDecoder&lt;InputStream, Z&gt; cacheDecoder,</span><br><span class="line">        ResourceFetcher&lt;T&gt; fetcher, ResourceDecoder&lt;T, Z&gt; decoder,  Transformation&lt;Z&gt; transformation,</span><br><span class="line">        ResourceEncoder&lt;Z&gt; encoder, Priority priority, ResourceCallback cb) &#123;</span><br><span class="line"></span><br><span class="line">    Key <span class="built_in">key</span> = keyFactory.buildKey(id, <span class="built_in">width</span>, <span class="built_in">height</span>, cacheDecoder, decoder, transformation, encoder);</span><br><span class="line"></span><br><span class="line">    Resource cached = cache.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cached.acquire(<span class="number">1</span>);</span><br><span class="line">        cb.onResourceReady(cached);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ResourceRunner current = runners.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">        EngineJob job = current.getJob();</span><br><span class="line">        job.addCallback(cb);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, job);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ResourceRunner&lt;Z&gt; runner = factory.build(<span class="built_in">key</span>, <span class="built_in">width</span>, <span class="built_in">height</span>, cacheDecoder, fetcher, decoder, transformation,</span><br><span class="line">            encoder, priority, <span class="keyword">this</span>);</span><br><span class="line">    runner.getJob().addCallback(cb);</span><br><span class="line">    runners.put(<span class="built_in">key</span>, runner);</span><br><span class="line">    runner.queue();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, runner.getJob());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能是作者在后面优化添加这个弱引用缓存的时候就顺手放到了原有逻辑的后面。</p>
<p>其实仔细想想内存缓存的架构，我觉得这个顺序其实并不重要，谁先谁后都不会有什么问题，无非是说流程是从lru cache拿出来放到弱引用缓存的，查询的时候先查弱引用缓存会比较符合一般人的思路。</p>
<p>我们回想下两个缓存存放的资源，简化到Activity的场景。弱引用缓存放的都是当前activity正在使用的图片，lru cache是activity退出之后回收的图片。如果先查弱引用缓存，意味着当上下不停滑动recyclerview的时候效率高一丢丢。如果先查lru cahe，意味着反复进出同一个activity的时候效率高一丢丢。很难说哪个顺序性能比较高。而且这一丢丢性能在现代设备中的确真的是毫无影响，所以让人好理解是最重要的，先查弱引用缓存没毛病。</p>

    
  </div>
</article>

</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    




  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235687', function() {
      // load success
    });
  }
</script>

  <footer style="flex: 0 0 auto;text-align: center;">
<a style="font-size:12px; color:#6C6C6C" target="_blank">© 2021  林嘉伟 ❤ <a style="font-size:12px; color:#6C6C6C" target="_blank" href="http://beian.miit.gov.cn/" rel="nofollow">粤ICP备2021021473号</a></footer>
</body>
</html>
