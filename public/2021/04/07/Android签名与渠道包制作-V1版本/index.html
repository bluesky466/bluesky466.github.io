<!DOCTYPE html>


  <html class="light page-home">


<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>Android签名与渠道包制作-V1版本 | 编程代码笔记</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="技术相关,Android,">
  

  <meta name="description" content="系列文章:  Android签名与渠道包制作-V1版本 Android签名与渠道包制作-V2/V3签名原理 Android签名与渠道包制作-V2/V3渠道包原理  偶然发现安卓的签名V3已经出到了版本，想想自己其实也没有太深入了解过v1、v2。本着查漏补缺的想法把三个版本的原理都过了一遍，并且利用签名的原理手撸了渠道包制作的demo。这系列的文章就带大家深入了解下各个版本的签名和渠道包制作原理。">
<meta name="keywords" content="技术相关,Android">
<meta property="og:type" content="article">
<meta property="og:title" content="Android签名与渠道包制作-V1版本">
<meta property="og:url" content="http://139.199.4.241/2021/04/07/Android签名与渠道包制作-V1版本/index.html">
<meta property="og:site_name" content="编程代码笔记">
<meta property="og:description" content="系列文章:  Android签名与渠道包制作-V1版本 Android签名与渠道包制作-V2/V3签名原理 Android签名与渠道包制作-V2/V3渠道包原理  偶然发现安卓的签名V3已经出到了版本，想想自己其实也没有太深入了解过v1、v2。本着查漏补缺的想法把三个版本的原理都过了一遍，并且利用签名的原理手撸了渠道包制作的demo。这系列的文章就带大家深入了解下各个版本的签名和渠道包制作原理。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://139.199.4.241/Android签名与渠道包制作V1版本/1.png">
<meta property="og:image" content="http://139.199.4.241/Android签名与渠道包制作V1版本/2.png">
<meta property="og:updated_time" content="2022-02-07T05:47:21.420Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android签名与渠道包制作-V1版本">
<meta name="twitter:description" content="系列文章:  Android签名与渠道包制作-V1版本 Android签名与渠道包制作-V2/V3签名原理 Android签名与渠道包制作-V2/V3渠道包原理  偶然发现安卓的签名V3已经出到了版本，想想自己其实也没有太深入了解过v1、v2。本着查漏补缺的想法把三个版本的原理都过了一遍，并且利用签名的原理手撸了渠道包制作的demo。这系列的文章就带大家深入了解下各个版本的签名和渠道包制作原理。">
<meta name="twitter:image" content="http://139.199.4.241/Android签名与渠道包制作V1版本/1.png">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=32204ee7" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>
</html>
<body>

  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#V1签名原理"><span class="toc-text">V1签名原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MANIFEST-MF"><span class="toc-text">MANIFEST.MF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CERT-SF"><span class="toc-text">CERT.SF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CERT-RSA"><span class="toc-text">CERT.RSA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#签名与校验流程"><span class="toc-text">签名与校验流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#渠道包原理"><span class="toc-text">渠道包原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#zip包格式"><span class="toc-text">zip包格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#渠道信息的写入"><span class="toc-text">渠道信息的写入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#渠道信息的读取"><span class="toc-text">渠道信息的读取</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#完整代码"><span class="toc-text">完整代码</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Android签名与渠道包制作-V1版本" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Android签名与渠道包制作-V1版本</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2021.04.07</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>林嘉伟</span>
        </span>
      

      


      

    </div>
  </header>

  <div class="article-content">
    
      <p>系列文章:</p>
<ul>
<li><a href="https://blog.islinjw.cn/2021/04/07/Android%E7%AD%BE%E5%90%8D%E4%B8%8E%E6%B8%A0%E9%81%93%E5%8C%85%E5%88%B6%E4%BD%9C-V1%E7%89%88%E6%9C%AC/" target="_blank" rel="noopener">Android签名与渠道包制作-V1版本</a></li>
<li><a href="https://blog.islinjw.cn/2021/04/07/Android%E7%AD%BE%E5%90%8D%E4%B8%8E%E6%B8%A0%E9%81%93%E5%8C%85%E5%88%B6%E4%BD%9C-V2-V3%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">Android签名与渠道包制作-V2/V3签名原理</a></li>
<li><a href="https://blog.islinjw.cn/2021/04/09/Android%E7%AD%BE%E5%90%8D%E4%B8%8E%E6%B8%A0%E9%81%93%E5%8C%85%E5%88%B6%E4%BD%9C-V2-V3%E6%B8%A0%E9%81%93%E5%8C%85%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">Android签名与渠道包制作-V2/V3渠道包原理</a></li>
</ul>
<p>偶然发现安卓的签名V3已经出到了版本，想想自己其实也没有太深入了解过v1、v2。本着查漏补缺的想法把三个版本的原理都过了一遍，并且利用签名的原理手撸了渠道包制作的demo。这系列的文章就带大家深入了解下各个版本的签名和渠道包制作原理。</p>
<p>这篇我们先来看看V1版本的原理。</p>
<h1 id="V1签名原理"><a href="#V1签名原理" class="headerlink" title="V1签名原理"></a>V1签名原理</h1><p>首先我们要知道用v1签名的apk包其实就是一个普通的zip压缩包，我们将后缀改成.zip就可以直接解压。解压出来可以在META-INF目录下看到MANIFEST.MF、CERT.SF、CERT.RSA这三个文件，V1签名就是靠的这三个文件来验证的。</p>
<h2 id="MANIFEST-MF"><a href="#MANIFEST-MF" class="headerlink" title="MANIFEST.MF"></a>MANIFEST.MF</h2><p>MANIFEST.MF长这个样子，它记录了apk所有原始文件的数据摘要的Base64编码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Built-By: Generated-by-ADT</span><br><span class="line">Created-By: Android Gradle 3.5.1</span><br><span class="line"></span><br><span class="line">Name: AndroidManifest.xml</span><br><span class="line">SHA-256-Digest: 6gizONW6AQK41R0kXhGh+M60wBxPA06WFrq5KSWrB24=</span><br><span class="line"></span><br><span class="line">Name: META-INF/androidx.appcompat_appcompat.version</span><br><span class="line">SHA-256-Digest: n9KGQtOsoZHlx/wjg8/W+rsqrIdD8Cnau4mJrFhOMbw=</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>正如我们所说，apk是个普通的压缩包，我们解压完修改里面的内容(如图片)再压缩回去，它仍然符合apk文件格式可以用于安装。但是V1签名在安装的时候会用MANIFEST.MF去检查原始文件是否被修改，如果被修改就拒绝安装。</p>
<h2 id="CERT-SF"><a href="#CERT-SF" class="headerlink" title="CERT.SF"></a>CERT.SF</h2><p>当然我们也可以将MANIFEST.MF一起修改了，但是安卓还会通过CERT.SF去检查MANIFEST.MF是否被修改。</p>
<p>CERT.SF长这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Signature-Version: 1.0</span><br><span class="line">Created-By: 1.0 (Android)</span><br><span class="line">SHA-256-Digest-Manifest: aed+nGnbmO5m79Dy1aNQ68aTFC9N5EyZj8kOeE56yyU=</span><br><span class="line"></span><br><span class="line">Name: AndroidManifest.xml</span><br><span class="line">SHA-256-Digest: QA9D/hXYs4aCJcZ4nZ8kLP2RnPn/kw15girRaw7xdng=</span><br><span class="line"></span><br><span class="line">Name: META-INF/androidx.appcompat_appcompat.version</span><br><span class="line">SHA-256-Digest: ABbgKP0s08CVeuJ5ZMlIZx/AvJtb1QhNA0ffeXfCaHk=</span><br><span class="line"></span><br><span class="line">Name: META-INF/androidx.arch.core_core-runtime.version</span><br><span class="line">SHA-256-Digest: PjygIQMN5T6nIKT/hi5PFaxVcEB+W20fr4f0g2n7jrg=</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>它将MANIFEST.MF整个文件和里面的每一项的摘要信息又做一次SHA摘要和Base64编码记录起来。例如CERT.SF第一个AndroidManifest.xml的SHA-256-Digest代表的其实是下面内容SHA摘要的Base64编码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Name: AndroidManifest.xml</span><br><span class="line">SHA-256-Digest: 6gizONW6AQK41R0kXhGh+M60wBxPA06WFrq5KSWrB24=</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p>PS: 最后一行的\r\n也是要参与计算的。</p>
<h2 id="CERT-RSA"><a href="#CERT-RSA" class="headerlink" title="CERT.RSA"></a>CERT.RSA</h2><p>同样的道理在修改apk的时候我们也可以将MANIFEST.MF和CERT.SF一并修改了。这个时候就轮到CERT.RSA出马了。</p>
<p>进行V1签名的时候会先计算CERT.SF的摘要，然后用开发者的私钥计算数字签名，然后将数字签名、开发者公钥等信息保存到CERT.RSA，在安装的时候就能进行验证。如果没有私钥，修改完CERT.SF就没有办法同步修改CERT.RSA。</p>
<h2 id="签名与校验流程"><a href="#签名与校验流程" class="headerlink" title="签名与校验流程"></a>签名与校验流程</h2><p>通过上面的介绍我们能总结出V1版本的签名和校验流程:</p>
<p>签名流程:</p>
<ol>
<li>计算每个原始文件的SHA摘要，用Base64编码保存到MANIFEST.MF</li>
<li>对MANIFEST.MF的整个文件和里面的每一项信息再进行SHA摘要，用Base64编码保存到CERT.SF</li>
<li>计算CERT.SF的摘要并使用开发者的私钥加密计算出数字签名，将该数字签名和开发者公钥等信息保存到CERT.RSA</li>
</ol>
<p>验证流程:</p>
<ol>
<li>在CERT.RSA读取公钥和CERT.SF的数字签名，计算CERT.SF的摘要</li>
<li>验证CERT.SF是否被修改</li>
<li>通过CERT.SF验证MANIFEST.MF是否被修改</li>
<li>通过MANIFEST.MF验证原始文件是否被修改</li>
</ol>
<h1 id="渠道包原理"><a href="#渠道包原理" class="headerlink" title="渠道包原理"></a>渠道包原理</h1><p>由于国内的应用市场众多，一般需要打多个渠道包上传，这些渠道包会保存该渠道的一些信息。虽然我们可以通过gradle的productFlavors去编译多个包，但是由于这种机制没生成一个渠道包都要走一遍编译流程，耗时比较多。而且一般会生成不同的BuildConfig.java类导致dex不同，如果使用Tinker需要对不同的渠道包都单独做差异包去热修复。</p>
<p>所以一般都不会用这种方式去打渠道包，而是在编译完之后在apk里面插入渠道信息。</p>
<p>刚刚我们也有讲到V1签名会对apk里面的文件进行校验，但是这里有个漏洞就是它是对原始文件进行校验，对整个apk包没有做校验。所以我们可以在apk包中插入渠道信息。</p>
<h2 id="zip包格式"><a href="#zip包格式" class="headerlink" title="zip包格式"></a>zip包格式</h2><p>使用将数据直接插入apk文件的方式，我们先要了解下apk(也就是zip包)的<a href="https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.2.0.txt" target="_blank" rel="noopener">文件格式</a>:</p>
<img src="/Android签名与渠道包制作V1版本/1.png">

<p>它主要分成了上面的三个部分，而我们的突破口就在最后一部分，我们来看看这部分的详细格式:</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>大小</th>
</tr>
</thead>
<tbody><tr>
<td>end of central dir signature (0x06054b50)</td>
<td>4 bytes</td>
</tr>
<tr>
<td>number of this disk</td>
<td>2 bytes</td>
</tr>
<tr>
<td>number of the disk with the start of the central directory</td>
<td>2 bytes</td>
</tr>
<tr>
<td>total number of entries in the central directory on this disk</td>
<td>2 bytes</td>
</tr>
<tr>
<td>total number of entries in the central directory</td>
<td>2 bytes</td>
</tr>
<tr>
<td>size of the central directory</td>
<td>4 bytes</td>
</tr>
<tr>
<td>offset of start of central directory with respect to the starting disk number</td>
<td>4 bytes</td>
</tr>
<tr>
<td>.ZIP file comment length</td>
<td>2 bytes</td>
</tr>
<tr>
<td>.ZIP file comment</td>
<td>(variable size)</td>
</tr>
</tbody></table>
<p>这部分我们简称eocd，它以一个魔数0x06054b50打头，后面带了一些zip包的描述。其中对我们最重要的是最后的.ZIP file comment length和.ZIP file comment。</p>
<p>zip包是可以在末尾携带描述信息的。描述信息的长度在.ZIP file comment length字段中获取。所以我们可以将渠道信息写到.ZIP file comment里。我这里参考<a href="[https://github.com/Tencent/VasDolly/wiki/VasDolly%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86](https://github.com/Tencent/VasDolly/wiki/VasDolly实现原理)">VasDolly</a>的实现原理将渠道信息格式定义成下面的样子插入到apk包的最末尾:</p>
<img src="/Android签名与渠道包制作V1版本/2.png">

<p>于是我们在运行的时候就能通过读取apk包的结尾4个字节看看是否能读到我们定义的魔数判断有无渠道信息，如果有的话往前两个字节读渠道信息的长度，最后根据长度再往前读取渠道信息。</p>
<h2 id="渠道信息的写入"><a href="#渠道信息的写入" class="headerlink" title="渠道信息的写入"></a>渠道信息的写入</h2><p>这边实现了个Demo，我们直接来看看代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addChannelInfo</span><span class="params">(String srcApk, String outputApk, String channelInfo)</span> </span>&#123;</span><br><span class="line">    RandomAccessFile zipFile = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    FileChannel srcChannel = <span class="keyword">null</span>;</span><br><span class="line">    FileChannel dstChannel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        zipFile = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(srcApk), <span class="string">"r"</span>);</span><br><span class="line">        srcChannel = zipFile.getChannel();</span><br><span class="line"></span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(outputApk);</span><br><span class="line">        dstChannel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找eocd</span></span><br><span class="line">        ByteBuffer originEocd = Utils.findEocd(srcChannel);</span><br><span class="line">        <span class="keyword">if</span> (originEocd == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 往eocd插入渠道信息得到新的eocd</span></span><br><span class="line">        ByteBuffer newEocd = addChannelInfo(originEocd, channelInfo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// eocd前面的数据是没有改到的,直接拷贝就好</span></span><br><span class="line">        Utils.copyByLength(srcChannel, dstChannel, zipFile.length() - originEocd.capacity());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 往后插入新的eocd</span></span><br><span class="line">        dstChannel.write(newEocd);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Utils.safeClose(srcChannel, zipFile, dstChannel, fos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eocd的读取很简单，从后往前查找eocd魔数即可:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">findEocd</span><span class="params">(FileChannel zipFile)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// end of central directory record 是整个zip包的结尾</span></span><br><span class="line">    <span class="comment">// 而且它以0x06054b50这个魔数做起始,所以只需从后往前遍历找到这个魔数,即可截取整个EOCD</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// [zip包其余内容]      ...</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// [EOCD]              end of central dir signature (0x06054b50)</span></span><br><span class="line">    <span class="comment">//                     eocd其余部分</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (zipFile.size() &lt; Utils.EOCD_MIN_LENGTH) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = (<span class="keyword">int</span>) Math.min(Utils.EOCD_MAX_LENGTH, zipFile.size());</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(length);</span><br><span class="line">        buffer.order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line"></span><br><span class="line">        zipFile.read(buffer, zipFile.size() - length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - Utils.EOCD_MIN_LENGTH; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer.getInt(i) == Utils.EOCD_SIG) &#123;</span><br><span class="line">                buffer.position(i);</span><br><span class="line">                <span class="keyword">return</span> buffer.slice().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"return null"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        zipFile.position(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果apk本身没有带描述，我们主需要直接读最后的22个字节就好，但是为了兼容带描述的情况，我们还是通过查找魔数的方式定位eocd。</p>
<p>.ZIP file comment length只有2字节,所以描述长度最多有0xffff,然后加上eocd前固定的22个字节就得到eocd可能的最大长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EOCD_MAX_LENGTH = <span class="number">0xffff</span> + <span class="number">22</span>;</span><br></pre></td></tr></table></figure>

<p>所以我们直接从apk最后读取这么多个字节去遍历就好。</p>
<p>查到到eocd之后我们在最后插入渠道信息，然后同步修改.ZIP file comment length字段:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ByteBuffer <span class="title">addChannelInfo</span><span class="params">(ByteBuffer eocd, String channelInfo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// end of central directory record 的格式如下:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// end of central dir signature                                                    4 bytes  (0x06054b50)</span></span><br><span class="line">    <span class="comment">// number of this disk                                                             2 bytes</span></span><br><span class="line">    <span class="comment">// number of the disk with the start of the central directory                      2 bytes</span></span><br><span class="line">    <span class="comment">// total number of entries in the central directory on this disk                   2 bytes</span></span><br><span class="line">    <span class="comment">// total number of entries in the central directory                                2 bytes</span></span><br><span class="line">    <span class="comment">// size of the central directory                                                   4 bytes</span></span><br><span class="line">    <span class="comment">// offset of start of central directory with respect to the starting disk number   4 bytes</span></span><br><span class="line">    <span class="comment">// .ZIP file comment length                                                        2 bytes</span></span><br><span class="line">    <span class="comment">// .ZIP file comment                                                               (variable size)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 我们可以在.ZIP file comment里面插入渠道信息块:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 渠道信息      大小记录在[渠道信息长度]中</span></span><br><span class="line">    <span class="comment">// 渠道信息长度  2字节</span></span><br><span class="line">    <span class="comment">// 魔数         4字节</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 魔数放在最后面方便我们读取判断是否有渠道信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> infoLength = (<span class="keyword">short</span>) channelInfo.getBytes().length;</span><br><span class="line">    <span class="keyword">short</span> channelBlockSize = (<span class="keyword">short</span>) (infoLength <span class="comment">// 渠道信息</span></span><br><span class="line">            + Short.BYTES      <span class="comment">// 渠道信息长度</span></span><br><span class="line">            + Integer.BYTES);  <span class="comment">// 渠道信息魔数</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(eocd.capacity() + channelBlockSize);</span><br><span class="line">    buffer.order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// eocd前面部分的数据我们没有改动,直接拷贝就好</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[Utils.EOCD_MIN_LENGTH - Utils.EOCD_SIZE_OF_COMMENT_LENGTH];</span><br><span class="line">    eocd.get(bytes);</span><br><span class="line">    buffer.put(bytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于插入了渠道信息块,zip包的注释长度需要相应的增加</span></span><br><span class="line">    buffer.putShort((<span class="keyword">short</span>) (eocd.getShort() + channelBlockSize));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝原本的zip包注释</span></span><br><span class="line">    eocd.position(Utils.EOCD_MIN_LENGTH);</span><br><span class="line">    buffer.put(eocd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入渠道包信息块</span></span><br><span class="line">    buffer.put(channelInfo.getBytes());     <span class="comment">// 渠道信息</span></span><br><span class="line">    buffer.putShort(infoLength);            <span class="comment">// 渠道信息长度</span></span><br><span class="line">    buffer.putInt(Utils.CHANNEL_INFO_SIG);  <span class="comment">// 魔数</span></span><br><span class="line"></span><br><span class="line">    buffer.flip();</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="渠道信息的读取"><a href="#渠道信息的读取" class="headerlink" title="渠道信息的读取"></a>渠道信息的读取</h2><p>讲完渠道信息的写入，我们再来看看运行的时候怎么去读取渠道信息:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getChannelInfo</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    String apkPath = Utils.getApkPath(context);</span><br><span class="line">    <span class="keyword">if</span> (apkPath == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    RandomAccessFile apk = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        apk = <span class="keyword">new</span> RandomAccessFile(apkPath, <span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取apk的结尾4字节看看是否为渠道信息魔数判断是否有渠道信息</span></span><br><span class="line">        <span class="keyword">long</span> sigPosition = apk.length() - Integer.BYTES;</span><br><span class="line">        <span class="keyword">int</span> sig = Utils.readInt(apk, sigPosition);</span><br><span class="line">        <span class="keyword">if</span> (sig != Utils.CHANNEL_INFO_SIG) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再往前读两个字节获取渠道信息的长度</span></span><br><span class="line">        <span class="keyword">long</span> lengthPosition = sigPosition - Short.BYTES;</span><br><span class="line">        <span class="keyword">short</span> length = Utils.readShort(apk, lengthPosition);</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据长度读取渠道信息</span></span><br><span class="line">        <span class="keyword">long</span> infoPosition = lengthPosition - length;</span><br><span class="line">        <span class="keyword">return</span> Utils.readString(apk, infoPosition, length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Utils.safeClose(apk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程很简单:</p>
<ol>
<li>判断apk结尾4个字节是否为渠道信息魔数</li>
<li>获取渠道信息长度</li>
<li>读取渠道信息</li>
</ol>
<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>完整的demo已经上传到<a href="https://github.com/bluesky466/ChannelInfoHelper" target="_blank" rel="noopener">Github</a>,我将添加渠道信息的操作放到了<a href="https://github.com/bluesky466/ChannelInfoHelper/blob/master/app/src/test/java/me/linjw/channelinfohelper/AddChannelInfo.java" target="_blank" rel="noopener">单元测试</a>里，编译完之后执行插入渠道信息。</p>

    
  </div>
</article>

</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    




  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235687', function() {
      // load success
    });
  }
</script>

  <footer style="flex: 0 0 auto;text-align: center;">
<a style="font-size:12px; color:#6C6C6C" target="_blank">© 2021  林嘉伟 ❤ <a style="font-size:12px; color:#6C6C6C" target="_blank" href="http://beian.miit.gov.cn/" rel="nofollow">粤ICP备2021021473号</a></footer>
</body>
</html>
