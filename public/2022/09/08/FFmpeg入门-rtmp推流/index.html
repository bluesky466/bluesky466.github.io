<!DOCTYPE html>


  <html class="light page-home">


<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>FFmpeg入门 - rtmp推流 | LinJW</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="技术相关,音视频,">
  

  <meta name="description" content="上一篇博客介绍了怎样用ffmpeg去播放视频. 里面用于打开视频流的avformat_open_input函数除了打开本地视频之外,实际上也能打开rtmp协议的远程视频,实现拉流: 123./demo -p 本地视频路径./demo -p rtmp://服务器ip/视频流路径  这篇文章我们来讲下怎样实现推流,然后和之前的demo代码配合就能完成推流、拉流的整个过程,实现直播。 rtmp服务器整个">
<meta name="keywords" content="技术相关,音视频">
<meta property="og:type" content="article">
<meta property="og:title" content="FFmpeg入门 - rtmp推流">
<meta property="og:url" content="http://139.199.4.241/2022/09/08/FFmpeg入门-rtmp推流/index.html">
<meta property="og:site_name" content="LinJW">
<meta property="og:description" content="上一篇博客介绍了怎样用ffmpeg去播放视频. 里面用于打开视频流的avformat_open_input函数除了打开本地视频之外,实际上也能打开rtmp协议的远程视频,实现拉流: 123./demo -p 本地视频路径./demo -p rtmp://服务器ip/视频流路径  这篇文章我们来讲下怎样实现推流,然后和之前的demo代码配合就能完成推流、拉流的整个过程,实现直播。 rtmp服务器整个">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://www.plantuml.com/plantuml/svg/uqhEoIzDKQZcKb28VZQdzsdNmgSpLyHorN9nHJ_hM_5iQ-FprUjZ5NJjK6IHs12fxaweIYu0">
<meta property="og:updated_time" content="2022-09-08T13:45:33.210Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="FFmpeg入门 - rtmp推流">
<meta name="twitter:description" content="上一篇博客介绍了怎样用ffmpeg去播放视频. 里面用于打开视频流的avformat_open_input函数除了打开本地视频之外,实际上也能打开rtmp协议的远程视频,实现拉流: 123./demo -p 本地视频路径./demo -p rtmp://服务器ip/视频流路径  这篇文章我们来讲下怎样实现推流,然后和之前的demo代码配合就能完成推流、拉流的整个过程,实现直播。 rtmp服务器整个">
<meta name="twitter:image" content="http://www.plantuml.com/plantuml/svg/uqhEoIzDKQZcKb28VZQdzsdNmgSpLyHorN9nHJ_hM_5iQ-FprUjZ5NJjK6IHs12fxaweIYu0">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=32204ee7" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>
</html>
<body>

  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#rtmp服务器"><span class="toc-text">rtmp服务器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#推流"><span class="toc-text">推流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备输出流"><span class="toc-text">准备输出流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#codec-id和codec-tag"><span class="toc-text">codec_id和codec_tag</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#写入视频数据"><span class="toc-text">写入视频数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#帧同步"><span class="toc-text">帧同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#资源释放"><span class="toc-text">资源释放</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他"><span class="toc-text">其他</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-FFmpeg入门-rtmp推流" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">FFmpeg入门 - rtmp推流</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2022.09.08</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>林嘉伟</span>
        </span>
      

      


      

    </div>
  </header>

  <div class="article-content">
    
      <p><a href="https://blog.islinjw.cn/2022/09/04/FFmpeg%E5%85%A5%E9%97%A8-%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/" target="_blank" rel="noopener">上一篇博客</a>介绍了怎样用ffmpeg去播放视频.</p>
<p>里面用于打开视频流的avformat_open_input函数除了打开本地视频之外,实际上也能打开rtmp协议的远程视频,实现拉流:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./demo -p 本地视频路径</span><br><span class="line"></span><br><span class="line">./demo -p rtmp://服务器ip/视频流路径</span><br></pre></td></tr></table></figure>

<p>这篇文章我们来讲下怎样实现推流,然后和之前的demo代码配合就能完成推流、拉流的整个过程,实现直播。</p>
<h1 id="rtmp服务器"><a href="#rtmp服务器" class="headerlink" title="rtmp服务器"></a>rtmp服务器</h1><p>整个直播的功能分成下面三个模块:</p>
<img src="http://www.plantuml.com/plantuml/svg/uqhEoIzDKQZcKb28VZQdzsdNmgSpLyHorN9nHJ_hM_5iQ-FprUjZ5NJjK6IHs12fxaweIYu0">

<p>从上图我们可以看到rtmp是需要服务器做转发的,我们选用开源的<a href="https://github.com/ossrs/srs" target="_blank" rel="noopener">srs</a>.直接从github上把它的源码拉下来编译,然后直接启动即可:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:ossrs/srs.git</span><br><span class="line">cd srs/trunk</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">./etc/init.d/srs start</span><br></pre></td></tr></table></figure>

<p>如果是本地的电脑,这个时候就能在局域网内直接用它的内网ip去访问了.但如果是腾讯云、阿里云之类的云服务器还需要配置安全组开放下面几个端口的访问权限:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">listen              1935;</span><br><span class="line">max_connections     1000;</span><br><span class="line">#srs_log_tank        file;</span><br><span class="line">#srs_log_file        ./objs/srs.log;</span><br><span class="line">daemon              on;</span><br><span class="line">http_api &#123;</span><br><span class="line">    enabled         on;</span><br><span class="line">    listen          1985;</span><br><span class="line">&#125;</span><br><span class="line">http_server &#123;</span><br><span class="line">    enabled         on;</span><br><span class="line">    listen          8080;</span><br><span class="line">    dir             ./objs/nginx/html;</span><br><span class="line">&#125;</span><br><span class="line">rtc_server &#123;</span><br><span class="line">    enabled on;</span><br><span class="line">    listen 8000; # UDP port</span><br><span class="line">    # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/webrtc#config-candidate</span><br><span class="line">    candidate $CANDIDATE;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>当然如果这几个端口已经被占用的话可以修改配置文件conf/srs.conf去修改</p>
<p>服务器到这里就准备好了,浏览器访问下面网址对srs进行调试、配置:</p>
<blockquote>
<p>http://服务器ip:8080/players/rtc_publisher.html<br>http://服务器ip:1985/console/ng_index.html</p>
</blockquote>
<h1 id="推流"><a href="#推流" class="headerlink" title="推流"></a>推流</h1><h2 id="准备输出流"><a href="#准备输出流" class="headerlink" title="准备输出流"></a>准备输出流</h2><p>我们选择推送本地的视频到rtmp服务器,所以第一步仍然是打开本地视频流:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> VideoSender::Send(<span class="keyword">const</span> <span class="built_in">string</span>&amp; srcUrl, <span class="keyword">const</span> <span class="built_in">string</span>&amp; destUrl) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 打开文件流读取文件头解析出视频信息如轨道信息、时长等</span></span><br><span class="line">    <span class="comment">// mFormatContext初始化为NULL,如果打开成功,它会被设置成非NULL的值</span></span><br><span class="line">    <span class="comment">// 这个方法实际可以打开多种来源的数据,url可以是本地路径、rtmp地址等</span></span><br><span class="line">    <span class="comment">// 在不需要的时候通过avformat_close_input关闭文件流</span></span><br><span class="line">    <span class="keyword">if</span>(avformat_open_input(&amp;inputFormatContext, srcUrl.c_str(), <span class="literal">NULL</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"open "</span> &lt;&lt; srcUrl &lt;&lt; <span class="string">" failed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于没有文件头的格式如MPEG或者H264裸流等,可以通过这个函数解析前几帧得到视频的信息</span></span><br><span class="line">    <span class="keyword">if</span>(avformat_find_stream_info(inputFormatContext, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"can't find stream info in "</span> &lt;&lt; srcUrl &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印输入视频信息</span></span><br><span class="line">    av_dump_format(inputFormatContext, <span class="number">0</span>, srcUrl.c_str(), <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本地视频打开之后,我们创建输出视频流上下文,然后为输出流创建轨道,最后打开输出视频流:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建输出流上下文,outputFormatContext初始化为NULL,如果打开成功,它会被设置成非NULL的值,在不需要的时候使用avformat_free_context释放</span></span><br><span class="line"><span class="comment">// 输出流使用flv格式</span></span><br><span class="line"><span class="keyword">if</span>(avformat_alloc_output_context2(&amp;outputFormatContext, <span class="literal">NULL</span>, <span class="string">"flv"</span>, destUrl.c_str()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"can't alloc output context for "</span> &lt;&lt; destUrl &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝编解码参数</span></span><br><span class="line"><span class="keyword">if</span>(!createOutputStreams(inputFormatContext, outputFormatContext)) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印输出视频信息</span></span><br><span class="line">av_dump_format(outputFormatContext, <span class="number">0</span>, destUrl.c_str(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开输出流,结束的时候使用avio_close关闭</span></span><br><span class="line"><span class="keyword">if</span>(avio_open(&amp;outputFormatContext-&gt;pb, destUrl.c_str(), AVIO_FLAG_WRITE) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"can't open avio "</span> &lt;&lt; destUrl &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个createOutputStreams用于根据本地视频文件的轨道信息,为输出流创建同样的轨道:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">createOutputStreams</span><span class="params">(AVFormatContext* inputFormatContext, AVFormatContext* outputFormatContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历输入流的所有轨道,拷贝编解码参数到输出流</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; inputFormatContext-&gt;nb_streams ; i++) &#123;</span><br><span class="line">        <span class="comment">// 为输出流创建轨道</span></span><br><span class="line">        AVStream* stream = avformat_new_stream(outputFormatContext, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == stream) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"can't create stream, index "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编解码参数在AVCodecParameters中保存,从输入流拷贝到输出流</span></span><br><span class="line">        <span class="keyword">if</span>(avcodec_parameters_copy(stream-&gt;codecpar, inputFormatContext-&gt;streams[i]-&gt;codecpar) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"can't copy codec paramters, stream index "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// codec_tag代表了音视频数据采用的码流格式,不同的封装格式如flv、mp4等的支持情况是不一样的</span></span><br><span class="line">        <span class="comment">// 上面的avcodec_parameters_copy将输出流的codec_tag从输入拷贝过来变成了一样的</span></span><br><span class="line">        <span class="comment">// 由于我们输出流在avformat_alloc_output_context2的时候写死了flv格式</span></span><br><span class="line">        <span class="comment">// 如果输入流不是flv而是mp4等格式的话就可能会出现mp4里某种codec_tag在flv不支持导致推流失败的情况</span></span><br><span class="line">        <span class="comment">// 这里我们可以用av_codec_get_id从输出流的oformat的支持的codec_tag列表里面查找codec_id</span></span><br><span class="line">        <span class="comment">// 如果和codecpar的codec_id不一致的话代表不支持</span></span><br><span class="line">        <span class="keyword">if</span>(av_codec_get_id(outputFormatContext-&gt;oformat-&gt;codec_tag, stream-&gt;codecpar-&gt;codec_tag) != stream-&gt;codecpar-&gt;codec_id) &#123;</span><br><span class="line">            <span class="comment">// 这里将codec_tag设置为0,FFmpeg会根据编码codec_id从封装格式的codec_tag列表中找到一个codec_tag</span></span><br><span class="line">            stream-&gt;codecpar-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="codec-id和codec-tag"><a href="#codec-id和codec-tag" class="headerlink" title="codec_id和codec_tag"></a>codec_id和codec_tag</h2><p>这里可以看到对于编码器有codec_id和codec_tag两个字段去描述,codec_id代表的是数据的编码类型.而codec_tag用于更详细的描述编解码的格式信息,它对应的是FourCC(Four-Character Codes)数据。</p>
<p>例如codec_id都是AV_CODEC_ID_RAWVIDEO的裸数据,但它可能是YUV的裸数据也可能是RGB的裸数据:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libavformat/isom.c</span></span><br><span class="line">&#123; AV_CODEC_ID_RAWVIDEO, MKTAG(<span class="string">'r'</span>, <span class="string">'a'</span>, <span class="string">'w'</span>, <span class="string">' '</span>) &#125;, <span class="comment">/* uncompressed RGB */</span></span><br><span class="line">&#123; AV_CODEC_ID_RAWVIDEO, MKTAG(<span class="string">'y'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>, <span class="string">'2'</span>) &#125;, <span class="comment">/* uncompressed YUV422 */</span></span><br><span class="line">&#123; AV_CODEC_ID_RAWVIDEO, MKTAG(<span class="string">'2'</span>, <span class="string">'v'</span>, <span class="string">'u'</span>, <span class="string">'y'</span>) &#125;, <span class="comment">/* uncompressed 8-bit 4:2:2 */</span></span><br><span class="line">&#123; AV_CODEC_ID_RAWVIDEO, MKTAG(<span class="string">'y'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>, <span class="string">'s'</span>) &#125;, <span class="comment">/* same as 2VUY but byte-swapped */</span></span><br></pre></td></tr></table></figure>

<p>又例如codec_id都是AV_CODEC_ID_H264,但实际上也有许多细分类型:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libavformat/isom.c</span></span><br><span class="line">&#123; AV_CODEC_ID_H264, MKTAG(<span class="string">'a'</span>, <span class="string">'v'</span>, <span class="string">'c'</span>, <span class="string">'1'</span>) &#125;, <span class="comment">/* AVC-1/H.264 */</span></span><br><span class="line">&#123; AV_CODEC_ID_H264, MKTAG(<span class="string">'a'</span>, <span class="string">'v'</span>, <span class="string">'c'</span>, <span class="string">'2'</span>) &#125;,</span><br><span class="line">&#123; AV_CODEC_ID_H264, MKTAG(<span class="string">'a'</span>, <span class="string">'v'</span>, <span class="string">'c'</span>, <span class="string">'3'</span>) &#125;,</span><br><span class="line">&#123; AV_CODEC_ID_H264, MKTAG(<span class="string">'a'</span>, <span class="string">'v'</span>, <span class="string">'c'</span>, <span class="string">'4'</span>) &#125;,</span><br><span class="line">&#123; AV_CODEC_ID_H264, MKTAG(<span class="string">'a'</span>, <span class="string">'i'</span>, <span class="string">'5'</span>, <span class="string">'p'</span>) &#125;, <span class="comment">/* AVC-Intra  50M 720p24/30/60 */</span></span><br><span class="line">&#123; AV_CODEC_ID_H264, MKTAG(<span class="string">'a'</span>, <span class="string">'i'</span>, <span class="string">'5'</span>, <span class="string">'q'</span>) &#125;, <span class="comment">/* AVC-Intra  50M 720p25/50 */</span></span><br><span class="line">&#123; AV_CODEC_ID_H264, MKTAG(<span class="string">'a'</span>, <span class="string">'i'</span>, <span class="string">'5'</span>, <span class="string">'2'</span>) &#125;, <span class="comment">/* AVC-Intra  50M 1080p25/50 */</span></span><br><span class="line">&#123; AV_CODEC_ID_H264, MKTAG(<span class="string">'a'</span>, <span class="string">'i'</span>, <span class="string">'5'</span>, <span class="string">'3'</span>) &#125;, <span class="comment">/* AVC-Intra  50M 1080p24/30/60 */</span></span><br><span class="line">&#123; AV_CODEC_ID_H264, MKTAG(<span class="string">'a'</span>, <span class="string">'i'</span>, <span class="string">'5'</span>, <span class="string">'5'</span>) &#125;, <span class="comment">/* AVC-Intra  50M 1080i50 */</span></span><br><span class="line">&#123; AV_CODEC_ID_H264, MKTAG(<span class="string">'a'</span>, <span class="string">'i'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>) &#125;, <span class="comment">/* AVC-Intra  50M 1080i60 */</span></span><br><span class="line">&#123; AV_CODEC_ID_H264, MKTAG(<span class="string">'a'</span>, <span class="string">'i'</span>, <span class="string">'1'</span>, <span class="string">'p'</span>) &#125;, <span class="comment">/* AVC-Intra 100M 720p24/30/60 */</span></span><br><span class="line">&#123; AV_CODEC_ID_H264, MKTAG(<span class="string">'a'</span>, <span class="string">'i'</span>, <span class="string">'1'</span>, <span class="string">'q'</span>) &#125;, <span class="comment">/* AVC-Intra 100M 720p25/50 */</span></span><br><span class="line">&#123; AV_CODEC_ID_H264, MKTAG(<span class="string">'a'</span>, <span class="string">'i'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>) &#125;, <span class="comment">/* AVC-Intra 100M 1080p25/50 */</span></span><br></pre></td></tr></table></figure>

<p>可以看出来codec_tag是通过4个字母去表示的,我们来看看MKTAG的定义:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MKTAG(a,b,c,d) ((a) | ((b) &lt;&lt; 8) | ((c) &lt;&lt; 16) | ((unsigned)(d) &lt;&lt; 24))</span></span><br></pre></td></tr></table></figure>

<p>最终它得到的是一个整数,例如MKTAG(‘a’, ‘v’, ‘c’, ‘1’)得到的值是0x31637661</p>
<ul>
<li>0x31 =1</li>
<li>0x63 = c</li>
<li>0x76 = v</li>
<li>0x61 = a</li>
</ul>
<p>我们可以用av_fourcc2str这个函数将最终的整数转换回字符串</p>
<p>回过头来看看这个判断:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(av_codec_get_id(outputFormatContext-&gt;oformat-&gt;codec_tag, stream-&gt;codecpar-&gt;codec_tag) != stream-&gt;codecpar-&gt;codec_id)</span><br></pre></td></tr></table></figure>

<p>大部分情况下如果codec_tag在输出流不支持的情况下av_codec_get_id拿到的是AV_CODEC_ID_NONE,所以大部分情况可以等价于:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(av_codec_get_id(outputFormatContext-&gt;oformat-&gt;codec_tag, stream-&gt;codecpar-&gt;codec_tag) != AV_CODEC_ID_NONE)</span><br></pre></td></tr></table></figure>

<p>不过也存在都是MKTAG(‘l’, ‘p’, ‘c’, ‘m’),但codec_id可能是AV_CODEC_ID_PCM_S16BE或者AV_CODEC_ID_PCM_S16LE的情况:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; AV_CODEC_ID_PCM_S16BE,       MKTAG(&apos;l&apos;, &apos;p&apos;, &apos;c&apos;, &apos;m&apos;) &#125;,</span><br><span class="line">&#123; AV_CODEC_ID_PCM_S16LE,       MKTAG(&apos;l&apos;, &apos;p&apos;, &apos;c&apos;, &apos;m&apos;) &#125;,</span><br></pre></td></tr></table></figure>

<p>所以最好还是和原本的codec_id做比较会靠谱点。</p>
<h2 id="写入视频数据"><a href="#写入视频数据" class="headerlink" title="写入视频数据"></a>写入视频数据</h2><p>接着就是视频数据的写入了,主要有三个步骤,写入文件头、读取本地视频包并写入输出视频流、写入文件结尾:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置flvflags为no_duration_filesize用于解决下面的报错</span></span><br><span class="line"><span class="comment">// [flv @ 0x14f808e00] Failed to update header with correct duration.</span></span><br><span class="line"><span class="comment">// [flv @ 0x14f808e00] Failed to update header with correct filesize</span></span><br><span class="line">AVDictionary * opts = <span class="literal">NULL</span>;</span><br><span class="line">av_dict_set(&amp;opts, <span class="string">"flvflags"</span>, <span class="string">"no_duration_filesize"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(avformat_write_header(outputFormatContext, opts ? &amp;opts : <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"write header to "</span> &lt;&lt; destUrl &lt;&lt; <span class="string">" failed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建创建AVPacket接收数据包</span></span><br><span class="line"><span class="comment">// 无论是压缩的音频流还是压缩的视频流,都是由一个个数据包组成的</span></span><br><span class="line"><span class="comment">// 解码的过程实际就是从文件流中读取一个个数据包传给解码器去解码</span></span><br><span class="line"><span class="comment">// 对于视频，它通常应包含一个压缩帧</span></span><br><span class="line"><span class="comment">// 对于音频，它可能是一段压缩音频、包含多个压缩帧</span></span><br><span class="line"><span class="comment">// 在不需要的时候可以通过av_packet_free释放</span></span><br><span class="line">packet = av_packet_alloc();</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == packet) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"can't alloc packet"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件流里面读取出数据包,这里的数据包是编解码层的压缩数据</span></span><br><span class="line"><span class="keyword">while</span>(av_read_frame(inputFormatContext, packet) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 我们以视频轨道为基准去同步时间</span></span><br><span class="line">    <span class="comment">// 如果时间还没有到就添加延迟,避免向服务器推流速度过快</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往输出流写入数据</span></span><br><span class="line">    av_interleaved_write_frame(outputFormatContext, packet);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入成之后压缩数据包的数据就不需要了,将它释放</span></span><br><span class="line">    av_packet_unref(packet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入视频尾部信息</span></span><br><span class="line">av_write_trailer(outputFormatContext);</span><br></pre></td></tr></table></figure>

<h2 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h2><p>由于av_read_frame这里读取出来的是未解码的压缩数据速度很快,如果不做控制一下子就发送完成了,会造成数据堆积在服务器上。这里我们忽略网络传输耗时,依然通过视频包的pts做一定的同步:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(av_read_frame(inputFormatContext, packet) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 我们以视频轨道为基准去同步时间</span></span><br><span class="line">    <span class="comment">// 如果时间还没有到就添加延迟,避免向服务器推流速度过快</span></span><br><span class="line">    <span class="keyword">if</span>(videoStreamIndex == packet-&gt;stream_index) &#123;</span><br><span class="line">        <span class="keyword">if</span>(AV_NOPTS_VALUE == packet-&gt;pts) &#123;</span><br><span class="line">            <span class="comment">// 有些视频流不带pts数据,按30fps将间隔统一成32ms</span></span><br><span class="line">            av_usleep(<span class="number">32000</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 带pts数据的视频流,我们计算出每一帧应该在什么时候播放</span></span><br><span class="line">            <span class="keyword">int64_t</span> nowTime = av_gettime() - startTime;</span><br><span class="line">            <span class="keyword">int64_t</span> pts = packet-&gt;pts * <span class="number">1000</span> * <span class="number">1000</span> * timeBaseFloat;</span><br><span class="line">            <span class="keyword">if</span>(pts &gt; nowTime) &#123;</span><br><span class="line">                av_usleep(pts - nowTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往输出流写入数据</span></span><br><span class="line">    av_interleaved_write_frame(outputFormatContext, packet);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入成之后压缩数据包的数据就不需要了,将它释放</span></span><br><span class="line">    av_packet_unref(packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="资源释放"><a href="#资源释放" class="headerlink" title="资源释放"></a>资源释放</h2><p>等视频流读写完成之后就是最后的资源释放收尾工作了:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> != packet) &#123;</span><br><span class="line">    av_packet_free(&amp;packet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> != outputFormatContext) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != outputFormatContext-&gt;pb) &#123;</span><br><span class="line">        avio_close(outputFormatContext-&gt;pb);</span><br><span class="line">    &#125;</span><br><span class="line">    avformat_free_context(outputFormatContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> != inputFormatContext) &#123;</span><br><span class="line">    avformat_close_input(&amp;inputFormatContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="https://github.com/bluesky466/FFmpegDemo/blob/main/video_sender.cpp" target="_blank" rel="noopener">源码</a>和上篇博客的是同一个<a href="https://github.com/bluesky466/FFmpegDemo" target="_blank" rel="noopener">仓库</a>,编译之后可以通过-s参数推流到服务器:</p>
<blockquote>
<p>./demo -s video.flv rtmp://服务器ip/live/livestream</p>
</blockquote>
<p>推流的同时就能使用-p参数去拉流进行实时播放:</p>
<blockquote>
<p>./demo -p rtmp://服务器ip/live/livestream</p>
</blockquote>
<p>这个demo只是简单的将本地视频文件推到服务器,实际上我们可以对他做些修改就能实现将摄像头的视频流推到服务器了。</p>

    
  </div>
</article>

</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    




  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235687', function() {
      // load success
    });
  }
</script>

  <footer style="flex: 0 0 auto;text-align: center;">
<a style="font-size:12px; color:#6C6C6C" target="_blank">© 2021  林嘉伟 ❤ <a style="font-size:12px; color:#6C6C6C" target="_blank" href="http://beian.miit.gov.cn/" rel="nofollow">粤ICP备2021021473号</a></footer>
</body>
</html>
