<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>安卓特效相机(三) OpenGL ES 特效渲染 | LinJW</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Android,技术相关," />
  

  <meta name="description" content="系列文章:
安卓特效相机(一) Camera2的使用安卓特效相机(二) EGL基础安卓特效相机(三) OpenGL ES 特效渲染安卓特效相机(四) 视频录制
特效的实现原理接下来这篇文章我们讲下特效的具体实现原理。
由于预览画面的渲染是将Surface传给CameraDevice由它去绘制的,而且我没有找到什么可以接管或者添加渲染效果的接口,所以并不能直接去处理摄像头的画面。
于是这里我们只能用">
<meta property="og:type" content="article">
<meta property="og:title" content="安卓特效相机(三) OpenGL ES 特效渲染">
<meta property="og:url" content="http://139.199.4.241/2019/09/22/安卓特效相机-三-OpenGL-ES-特效渲染/index.html">
<meta property="og:site_name" content="LinJW">
<meta property="og:description" content="系列文章:
安卓特效相机(一) Camera2的使用安卓特效相机(二) EGL基础安卓特效相机(三) OpenGL ES 特效渲染安卓特效相机(四) 视频录制
特效的实现原理接下来这篇文章我们讲下特效的具体实现原理。
由于预览画面的渲染是将Surface传给CameraDevice由它去绘制的,而且我没有找到什么可以接管或者添加渲染效果的接口,所以并不能直接去处理摄像头的画面。
于是这里我们只能用">
<meta property="og:image" content="http://139.199.4.241/安卓特效相机三/5.png">
<meta property="og:image" content="http://139.199.4.241/安卓特效相机三/4.jpeg">
<meta property="og:image" content="http://139.199.4.241/安卓特效相机三/6.png">
<meta property="og:image" content="http://139.199.4.241/安卓特效相机三/1.png">
<meta property="og:image" content="http://139.199.4.241/安卓特效相机三/2.png">
<meta property="og:image" content="http://139.199.4.241/安卓特效相机三/3.png">
<meta property="og:image" content="http://139.199.4.241/安卓特效相机三/7.png">
<meta property="og:image" content="http://139.199.4.241/安卓特效相机三/8.png">
<meta property="og:image" content="http://139.199.4.241/安卓特效相机三/9.png">
<meta property="og:image" content="http://139.199.4.241/安卓特效相机三/10.png">
<meta property="og:image" content="http://139.199.4.241/安卓特效相机三/11.png">
<meta property="og:image" content="http://139.199.4.241/安卓特效相机三/12.png">
<meta property="og:updated_time" content="2019-10-14T14:06:52.280Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="安卓特效相机(三) OpenGL ES 特效渲染">
<meta name="twitter:description" content="系列文章:
安卓特效相机(一) Camera2的使用安卓特效相机(二) EGL基础安卓特效相机(三) OpenGL ES 特效渲染安卓特效相机(四) 视频录制
特效的实现原理接下来这篇文章我们讲下特效的具体实现原理。
由于预览画面的渲染是将Surface传给CameraDevice由它去绘制的,而且我没有找到什么可以接管或者添加渲染效果的接口,所以并不能直接去处理摄像头的画面。
于是这里我们只能用">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css" type="text/css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#u7279_u6548_u7684_u5B9E_u73B0_u539F_u7406"><span class="toc-text">特效的实现原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OpenGL_u5B9E_u73B0"><span class="toc-text">OpenGL实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#u9876_u70B9_u7740_u8272_u5668"><span class="toc-text">顶点着色器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u7247_u5143_u9876_u70B9_u7740_u8272_u5668"><span class="toc-text">片元顶点着色器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u521B_u5EFA_u6E32_u67D3_u5668"><span class="toc-text">创建渲染器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#glViewport"><span class="toc-text">glViewport</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u586B_u5145_u9876_u70B9_u4FE1_u606F"><span class="toc-text">填充顶点信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u586B_u5145_u989C_u8272_u7279_u6548_u77E9_u9635"><span class="toc-text">填充颜色特效矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u7EB9_u7406_u53D8_u6362_u77E9_u9635"><span class="toc-text">纹理变换矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u521B_u5EFA_u7EB9_u7406_u7ED8_u5236_u6444_u50CF_u5934_u753B_u9762"><span class="toc-text">创建纹理绘制摄像头画面</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#u7ED8_u5236_u4E0E_u53CC_u7F13_u51B2"><span class="toc-text">绘制与双缓冲</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#u5B8C_u6574_u4EE3_u7801"><span class="toc-text">完整代码</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-安卓特效相机-三-OpenGL-ES-特效渲染" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">安卓特效相机(三) OpenGL ES 特效渲染</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2019.09.22</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>林嘉伟</span>
        </span>
      

      


      
        <span>
          <i class="icon-comment"></i>
          <a href="http://blog.islinjw.cn/2019/09/22/安卓特效相机-三-OpenGL-ES-特效渲染/#disqus_thread"></a>
        </span>
      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      

      
      
    </div>
  </header>

  <div class="article-content">
    
      <p>系列文章:</p>
<p><a href="http://blog.islinjw.cn/2019/08/27/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%B8%80-Camera2%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">安卓特效相机(一) Camera2的使用</a><br><a href="http://blog.islinjw.cn/2019/09/13/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%BA%8C-EGL%E5%9F%BA%E7%A1%80/" target="_blank" rel="external">安卓特效相机(二) EGL基础</a><br><a href="http://blog.islinjw.cn/2019/09/22/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%B8%89-OpenGL-ES-%E7%89%B9%E6%95%88%E6%B8%B2%E6%9F%93/" target="_blank" rel="external">安卓特效相机(三) OpenGL ES 特效渲染</a><br><a href="http://blog.islinjw.cn/2019/10/09/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E5%9B%9B-%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/" target="_blank" rel="external">安卓特效相机(四) 视频录制</a></p>
<h1 id="u7279_u6548_u7684_u5B9E_u73B0_u539F_u7406"><a href="#u7279_u6548_u7684_u5B9E_u73B0_u539F_u7406" class="headerlink" title="特效的实现原理"></a>特效的实现原理</h1><p>接下来这篇文章我们讲下特效的具体实现原理。</p>
<p>由于预览画面的渲染是将Surface传给CameraDevice由它去绘制的,而且我没有找到什么可以接管或者添加渲染效果的接口,所以并不能直接去处理摄像头的画面。</p>
<p>于是这里我们只能用一种游戏中常用的手段去处理,这种手段的名字叫做RTT(render to texture),中文名叫做渲染到纹理。</p>
<p>玩法是先将我们想要处理的画面,不直接绘制到屏幕,而是绘制成一张图片,然后我们再拿这张图片去做一些特殊的处理,或者特殊的用途:</p>
<img src="/安卓特效相机三/5.png">
<p>例如游戏中水面的倒影一种比较古老的实现方法就是先将岸上的画面绘制成一张图片,然后倒过来然后做一些扭曲、模糊、淡化等处理,然后贴到水面上。</p>
<p>又例如下面这种狙击镜的实现原理就是先将摄像头位置调到远处,将远处的画面绘制到一张贴图上,然后将摄像头位置再调回角色处,把刚刚得到的远处的画面的图片直接贴到狙击镜上:</p>
<img src="/安卓特效相机三/4.jpeg">
<p>所以在这个特效相机的例子里面我们的实现原理如下:</p>
<img src="/安卓特效相机三/6.png">
<h1 id="OpenGL_u5B9E_u73B0"><a href="#OpenGL_u5B9E_u73B0" class="headerlink" title="OpenGL实现"></a>OpenGL实现</h1><p>我们使用OpenGL ES 2.0版本,这个版本要求我们用GLSL实现顶点着色器和片元着色器。这两个着色器其实是两个运行在GPU的程序。</p>
<p>GLSL全称是OpenGL Shading Language即OpenGL着色语言,它在语法上和C语言有点像。只是看的话相信大家都能看懂,我就不仔细介绍语法了。</p>
<p>OpenGL可编程渲染管线的整个流程比较复杂,作为初学者我们只要理解其中的顶点着色器和和片元着色器就可以了。简单来讲就是OpenGL会在顶点着色器确定顶点的位置,然后这些顶点连起来就是我们想要的图形。接着在片元着色器里面给这些图形上色:</p>
<img src="/安卓特效相机三/1.png">
<p>我们直接看看两个着色器的代码。</p>
<h2 id="u9876_u70B9_u7740_u8272_u5668"><a href="#u9876_u70B9_u7740_u8272_u5668" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><p>OpenGL会将每个顶点的坐标传递给顶点着色器,我们可以在这里改变顶点的位置。例如我们给每个顶点都加上一个偏移,就能实现整个图形的移动。</p>
<p>在这个demo里面我们不改变顶点的坐标,只是简单的将它从二维转换成四维。现实世界里面都是三维的,那为什么要装换成四维呢?原因是我们可以用4*4的矩阵对坐标进行旋转、缩放、平移等变换,但是4*4的矩阵只能和四维向量相乘,所以需要在xyz之外加多一个维度,我们一般情况下直接把这个维度的值设成1就好。然后将计算得到的四维坐标放到gl_Position作为最终结果值:</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">attribute</span> <span class="keyword">vec2</span> vPosition;</span><br><span class="line"><span class="keyword">attribute</span> <span class="keyword">vec2</span> vCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">varying</span> <span class="keyword">vec2</span> vPreviewCoord;</span><br><span class="line"><span class="keyword">uniform</span> <span class="keyword">mat4</span> matTransform;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="keyword">vec4</span>(vPosition, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    vPreviewCoord = (matTransform * <span class="keyword">vec4</span>(vCoord.xy, <span class="number">0</span>, <span class="number">1</span>)).xy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后除了vPosition这个顶点的坐标,大家还会看到vCoord,它是纹理坐标。什么是纹理坐标呢?</p>
<p>纹理其实可以理解成图片,我们将图片的左下角定义成原点(0,0),左上角、右上角、右下角分别为(0,1)、(1,1)、(1,0):</p>
<img src="/安卓特效相机三/2.png">
<p>我们的每个顶点,除了携带顶点坐标之外,还携带了纹理坐标的信息,顶点坐标确定了这个图形的形状,而纹理坐标则确定贴图要怎么样贴到这个图形上。然后在片元着色器里面就可以根据这个纹理坐标去给图形贴上贴图了:</p>
<img src="/安卓特效相机三/3.png">
<p>不过看到代码可以看到,我们这里还用matTransform这个矩阵对纹理坐标进行了变换。这里是由于我们的图片不是普通的图片,而是将摄像头的画面画到另外一个surface之后拿过来的,需要进行变换。这块等下再仔细讲解。</p>
<h2 id="u7247_u5143_u9876_u70B9_u7740_u8272_u5668"><a href="#u7247_u5143_u9876_u70B9_u7740_u8272_u5668" class="headerlink" title="片元顶点着色器"></a>片元顶点着色器</h2><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#extension GL_OES_EGL_image_external : require</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">highp</span> <span class="keyword">float</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">varying</span> <span class="keyword">vec2</span> vPreviewCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> samplerExternalOES texPreview;</span><br><span class="line"><span class="keyword">uniform</span> <span class="keyword">mat4</span> uColorMatrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = uColorMatrix * <span class="built_in">texture2D</span>(texPreview, vPreviewCoord).rgba;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>片元着色器就比较简单了,第一行是由于我们使用了samplerExternalOES需要开启特殊配置,这个是由于在安卓上我们只能用samplerExternalOES类型的纹理去接收摄像头的画面,而使用samplerExternalOES需要开启GL_OES_EGL_image_external功能。</p>
<p>然后这个texPreview就是我们摄像头画面绘制成的那张图片了,我们用texture2D这个方法去读取图片某个像素的颜色值,它的第一个参数就是我们的纹理,第二个参数就是我们的纹理坐标,也就是上一步顶点着色器计算的到的纹理坐标:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vPreviewCoord = (matTransform * vec4(vCoord.xy, 0, 1)).xy<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这里有同学可能会疑问我们在顶点着色器不是只计算了顶点的纹理坐标吗?那图形边上和内部的纹理坐标又是怎么来的呢?</p>
<p>没错顶点着色器只是处理顶点的,有多少个顶点,顶点着色器就会执行多少次,处理完所有的顶点之后,我们将值传给varying类型的变量,OpenGL就会帮我们对varying变量做插值,计算出图像上每个像素对应的纹理坐标,然后每个像素都会调用片元着色器去处理。于是运行完所有像素的片元着色器之后整个图像就显示出来了:</p>
<img src="/安卓特效相机三/7.png">
<p>通过texture2D函数获得这个像素在预览画面对应的颜色值之后我们再用一个特效处理矩阵去和它相乘做特效处理。例如黑白、怀旧、反相的处理就是不同的矩阵去和这个颜色相乘,得到最终显示出来的颜色。</p>
<p>例如一个颜色(r,g,b)反相效果其实就是(1.0-r, 1.0-b, 1.0-f),所以我们可以用这个矩阵去和像素颜色相乘:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">1.0f</span>  <span class="number">0.0f</span>  <span class="number">0.0f</span> <span class="number">1.0f</span></span><br><span class="line"> <span class="number">0.0f</span> -<span class="number">1.0f</span>  <span class="number">0.0f</span> <span class="number">1.0f</span></span><br><span class="line"> <span class="number">0.0f</span>  <span class="number">0.0f</span> -<span class="number">1.0f</span> <span class="number">1.0f</span></span><br><span class="line"> <span class="number">0.0f</span>  <span class="number">0.0f</span>  <span class="number">0.0f</span> <span class="number">1.0f</span></span><br></pre></td></tr></table></figure>
<p>至于原理的话不知道大家记不记得线性代数的知识:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">1.0f</span>  <span class="number">0.0f</span>  <span class="number">0.0f</span> <span class="number">1.0f</span>         r       -r + a</span><br><span class="line"> <span class="number">0.0f</span> -<span class="number">1.0f</span>  <span class="number">0.0f</span> <span class="number">1.0f</span>    *    g   =   -g + a</span><br><span class="line"> <span class="number">0.0f</span>  <span class="number">0.0f</span> -<span class="number">1.0f</span> <span class="number">1.0f</span>         b       -b + a</span><br><span class="line"> <span class="number">0.0f</span>  <span class="number">0.0f</span>  <span class="number">0.0f</span> <span class="number">1.0f</span>         a       a</span><br></pre></td></tr></table></figure>
<p>然后我们把alpha通道设置成1,0,就是[1.0-r, 1.0-g, 1.0-b, 1.0]就是(r,g,b,1)的反相颜色了。</p>
<p>其他的效果类似的,我这边列出两个特效矩阵给大家用:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去色效果矩阵</span></span><br><span class="line"><span class="number">0.299f</span> <span class="number">0.587f</span> <span class="number">0.114f</span> <span class="number">0.0f</span></span><br><span class="line"><span class="number">0.299f</span> <span class="number">0.587f</span> <span class="number">0.114f</span> <span class="number">0.0f</span></span><br><span class="line"><span class="number">0.299f</span> <span class="number">0.587f</span> <span class="number">0.114f</span> <span class="number">0.0f</span></span><br><span class="line"><span class="number">0.0f</span>   <span class="number">0.0f</span>   <span class="number">0.0f</span>   <span class="number">1.0f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 怀旧效果矩阵</span></span><br><span class="line"><span class="number">0.393f</span> <span class="number">0.769f</span> <span class="number">0.189f</span> <span class="number">0.0f</span></span><br><span class="line"><span class="number">0.349f</span> <span class="number">0.686f</span> <span class="number">0.168f</span> <span class="number">0.0f</span></span><br><span class="line"><span class="number">0.272f</span> <span class="number">0.534f</span> <span class="number">0.131f</span> <span class="number">0.0f</span></span><br><span class="line"><span class="number">0.0f</span>   <span class="number">0.0f</span>   <span class="number">0.0f</span>   <span class="number">1.0f</span></span><br></pre></td></tr></table></figure>
<h2 id="u521B_u5EFA_u6E32_u67D3_u5668"><a href="#u521B_u5EFA_u6E32_u67D3_u5668" class="headerlink" title="创建渲染器"></a>创建渲染器</h2><p>我们写好顶点着色器和片元着色器之后要让他们在我们的OpenGL程序里面运行。</p>
<p>我们可以用下面代码创建着色器</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> <span class="built_in">loadShader</span>(<span class="built_in">int</span> shaderType, InputStream source) &#123;</span><br><span class="line">        <span class="comment">// 读取着色器代码</span></span><br><span class="line">        <span class="keyword">String</span> sourceStr;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sourceStr = readStringFromStream(source);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"read shaderType "</span> + shaderType + <span class="string">" source failed"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建着色器并且编译</span></span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">shader</span> = GLES20.glCreateShader(shaderType); <span class="comment">// 创建着色器程序</span></span><br><span class="line">        GLES20.glShaderSource(<span class="built_in">shader</span>, sourceStr); <span class="comment">// 加载着色器源码</span></span><br><span class="line">        GLES20.glCompileShader(<span class="built_in">shader</span>); <span class="comment">// 编译着色器程序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查编译是否出现异常</span></span><br><span class="line">        <span class="built_in">int</span>[] compiled = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">1</span>];</span><br><span class="line">        GLES20.glGetShaderiv(<span class="built_in">shader</span>, GLES20.GL_COMPILE_STATUS, compiled, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (compiled[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">String</span> <span class="built_in">log</span> = GLES20.glGetShaderInfoLog(<span class="built_in">shader</span>);</span><br><span class="line">            GLES20.glDeleteShader(<span class="built_in">shader</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"create shaderType "</span> + shaderType + <span class="string">" failed : "</span> + <span class="built_in">log</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shader</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>它最关键的其实就是中间这三行代码:</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">shader</span> = GLES20.glCreateShader(shaderType); <span class="comment">// 创建着色器程序</span></span><br><span class="line">GLES20.glShaderSource(<span class="built_in">shader</span>, sourceStr); <span class="comment">// 加载着色器源码</span></span><br><span class="line">GLES20.glCompileShader(<span class="built_in">shader</span>); <span class="comment">// 编译着色器程序</span></span><br></pre></td></tr></table></figure>
<p>在GLES20.glCreateShader的时候需要指定着色器类型,顶点着色器(GLES20.GL_VERTEX_SHADER)或者片元着色器(GLES20.GL_FRAGMENT_SHADER)创建出来的着色器程序需要链接到我们的渲染程序当中:</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> createProgram(InputStream vShaderSource, InputStream fShaderSource) &#123;</span><br><span class="line">    // 创建渲染程序</span><br><span class="line">    <span class="built_in">int</span> <span class="function"><span class="keyword">program</span></span> = GLES20.glCreateProgram();</span><br><span class="line">    GLES20.glAttachShader(<span class="function"><span class="keyword">program</span></span>, loadShader(GLES20.GL_VERTEX_SHADER, vShaderSource));</span><br><span class="line">    GLES20.glAttachShader(<span class="function"><span class="keyword">program</span></span>, loadShader(GLES20.GL_FRAGMENT_SHADER, fShaderSource));</span><br><span class="line">    GLES20.glLinkProgram(<span class="function"><span class="keyword">program</span></span>);</span><br><span class="line"></span><br><span class="line">    // 检查链接是否出现异常</span><br><span class="line">    <span class="built_in">int</span>[] linked = new <span class="built_in">int</span>[<span class="number">1</span>];</span><br><span class="line">    GLES20.glGetProgramiv(<span class="function"><span class="keyword">program</span></span>, GLES20.GL_LINK_STATUS, linked, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (linked[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        String <span class="built_in">log</span> = GLES20.glGetProgramInfoLog(<span class="function"><span class="keyword">program</span></span>);</span><br><span class="line">        GLES20.glDeleteProgram(<span class="function"><span class="keyword">program</span></span>);</span><br><span class="line">        throw new RuntimeException(<span class="string">"link program failed : "</span> + <span class="built_in">log</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">program</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后调用GLES20.glUseProgram方法使用创建的渲染程序:</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AssetManager asset = context.getAssets();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    mProgram = createProgram(asset.<span class="built_in">open</span>(VERTICES_SHADER), asset.<span class="built_in">open</span>(FRAGMENT_SHADER));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"can't open shader"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">GLES20.glUseProgram(mProgram);</span><br></pre></td></tr></table></figure>
<h2 id="glViewport"><a href="#glViewport" class="headerlink" title="glViewport"></a>glViewport</h2><p>这里有个比较重要的方法要先讲一下,GLES20.glViewport定义了视窗的位置。</p>
<p>OpenGL虽然是在Surface上绘制,但我们可以不铺满整个Surface,可以只在它的某部分绘制，例如我们可以用下面代码只用TextureSurface的左下角的四分之一去显示OpenGL的画面:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//width、height是TextureView的宽高</span></span><br><span class="line">GLES20.glViewport(<span class="number">0</span>, <span class="number">0</span>, width/<span class="number">2</span>, height/<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<img src="/安卓特效相机三/8.png">
<p>当然一般情况下我们都是铺满整个Surface</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLES20.glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br></pre></td></tr></table></figure>
<h2 id="u586B_u5145_u9876_u70B9_u4FE1_u606F"><a href="#u586B_u5145_u9876_u70B9_u4FE1_u606F" class="headerlink" title="填充顶点信息"></a>填充顶点信息</h2><p>从顶点着色器代码来看,我们的顶点携带了两种信息,一个是顶点的坐标、一个是纹理坐标:</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">attribute</span> <span class="keyword">vec2</span> vPosition;</span><br><span class="line"><span class="keyword">attribute</span> <span class="keyword">vec2</span> vCoord;</span><br></pre></td></tr></table></figure>
<p>在java代码中,glUseProgram之后我们可以这样拿到他们的id:</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">mPositionId = <span class="value">GLES20.glGetAttribLocation(mProgram, <span class="string">"vPosition"</span>);</span></span></span><br><span class="line"><span class="setting">mCoordId = <span class="value">GLES20.glGetAttribLocation(mProgram, <span class="string">"vCoord"</span>);</span></span></span><br></pre></td></tr></table></figure>
<p>然后就可以通过这两个id,去给这两个变量填充值了。那具体要填充些什么值呢?</p>
<p>在OpenGL中,三角形是基本图形,任何的图形都可以由三角形组合而来。我们的TextureView其实是一个矩形,它可以由两个三角形组成。但是这个矩形的坐标应该设置成多少呢?</p>
<p>默认情况下当我们设置一个顶点的x=0,y=0的时候它就在OpenGL画面的中心,x轴正方向在右边,y轴正方向在上边,画面的上下左右分别是y=1、y=-1、x=-1、x=1:</p>
<img src="/安卓特效相机三/9.png">
<p>无论z坐标是多少都会忽略,只会管x,y坐标。有同学可能会疑惑,OpenGL不是可以处理三维图形运算的吗?<br>没错,但是OpenGL ES 2.0将整个三维运算都交给了我们,我们需要自己去乘观察矩阵和投影矩阵才能得到三维的效果,这块比较复杂这里就不讲了。我们不去乘的话OpenGL就变成了上面说的这样。</p>
<p>好了现在可以定义我们的顶点的坐标了:</p>
<img src="/安卓特效相机三/10.png">
<p>我们当然可以用六个点去定义两个三角形:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span>[] VERTICES = &#123;</span><br><span class="line">        <span class="comment">// 左下角三角形</span></span><br><span class="line">        -<span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        -<span class="number">1.0f</span>, -<span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">1.0f</span>, -<span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右上角三角形</span></span><br><span class="line">        <span class="number">1.0f</span>, -<span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        -<span class="number">1.0f</span>, <span class="number">1.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是这样的话有两个交点被重复定义了,占用内存比较多,更多情况下我们会用四个点,然后再加一个序号数组去标识三角形的顶点:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">float</span>[] VERTICES = &#123;</span><br><span class="line">        -<span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        -<span class="number">1.0f</span>, -<span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">1.0f</span>, -<span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">1.0f</span>, <span class="number">1.0f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">short</span>[] ORDERS = &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="comment">// 左下角三角形</span></span><br><span class="line"></span><br><span class="line">        <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>  <span class="comment">// 右上角三角形</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>设置顶点坐标的代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mVertices = CommonUtils.toFloatBuffer(VERTICES);</span><br><span class="line">GLES20.glVertexAttribPointer(mPositionId, <span class="number">2</span>, GLES20.GL_FLOAT, <span class="literal">false</span>, <span class="number">0</span>, mVertices);</span><br><span class="line">GLES20.glEnableVertexAttribArray(mPositionId);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FloatBuffer <span class="title">toFloatBuffer</span><span class="params">(<span class="keyword">float</span>[] data)</span> </span>&#123;</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocateDirect(data.length * <span class="number">4</span>);</span><br><span class="line">    buffer.order(ByteOrder.nativeOrder());</span><br><span class="line">    FloatBuffer floatBuffer = buffer.asFloatBuffer();</span><br><span class="line">    floatBuffer.put(data);</span><br><span class="line">    floatBuffer.position(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> floatBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>纹理坐标同理:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">float</span>[] TEXTURE_COORDS = &#123;</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">1.0f</span>, <span class="number">1.0f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">mCoords = CommonUtils.toFloatBuffer(TEXTURE_COORDS);</span><br><span class="line">GLES20.glVertexAttribPointer(mCoordId, <span class="number">2</span>, GLES20.GL_FLOAT, <span class="literal">false</span>, <span class="number">0</span>, mCoords);</span><br><span class="line">GLES20.glEnableVertexAttribArray(mCoordId);</span><br></pre></td></tr></table></figure>
<h2 id="u586B_u5145_u989C_u8272_u7279_u6548_u77E9_u9635"><a href="#u586B_u5145_u989C_u8272_u7279_u6548_u77E9_u9635" class="headerlink" title="填充颜色特效矩阵"></a>填充颜色特效矩阵</h2><p>片元着色器中的uColorMatrix的设置类似,只不过由于它是uniform类型的变量,我们用GLES20.glUniformMXXXX去设置:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span>[] COLOR_MATRIX = &#123;</span><br><span class="line">    -<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, -<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">0.0f</span>, -<span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">mColorMatrixId = GLES20.glGetUniformLocation(mProgram, <span class="string">"uColorMatrix"</span>);</span><br><span class="line"></span><br><span class="line">GLES20.glUniformMatrix4fv(mColorMatrixId, <span class="number">1</span>, <span class="literal">true</span>, COLOR_MATRIX, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>glUniformMatrix4fv方法的第三个参数比较值得注意,这里我们填了true，代表需要转置,这是由于OpenGL的矩阵是列优先的:</p>
<img src="/安卓特效相机三/11.png">
<p>因为我们的COLOR_MATRIX是一个一维数组,其实实际上是这样的:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">float</span>[] COLOR_MATRIX = &#123;-<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, -<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, -<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>它去到GPU之后设置给uColorMatrix得到了这个4*4的矩阵:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"> <span class="number">0.0f</span>, -<span class="number">1.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"> <span class="number">0.0f</span>,  <span class="number">0.0f</span>, -<span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"> <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span></span><br></pre></td></tr></table></figure>
<p>所以我们需要给他做转置操作得到：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"><span class="number">0.0f</span>, -<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"><span class="number">0.0f</span>, <span class="number">0.0f</span>, -<span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"><span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br></pre></td></tr></table></figure>
<h2 id="u7EB9_u7406_u53D8_u6362_u77E9_u9635"><a href="#u7EB9_u7406_u53D8_u6362_u77E9_u9635" class="headerlink" title="纹理变换矩阵"></a>纹理变换矩阵</h2><p>在顶点着色器里面我们讲到了matTransform这个变换矩阵用于变换纹理坐标,它是从SurfaceTexture里面拿到的:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">float</span>[] mTransformMatrix = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">16</span>];</span><br><span class="line">...</span><br><span class="line">mPreviewTexutre.getTransformMatrix(mTransformMatrix);</span><br><span class="line">...</span><br><span class="line">mTransformMatrixId = GLES20.glGetUniformLocation(mProgram, <span class="string">"matTransform"</span>);</span><br><span class="line">...</span><br><span class="line">GLES20.glUniformMatrix4fv(mTransformMatrixId, <span class="number">1</span>, <span class="literal">false</span>, matrix, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>SurfaceTexture从哪里来的我们等下再说,我们的摄像头就是往这里绘制画面。可以用getTransformMatrix方法得到变换矩阵:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Retrieve <span class="keyword">the</span> <span class="number">4</span>x4 texture coordinate transform matrix associated <span class="keyword">with</span> <span class="keyword">the</span> texture image <span class="keyword">set</span> <span class="keyword">by</span></span><br><span class="line">    * <span class="keyword">the</span> most recent call <span class="keyword">to</span> updateTexImage.</span><br><span class="line">    *</span><br><span class="line">    * This transform matrix maps <span class="number">2</span>D homogeneous texture coordinates <span class="keyword">of</span> <span class="keyword">the</span> form (s, t, <span class="number">0</span>, <span class="number">1</span>) <span class="keyword">with</span> s</span><br><span class="line">    * <span class="keyword">and</span> t <span class="keyword">in</span> <span class="keyword">the</span> inclusive range [<span class="number">0</span>, <span class="number">1</span>] <span class="keyword">to</span> <span class="keyword">the</span> texture coordinate <span class="keyword">that</span> should be used <span class="keyword">to</span> sample</span><br><span class="line">    * <span class="keyword">that</span> location <span class="keyword">from</span> <span class="keyword">the</span> texture.  Sampling <span class="keyword">the</span> texture outside <span class="keyword">of</span> <span class="keyword">the</span> range <span class="keyword">of</span> this transform</span><br><span class="line">    * <span class="keyword">is</span> undefined.</span><br><span class="line">    *</span><br><span class="line">    * The matrix <span class="keyword">is</span> stored <span class="keyword">in</span> column-major order so <span class="keyword">that</span> <span class="keyword">it</span> may be passed directly <span class="keyword">to</span> OpenGL ES via</span><br><span class="line">    * <span class="keyword">the</span> glLoadMatrixf <span class="keyword">or</span> glUniformMatrix4fv functions.</span><br><span class="line">    *</span><br><span class="line">    * @param mtx <span class="keyword">the</span> array <span class="keyword">into</span> which <span class="keyword">the</span> <span class="number">4</span>x4 matrix will be stored.  The array must have exactly</span><br><span class="line">    *     <span class="number">16</span> elements.</span><br><span class="line">    */</span><br><span class="line">   public void getTransformMatrix(float[] mtx) &#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>它返回4*4的纹理坐标变换矩阵:</p>
<blockquote>
<p>Retrieve the 4x4 texture coordinate transform matrix associated with the texture image</p>
</blockquote>
<p>然后它是列优先的可以直接使用不用转置:</p>
<blockquote>
<p>The matrix is stored in column-major order so that it may be passed directly to OpenGL ES via the glLoadMatrixf or glUniformMatrix4fv functions.</p>
</blockquote>
<p>所以第三个参数我们设置成false:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLES20.glUniformMatrix4fv(mTransformMatrixId, <span class="number">1</span>, <span class="literal">false</span>, matrix, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h2 id="u521B_u5EFA_u7EB9_u7406_u7ED8_u5236_u6444_u50CF_u5934_u753B_u9762"><a href="#u521B_u5EFA_u7EB9_u7406_u7ED8_u5236_u6444_u50CF_u5934_u753B_u9762" class="headerlink" title="创建纹理绘制摄像头画面"></a>创建纹理绘制摄像头画面</h2><p>我们一直说要将摄像头的画面画到图片上,那图片是怎么来的呢?并不是用安卓上常见的Bitmap去画,而是用GLES20.glGenTextures创建一张OpenGL的纹理:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTexture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mGLTextureId == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] textures = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        GLES20.glGenTextures(<span class="number">1</span>, textures, <span class="number">0</span>);</span><br><span class="line">        mGLTextureId = textures[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mGLTextureId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是创建出来就只是一个id,要怎么给摄像机去用呢?不知道大家还就不记得第一篇<a href="http://blog.islinjw.cn/2019/08/27/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%B8%80-Camera2%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">博客</a>里面讲到如何设置摄像机画面的接收Surface:</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> onSurfaceTextureAvailable(SurfaceTexture surface, <span class="built_in">int</span> <span class="variable">width</span>, <span class="built_in">int</span> <span class="variable">height</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mPreviewSurface = <span class="keyword">new</span> Surface(surface);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">CaptureRequest.Builder builder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line">builder.addTarget(mPreviewSurface);</span><br><span class="line">session.setRepeatingRequest(builder.build(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>所以我们也要将这个纹理转换成Surface放到CaptureRequest的Target里面传给CameraDevice:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mCameraTexture = new SurfaceTexture(mGLRender.getTexture())<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">CaptureRequest.Builder builder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW)<span class="comment">;</span></span><br><span class="line">builder.addTarget(mCameraTexture)<span class="comment">;</span></span><br><span class="line">session.setRepeatingRequest(builder.build(), mCaptureCallback, mHandler)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这里我们传入了个mCaptureCallback,摄像机画面绘制到纹理上之后会调用回调,我们需要在回调里面将画面上传到GPU,前面说的纹理转换矩阵也是在这个时候才去获取的:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">Override</span></span><br><span class="line">public void <span class="function">onCaptureCompleted</span>() </span>&#123;</span><br><span class="line">  <span class="tag">mCameraTexture</span><span class="class">.updateTexImage</span>();</span><br><span class="line">  <span class="tag">mCameraTexture</span><span class="class">.getTransformMatrix</span>(<span class="tag">mTransformMatrix</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有说明OpenGL ES里面只能用GL_TEXTURE_EXTERNAL_OES这种纹理去接收:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Update the texture image to the most recent frame from the image stream.  This may only be</span><br><span class="line"> * called while the OpenGL ES context that owns the texture is current on the calling thread.</span><br><span class="line"> * It will implicitly bind its texture to the GL_TEXTURE_EXTERNAL_OES texture target.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateTexImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    nativeUpdateTexImage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以我们拿到片元着色器里的texPreview之后需要将它绑定到GLES11Ext.GL_SAMPLER_EXTERNAL_OES:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mTexPreviewId = GLES20.glGetUniformLocation(mProgram, "texPreview")<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">GLES20.glActiveTexture(GLES20.GL_TEXTURE0)<span class="comment">;</span></span><br><span class="line">GLES20.glBindTexture(GLES11Ext.GL_SAMPLER_EXTERNAL_OES, mGLTextureId)<span class="comment">;</span></span><br><span class="line">GLES20.glUniform1i(mTexPreviewId, 0)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h1 id="u7ED8_u5236_u4E0E_u53CC_u7F13_u51B2"><a href="#u7ED8_u5236_u4E0E_u53CC_u7F13_u51B2" class="headerlink" title="绘制与双缓冲"></a>绘制与双缓冲</h1><p>最后的最后我们要执行绘制操作,将整个画面绘画出来:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GLES20.glClear(GLES20.GL_DEPTH_BUFFER_BIT | GLES20.GL_COLOR_BUFFER_BIT)<span class="comment">;</span></span><br><span class="line">GLES20.glDrawElements(GLES20.GL_TRIANGLES, ORDERS.length, GLES20.GL_UNSIGNED_SHORT, mOrder)<span class="comment">;</span></span><br><span class="line">EGL14.eglSwapBuffers(mEGLDisplay, mEGLSurface)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这个GLES20.glClear用于将上一帧的画面清除,要不然如果有透明通道的话两帧的画面就会重叠。<br>而GLES20.glDrawElements代表用mOrder这个顶点顺序去绘制图形,GLES20.GL_TRIANGLES代表要绘制的是三角形。</p>
<p>最后的mGLCore.swapBuffers代表交互缓冲区,这是由于OpenGL使用了双缓冲的技术。</p>
<p>什么是双缓冲呢?就是有两个缓冲区域:前台缓冲和后台缓冲。前台缓冲即我们看到的屏幕,后台缓冲则在内存当中。</p>
<p>我们会先在后台缓冲绘制图像,绘制完成之后调用EGL14.eglSwapBuffers交换两个缓冲区,原先绘制的缓冲就变成了前台缓冲,显示在屏幕上:</p>
<img src="/安卓特效相机三/12.png">
<p>为什么需要双缓冲呢?这是为了解决绘制的时候屏幕闪烁的问题。我们都知道一般手机屏幕的刷新率是60Hz，而且有些高端的手机甚至比这个更高。</p>
<p>也就是说屏幕一秒钟至少从前台缓冲中获取60次画面显示出来,如果只有一个缓冲的话,假设我们的绘制比较复杂耗时比较多,那可能屏幕会拿到画到一半的图片,就会造成闪烁。而两个缓冲的话就画到一半的图像都在后台缓冲并不会显示,只有完全画好才会交换变成前台缓冲去显示,就解决了这个闪烁的问题。</p>
<h1 id="u5B8C_u6574_u4EE3_u7801"><a href="#u5B8C_u6574_u4EE3_u7801" class="headerlink" title="完整代码"></a>完整代码</h1><p>完整代码见<a href="https://github.com/bluesky466/CameraDemo/tree/feature_shader" target="_blank" rel="external">github</a>(注意是feature_shader分支,master分支是第一篇文章的demo)</p>

    
  </div>
</article>


   

   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2019/09/13/安卓特效相机-二-EGL基础/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2019/10/09/安卓特效相机-四-视频录制/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'forsigner';
    
    var disqus_url = 'http://139.199.4.241/2019/09/22/安卓特效相机-三-OpenGL-ES-特效渲染/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//forsigner.disqus.com/count.js" async></script>



    




    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
