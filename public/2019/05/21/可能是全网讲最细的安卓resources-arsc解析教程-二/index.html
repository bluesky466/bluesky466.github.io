<!DOCTYPE html>


  <html class="light page-home">


<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>可能是全网讲最细的安卓resources.arsc解析教程(二) | LinJW</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="技术相关,Android,">
  

  <meta name="description" content="上篇博客写到,Package资源剩下的部分是由多组RES_TABLE_TYPE_SPEC_TYPE和RES_TABLE_TYPE_TYPE构成的。 一个RES_TABLE_TYPE_SPEC_TYPE后面跟着一个或者多个RES_TABLE_TYPE_TYPE构成一种类型的资源的描述(例如string类型、bool类型、dimen类型等) RES_TABLE_TYPE_SPEC_TYPE我们接着来看">
<meta name="keywords" content="技术相关,Android">
<meta property="og:type" content="article">
<meta property="og:title" content="可能是全网讲最细的安卓resources.arsc解析教程(二)">
<meta property="og:url" content="http://139.199.4.241/2019/05/21/可能是全网讲最细的安卓resources-arsc解析教程-二/index.html">
<meta property="og:site_name" content="LinJW">
<meta property="og:description" content="上篇博客写到,Package资源剩下的部分是由多组RES_TABLE_TYPE_SPEC_TYPE和RES_TABLE_TYPE_TYPE构成的。 一个RES_TABLE_TYPE_SPEC_TYPE后面跟着一个或者多个RES_TABLE_TYPE_TYPE构成一种类型的资源的描述(例如string类型、bool类型、dimen类型等) RES_TABLE_TYPE_SPEC_TYPE我们接着来看">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://139.199.4.241/可能是全网讲最细的安卓resources_arsc解析教程二/1.png">
<meta property="og:image" content="http://139.199.4.241/可能是全网讲最细的安卓resources_arsc解析教程二/2.png">
<meta property="og:updated_time" content="2019-10-14T14:06:52.274Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="可能是全网讲最细的安卓resources.arsc解析教程(二)">
<meta name="twitter:description" content="上篇博客写到,Package资源剩下的部分是由多组RES_TABLE_TYPE_SPEC_TYPE和RES_TABLE_TYPE_TYPE构成的。 一个RES_TABLE_TYPE_SPEC_TYPE后面跟着一个或者多个RES_TABLE_TYPE_TYPE构成一种类型的资源的描述(例如string类型、bool类型、dimen类型等) RES_TABLE_TYPE_SPEC_TYPE我们接着来看">
<meta name="twitter:image" content="http://139.199.4.241/可能是全网讲最细的安卓resources_arsc解析教程二/1.png">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=32204ee7" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>
</html>
<body>

  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RES-TABLE-TYPE-SPEC-TYPE"><span class="toc-text">RES_TABLE_TYPE_SPEC_TYPE</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RES-TABLE-TYPE-TYPE"><span class="toc-text">RES_TABLE_TYPE_TYPE</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ResTable-entry"><span class="toc-text">ResTable_entry</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ResTable-map-entry"><span class="toc-text">ResTable_map_entry</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#资源的id"><span class="toc-text">资源的id</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ResTable-map"><span class="toc-text">ResTable_map</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Demo"><span class="toc-text">Demo</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-可能是全网讲最细的安卓resources-arsc解析教程-二" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">可能是全网讲最细的安卓resources.arsc解析教程(二)</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2019.05.21</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>林嘉伟</span>
        </span>
      

      


      

    </div>
  </header>

  <div class="article-content">
    
      <p>上篇<a href="http://blog.islinjw.cn/2019/05/18/%E5%8F%AF%E8%83%BD%E6%98%AF%E5%85%A8%E7%BD%91%E8%AE%B2%E6%9C%80%E7%BB%86%E7%9A%84%E5%AE%89%E5%8D%93resources-arsc%E8%A7%A3%E6%9E%90%E6%95%99%E7%A8%8B-%E4%B8%80/" target="_blank" rel="noopener">博客</a>写到,Package资源剩下的部分是由多组RES_TABLE_TYPE_SPEC_TYPE和RES_TABLE_TYPE_TYPE构成的。</p>
<p>一个RES_TABLE_TYPE_SPEC_TYPE后面跟着一个或者多个RES_TABLE_TYPE_TYPE构成一种类型的资源的描述(例如string类型、bool类型、dimen类型等)</p>
<h1 id="RES-TABLE-TYPE-SPEC-TYPE"><a href="#RES-TABLE-TYPE-SPEC-TYPE" class="headerlink" title="RES_TABLE_TYPE_SPEC_TYPE"></a>RES_TABLE_TYPE_SPEC_TYPE</h1><p>我们接着来看看RES_TABLE_TYPE_SPEC_TYPE的头部结构体:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A specification of the resources defined by a particular type.</span><br><span class="line"> *</span><br><span class="line"> * There should be one of these chunks for each resource type.</span><br><span class="line"> *</span><br><span class="line"> * This structure is followed by an array of integers providing the set of</span><br><span class="line"> * configuration change flags (ResTable_config::CONFIG_*) that have multiple</span><br><span class="line"> * resources for that configuration.  In addition, the high bit is set if that</span><br><span class="line"> * resource has been made public.</span><br><span class="line"> */</span><br><span class="line">struct ResTable_typeSpec</span><br><span class="line">&#123;</span><br><span class="line">    struct ResChunk_header header;</span><br><span class="line"></span><br><span class="line">    // The type identifier this chunk is holding.  Type IDs start</span><br><span class="line">    // at 1 (corresponding to the value of the type bits in a</span><br><span class="line">    // resource identifier).  0 is invalid.</span><br><span class="line">    uint8_t id;</span><br><span class="line"></span><br><span class="line">    // Must be 0.</span><br><span class="line">    uint8_t res0;</span><br><span class="line">    // Must be 0.</span><br><span class="line">    uint16_t res1;</span><br><span class="line"></span><br><span class="line">    // Number of uint32_t entry configuration masks that follow.</span><br><span class="line">    uint32_t entryCount;</span><br><span class="line"></span><br><span class="line">    enum &#123;</span><br><span class="line">        // Additional flag indicating an entry is public.</span><br><span class="line">        SPEC_PUBLIC = 0x40000000</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从注释中可以知道ResTable_typeSpec头部后面会跟着entryCount个uint32_t,代表这种类型有entryCount个数据,并且每个uint32_t标识了这个数据在哪些configuration下有特殊的值。</p>
<p>这些configuration可能是不同的地区、不同的屏幕分辨率、不同的sdk版本等:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Flags indicating a set of config values.  These flag constants must</span><br><span class="line">// match the corresponding ones in android.content.pm.ActivityInfo and</span><br><span class="line">// attrs_manifest.xml.</span><br><span class="line">enum &#123;</span><br><span class="line">    CONFIG_MCC = ACONFIGURATION_MCC,</span><br><span class="line">    CONFIG_MNC = ACONFIGURATION_MCC,</span><br><span class="line">    CONFIG_LOCALE = ACONFIGURATION_LOCALE,</span><br><span class="line">    CONFIG_TOUCHSCREEN = ACONFIGURATION_TOUCHSCREEN,</span><br><span class="line">    CONFIG_KEYBOARD = ACONFIGURATION_KEYBOARD,</span><br><span class="line">    CONFIG_KEYBOARD_HIDDEN = ACONFIGURATION_KEYBOARD_HIDDEN,</span><br><span class="line">    CONFIG_NAVIGATION = ACONFIGURATION_NAVIGATION,</span><br><span class="line">    CONFIG_ORIENTATION = ACONFIGURATION_ORIENTATION,</span><br><span class="line">    CONFIG_DENSITY = ACONFIGURATION_DENSITY,</span><br><span class="line">    CONFIG_SCREEN_SIZE = ACONFIGURATION_SCREEN_SIZE,</span><br><span class="line">    CONFIG_SMALLEST_SCREEN_SIZE = ACONFIGURATION_SMALLEST_SCREEN_SIZE,</span><br><span class="line">    CONFIG_VERSION = ACONFIGURATION_VERSION,</span><br><span class="line">    CONFIG_SCREEN_LAYOUT = ACONFIGURATION_SCREEN_LAYOUT,</span><br><span class="line">    CONFIG_UI_MODE = ACONFIGURATION_UI_MODE,</span><br><span class="line">    CONFIG_LAYOUTDIR = ACONFIGURATION_LAYOUTDIR,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里直接举个例子,例如我们可能会在res/values目录下创建一些bool配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bool name=&quot;abc_action_bar_embed_tabs&quot;&gt;true&lt;/bool&gt;</span><br><span class="line">&lt;bool name=&quot;abc_allow_stacked_button_bar&quot;&gt;false&lt;/bool&gt;</span><br><span class="line">&lt;bool name=&quot;abc_config_actionMenuItemAllCaps&quot;&gt;true&lt;/bool&gt;</span><br></pre></td></tr></table></figure>

<p>然后可能在竖屏的情况下我们不需要显示action bar,所以在res/values-port目录下我们会把abc_action_bar_embed_tabs的值设置成false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bool name=&quot;abc_action_bar_embed_tabs&quot;&gt;false&lt;/bool&gt;</span><br></pre></td></tr></table></figure>

<p>然后下面代码就能在横屏、竖屏下拿到不同的配置了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.getResources().getBoolean(R.bool.abc_action_bar_embed_tabs);</span><br></pre></td></tr></table></figure>

<p>在代码里面,我们可以先读取ResTable_typeSpec,然后根据entryCount得到这种类型有多少个数据(例如这里的bool就有abc_action_bar_embed_tabs、abc_allow_stacked_button_bar、abc_config_actionMenuItemAllCaps三个数据,所以bool类型下的entryCount就是3),然后继续读entryCount个uint32_t,读出来就是每个数据在哪些configuration下有特殊的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//printStringFromStringsPool:</span><br><span class="line"></span><br><span class="line">void printStringFromStringsPool(uint32_t* pOffsets, char* pStringsStart, uint32_t stringIndex, uint32_t isUtf8) &#123;</span><br><span class="line">    //前面两个字节是长度,要跳过</span><br><span class="line">    char* str = pStringsStart + *(pOffsets + stringIndex) + 2;</span><br><span class="line">    if(isUtf8) &#123;</span><br><span class="line">        printf(&quot;%s\n&quot;, str);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printUtf16String((char16_t*)str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//main:</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ResTable_typeSpec typeSpecHeader;</span><br><span class="line">uint32_t config;</span><br><span class="line">uint16_t type;</span><br><span class="line">while(fread((void*)&amp;type, sizeof(u_int16_t), 1, pFile) != 0) &#123;</span><br><span class="line">    fseek(pFile, -sizeof(uint16_t), SEEK_CUR);</span><br><span class="line">    if(RES_TABLE_TYPE_SPEC_TYPE == type) &#123;</span><br><span class="line">        fread((void*)&amp;typeSpecHeader, sizeof(struct ResTable_typeSpec), 1, pFile);</span><br><span class="line">        printf(&quot;type: id=0x%x,name=&quot;, typeSpecHeader.id);</span><br><span class="line">        printStringFromStringsPool(</span><br><span class="line">                (uint32_t*)pTypeStrings,</span><br><span class="line">                (char*)pTypeStrings + typeStringPoolHeader.stringsStart - sizeof(struct ResStringPool_header),</span><br><span class="line">                typeSpecHeader.id - 1,</span><br><span class="line">                typeStringPoolHeader.flags &amp; ResStringPool_header::UTF8_FLAG</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        for(int i = 0 ; i &lt; typeSpecHeader.entryCount ; i++) &#123;</span><br><span class="line">            fread((void*)&amp;config, sizeof(uint32_t), 1, pFile);</span><br><span class="line">            printf(&quot;%x\n&quot;,config);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们直接找到bool类型下的打印:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">type:id=3,name=bool</span><br><span class="line">80</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到bool类型下的确有三个uint32_t,分别是80、0、0。这个80代表的就是CONFIG_ORIENTATION,也就是说这个数据在不同的屏幕方向下面会有和默认值不同的值。而0则代表了这个数据只有一个默认值,不会跟着configuration的变化而改变:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//configuration.h</span><br><span class="line">ACONFIGURATION_ORIENTATION = 0x0080,</span><br><span class="line"></span><br><span class="line">//ResTable_config里面的enum</span><br><span class="line">CONFIG_ORIENTATION = ACONFIGURATION_ORIENTATION,</span><br></pre></td></tr></table></figure>

<p>让我们返回去对比下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// res/values目录下</span><br><span class="line">&lt;bool name=&quot;abc_action_bar_embed_tabs&quot;&gt;true&lt;/bool&gt;</span><br><span class="line">&lt;bool name=&quot;abc_allow_stacked_button_bar&quot;&gt;false&lt;/bool&gt;</span><br><span class="line">&lt;bool name=&quot;abc_config_actionMenuItemAllCaps&quot;&gt;true&lt;/bool&gt;</span><br><span class="line"></span><br><span class="line">// res/values-port目录下</span><br><span class="line">&lt;bool name=&quot;abc_action_bar_embed_tabs&quot;&gt;false&lt;/bool&gt;</span><br></pre></td></tr></table></figure>

<p>第一个abc_action_bar_embed_tabs在不同的屏幕方向下可能值会改变,所以它的uint32_t值是80,也就是CONFIG_ORIENTATION,而abc_allow_stacked_button_bar 和abc_config_actionMenuItemAllCaps只有默认的配置,所以他们的uint32_t都是0。</p>
<p>所以RES_TABLE_TYPE_SPEC_TYPE的作用就是将数据受到哪些configuration影响都标识出来。</p>
<p>在读取数据的时候先看看它是否会受configuration影响,如果不会,直接读默认的RES_TABLE_TYPE_TYPE里面的默认值就好,否则就根据当前的configuration去到后面对应的RES_TABLE_TYPE_TYPE下面读取对应的值了。</p>
<h1 id="RES-TABLE-TYPE-TYPE"><a href="#RES-TABLE-TYPE-TYPE" class="headerlink" title="RES_TABLE_TYPE_TYPE"></a>RES_TABLE_TYPE_TYPE</h1><p>讲的这里终于到了最重要的部分,我们在xml里面配的值,都会在RES_TABLE_TYPE_TYPE里面体现出来。</p>
<p>我们照例先来看看它的头部结构体:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A collection of resource entries for a particular resource data</span><br><span class="line"> * type. Followed by an array of uint32_t defining the resource</span><br><span class="line"> * values, corresponding to the array of type strings in the</span><br><span class="line"> * ResTable_package::typeStrings string block. Each of these hold an</span><br><span class="line"> * index from entriesStart; a value of NO_ENTRY means that entry is</span><br><span class="line"> * not defined.</span><br><span class="line"> *</span><br><span class="line"> * There may be multiple of these chunks for a particular resource type,</span><br><span class="line"> * supply different configuration variations for the resource values of</span><br><span class="line"> * that type.</span><br><span class="line"> *</span><br><span class="line"> * It would be nice to have an additional ordered index of entries, so</span><br><span class="line"> * we can do a binary search if trying to find a resource by string name.</span><br><span class="line"> */</span><br><span class="line">struct ResTable_type</span><br><span class="line">&#123;</span><br><span class="line">    struct ResChunk_header header;</span><br><span class="line"></span><br><span class="line">    enum &#123;</span><br><span class="line">        NO_ENTRY = 0xFFFFFFFF</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // The type identifier this chunk is holding.  Type IDs start</span><br><span class="line">    // at 1 (corresponding to the value of the type bits in a</span><br><span class="line">    // resource identifier).  0 is invalid.</span><br><span class="line">    uint8_t id;</span><br><span class="line"></span><br><span class="line">    // Must be 0.</span><br><span class="line">    uint8_t res0;</span><br><span class="line">    // Must be 0.</span><br><span class="line">    uint16_t res1;</span><br><span class="line"></span><br><span class="line">    // Number of uint32_t entry indices that follow.</span><br><span class="line">    uint32_t entryCount;</span><br><span class="line"></span><br><span class="line">    // Offset from header where ResTable_entry data starts.</span><br><span class="line">    uint32_t entriesStart;</span><br><span class="line"></span><br><span class="line">    ResTable_config config;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个ResTable_type里有个config成员,它就是具体的配置了,我们可以把它打印出来:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">else if(RES_TABLE_TYPE_TYPE == type) &#123;</span><br><span class="line">    fread((void*)&amp;typeHeader, sizeof(struct ResTable_type), 1, pFile);</span><br><span class="line">    printConfig(typeHeader.config);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到bool的那一段,可以看到它有两个RES_TABLE_TYPE_TYPE,第一个是默认的配置(values目录),第二个是port下的配置(values-port目录):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">type: id=0x3,name=bool</span><br><span class="line">80</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">config : </span><br><span class="line">config : port</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>然后根据注释的说明我们知道,ResTable_type头部后跟着entryCount个uint32_t,代表了每个entry相对entriesStart的偏移。这里和RES_STRING_POOL_TYPE有点像,也是从偏移数组读取数据的偏移值,然后从entriesStart进行偏移得到数据的地址。</p>
<img src="/可能是全网讲最细的安卓resources_arsc解析教程二/1.png">


<p>那entriesStart后面的entry是什么呢？其实entry有两种类型ResTable_entry和ResTable_map_entry。</p>
<p>他们其实是有继承关系的,ResTable_map_entry是ResTable_entry的子类(这里的继承关系是c++里面的继承关系,前面我们都是用c语言去讲的,但是这里必须引入c++了,不过也是最基础的继承而已,大家可以自行搜索下)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * This is the beginning of information about an entry in the resource</span><br><span class="line"> * table.  It holds the reference to the name of this entry, and is</span><br><span class="line"> * immediately followed by one of:</span><br><span class="line"> *   * A Res_value structure, if FLAG_COMPLEX is -not- set.</span><br><span class="line"> *   * An array of ResTable_map structures, if FLAG_COMPLEX is set.</span><br><span class="line"> *     These supply a set of name/value mappings of data.</span><br><span class="line"> */</span><br><span class="line">struct ResTable_entry</span><br><span class="line">&#123;</span><br><span class="line">    // Number of bytes in this structure.</span><br><span class="line">    uint16_t size;</span><br><span class="line"></span><br><span class="line">    enum &#123;</span><br><span class="line">        // If set, this is a complex entry, holding a set of name/value</span><br><span class="line">        // mappings.  It is followed by an array of ResTable_map structures.</span><br><span class="line">        FLAG_COMPLEX = 0x0001,</span><br><span class="line">        // If set, this resource has been declared public, so libraries</span><br><span class="line">        // are allowed to reference it.</span><br><span class="line">        FLAG_PUBLIC = 0x0002,</span><br><span class="line">        // If set, this is a weak resource and may be overriden by strong</span><br><span class="line">        // resources of the same name/type. This is only useful during</span><br><span class="line">        // linking with other resource tables.</span><br><span class="line">        FLAG_WEAK = 0x0004</span><br><span class="line">    &#125;;</span><br><span class="line">    uint16_t flags;</span><br><span class="line"></span><br><span class="line">    // Reference into ResTable_package::keyStrings identifying this entry.</span><br><span class="line">    struct ResStringPool_ref key;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Extended form of a ResTable_entry for map entries, defining a parent map</span><br><span class="line"> * resource from which to inherit values.</span><br><span class="line"> */</span><br><span class="line">struct ResTable_map_entry : public ResTable_entry</span><br><span class="line">&#123;</span><br><span class="line">    // Resource identifier of the parent mapping, or 0 if there is none.</span><br><span class="line">    ResTable_ref parent;</span><br><span class="line">    // Number of name/value pairs that follow for FLAG_COMPLEX.</span><br><span class="line">    uint32_t count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看到注释我们可以知道, ResTable_entry有个flags成员变量,如果它的FLAG_COMPLEX位被置1(也就是说flags &amp; 0x0001 != 0),则它是个ResTable_map_entry结构。</p>
<p>两种结构的不同之处在于ResTable_entry后面跟着的是一个Res_value,而ResTable_map_entry后面跟着的是多个name/value键值对,这个键值对是用struct ResTable_map来表示的。</p>
<h2 id="ResTable-entry"><a href="#ResTable-entry" class="headerlink" title="ResTable_entry"></a>ResTable_entry</h2><p>我们先从ResTable_entry讲起,我们读完struct ResTable_type头部信息之后继续将offset数组和entriesStart开始到剩下的部分都读进去保存到pOffset和pData中。</p>
<p>接着就可以用*(pOffsets + i)得到每个entry的偏移,再与entriesStart相加得到entry的具体位置。这里有一点需要注意的是如果offset是ResTable_type::NO_ENTRY,也就是0xFFFFFFFF的时候,代表它是无效的,直接跳过即可:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">else if(RES_TABLE_TYPE_TYPE == type) &#123;</span><br><span class="line">    fread((void*)&amp;typeHeader, sizeof(struct ResTable_type), 1, pFile);</span><br><span class="line">    printConfig(typeHeader.config);</span><br><span class="line"></span><br><span class="line">    // 实际struct ResTable_type的大小可能不同sdk版本不一样,所以typeHeader.header.headerSize才是真正的头部大小</span><br><span class="line">    fseek(pFile, typeHeader.header.headerSize -  sizeof(struct ResTable_type), SEEK_CUR);;</span><br><span class="line"></span><br><span class="line">    uint32_t* pOffsets = (uint32_t*)malloc(typeHeader.entryCount * sizeof(uint32_t));</span><br><span class="line">    fread((void*)pOffsets, sizeof(uint32_t), typeHeader.entryCount, pFile);</span><br><span class="line"></span><br><span class="line">    unsigned char* pData = (unsigned char*)malloc(typeHeader.header.size - typeHeader.entriesStart);</span><br><span class="line">    fread((void*)pData, typeHeader.header.size - typeHeader.entriesStart, 1, pFile);</span><br><span class="line"></span><br><span class="line">    for(int i = 0 ; i&lt; typeHeader.entryCount ; i++) &#123;</span><br><span class="line">        uint32_t offset = *(pOffsets + i);</span><br><span class="line">        if(offset == ResTable_type::NO_ENTRY) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        struct ResTable_entry* pEntry = (struct ResTable_entry*)(pData + offset);</span><br><span class="line">        printf(&quot;entryIndex: 0x%x, key :\n&quot;, i);</span><br><span class="line">        printStringFromStringsPool(</span><br><span class="line">            (uint32_t*)pKeyStrings,</span><br><span class="line">            (char*)pKeyStrings + keyStringPoolHeader.stringsStart - sizeof(struct ResStringPool_header),</span><br><span class="line">            pEntry-&gt;key.index,</span><br><span class="line">            keyStringPoolHeader.flags &amp; ResStringPool_header::UTF8_FLAG</span><br><span class="line">        );</span><br><span class="line">        if(pEntry-&gt;flags &amp; ResTable_entry::FLAG_COMPLEX) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            struct Res_value* pValue = (struct Res_value*)((unsigned char*)pEntry + sizeof(struct ResTable_entry));</span><br><span class="line">            printf(&quot;value :\n&quot;);</span><br><span class="line">            printValue(pValue, globalStringPoolHeader, pGlobalStrings);</span><br><span class="line">            printf(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(pOffsets);</span><br><span class="line">    free(pData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pEntry-&gt;key.index就是资源的key在资源key字符串池中的序号了,直接打印即可。</p>
<p>然后找到struct ResTable_entry后面跟着的struct Res_value,这个结构体里面就是资源的值。但是这个值的获取比较复杂,我们先来看看这个结构体的定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Representation of a value in a resource, supplying type</span><br><span class="line"> * information.</span><br><span class="line"> */</span><br><span class="line">struct Res_value</span><br><span class="line">&#123;</span><br><span class="line">    // Number of bytes in this structure.</span><br><span class="line">    uint16_t size;</span><br><span class="line"></span><br><span class="line">    // Always set to 0.</span><br><span class="line">    uint8_t res0;</span><br><span class="line"></span><br><span class="line">    // Type of the data value.</span><br><span class="line">    enum &#123;</span><br><span class="line">        // The &apos;data&apos; is either 0 or 1, specifying this resource is either</span><br><span class="line">        // undefined or empty, respectively.</span><br><span class="line">        TYPE_NULL = 0x00,</span><br><span class="line">        // The &apos;data&apos; holds a ResTable_ref, a reference to another resource</span><br><span class="line">        // table entry.</span><br><span class="line">        TYPE_REFERENCE = 0x01,</span><br><span class="line">        // The &apos;data&apos; holds an attribute resource identifier.</span><br><span class="line">        TYPE_ATTRIBUTE = 0x02,</span><br><span class="line">        // The &apos;data&apos; holds an index into the containing resource table&apos;s</span><br><span class="line">        // global value string pool.</span><br><span class="line">        TYPE_STRING = 0x03,</span><br><span class="line">        // The &apos;data&apos; holds a single-precision floating point number.</span><br><span class="line">        TYPE_FLOAT = 0x04,</span><br><span class="line">        // The &apos;data&apos; holds a complex number encoding a dimension value,</span><br><span class="line">        // such as &quot;100in&quot;.</span><br><span class="line">        TYPE_DIMENSION = 0x05,</span><br><span class="line">        // The &apos;data&apos; holds a complex number encoding a fraction of a</span><br><span class="line">        // container.</span><br><span class="line">        TYPE_FRACTION = 0x06,</span><br><span class="line">        // The &apos;data&apos; holds a dynamic ResTable_ref, which needs to be</span><br><span class="line">        // resolved before it can be used like a TYPE_REFERENCE.</span><br><span class="line">        TYPE_DYNAMIC_REFERENCE = 0x07,</span><br><span class="line">        // The &apos;data&apos; holds an attribute resource identifier, which needs to be resolved</span><br><span class="line">        // before it can be used like a TYPE_ATTRIBUTE.</span><br><span class="line">        TYPE_DYNAMIC_ATTRIBUTE = 0x08,</span><br><span class="line">        </span><br><span class="line">        // Beginning of integer flavors...</span><br><span class="line">        TYPE_FIRST_INT = 0x10,</span><br><span class="line"></span><br><span class="line">        // The &apos;data&apos; is a raw integer value of the form n..n.</span><br><span class="line">        TYPE_INT_DEC = 0x10,</span><br><span class="line">        // The &apos;data&apos; is a raw integer value of the form 0xn..n.</span><br><span class="line">        TYPE_INT_HEX = 0x11,</span><br><span class="line">        // The &apos;data&apos; is either 0 or 1, for input &quot;false&quot; or &quot;true&quot; respectively.</span><br><span class="line">        TYPE_INT_BOOLEAN = 0x12,</span><br><span class="line"></span><br><span class="line">        // Beginning of color integer flavors...</span><br><span class="line">        TYPE_FIRST_COLOR_INT = 0x1c,</span><br><span class="line"></span><br><span class="line">        // The &apos;data&apos; is a raw integer value of the form #aarrggbb.</span><br><span class="line">        TYPE_INT_COLOR_ARGB8 = 0x1c,</span><br><span class="line">        // The &apos;data&apos; is a raw integer value of the form #rrggbb.</span><br><span class="line">        TYPE_INT_COLOR_RGB8 = 0x1d,</span><br><span class="line">        // The &apos;data&apos; is a raw integer value of the form #argb.</span><br><span class="line">        TYPE_INT_COLOR_ARGB4 = 0x1e,</span><br><span class="line">        // The &apos;data&apos; is a raw integer value of the form #rgb.</span><br><span class="line">        TYPE_INT_COLOR_RGB4 = 0x1f,</span><br><span class="line"></span><br><span class="line">        // ...end of integer flavors.</span><br><span class="line">        TYPE_LAST_COLOR_INT = 0x1f,</span><br><span class="line"></span><br><span class="line">        // ...end of integer flavors.</span><br><span class="line">        TYPE_LAST_INT = 0x1f</span><br><span class="line">    &#125;;</span><br><span class="line">    uint8_t dataType;</span><br><span class="line">    </span><br><span class="line">     // Structure of complex data values (TYPE_UNIT and TYPE_FRACTION)</span><br><span class="line">    enum &#123;</span><br><span class="line">        // Where the unit type information is.  This gives us 16 possible</span><br><span class="line">        // types, as defined below.</span><br><span class="line">        COMPLEX_UNIT_SHIFT = 0,</span><br><span class="line">        COMPLEX_UNIT_MASK = 0xf,</span><br><span class="line"></span><br><span class="line">        // TYPE_DIMENSION: Value is raw pixels.</span><br><span class="line">        COMPLEX_UNIT_PX = 0,</span><br><span class="line">        // TYPE_DIMENSION: Value is Device Independent Pixels.</span><br><span class="line">        COMPLEX_UNIT_DIP = 1,</span><br><span class="line">        // TYPE_DIMENSION: Value is a Scaled device independent Pixels.</span><br><span class="line">        COMPLEX_UNIT_SP = 2,</span><br><span class="line">        // TYPE_DIMENSION: Value is in points.</span><br><span class="line">        COMPLEX_UNIT_PT = 3,</span><br><span class="line">        // TYPE_DIMENSION: Value is in inches.</span><br><span class="line">        COMPLEX_UNIT_IN = 4,</span><br><span class="line">        // TYPE_DIMENSION: Value is in millimeters.</span><br><span class="line">        COMPLEX_UNIT_MM = 5,</span><br><span class="line"></span><br><span class="line">        // TYPE_FRACTION: A basic fraction of the overall size.</span><br><span class="line">        COMPLEX_UNIT_FRACTION = 0,</span><br><span class="line">        // TYPE_FRACTION: A fraction of the parent size.</span><br><span class="line">        COMPLEX_UNIT_FRACTION_PARENT = 1,</span><br><span class="line"></span><br><span class="line">        // Where the radix information is, telling where the decimal place</span><br><span class="line">        // appears in the mantissa.  This give us 4 possible fixed point</span><br><span class="line">        // representations as defined below.</span><br><span class="line">        COMPLEX_RADIX_SHIFT = 4,</span><br><span class="line">        COMPLEX_RADIX_MASK = 0x3,</span><br><span class="line"></span><br><span class="line">        // The mantissa is an integral number -- i.e., 0xnnnnnn.0</span><br><span class="line">        COMPLEX_RADIX_23p0 = 0,</span><br><span class="line">        // The mantissa magnitude is 16 bits -- i.e, 0xnnnn.nn</span><br><span class="line">        COMPLEX_RADIX_16p7 = 1,</span><br><span class="line">        // The mantissa magnitude is 8 bits -- i.e, 0xnn.nnnn</span><br><span class="line">        COMPLEX_RADIX_8p15 = 2,</span><br><span class="line">        // The mantissa magnitude is 0 bits -- i.e, 0x0.nnnnnn</span><br><span class="line">        COMPLEX_RADIX_0p23 = 3,</span><br><span class="line">        </span><br><span class="line">        // Where the actual value is.  This gives us 23 bits of</span><br><span class="line">        // precision.  The top bit is the sign.</span><br><span class="line">        COMPLEX_MANTISSA_SHIFT = 8,</span><br><span class="line">        COMPLEX_MANTISSA_MASK = 0xffffff</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // Possible data values for TYPE_NULL.</span><br><span class="line">    enum &#123;</span><br><span class="line">        // The value is not defined.</span><br><span class="line">        DATA_NULL_UNDEFINED = 0,</span><br><span class="line">        // The value is explicitly defined as empty.</span><br><span class="line">        DATA_NULL_EMPTY = 1</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // The data for this item, as interpreted according to dataType.</span><br><span class="line">    typedef uint32_t data_type;</span><br><span class="line">    data_type data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们先需要根据dataType判断这个值是什么类型的,然后再根据不同的类型,从data读取具体的值。读取的方法比较复杂,我就不具体讲解,大家可以参考我的demo代码理解。</p>
<p>我们找到bool部分的打印,可以看到key和value就都打印出来了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">type: id=0x3,name=bool</span><br><span class="line">80</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">config :</span><br><span class="line">entryIndex: 0x0, key :</span><br><span class="line">abc_action_bar_embed_tabs</span><br><span class="line">value :</span><br><span class="line">(boolean) true</span><br><span class="line"></span><br><span class="line">entryIndex: 0x1, key :</span><br><span class="line">abc_allow_stacked_button_bar</span><br><span class="line">value :</span><br><span class="line">(boolean) false</span><br><span class="line"></span><br><span class="line">entryIndex: 0x2, key :</span><br><span class="line">abc_config_actionMenuItemAllCaps</span><br><span class="line">value :</span><br><span class="line">(boolean) true</span><br><span class="line"></span><br><span class="line">config : port</span><br><span class="line">entryIndex: 0x0, key :</span><br><span class="line">abc_action_bar_embed_tabs</span><br><span class="line">value :</span><br><span class="line">(boolean) false</span><br></pre></td></tr></table></figure>

<h2 id="ResTable-map-entry"><a href="#ResTable-map-entry" class="headerlink" title="ResTable_map_entry"></a>ResTable_map_entry</h2><p>从上面可以看出来ResTable_entry代表的是普通键值对的资源如string、bool、drawable等,那ResTable_map_entry又代表的是啥呢?</p>
<p>其实它代表的是类型style、attr的资源:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;attr name=&quot;buttonTintMode&quot;&gt;</span><br><span class="line">	&lt;enum name=&quot;src_over&quot; value=&quot;3&quot;/&gt;</span><br><span class="line">	&lt;enum name=&quot;src_in&quot; value=&quot;5&quot;/&gt;</span><br><span class="line">	&lt;enum name=&quot;src_atop&quot; value=&quot;9&quot;/&gt;</span><br><span class="line">	&lt;enum name=&quot;multiply&quot; value=&quot;14&quot;/&gt;</span><br><span class="line">	&lt;enum name=&quot;screen&quot; value=&quot;15&quot;/&gt;</span><br><span class="line">	&lt;enum name=&quot;add&quot; value=&quot;16&quot;/&gt;</span><br><span class="line">&lt;/attr&gt;</span><br><span class="line"></span><br><span class="line">&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt;</span><br><span class="line">        &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>像上面的R.attr.buttonTintMode和R.style.AppTheme的值都需要用一个map去表示。</p>
<p>我们来看看struct ResTable_map_entry:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Extended form of a ResTable_entry for map entries, defining a parent map</span><br><span class="line"> * resource from which to inherit values.</span><br><span class="line"> */</span><br><span class="line">struct ResTable_map_entry : public ResTable_entry</span><br><span class="line">&#123;</span><br><span class="line">    // Resource identifier of the parent mapping, or 0 if there is none.</span><br><span class="line">    ResTable_ref parent;</span><br><span class="line">    // Number of name/value pairs that follow for FLAG_COMPLEX.</span><br><span class="line">    uint32_t count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它的parent成员变量就定义了这个style的parent,count成员变量则代表了这个map的大小,也就是ResTable_map_entry后面跟着的键值对的数量。</p>
<h3 id="资源的id"><a href="#资源的id" class="headerlink" title="资源的id"></a>资源的id</h3><p>struct ResTable_ref也是一个需要重点讲解的结构体,它的定义很简单:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  This is a reference to a unique entry (a ResTable_entry structure)</span><br><span class="line"> *  in a resource table.  The value is structured as: 0xpptteeee,</span><br><span class="line"> *  where pp is the package index, tt is the type index in that</span><br><span class="line"> *  package, and eeee is the entry index in that type.  The package</span><br><span class="line"> *  and type values start at 1 for the first item, to help catch cases</span><br><span class="line"> *  where they have not been supplied.</span><br><span class="line"> */</span><br><span class="line">struct ResTable_ref</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t ident;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个ident代表的就是资源的id。这个值其实我们在java里面也能看到:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final class R &#123;</span><br><span class="line">	...</span><br><span class="line">	public static final class bool &#123;</span><br><span class="line">	    public static final int abc_action_bar_embed_tabs=0x7f030000;</span><br><span class="line">	    public static final int abc_allow_stacked_button_bar=0x7f030001;</span><br><span class="line">	    public static final int abc_config_actionMenuItemAllCaps=0x7f030002;</span><br><span class="line">	  &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>资源的id其实是有固定的格式和含义的,它的格式如下:</p>
<blockquote>
<p>0xpptteeee</p>
</blockquote>
<p>头一个字节保存了packageId,接着的一个字节保存了typeId,后面的两个字节保存了entryIndex。例如我们的abc_allow_stacked_button_bar=0x7f030001,它的packageId=0x7f, typeId=0x3, entryIndex=0x1。</p>
<p>我们在解析package资源的时候就已经把package id打印了出来,它就是0x7f:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type:512, headSize:288, size:188068, id:7f, packageName:com.cvte.tv.myapplication</span><br></pre></td></tr></table></figure>

<p>而在后面解析资源的时候也把typeId和entryIndex打印了出来:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type: id=0x3,name=bool</span><br><span class="line">80</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">config :</span><br><span class="line">entryIndex: 0x0, key :</span><br><span class="line">abc_action_bar_embed_tabs</span><br><span class="line">value :</span><br><span class="line">(boolean) true</span><br><span class="line"></span><br><span class="line">entryIndex: 0x1, key :</span><br><span class="line">abc_allow_stacked_button_bar</span><br></pre></td></tr></table></figure>

<p>于是乎我们就能定位到abc_allow_stacked_button_bar这个资源了。</p>
<p>所以我们的style的parent.ident就可以定位到style的parent资源。</p>
<p>有时候我们会看到packageId是0x01,在我们的resource.arsc里面找不到对应的package。这个package指定其实是系统资源包,我们在xml里面配置的@android:color/black就会使用到系统资源包里面的资源,这个资源是不会打包进我们的应用的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">type: id=0x4,name=color</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">entryIndex: 0x41, key :</span><br><span class="line">primary_dark_material_dark</span><br><span class="line">value :</span><br><span class="line">(reference) 0x0106000c</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="ResTable-map"><a href="#ResTable-map" class="headerlink" title="ResTable_map"></a>ResTable_map</h3><p>ResTable_map_entry后面跟着的键值对数组其实就是一个个的ResTable_map:</p>
<img src="/可能是全网讲最细的安卓resources_arsc解析教程二/2.png">

<p>struct ResTable_map定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A single name/value mapping that is part of a complex resource</span><br><span class="line"> * entry.</span><br><span class="line"> */</span><br><span class="line">struct ResTable_map</span><br><span class="line">&#123;</span><br><span class="line">    // The resource identifier defining this mapping&apos;s name.  For attribute</span><br><span class="line">    // resources, &apos;name&apos; can be one of the following special resource types</span><br><span class="line">    // to supply meta-data about the attribute; for all other resource types</span><br><span class="line">    // it must be an attribute resource.</span><br><span class="line">    ResTable_ref name;</span><br><span class="line"></span><br><span class="line">    // Special values for &apos;name&apos; when defining attribute resources.</span><br><span class="line">    enum &#123;</span><br><span class="line">        // This entry holds the attribute&apos;s type code.</span><br><span class="line">        ATTR_TYPE = Res_MAKEINTERNAL(0),</span><br><span class="line"></span><br><span class="line">        // For integral attributes, this is the minimum value it can hold.</span><br><span class="line">        ATTR_MIN = Res_MAKEINTERNAL(1),</span><br><span class="line"></span><br><span class="line">        // For integral attributes, this is the maximum value it can hold.</span><br><span class="line">        ATTR_MAX = Res_MAKEINTERNAL(2),</span><br><span class="line"></span><br><span class="line">        // Localization of this resource is can be encouraged or required with</span><br><span class="line">        // an aapt flag if this is set</span><br><span class="line">        ATTR_L10N = Res_MAKEINTERNAL(3),</span><br><span class="line"></span><br><span class="line">        // for plural support, see android.content.res.PluralRules#attrForQuantity(int)</span><br><span class="line">        ATTR_OTHER = Res_MAKEINTERNAL(4),</span><br><span class="line">        ATTR_ZERO = Res_MAKEINTERNAL(5),</span><br><span class="line">        ATTR_ONE = Res_MAKEINTERNAL(6),</span><br><span class="line">        ATTR_TWO = Res_MAKEINTERNAL(7),</span><br><span class="line">        ATTR_FEW = Res_MAKEINTERNAL(8),</span><br><span class="line">        ATTR_MANY = Res_MAKEINTERNAL(9)</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">     // Bit mask of allowed types, for use with ATTR_TYPE.</span><br><span class="line">    enum &#123;</span><br><span class="line">        // No type has been defined for this attribute, use generic</span><br><span class="line">        // type handling.  The low 16 bits are for types that can be</span><br><span class="line">        // handled generically; the upper 16 require additional information</span><br><span class="line">        // in the bag so can not be handled generically for TYPE_ANY.</span><br><span class="line">        TYPE_ANY = 0x0000FFFF,</span><br><span class="line"></span><br><span class="line">        // Attribute holds a references to another resource.</span><br><span class="line">        TYPE_REFERENCE = 1&lt;&lt;0,</span><br><span class="line"></span><br><span class="line">        // Attribute holds a generic string.</span><br><span class="line">        TYPE_STRING = 1&lt;&lt;1,</span><br><span class="line"></span><br><span class="line">        // Attribute holds an integer value.  ATTR_MIN and ATTR_MIN can</span><br><span class="line">        // optionally specify a constrained range of possible integer values.</span><br><span class="line">        TYPE_INTEGER = 1&lt;&lt;2,</span><br><span class="line"></span><br><span class="line">        // Attribute holds a boolean integer.</span><br><span class="line">        TYPE_BOOLEAN = 1&lt;&lt;3,</span><br><span class="line"></span><br><span class="line">        // Attribute holds a color value.</span><br><span class="line">        TYPE_COLOR = 1&lt;&lt;4,</span><br><span class="line"></span><br><span class="line">        // Attribute holds a floating point value.</span><br><span class="line">        TYPE_FLOAT = 1&lt;&lt;5,</span><br><span class="line"></span><br><span class="line">        // Attribute holds a dimension value, such as &quot;20px&quot;.</span><br><span class="line">        TYPE_DIMENSION = 1&lt;&lt;6,</span><br><span class="line"></span><br><span class="line">        // Attribute holds a fraction value, such as &quot;20%&quot;.</span><br><span class="line">        TYPE_FRACTION = 1&lt;&lt;7,</span><br><span class="line"></span><br><span class="line">        // Attribute holds an enumeration.  The enumeration values are</span><br><span class="line">        // supplied as additional entries in the map.</span><br><span class="line">        TYPE_ENUM = 1&lt;&lt;16,</span><br><span class="line"></span><br><span class="line">        // Attribute holds a bitmaks of flags.  The flag bit values are</span><br><span class="line">        // supplied as additional entries in the map.</span><br><span class="line">        TYPE_FLAGS = 1&lt;&lt;17</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    // Enum of localization modes, for use with ATTR_L10N.</span><br><span class="line">    enum &#123;</span><br><span class="line">        L10N_NOT_REQUIRED = 0,</span><br><span class="line">        L10N_SUGGESTED    = 1</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // This mapping&apos;s value.</span><br><span class="line">    Res_value value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它的name代表的就是这个键值对的key,而它的value代表的就是键值对的值。</p>
<p>name同样的是个struct ResTable_ref,它同样可以从资源id拿到对应的资源,但是这个name有点特殊,如果是它的ident的值是下面枚举中的一个的话:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#define Res_MAKEINTERNAL(entry) (0x01000000 | (entry&amp;0xFFFF))</span><br><span class="line"></span><br><span class="line">enum &#123;</span><br><span class="line">    // This entry holds the attribute&apos;s type code.</span><br><span class="line">    ATTR_TYPE = Res_MAKEINTERNAL(0),</span><br><span class="line"></span><br><span class="line">    // For integral attributes, this is the minimum value it can hold.</span><br><span class="line">    ATTR_MIN = Res_MAKEINTERNAL(1),</span><br><span class="line"></span><br><span class="line">    // For integral attributes, this is the maximum value it can hold.</span><br><span class="line">    ATTR_MAX = Res_MAKEINTERNAL(2),</span><br><span class="line"></span><br><span class="line">    // Localization of this resource is can be encouraged or required with</span><br><span class="line">    // an aapt flag if this is set</span><br><span class="line">    ATTR_L10N = Res_MAKEINTERNAL(3),</span><br><span class="line"></span><br><span class="line">    // for plural support, see android.content.res.PluralRules#attrForQuantity(int)</span><br><span class="line">    ATTR_OTHER = Res_MAKEINTERNAL(4),</span><br><span class="line">    ATTR_ZERO = Res_MAKEINTERNAL(5),</span><br><span class="line">    ATTR_ONE = Res_MAKEINTERNAL(6),</span><br><span class="line">    ATTR_TWO = Res_MAKEINTERNAL(7),</span><br><span class="line">    ATTR_FEW = Res_MAKEINTERNAL(8),</span><br><span class="line">    ATTR_MANY = Res_MAKEINTERNAL(9)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例如如果index==0x01000000,就代表name是ATTR_TYPE,也代表这个资源是attr。</p>
<p>此时,它的value也是特殊的,是下面枚举中的一个,代表attr的类型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">    // No type has been defined for this attribute, use generic</span><br><span class="line">    // type handling.  The low 16 bits are for types that can be</span><br><span class="line">    // handled generically; the upper 16 require additional information</span><br><span class="line">    // in the bag so can not be handled generically for TYPE_ANY.</span><br><span class="line">    TYPE_ANY = 0x0000FFFF,</span><br><span class="line"></span><br><span class="line">    // Attribute holds a references to another resource.</span><br><span class="line">    TYPE_REFERENCE = 1&lt;&lt;0,</span><br><span class="line"></span><br><span class="line">    // Attribute holds a generic string.</span><br><span class="line">    TYPE_STRING = 1&lt;&lt;1,</span><br><span class="line"></span><br><span class="line">    // Attribute holds an integer value.  ATTR_MIN and ATTR_MIN can</span><br><span class="line">    // optionally specify a constrained range of possible integer values.</span><br><span class="line">    TYPE_INTEGER = 1&lt;&lt;2,</span><br><span class="line"></span><br><span class="line">    // Attribute holds a boolean integer.</span><br><span class="line">    TYPE_BOOLEAN = 1&lt;&lt;3,</span><br><span class="line"></span><br><span class="line">    // Attribute holds a color value.</span><br><span class="line">    TYPE_COLOR = 1&lt;&lt;4,</span><br><span class="line"></span><br><span class="line">    // Attribute holds a floating point value.</span><br><span class="line">    TYPE_FLOAT = 1&lt;&lt;5,</span><br><span class="line"></span><br><span class="line">    // Attribute holds a dimension value, such as &quot;20px&quot;.</span><br><span class="line">    TYPE_DIMENSION = 1&lt;&lt;6,</span><br><span class="line"></span><br><span class="line">    // Attribute holds a fraction value, such as &quot;20%&quot;.</span><br><span class="line">    TYPE_FRACTION = 1&lt;&lt;7,</span><br><span class="line"></span><br><span class="line">    // Attribute holds an enumeration.  The enumeration values are</span><br><span class="line">    // supplied as additional entries in the map.</span><br><span class="line">    TYPE_ENUM = 1&lt;&lt;16,</span><br><span class="line"></span><br><span class="line">    // Attribute holds a bitmaks of flags.  The flag bit values are</span><br><span class="line">    // supplied as additional entries in the map.</span><br><span class="line">    TYPE_FLAGS = 1&lt;&lt;17</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解析代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(pEntry-&gt;flags &amp; ResTable_entry::FLAG_COMPLEX) &#123;</span><br><span class="line">    struct ResTable_map_entry* pMapEntry = (struct ResTable_map_entry*)(pData + offset);</span><br><span class="line">    for(int i = 0; i &lt;pMapEntry-&gt;count ; i++) &#123;</span><br><span class="line">        struct ResTable_map* pMap = (struct ResTable_map*)(pData + offset + pMapEntry-&gt;size + i * sizeof(struct ResTable_map_entry));</span><br><span class="line">        printf(&quot;\tname:0x%x, valueType:%u, value:%u\n&quot;, pMap-&gt;name.ident, pMap-&gt;value.dataType, pMap-&gt;value.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们找到buttonTintMode的打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">entryIndex: 0x69, key :</span><br><span class="line">buttonTintMode</span><br><span class="line">    name:0x1000000, valueType:16, value:65536</span><br><span class="line">    name:0x7f070019, valueType:16, value:16</span><br><span class="line">    name:0x7f070050, valueType:16, value:14</span><br><span class="line">    name:0x7f070061, valueType:16, value:15</span><br><span class="line">    name:0x7f070078, valueType:16, value:9</span><br><span class="line">    name:0x7f070079, valueType:16, value:5</span><br><span class="line">    name:0x7f07007a, valueType:16, value:3</span><br></pre></td></tr></table></figure>

<p>第一个ResTable_ref的name的indent的值是0x1000000,就代表name是ATTR_TYPE,也代表这个资源是attr。然后value是65536,也就是TYPE_ENUM。</p>
<p>然后我们顺便找下7f070019、7f070050、7f070061、7f070078、7f070079、7f07007a资源的定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">type: id=0x7,name=id</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">entryIndex: 0x19, key :</span><br><span class="line">add</span><br><span class="line">value :</span><br><span class="line">(boolean) false</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">entryIndex: 0x50, key :</span><br><span class="line">multiply</span><br><span class="line">value :</span><br><span class="line">(boolean) false</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">entryIndex: 0x61, key :</span><br><span class="line">screen</span><br><span class="line">value :</span><br><span class="line">(boolean) false</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">entryIndex: 0x78, key :</span><br><span class="line">src_atop</span><br><span class="line">value :</span><br><span class="line">(boolean) false</span><br><span class="line"></span><br><span class="line">entryIndex: 0x79, key :</span><br><span class="line">src_in</span><br><span class="line">value :</span><br><span class="line">(boolean) false</span><br><span class="line"></span><br><span class="line">entryIndex: 0x7a, key :</span><br><span class="line">src_over</span><br><span class="line">value :</span><br><span class="line">(boolean) false</span><br></pre></td></tr></table></figure>

<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>完整的demo可以在github上找到:</p>
<p><a href="https://github.com/bluesky466/ResourcesArscDemo" target="_blank" rel="noopener">https://github.com/bluesky466/ResourcesArscDemo</a></p>
<p>呼~长舒一口气,终于大功告成。</p>

    
  </div>
</article>

</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    




  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235687', function() {
      // load success
    });
  }
</script>

  <footer style="flex: 0 0 auto;text-align: center;">
<a style="font-size:12px; color:#6C6C6C" target="_blank">© 2021  林嘉伟 ❤ <a style="font-size:12px; color:#6C6C6C" target="_blank" href="http://beian.miit.gov.cn/" rel="nofollow">粤ICP备2021021473号</a></footer>
</body>
</html>
