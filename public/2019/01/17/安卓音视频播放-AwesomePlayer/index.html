<!DOCTYPE html>


  <html class="light page-home">


<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>安卓音视频播放 - AwesomePlayer | LinJW</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="技术相关,Android,">
  

  <meta name="description" content="系列文章:  安卓音视频播放 - 总体架构 安卓音视频播放 - AwesomePlayer 安卓音视频播放 - NuPlayer  音视频播放基础流程在讲具体的实现之前我们看一下音视频播放的基础流程:   流程很简单,就是将复用的音视频流解复用出编码后的音频流和编码后的视频流。然后通过音频解码解出PCM数据给音频设备去播放,通过视频解码解出YUV数据给视频设备去播放。 StagefrightPla">
<meta name="keywords" content="技术相关,Android">
<meta property="og:type" content="article">
<meta property="og:title" content="安卓音视频播放 - AwesomePlayer">
<meta property="og:url" content="http://139.199.4.241/2019/01/17/安卓音视频播放-AwesomePlayer/index.html">
<meta property="og:site_name" content="LinJW">
<meta property="og:description" content="系列文章:  安卓音视频播放 - 总体架构 安卓音视频播放 - AwesomePlayer 安卓音视频播放 - NuPlayer  音视频播放基础流程在讲具体的实现之前我们看一下音视频播放的基础流程:   流程很简单,就是将复用的音视频流解复用出编码后的音频流和编码后的视频流。然后通过音频解码解出PCM数据给音频设备去播放,通过视频解码解出YUV数据给视频设备去播放。 StagefrightPla">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://139.199.4.241/安卓音视频播放-AwesomePlayer/1.png">
<meta property="og:image" content="http://139.199.4.241/安卓音视频播放-AwesomePlayer/2.png">
<meta property="og:image" content="http://139.199.4.241/安卓音视频播放-AwesomePlayer/3.png">
<meta property="og:image" content="http://139.199.4.241/安卓音视频播放-AwesomePlayer/4.png">
<meta property="og:image" content="http://139.199.4.241/安卓音视频播放-AwesomePlayer/5.png">
<meta property="og:updated_time" content="2022-02-07T05:47:21.442Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="安卓音视频播放 - AwesomePlayer">
<meta name="twitter:description" content="系列文章:  安卓音视频播放 - 总体架构 安卓音视频播放 - AwesomePlayer 安卓音视频播放 - NuPlayer  音视频播放基础流程在讲具体的实现之前我们看一下音视频播放的基础流程:   流程很简单,就是将复用的音视频流解复用出编码后的音频流和编码后的视频流。然后通过音频解码解出PCM数据给音频设备去播放,通过视频解码解出YUV数据给视频设备去播放。 StagefrightPla">
<meta name="twitter:image" content="http://139.199.4.241/安卓音视频播放-AwesomePlayer/1.png">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=32204ee7" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>
</html>
<body>

  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#音视频播放基础流程"><span class="toc-text">音视频播放基础流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#StagefrightPlayer"><span class="toc-text">StagefrightPlayer</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#多线程架构"><span class="toc-text">多线程架构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Demux"><span class="toc-text">Demux</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#解码器"><span class="toc-text">解码器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#播放流程"><span class="toc-text">播放流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VideoRender"><span class="toc-text">VideoRender</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#完整架构图"><span class="toc-text">完整架构图</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-安卓音视频播放-AwesomePlayer" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">安卓音视频播放 - AwesomePlayer</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2019.01.17</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>林嘉伟</span>
        </span>
      

      


      

    </div>
  </header>

  <div class="article-content">
    
      <p>系列文章:</p>
<ul>
<li><a href="http://blog.islinjw.cn/2019/01/17/%E5%AE%89%E5%8D%93%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/" target="_blank" rel="noopener">安卓音视频播放 - 总体架构</a></li>
<li><a href="http://blog.islinjw.cn/2019/01/17/%E5%AE%89%E5%8D%93%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE-AwesomePlayer/" target="_blank" rel="noopener">安卓音视频播放 - AwesomePlayer</a></li>
<li><a href="http://blog.islinjw.cn/2019/01/19/%E5%AE%89%E5%8D%93%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE-NuPlayer/" target="_blank" rel="noopener">安卓音视频播放 - NuPlayer</a></li>
</ul>
<h1 id="音视频播放基础流程"><a href="#音视频播放基础流程" class="headerlink" title="音视频播放基础流程"></a>音视频播放基础流程</h1><p>在讲具体的实现之前我们看一下音视频播放的基础流程:</p>
<img src="/安卓音视频播放-AwesomePlayer/1.png">

<p>流程很简单,就是将复用的音视频流解复用出编码后的音频流和编码后的视频流。然后通过音频解码解出PCM数据给音频设备去播放,通过视频解码解出YUV数据给视频设备去播放。</p>
<h1 id="StagefrightPlayer"><a href="#StagefrightPlayer" class="headerlink" title="StagefrightPlayer"></a>StagefrightPlayer</h1><p><a href="http://blog.islinjw.cn/2019/01/17/%E5%AE%89%E5%8D%93%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/" target="_blank" rel="noopener">上一篇文章</a>有讲到MediaPlayerService会通过MediaPlayerFactory创建Player,其中一个创建的就是StagefrightPlayer.但它实际上是一个空壳,只是简单的调用AwesomePlayer的实现而已:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//StagefrightPlayer.h</span><br><span class="line">class StagefrightPlayer : public MediaPlayerInterface &#123;</span><br><span class="line">	...</span><br><span class="line">private:</span><br><span class="line">	AwesomePlayer *mPlayer;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//StagefrightPlayer.cpp</span><br><span class="line">status_t StagefrightPlayer::pause() &#123;</span><br><span class="line">    ALOGV(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">    return mPlayer-&gt;pause();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool StagefrightPlayer::isPlaying() &#123;</span><br><span class="line">    ALOGV(&quot;isPlaying&quot;);</span><br><span class="line">    return mPlayer-&gt;isPlaying();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t StagefrightPlayer::seekTo(int msec) &#123;</span><br><span class="line">    ALOGV(&quot;seekTo %.2f secs&quot;, msec / 1E3);</span><br><span class="line"></span><br><span class="line">    status_t err = mPlayer-&gt;seekTo((int64_t)msec * 1000);</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>所以我们直接看AwesomePlayer的实现。</p>
<h1 id="多线程架构"><a href="#多线程架构" class="headerlink" title="多线程架构"></a>多线程架构</h1><p>音视频的处理一般都很耗时,所以AwesomePlayer开了一个子线程去工作,防止阻塞住MediaPlayerService的主线程。</p>
<p>具体的架构如下(这幅图是在这篇<a href="https://www.cnblogs.com/shakin/p/4463639.html" target="_blank" rel="noopener">博客</a>抄来的,这篇文章写得的确不错,大家感兴趣可以去仔细读一下:</p>
<img src="/安卓音视频播放-AwesomePlayer/2.png">

<p>首先AwesomePlayer内部有个TimedEventQueue对象,所有的操作都会封装成一个个的Event,丢到这个队列里。然后TimedEventQueue创建了一个子线程,不断从队列中拿出Event来执行。</p>
<p>例如prepare操作最后会调到prepareAsync_l,这里面就是创建了个Event,通过postEvent丢到队列里:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">status_t AwesomePlayer::prepareAsync_l() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (!mQueueStarted) &#123;</span><br><span class="line">        mQueue.start();</span><br><span class="line">        mQueueStarted = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">    mAsyncPrepareEvent = new AwesomeEvent(</span><br><span class="line">            this, &amp;AwesomePlayer::onPrepareAsyncEvent);</span><br><span class="line"></span><br><span class="line">    mQueue.postEvent(mAsyncPrepareEvent);</span><br><span class="line"></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AwesomeEvent继承TimedEventQueue::Event,实现了fire方法,回调了注册的方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct AwesomeEvent : public TimedEventQueue::Event &#123;</span><br><span class="line">    AwesomeEvent(</span><br><span class="line">            AwesomePlayer *player,</span><br><span class="line">            void (AwesomePlayer::*method)())</span><br><span class="line">        : mPlayer(player),</span><br><span class="line">          mMethod(method) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    virtual void fire(TimedEventQueue *queue, int64_t /* now_us */) &#123;</span><br><span class="line">        (mPlayer-&gt;*mMethod)();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>TimedEventQueue::start创建了一个子线程,调用TimedEventQueue::threadEntry方法,这里面有个死循环一直在从Event队列中拿出Event,执行fire方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">void TimedEventQueue::start() &#123;</span><br><span class="line">    if (mRunning) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mStopped = false;</span><br><span class="line"></span><br><span class="line">    pthread_attr_t attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;mThread, &amp;attr, ThreadWrapper, this);</span><br><span class="line"></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    mRunning = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *TimedEventQueue::ThreadWrapper(void *me) &#123;</span><br><span class="line"></span><br><span class="line">    androidSetThreadPriority(0, ANDROID_PRIORITY_FOREGROUND);</span><br><span class="line"></span><br><span class="line">    static_cast&lt;TimedEventQueue *&gt;(me)-&gt;threadEntry();</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TimedEventQueue::threadEntry() &#123;</span><br><span class="line">    ...</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        event = removeEventFromQueue_l(eventID);</span><br><span class="line"></span><br><span class="line">        if (event != NULL) &#123;</span><br><span class="line">            // Fire event with the lock NOT held.</span><br><span class="line">            event-&gt;fire(this, now_us);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Demux"><a href="#Demux" class="headerlink" title="Demux"></a>Demux</h1><p>我们先来看看prepare回调的时候实际是调用了AwesomePlayer::beginPrepareAsync_l()方法,在这里会实际的去设置数据源,然后初始化Demux、视频解码器和音频解码器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void AwesomePlayer::onPrepareAsyncEvent() &#123;</span><br><span class="line">    Mutex::Autolock autoLock(mLock);</span><br><span class="line">    beginPrepareAsync_l();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void AwesomePlayer::beginPrepareAsync_l() &#123;</span><br><span class="line">    ...</span><br><span class="line">    status_t err = finishSetDataSource_l();</span><br><span class="line">    ...</span><br><span class="line">    status_t err = initVideoDecoder();</span><br><span class="line">    ...</span><br><span class="line">    status_t err = initAudioDecoder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先来看看AwesomePlayer::finishSetDataSource_l实际上是为音视频源找到对应的MediaExtractor,这个MediaExtractor的功能就是实现播放器的基础流程中的Demux,分解出视频流和音频流:</p>
<img src="/安卓音视频播放-AwesomePlayer/3.png">

<p>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">status_t AwesomePlayer::finishSetDataSource_l() &#123;</span><br><span class="line">    ...</span><br><span class="line">    extractor = MediaExtractor::Create(dataSource, sniffedMIME.empty() ? NULL : sniffedMIME.c_str());</span><br><span class="line">    ...</span><br><span class="line">    status_t err = setDataSource_l(extractor);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">status_t AwesomePlayer::setDataSource_l(const sp&lt;MediaExtractor&gt; &amp;extractor) &#123;</span><br><span class="line">    ...</span><br><span class="line">    for (size_t i = 0; i &lt; extractor-&gt;countTracks(); ++i) &#123;</span><br><span class="line">        sp&lt;MetaData&gt; meta = extractor-&gt;getTrackMetaData(i);</span><br><span class="line"></span><br><span class="line">        const char *_mime;</span><br><span class="line">        CHECK(meta-&gt;findCString(kKeyMIMEType, &amp;_mime));</span><br><span class="line"></span><br><span class="line">        String8 mime = String8(_mime);</span><br><span class="line">        ...</span><br><span class="line">        if (!haveVideo &amp;&amp; !strncasecmp(mime.string(), &quot;video/&quot;, 6)) &#123;</span><br><span class="line">            setVideoSource(extractor-&gt;getTrack(i));</span><br><span class="line">            ...</span><br><span class="line">        &#125; else if (!haveAudio &amp;&amp; !strncasecmp(mime.string(), &quot;audio/&quot;, 6)) &#123;</span><br><span class="line">            setAudioSource(extractor-&gt;getTrack(i));</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MediaExtractor::Create的实现也是蛮粗暴的,判断媒体类型,然后创建不同的MediaExtractor,如MPEG4Extractor、MP3Extractor等:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sp&lt;MediaExtractor&gt; MediaExtractor::Create(const sp&lt;DataSource&gt; &amp;source, const char *mime) &#123;</span><br><span class="line">	..</span><br><span class="line">	MediaExtractor *ret = NULL;</span><br><span class="line">	    if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG4)</span><br><span class="line">	            || !strcasecmp(mime, &quot;audio/mp4&quot;)) &#123;</span><br><span class="line">	        ret = new MPEG4Extractor(source);</span><br><span class="line">	    &#125; else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG)) &#123;</span><br><span class="line">	        ret = new MP3Extractor(source, meta);</span><br><span class="line">	    &#125; else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AMR_NB)</span><br><span class="line">	            || !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AMR_WB)) &#123;</span><br><span class="line">	        ret = new AMRExtractor(source);</span><br><span class="line">	    &#125; else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_FLAC)) &#123;</span><br><span class="line">	        ret = new FLACExtractor(source);</span><br><span class="line">	    &#125; else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_WAV)) &#123;</span><br><span class="line">	        ret = new WAVExtractor(source);</span><br><span class="line">	    &#125; else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_OGG)) &#123;</span><br><span class="line">	        ret = new OggExtractor(source);</span><br><span class="line">	    &#125; else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MATROSKA)) &#123;</span><br><span class="line">	        ret = new MatroskaExtractor(source);</span><br><span class="line">	    &#125; else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG2TS)) &#123;</span><br><span class="line">	        ret = new MPEG2TSExtractor(source);</span><br><span class="line">	    &#125; else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_WVM)) &#123;</span><br><span class="line">	        // Return now.  WVExtractor should not have the DrmFlag set in the block below.</span><br><span class="line">	        return new WVMExtractor(source);</span><br><span class="line">	    &#125; else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC_ADTS)) &#123;</span><br><span class="line">	        ret = new AACExtractor(source, meta);</span><br><span class="line">	    &#125; else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG2PS)) &#123;</span><br><span class="line">	        ret = new MPEG2PSExtractor(source);</span><br><span class="line">	    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/安卓音视频播放-AwesomePlayer/4.png">

<h1 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h1><p>然后AwesomePlayer::initVideoDecoder、AwesomePlayer::initAudioDecoder里面就是调用OMXCodec去做解码,OMXCodec其实是OpenMax的一层封装。OpenMax就是具体的解码器实现了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">status_t AwesomePlayer::initVideoDecoder(uint32_t flags) &#123;</span><br><span class="line">	...</span><br><span class="line">	mVideoSource = OMXCodec::Create(</span><br><span class="line">            mClient.interface(), mVideoTrack-&gt;getFormat(),</span><br><span class="line">            false, // createEncoder</span><br><span class="line">            mVideoTrack,</span><br><span class="line">            NULL, flags, USE_SURFACE_ALLOC ? mNativeWindow : NULL);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">status_t AwesomePlayer::initAudioDecoder() &#123;</span><br><span class="line">	...</span><br><span class="line">	mOmxSource = OMXCodec::Create(</span><br><span class="line">                mClient.interface(), mAudioTrack-&gt;getFormat(),</span><br><span class="line">                false, // createEncoder</span><br><span class="line">                mAudioTrack);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="播放流程"><a href="#播放流程" class="headerlink" title="播放流程"></a>播放流程</h1><p>应用在java层调用MediaPlayer.start,最终会通过IPC去到MediaPlayerService里调用到StagefrightPlayer::start方法,我们直接从这里开始往下挖:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//从这里开始是StagefrightPlayer.cpp里的代码</span><br><span class="line">status_t StagefrightPlayer::start() &#123;</span><br><span class="line">    return mPlayer-&gt;play();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//从这里开始是AwesomePlayer.cpp里的代码</span><br><span class="line">status_t AwesomePlayer::play() &#123;</span><br><span class="line">	...</span><br><span class="line">    return play_l();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t AwesomePlayer::play_l() &#123;</span><br><span class="line">    ...</span><br><span class="line">    createAudioPlayer_l();</span><br><span class="line">    ...</span><br><span class="line">    postVideoEvent_l();</span><br><span class="line">    ...</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AwesomePlayer::postVideoEvent_l(int64_t delayUs) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mQueue.postEventWithDelay(mVideoEvent, delayUs &lt; 0 ? 10000 : delayUs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在AwesomePlayer::play_l方法里面调用AwesomePlayer::createAudioPlayer_l创建了一个AudioPlayer,然后调用AwesomePlayer::postVideoEvent_l往mQueue里丢了一个事件。</p>
<p>还记得这个mVideoEvent吗?它对应的是AwesomePlayer::onVideoEvent方法,也就是说把这个Event丢到mQueue里面之后AwesomePlayer::onVideoEvent就会在子线程中被调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mVideoEvent = new AwesomeEvent(this, &amp;AwesomePlayer::onVideoEvent);</span><br></pre></td></tr></table></figure>

<p>让我们继续看看AwesomePlayer::onVideoEvent方法里面干了什么:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void AwesomePlayer::onVideoEvent() &#123;</span><br><span class="line">	...</span><br><span class="line">	status_t err = mVideoSource-&gt;read(&amp;mVideoBuffer, &amp;options);</span><br><span class="line">	...</span><br><span class="line">	if ((mNativeWindow != NULL)</span><br><span class="line">            &amp;&amp; (mVideoRendererIsPreview || mVideoRenderer == NULL)) &#123;</span><br><span class="line">        mVideoRendererIsPreview = false;</span><br><span class="line"></span><br><span class="line">        initRenderer_l();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    if (mAudioPlayer != NULL &amp;&amp; !(mFlags &amp; (AUDIO_RUNNING | SEEK_PREVIEW))) &#123;</span><br><span class="line">        startAudioPlayer_l();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    if (mVideoRenderer != NULL) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mVideoRenderer-&gt;render(mVideoBuffer);</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">	postVideoEvent_l();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法最重要的就是创建一个VideoRender,从mVideoSource读取解码好的视频帧去渲染,渲染完之后再调AwesomePlayer::postVideoEvent_l再往队列丢入一个VideoEvent。于是画面就不断的刷新了。</p>
<p>可以看到,这个方法内部也启动了音频播放器去播放音频。而且其实它还做了一些音视频同步的工作,但是考虑到逻辑比较啰嗦,我这里就省略了。</p>
<h1 id="VideoRender"><a href="#VideoRender" class="headerlink" title="VideoRender"></a>VideoRender</h1><p>最后让我们来看看VideoRendere是怎么来的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void AwesomePlayer::initRenderer_l() &#123;</span><br><span class="line">	...</span><br><span class="line">	if (USE_SURFACE_ALLOC</span><br><span class="line">	        &amp;&amp; !strncmp(component, &quot;OMX.&quot;, 4)</span><br><span class="line">	        &amp;&amp; strncmp(component, &quot;OMX.google.&quot;, 11)</span><br><span class="line">	        &amp;&amp; strcmp(component, &quot;OMX.Nvidia.mpeg2v.decode&quot;)) &#123;</span><br><span class="line">	    mVideoRenderer =</span><br><span class="line">	        new AwesomeNativeWindowRenderer(mNativeWindow, rotationDegrees);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">	    mVideoRenderer = new AwesomeLocalRenderer(mNativeWindow, meta);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到,是根据解码器类型用mNativeWindow创建了不同的AwesomeNativeWindowRenderer或者AwesomeLocalRenderer。这个mNativeWindow就是画面最终需要渲染到的地方</p>
<p>我们看看mNativeWindow是怎么来的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">// AwesomePlayer.cpp</span><br><span class="line">status_t AwesomePlayer::setNativeWindow_l(const sp&lt;ANativeWindow&gt; &amp;native) &#123;</span><br><span class="line">    mNativeWindow = native;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t AwesomePlayer::setSurfaceTexture(const sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer) &#123;</span><br><span class="line">   ...</span><br><span class="line">   err = setNativeWindow_l(new Surface(bufferProducer));</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//StagefrightPlayer.cpp</span><br><span class="line">status_t StagefrightPlayer::setVideoSurfaceTexture(</span><br><span class="line">        const sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer) &#123;</span><br><span class="line">    ALOGV(&quot;setVideoSurfaceTexture&quot;);</span><br><span class="line"></span><br><span class="line">    return mPlayer-&gt;setSurfaceTexture(bufferProducer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//MediaPlayerService.cpp</span><br><span class="line">status_t MediaPlayerService::Client::setVideoSurfaceTexture(</span><br><span class="line">	...</span><br><span class="line">	sp&lt;MediaPlayerBase&gt; p = getPlayer();</span><br><span class="line">	...</span><br><span class="line">	status_t err = p-&gt;setVideoSurfaceTexture(bufferProducer);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//MediaPlayer.cpp</span><br><span class="line">status_t MediaPlayer::setVideoSurfaceTexture(</span><br><span class="line">        const sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    return mPlayer-&gt;setVideoSurfaceTexture(bufferProducer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//android_media_MediaPlayer.cpp</span><br><span class="line">static void setVideoSurface(JNIEnv *env, jobject thiz, jobject jsurface, jboolean mediaPlayerMustBeAlive)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;Surface&gt; surface(android_view_Surface_getSurface(env, jsurface));</span><br><span class="line">    ...</span><br><span class="line">    new_st = surface-&gt;getIGraphicBufferProducer();</span><br><span class="line">    ...</span><br><span class="line">    mp-&gt;setVideoSurfaceTexture(new_st);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void android_media_MediaPlayer_setVideoSurface(JNIEnv *env, jobject thiz, jobject jsurface)</span><br><span class="line">&#123;</span><br><span class="line">    setVideoSurface(env, thiz, jsurface, true /* mediaPlayerMustBeAlive */);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//android.media.MediaPlayer.java</span><br><span class="line">public class MediaPlayer extends PlayerBase</span><br><span class="line">                         implements SubtitleController.Listener</span><br><span class="line">                                  , VolumeAutomation</span><br><span class="line">                                  , AudioRouting</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	private native void _setVideoSurface(Surface surface);</span><br><span class="line">	...</span><br><span class="line">	public void setDisplay(SurfaceHolder sh) &#123;</span><br><span class="line">        mSurfaceHolder = sh;</span><br><span class="line">        Surface surface;</span><br><span class="line">        if (sh != null) &#123;</span><br><span class="line">            surface = sh.getSurface();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            surface = null;</span><br><span class="line">        &#125;</span><br><span class="line">        _setVideoSurface(surface);</span><br><span class="line">        updateSurfaceScreenOn();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到,VideoRendere最终是根据MediaPlayer.setDisplay这个方法设置的SurfaceHolder创建的到的。这就解释了画面是怎么渲染到指定的SurfaceView上的。</p>
<h1 id="完整架构图"><a href="#完整架构图" class="headerlink" title="完整架构图"></a>完整架构图</h1><p>整个渲染的架构如下:</p>
<img src="/安卓音视频播放-AwesomePlayer/5.png">



    
  </div>
</article>

</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    




  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235687', function() {
      // load success
    });
  }
</script>

  <footer style="flex: 0 0 auto;text-align: center;">
<a style="font-size:12px; color:#6C6C6C" target="_blank">© 2021  林嘉伟 ❤ <a style="font-size:12px; color:#6C6C6C" target="_blank" href="http://beian.miit.gov.cn/" rel="nofollow">粤ICP备2021021473号</a></footer>
</body>
</html>
