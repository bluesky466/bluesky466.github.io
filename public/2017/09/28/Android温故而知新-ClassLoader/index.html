<!DOCTYPE html>


  <html class="light page-home">


<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>Android温故而知新 - ClassLoader | 编程代码笔记</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="技术相关,Android,">
  

  <meta name="description" content="安卓插件化越来越流行,其中用到的技术不外乎加载外部的资源和加载外部的代码,关于加载外部资源我之前写过一篇文章《安卓皮肤包机制的原理》,感兴趣的同学可以去看一下。 加载外部代码的作用在于热更新。程序主体定义接口,具体实现放在外部。只需要替换外部代码,就能修复bug甚至是更新功能。相比传统的ota手段更加省流量,用户体验也更加的好,毕竟有很多的用户是不喜欢更新的。 这篇文章我想复习一下ClassLoa">
<meta name="keywords" content="技术相关,Android">
<meta property="og:type" content="article">
<meta property="og:title" content="Android温故而知新 - ClassLoader">
<meta property="og:url" content="https://blog.islinjw.cn/2017/09/28/Android温故而知新-ClassLoader/index.html">
<meta property="og:site_name" content="编程代码笔记">
<meta property="og:description" content="安卓插件化越来越流行,其中用到的技术不外乎加载外部的资源和加载外部的代码,关于加载外部资源我之前写过一篇文章《安卓皮肤包机制的原理》,感兴趣的同学可以去看一下。 加载外部代码的作用在于热更新。程序主体定义接口,具体实现放在外部。只需要替换外部代码,就能修复bug甚至是更新功能。相比传统的ota手段更加省流量,用户体验也更加的好,毕竟有很多的用户是不喜欢更新的。 这篇文章我想复习一下ClassLoa">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://blog.islinjw.cn/Android温故而知新-ClassLoader/1.png">
<meta property="og:updated_time" content="2022-02-07T05:47:21.419Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android温故而知新 - ClassLoader">
<meta name="twitter:description" content="安卓插件化越来越流行,其中用到的技术不外乎加载外部的资源和加载外部的代码,关于加载外部资源我之前写过一篇文章《安卓皮肤包机制的原理》,感兴趣的同学可以去看一下。 加载外部代码的作用在于热更新。程序主体定义接口,具体实现放在外部。只需要替换外部代码,就能修复bug甚至是更新功能。相比传统的ota手段更加省流量,用户体验也更加的好,毕竟有很多的用户是不喜欢更新的。 这篇文章我想复习一下ClassLoa">
<meta name="twitter:image" content="https://blog.islinjw.cn/Android温故而知新-ClassLoader/1.png">

  
    <link rel="alternate" href="/atom.xml" title="编程代码笔记" type="application/atom+xml">
  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=32204ee7" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>
</html>
<body>

  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            target="_self"
            >
            搜索
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            target="_self"
            >
            RSS
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#普通java程序的类加载机制"><span class="toc-text">普通java程序的类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java类的加载流程"><span class="toc-text">Java类的加载流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ClassLoader的创建"><span class="toc-text">ClassLoader的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双亲委托"><span class="toc-text">双亲委托</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义ClassLoader"><span class="toc-text">自定义ClassLoader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Context-ClassLoader"><span class="toc-text">Context ClassLoader</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#安卓中的ClassLoader"><span class="toc-text">安卓中的ClassLoader</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PathClassLoader"><span class="toc-text">PathClassLoader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DexClassLoader"><span class="toc-text">DexClassLoader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生成dex文件"><span class="toc-text">生成dex文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态加载dex文件"><span class="toc-text">动态加载dex文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用反射的反射加载"><span class="toc-text">使用反射的反射加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用接口的方式加载"><span class="toc-text">使用接口的方式加载</span></a></li></ol></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Android温故而知新-ClassLoader" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Android温故而知新 - ClassLoader</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.09.28</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>林嘉伟</span>
        </span>
      

      


      

    </div>
  </header>

  <div class="article-content">
    
      <p>安卓插件化越来越流行,其中用到的技术不外乎加载外部的资源和加载外部的代码,关于加载外部资源我之前写过一篇文章<a href="http://blog.islinjw.cn/2017/08/01/%E5%AE%89%E5%8D%93%E7%9A%AE%E8%82%A4%E5%8C%85%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86/">《安卓皮肤包机制的原理》</a>,感兴趣的同学可以去看一下。</p>
<p>加载外部代码的作用在于热更新。程序主体定义接口,具体实现放在外部。只需要替换外部代码,就能修复bug甚至是更新功能。相比传统的ota手段更加省流量,用户体验也更加的好,毕竟有很多的用户是不喜欢更新的。</p>
<p>这篇文章我想复习一下ClassLoader的相关知识,它是加载外部代码的核心原理。</p>
<p>虽然android自己实现了一个特殊的虚拟机,它的类加载机制和普通的java程序有点区别。但是我还是想从普通的java程序讲起,一方面多知道点东西总是好的,另一方面它们的基本原理是一样的,对我们理解安卓的类加载机制也有很大的帮助。</p>
<h1 id="普通java程序的类加载机制"><a href="#普通java程序的类加载机制" class="headerlink" title="普通java程序的类加载机制"></a>普通java程序的类加载机制</h1><p>我们都知道java代码需要先编译成class文件才能被jvm加载运行。那jvm又是如何加载class文件的呢?</p>
<p>其实class文件是通过ClassLoader加载到jvm的。java自带了三个ClassLoader,分别是:</p>
<ul>
<li>BootstrapClassLoader 用于加载核心类库</li>
<li>ExtClassLoader 用于加载拓展库</li>
<li>AppClassLoader 用于加载当前应用的类</li>
</ul>
<p>然后需要说明的是java类不是一次性全部加载的,而是只有在用到的时候才会去加载。</p>
<p>因为全部加载的话会加载一些没有用到的类,造成资源的浪费。所以当程序需要用到某个类时,才会通过ClassLoader在系统的特定路径搜索这个类的class文件并将它加载到jvm去执行。</p>
<p>ExtClassLoader和AppClassLoader都是URLClassLoader的子类,他们内部保存了URL列表用于指定搜索路径。我们可以通过URLClassLoader.getURLs()方法获取到这个URL列表。</p>
<p>BootstrapClassLoader虽然不是URLClassLoader的子类,但我们也可以从sun.misc.Launcher.getBootstrapClassPath().getURLs()方法获取到BootstrapClassLoader的搜索路径。</p>
<p>下面的代码打印了各个ClassLoader的搜索路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.net.URL;</span><br><span class="line">import java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line">public class ClassLoaderURLs &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;BootstrapClassLoader urls :&quot;);</span><br><span class="line">        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        for (URL url : urls) &#123;</span><br><span class="line">            System.out.println(url);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        URLClassLoader extClassLoader = (URLClassLoader) ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line">        System.out.println(&quot;\n&quot; + extClassLoader + &quot; urls :&quot;);</span><br><span class="line">        urls = extClassLoader.getURLs();</span><br><span class="line">        for (URL url : urls) &#123;</span><br><span class="line">            System.out.println(url);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        URLClassLoader appClassLoader = (URLClassLoader) ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(&quot;\n&quot; + appClassLoader + &quot; urls :&quot;);</span><br><span class="line">        urls = appClassLoader.getURLs();</span><br><span class="line">        for (URL url : urls) &#123;</span><br><span class="line">            System.out.println(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">BootstrapClassLoader urls :</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/resources.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/rt.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/sunrsasign.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/jsse.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/jce.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/charsets.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/jfr.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/classes</span><br><span class="line"></span><br><span class="line">sun.misc.Launcher$ExtClassLoader@74a14482 urls :</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/cldrdata.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/dnsns.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/jfxrt.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/localedata.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/nashorn.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/sunec.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/jre/lib/ext/zipfs.jar</span><br><span class="line">file:/System/Library/Java/Extensions/AppleScriptEngine.jar</span><br><span class="line">file:/System/Library/Java/Extensions/dns_sd.jar</span><br><span class="line">file:/System/Library/Java/Extensions/j3daudio.jar</span><br><span class="line">file:/System/Library/Java/Extensions/j3dcore.jar</span><br><span class="line">file:/System/Library/Java/Extensions/j3dutils.jar</span><br><span class="line">file:/System/Library/Java/Extensions/jai_codec.jar</span><br><span class="line">file:/System/Library/Java/Extensions/jai_core.jar</span><br><span class="line">file:/System/Library/Java/Extensions/libAppleScriptEngine.jnilib</span><br><span class="line">file:/System/Library/Java/Extensions/libJ3D.jnilib</span><br><span class="line">file:/System/Library/Java/Extensions/libJ3DAudio.jnilib</span><br><span class="line">file:/System/Library/Java/Extensions/libJ3DUtils.jnilib</span><br><span class="line">file:/System/Library/Java/Extensions/libmlib_jai.jnilib</span><br><span class="line">file:/System/Library/Java/Extensions/mlibwrapper_jai.jar</span><br><span class="line">file:/System/Library/Java/Extensions/MRJToolkit.jar</span><br><span class="line">file:/System/Library/Java/Extensions/vecmath.jar</span><br><span class="line">file:/usr/lib/java/libjdns_sd.jnilib</span><br><span class="line"></span><br><span class="line">sun.misc.Launcher$AppClassLoader@28d93b30 urls :</span><br><span class="line">file:/Users/linjw/workspace/class_loader_demo/</span><br></pre></td></tr></table></figure>

<p>我们可以看到这些url有指向jar包的,也有指向一个目录的(还有指向.jnilib文件的,这个我们可以不用管)。</p>
<p>ClassLoader从指定的路径下搜索class文件。而jar包其实是一个压缩包,将class文件打包在一起,所以ClassLoader也可以从jar包中搜索需要用到的class。</p>
<h2 id="Java类的加载流程"><a href="#Java类的加载流程" class="headerlink" title="Java类的加载流程"></a>Java类的加载流程</h2><h3 id="ClassLoader的创建"><a href="#ClassLoader的创建" class="headerlink" title="ClassLoader的创建"></a>ClassLoader的创建</h3><p>我们先从ClassLoader的创建开始说起。我们可以直接看<a href="http://www.grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/sun/misc/Launcher.java" target="_blank" rel="noopener">sun.misc.Launcher</a>的源码,它在构造函数中创建了ExtClassLoader和AppClassLoader:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public Launcher() &#123;</span><br><span class="line">    // Create the extension class loader</span><br><span class="line">    ClassLoader extcl;</span><br><span class="line">    try &#123;</span><br><span class="line">        extcl = ExtClassLoader.getExtClassLoader();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        throw new InternalError(</span><br><span class="line">            &quot;Could not create extension class loader&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Now create the class loader to use to launch the application</span><br><span class="line">    try &#123;</span><br><span class="line">        loader = AppClassLoader.getAppClassLoader(extcl);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        throw new InternalError(</span><br><span class="line">            &quot;Could not create application class loader&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Also set the context class loader for the primordial thread.</span><br><span class="line">    Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ExtClassLoader.getExtClassLoader()是一个工厂方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static ExtClassLoader getExtClassLoader() throws IOException</span><br><span class="line">&#123;</span><br><span class="line">    final File[] dirs = getExtDirs();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // Prior implementations of this doPrivileged() block supplied</span><br><span class="line">        // aa synthesized ACC via a call to the private method</span><br><span class="line">        // ExtClassLoader.getContext().</span><br><span class="line"></span><br><span class="line">        return AccessController.doPrivileged(</span><br><span class="line">            new PrivilegedExceptionAction&lt;ExtClassLoader&gt;() &#123;</span><br><span class="line">                public ExtClassLoader run() throws IOException &#123;</span><br><span class="line">                    int len = dirs.length;</span><br><span class="line">                    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">                        MetaIndex.registerDirectory(dirs[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    return new ExtClassLoader(dirs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125; catch (java.security.PrivilegedActionException e) &#123;</span><br><span class="line">        throw (IOException) e.getException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AppClassLoader.getAppClassLoader(final ClassLoader extcl)也是一个工厂方法,它需要传入一个ClassLoader作为AppClassLoader的父ClassLoader。而我们将ExtClassLoader传了进去,也就是说ExtClassLoader是AppClassLoader的父ClassLoader:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static ClassLoader getAppClassLoader(final ClassLoader extcl)</span><br><span class="line">    throws IOException</span><br><span class="line">&#123;</span><br><span class="line">    final String s = System.getProperty(&quot;java.class.path&quot;);</span><br><span class="line">    final File[] path = (s == null) ? new File[0] : getClassPath(s);</span><br><span class="line"></span><br><span class="line">    // Note: on bugid 4256530</span><br><span class="line">    // Prior implementations of this doPrivileged() block supplied</span><br><span class="line">    // a rather restrictive ACC via a call to the private method</span><br><span class="line">    // AppClassLoader.getContext(). This proved overly restrictive</span><br><span class="line">    // when loading  classes. Specifically it prevent</span><br><span class="line">    // accessClassInPackage.sun.* grants from being honored.</span><br><span class="line">    //</span><br><span class="line">    return AccessController.doPrivileged(</span><br><span class="line">        new PrivilegedAction&lt;AppClassLoader&gt;() &#123;</span><br><span class="line">            public AppClassLoader run() &#123;</span><br><span class="line">            URL[] urls =</span><br><span class="line">                (s == null) ? new URL[0] : pathToURLs(path);</span><br><span class="line">            return new AppClassLoader(urls, extcl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个ClassLoader都有一个父ClassLoader,我们可以通过ClassLoader.getParent()方法获取。同时我们也能使用Class.getClassLoader()获取加载这个类的ClassLoader。所以让我们来看看下面的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class GetClassLoader &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassLoader loader = GetClassLoader.class.getClassLoader();</span><br><span class="line">        do &#123;</span><br><span class="line">            System.out.println(loader);</span><br><span class="line">        &#125; while ((loader = loader.getParent()) != null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看打印我们可以知道, GetClassLoader是AppClassLoader加载的,而AppClassLoader的父ClassLoader是ExtClassLoader:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@28d93b30</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@74a14482</span><br></pre></td></tr></table></figure>

<p>但是如果我们查看String的ClassLoader又会发现它是null的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class GetClassLoader &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassLoader loader = String.class.getClassLoader();</span><br><span class="line">        System.out.println(&quot;loader : &quot; + loader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loader : null</span><br></pre></td></tr></table></figure>

<p>那是不是说String不是由ClassLoader加载的?当然不是!其实String是BootstrapClassLoader加载的。BootstrapClassLoader负责加载java的核心类。</p>
<p>但是为什么String.class.getClassLoader()拿到的是null呢？</p>
<p>原因是BootstrapClassLoader实际上不是一个java类,它是由C/C++编写的,它本身是虚拟机的一部分。所以在java中当然没有办法获取到它的引用。</p>
<h3 id="双亲委托"><a href="#双亲委托" class="headerlink" title="双亲委托"></a>双亲委托</h3><p>相信大家如果知道ClassLoader的话应该有听说过双亲委托,那下面我们就来讲一下双亲委托究竟是怎么一回事。</p>
<p>我们知道ClassLoader.loadClass()的方法可以加载一个类,所以研究一个类的加载流程,最好的方法当然还是去看源码啦:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">    throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">        // 首先,从缓存中查询该类是不是被加载过,如果加载过就可以直接返回</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            long t0 = System.nanoTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent != null) &#123;</span><br><span class="line">            		//判断它的父ClassLoader是否为空,如果不为空就调用父ClassLoader的loadClass方法去加载该类</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                	//如果它的父ClassLoader为空,则调用BootstrapClassLoader去加载该类,所以此时从逻辑上来讲BootstrapClassLoader是父ClassLoader</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                long t1 = System.nanoTime();</span><br><span class="line">                </span><br><span class="line">                //如果父ClassLoader不能加载该类才由自己去加载,这个方法从本ClassLoader的搜索路径中查找该类</span><br><span class="line">                c = findClass(name);</span><br><span class="line">                </span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中我们可以看到,加载一个类的时候,ClassLoader先会让父类去加载,如果父类加载失败,才会由它自己去加载,这就是我们说的双亲委托。</p>
<p>为什么类加载需要设计成双亲委托的方式呢？原因就在于双亲委托可以防止类被重复加载。如果父ClassLoader已经加载过一个类了,子ClassLoader就不会再次加载,可以防止同一个类被两个ClassLoader重复加载的问题。</p>
<p>这里还需要说的是,当我们自定义一个ClassLoader的时候,最好将AppClassLoader设为父ClassLoader。这样的话可以保证我们自定义的ClassLoader找加载类失败的时候还能从父ClassLoader中加载这个类。</p>
<p>双亲委托模式的流程如下图所示:</p>
<img src="/Android温故而知新-ClassLoader/1.png">


<h2 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h2><p>有时候我们可以继承ClassLoader实现自己的类加载器。自定义ClassLoader有两种方式:</p>
<ol>
<li>重写loadClass方法 </li>
<li>重写findClass方法</li>
</ol>
<p>他们有什么区别呢,还记得上一级ClassLoader.loadClass()的源码吗？loadClass方法内会先调用父ClassLoader的loadClass方法,如果父ClassLoader没有加载过该类才会调用本ClassLoader的findClass方法去加载类。</p>
<p>所以如果想要打破双亲委托机制的话就可以loadClass(),而如果还想继续沿用双亲委托机制的话就只需要重写findClass就好了。</p>
<p>我们写个小例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class MyClassLoader extends ClassLoader &#123;</span><br><span class="line">    public String mClassDir;</span><br><span class="line"></span><br><span class="line">    public MyClassLoader(String classDir) &#123;</span><br><span class="line">        this.mClassDir = classDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        File file = new File(mClassDir, getClassFileName(name));</span><br><span class="line">        if (file.exists()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                FileInputStream is = new FileInputStream(file);</span><br><span class="line"></span><br><span class="line">                ByteArrayOutputStream buf = new ByteArrayOutputStream();</span><br><span class="line">                int len;</span><br><span class="line">                while ((len = is.read()) != -1) &#123;</span><br><span class="line">                    buf.write(len);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                byte[] data = buf.toByteArray();</span><br><span class="line">                is.close();</span><br><span class="line">                buf.close();</span><br><span class="line"></span><br><span class="line">                return defineClass(name, data, 0, data.length);</span><br><span class="line">            &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return super.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getClassFileName(String fullName) &#123;</span><br><span class="line">        int index = fullName.lastIndexOf(&quot;.&quot;);</span><br><span class="line">        if (index == -1) &#123;</span><br><span class="line">            return fullName + &quot;.class&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return fullName.substring(index + 1) + &quot;.class&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们不需要打破双亲委托机制所以只需要重写findClass方法就可以了。我们自定义的ClassLoader会从指定的路径中搜索class文件,将它读入内存,然后通过调用ClassLoader.defineClass()方法去加载这个类。</p>
<p>我们在/Users/linjw/workspace/class_loader_demo目录下创建了一个Test.java:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package linjw.demo.classloader;</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public String getData() &#123;</span><br><span class="line">        return &quot;Hello World&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后通过javac命令编译出Test.class文件,同样放在/Users/linjw/workspace/class_loader_demo目录下。</p>
<p>然后用我们的MyClassLoader去加载它:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyClassLoader loader = new MyClassLoader(&quot;/Users/linjw/workspace/class_loader_demo&quot;);</span><br><span class="line">Class clazz = loader.loadClass(&quot;linjw.demo.classloader.Test&quot;);</span><br><span class="line">if (clazz != null) &#123;</span><br><span class="line">    Object obj = clazz.newInstance();</span><br><span class="line">    Method method = clazz.getDeclaredMethod(&quot;getData&quot;);</span><br><span class="line">    String result = (String) method.invoke(obj);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    System.out.println(&quot;ClassLoader : &quot; + clazz.getClassLoader());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;can&apos;t load class&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到下面的打印,说明我们已经成功用MyClassLoader加载了Test这个类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello World</span><br><span class="line">ClassLoader : linjw.demo.classloader.MyClassLoader@66cd51c3</span><br></pre></td></tr></table></figure>

<p>这里还有一个小的知识点,如果一个类是由某个ClassLoader加载的,那么它import的类也会由这个ClassLoader去加载。这里我们可以做一个实验:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package linjw.demo.classloader;</span><br><span class="line"></span><br><span class="line">import linjw.demo.classloader.Test;</span><br><span class="line"></span><br><span class="line">public class Test2 &#123;</span><br><span class="line">    public String getData()&#123;</span><br><span class="line">        return &quot;Test ClassLoader : &quot; + Test.class.getClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们写一个Test2类,它会import Test并返回Test的ClassLoader。让我们写个demo看看这个Test的ClassLoader:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyClassLoader loader = new MyClassLoader(&quot;/Users/linjw/workspace/class_loader_demo&quot;);</span><br><span class="line">Class clazz = loader.loadClass(&quot;linjw.demo.classloader.Test2&quot;);</span><br><span class="line">if (clazz != null) &#123;</span><br><span class="line">    Object obj = clazz.newInstance();</span><br><span class="line">    Method method = clazz.getDeclaredMethod(&quot;getData&quot;);</span><br><span class="line">    String result = (String) method.invoke(obj);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;can&apos;t load class&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过打印可以知道Test也是由MyClassLoader加载的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linjw.demo.classloader.MyClassLoader@66cd51c3</span><br></pre></td></tr></table></figure>

<h2 id="Context-ClassLoader"><a href="#Context-ClassLoader" class="headerlink" title="Context ClassLoader"></a>Context ClassLoader</h2><p>Context ClassLoader并不是一个实际的类,它只是Thread的一个成员变量:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line">	private ClassLoader contextClassLoader;</span><br><span class="line"></span><br><span class="line">	private void init2(Thread parent) &#123;</span><br><span class="line">        this.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ClassLoader getContextClassLoader() &#123;</span><br><span class="line">        return contextClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContextClassLoader(ClassLoader cl) &#123;</span><br><span class="line">        contextClassLoader = cl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个Thread都有一个相关联的ClassLoader,子线程默认使用父线程的ClassLoader。</p>
<p>而线程的默认ClassLoader是AppClassLoader:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public Launcher() &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    try &#123;</span><br><span class="line">        loader = AppClassLoader.getAppClassLoader(extcl);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        throw new InternalError(</span><br><span class="line">            &quot;Could not create application class loader&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //设置AppClassLoader为当前线程的Context ClassLoader</span><br><span class="line">    Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Context ClassLoader的存在是为了解决使用双亲委托机制下父ClassLoader无法找到子ClassLoader的问题。假如有下面的委托链:</p>
<p>ClassLoaderA -&gt; AppClassLoader -&gt; ExtClassLoader -&gt; BootstrapClassLoader</p>
<p>那么委派链左边的ClassLoader就可以很自然的使用右边的ClassLoader所加载的类。 </p>
<p>但如果是右边的ClassLoader想要反过来使用左边的ClassLoader所加载的类就无能为力了。</p>
<p>这个时候如果使用Context ClassLoader就能从线程中获得左边的ClassLoader了。</p>
<p>那什么时候会出现右边的ClassLoader想要反过来使用左边的ClassLoader所加载的类的情况呢？</p>
<p>我们上一节刚刚说过:“如果一个类是由某个ClassLoader加载的,那么它import的类也会由这个ClassLoader去加载”。</p>
<p>举个例子,Java 提供了很多服务提供者接口（Service Provider Interface，SPI）,允许第三方为这些接口提供实现。如JAXP(XML处理的Java API)的SPI__接口__定义包含在 javax.xml.parsers包中，它是由BootstrapClassLoader加载的。</p>
<p>但是它的实现代码很可能是作为Java应用所依赖的jar包被包含进来,如实现了JAXP SPI的Apache Xerces所包含的jar包,它由AppClassLoader加载。</p>
<p>我们用javax.xml.parsers.DocumentBuilderFactory类中的newInstance()方法用来生成一个新的DocumentBuilderFactory的实例, DocumentBuilderFactory是一个抽象类,它定是java核心库的一部分,由BootstrapClassLoader去加载。因此,DocumentBuilderFactory里面import的类都由BootstrapClassLoader去加载。</p>
<p>但是DocumentBuilderFactory的实现类却是在org.apache.xerces.jaxp.DocumentBuilderFactoryImpl中定义的, BootstrapClassLoader无法加载它。这个时候就需要在DocumentBuilderFactory. newInstance()的代码中使用Context ClassLoader，找到AppClassLoader去加载DocumentBuilderFactoryImpl这个实现类。</p>
<h1 id="安卓中的ClassLoader"><a href="#安卓中的ClassLoader" class="headerlink" title="安卓中的ClassLoader"></a>安卓中的ClassLoader</h1><p>安卓的的类也是通过ClassLoader加载的,但是并不是java中的BootstrapClassLoader、 ExtClassLoader或者AppClassLoader。写个小demo看看安卓中加载类的是哪些ClassLoader:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Log.d(&quot;DxClassLoader&quot;, &quot;BootClassLoader :&quot; + String.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">ClassLoader loader = MainActivity.class.getClassLoader();</span><br><span class="line">do &#123;</span><br><span class="line">	Log.d(&quot;DxClassLoader&quot;, &quot;loader :&quot; + loader);</span><br><span class="line">&#125; while ((loader = loader.getParent()) != null);</span><br></pre></td></tr></table></figure>

<p>打印如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">09-27 23:11:03.432 21151-21151/? D/DxClassLoader: BootClassLoader :java.lang.BootClassLoader@ad96016</span><br><span class="line">09-27 23:11:03.432 21151-21151/? D/DxClassLoader: loader :dalvik.system.PathClassLoader[DexPathList[[zip file &quot;/data/app/linjw.demo.classloader-2/base.apk&quot;],nativeLibraryDirectories=[/data/app/linjw.demo.classloader-2/lib/arm64, /vendor/lib64, /system/lib64]]]</span><br><span class="line">09-27 23:11:03.433 21151-21151/? D/DxClassLoader: loader :java.lang.BootClassLoader@ad96016</span><br></pre></td></tr></table></figure>

<p>我们可以看到安卓中用的了PathClassLoader和BootClassLoader两个ClassLoader,其中BootClassLoader是PathClassLoader的parent。</p>
<p>而和在java程序不同的是String是由BootClassLoader加载的。安卓的BootClassLoader其实就相当于java的BootstrapClassLoader,只不过它是由java实现的而不是由c/c++实现的。</p>
<h2 id="PathClassLoader"><a href="#PathClassLoader" class="headerlink" title="PathClassLoader"></a>PathClassLoader</h2><p>我们在上一节中将PathClassLoader打印出来的时候可以看到一个apk路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zip file &quot;/data/app/linjw.demo.classloader-2/base.apk&quot;]</span><br></pre></td></tr></table></figure>

<p>apk其实是一个也是一个zip压缩包,我们可以将一个apk文件后缀改成.zip然后就可以直接解压了。PathClassLoader的作用其实就是在这个zip包中加载dex文件,我们通过它甚至可以加载其他应用的代码,但它只能加载已安装的应用。</p>
<p>例如我们可以新建一个ext工程,它的包名为linjw.demo.classloader.ext,然后在里面创建Test类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package linjw.demo.classloader.ext;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public String getData() &#123;</span><br><span class="line">        return &quot;Hello World&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编译出apk来,并且安装。之后就能从这个apk中加载出Test类了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">String path = null;</span><br><span class="line">PackageManager pm = getPackageManager();</span><br><span class="line">try &#123;</span><br><span class="line">    path = pm.getApplicationInfo(&quot;linjw.demo.classloader.ext&quot;, 0).sourceDir;</span><br><span class="line">&#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PathClassLoader loader = new PathClassLoader(path, ClassLoader.getSystemClassLoader());</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    Class clazz = loader.loadClass(&quot;linjw.demo.classloader.ext.Test&quot;);</span><br><span class="line"></span><br><span class="line">    if (clazz != null) &#123;</span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line">        Method method = clazz.getDeclaredMethod(&quot;getData&quot;);</span><br><span class="line">        String result = (String) method.invoke(obj);</span><br><span class="line">        Log.d(&quot;DxClassLoader&quot;, result);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Log.d(&quot;DxClassLoader&quot;, &quot;can&apos;t load class&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; catch (InstantiationException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以得到打印:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">09-27 23:39:16.571 24077-24077/? D/DxClassLoader: Hello World</span><br></pre></td></tr></table></figure>

<h2 id="DexClassLoader"><a href="#DexClassLoader" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h2><p>PathClassLoader只能加载已经安装的应用里面的类,但是DexClassLoader却能加载未安装的应用里面的类。例如我们将apk放到存储卡目录下而不去安装它:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">String dir = Environment.getExternalStorageDirectory().getAbsolutePath();</span><br><span class="line">File apk = new File(dir, &quot;Ext.apk&quot;);</span><br><span class="line">File dexOutputDir = this.getDir(&quot;dex&quot;, 0);</span><br><span class="line">DexClassLoader loader = new DexClassLoader(</span><br><span class="line">        apk.getAbsolutePath(),</span><br><span class="line">        dexOutputDir.getAbsolutePath(),</span><br><span class="line">        null, getClassLoader());</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    Class clazz = loader.loadClass(&quot;linjw.demo.classloader.ext.Test&quot;);</span><br><span class="line"></span><br><span class="line">    if (clazz != null) &#123;</span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line">        Method method = clazz.getDeclaredMethod(&quot;getData&quot;);</span><br><span class="line">        String result = (String) method.invoke(obj);</span><br><span class="line">        Log.d(&quot;DxClassLoader&quot;, result);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Log.d(&quot;DxClassLoader&quot;, &quot;can&apos;t load class&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; catch (InstantiationException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样可以得到打印:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">09-27 23:54:29.206 25472-25472/? D/DxClassLoader: Hello World</span><br></pre></td></tr></table></figure>

<p>我们可以看到, DexClassLoader的构造函数的参数比PathClassLoader的要多出一个optimizedDirectory:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class DexClassLoader extends BaseDexClassLoader &#123;</span><br><span class="line">    public DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) &#123;</span><br><span class="line">        super((String)null, (File)null, (String)null, (ClassLoader)null);</span><br><span class="line">        throw new RuntimeException(&quot;Stub!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class PathClassLoader extends BaseDexClassLoader &#123;</span><br><span class="line">    public PathClassLoader(String dexPath, ClassLoader parent) &#123;</span><br><span class="line">        super((String)null, (File)null, (String)null, (ClassLoader)null);</span><br><span class="line">        throw new RuntimeException(&quot;Stub!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) &#123;</span><br><span class="line">        super((String)null, (File)null, (String)null, (ClassLoader)null);</span><br><span class="line">        throw new RuntimeException(&quot;Stub!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那这个optimizedDirectory到底有什么作用呢?其实optimizedDirectory是用来存放从apk中解压出来的dex文件的。</p>
<p>DexClassLoader和PathClassLoader其实归根结底都是通过DexFile这个类去加载的dex文件,并不是直接读取的apk。因为如果每次都需要解压才能加载代码的话效率实在太低了。</p>
<p>DexClassLoader可以主动解压apk,所以可以加载未安装的应用中的代码。但PathClassLoader不会主动解压apk,它是读取的已经安装的apk在cache中存在缓存的dex文件,所以它只能加载已安装应用中的代码。</p>
<h2 id="生成dex文件"><a href="#生成dex文件" class="headerlink" title="生成dex文件"></a>生成dex文件</h2><p>DexClassLoader和PathClassLoader最后都是加载的dex文件。所以我们可以直接将dex文件的路径传给他们去加载。但dex文件又是个什么东西呢？</p>
<p>普通的java程序中,JVM虚拟机可以通过ClassLoader去加载jar到的加载类的目的。但是android使用的Dalvik/ART虚拟机不能直接加载jar包,需要把.jar文件优化成.dex文件才能加载。所以实际上dex文件是优化过的jar包。</p>
<p>我们可以用Android SDK提供的DX工具把.jar文件优化成.dex文件。我们用之前的Test.java做例子,具体步骤如下:</p>
<p>1.使用javac命令编译Test.java得到Test.class文件(我这边的java环境是1.8的,如果不指定用1.7的话生成dex也会失败,报<strong>com.android.dx.cf.iface.ParseException: bad class file magic (cafebabe) or version (0034.0000)</strong>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -source 1.7 -target 1.7 Test.java</span><br></pre></td></tr></table></figure>

<p>2.将创建目录子目录linjw/demo/classloader/ext并将Test.class移动到子目录中(因为Test的package是linjw.demo.classloader.ext,所以要根据它生成同样的目录,要不然生成dex会失败)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p linjw/demo/classloader/ext</span><br><span class="line">mv Test.class linjw/demo/classloader/ext</span><br></pre></td></tr></table></figure>

<p>3.使用jar命令将linjw目录打包成jar包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cf Test.jar linjw</span><br></pre></td></tr></table></figure>

<p>4.用dx工具将jar包优化成dex包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/linjw/androidsdk/android-sdk-macosx/build-tools/19.1.0/dx --dex --output=Test.dex Test.jar</span><br></pre></td></tr></table></figure>

<h2 id="动态加载dex文件"><a href="#动态加载dex文件" class="headerlink" title="动态加载dex文件"></a>动态加载dex文件</h2><p>然后我们就能将它放到存储卡中用DexClassLoader或者PathClassLoader去加载了。</p>
<h3 id="使用反射的反射加载"><a href="#使用反射的反射加载" class="headerlink" title="使用反射的反射加载"></a>使用反射的反射加载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String dir = Environment.getExternalStorageDirectory().getAbsolutePath();</span><br><span class="line">File dex = new File(dir, &quot;Test.dex&quot;);</span><br><span class="line">File dexOutputDir = this.getDir(&quot;dex&quot;, 0);</span><br><span class="line"></span><br><span class="line">//使用PathClassLoader加载dex</span><br><span class="line">//PathClassLoader loader = new PathClassLoader(dex.getAbsolutePath(), getClassLoader());</span><br><span class="line"></span><br><span class="line">//使用DexClassLoader加载dex</span><br><span class="line">DexClassLoader loader = new DexClassLoader(</span><br><span class="line">        dex.getAbsolutePath(),</span><br><span class="line">        dexOutputDir.getAbsolutePath(),</span><br><span class="line">        null,</span><br><span class="line">        getClassLoader());</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    Class clazz = loader.loadClass(&quot;linjw.demo.classloader.ext.Test&quot;);</span><br><span class="line"></span><br><span class="line">    if (clazz != null) &#123;</span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line">        Method method = clazz.getDeclaredMethod(&quot;getData&quot;);</span><br><span class="line">        String result = (String) method.invoke(obj);</span><br><span class="line">        Log.d(&quot;DxClassLoader&quot;, result);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Log.d(&quot;DxClassLoader&quot;, &quot;can&apos;t load class&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; catch (InstantiationException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用接口的方式加载"><a href="#使用接口的方式加载" class="headerlink" title="使用接口的方式加载"></a>使用接口的方式加载</h3><p>或者我们也可以使用接口的方式:</p>
<p>1.添加ITest接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package linjw.demo.classloader.ext;</span><br><span class="line"></span><br><span class="line">public interface ITest &#123;</span><br><span class="line">    String getData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.Test类实现ITest接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package linjw.demo.classloader.ext;</span><br><span class="line"></span><br><span class="line">public class Test implements ITest &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getData() &#123;</span><br><span class="line">        return &quot;Hello World&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.将它们一起打包到Test.dex</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">javac -source 1.7 -target 1.7 Test.java ITest.java</span><br><span class="line"></span><br><span class="line">mkdir -p linjw/demo/classloader/ext</span><br><span class="line"></span><br><span class="line">mv Test.class linjw/demo/classloader/ext</span><br><span class="line"></span><br><span class="line">mv Test.class linjw/demo/classloader</span><br><span class="line"></span><br><span class="line">jar -cf Test.jar linjw</span><br><span class="line"></span><br><span class="line">/Users/linjw/androidsdk/android-sdk-macosx/build-tools/19.1.0/dx --dex --output=Test.dex Test.jar</span><br></pre></td></tr></table></figure>

<p>4.在安卓项目中导入ITest接口并调整代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">String dir = Environment.getExternalStorageDirectory().getAbsolutePath();</span><br><span class="line">File dex = new File(dir, &quot;Test.dex&quot;);</span><br><span class="line">File dexOutputDir = this.getDir(&quot;dex&quot;, 0);</span><br><span class="line"></span><br><span class="line">//使用PathClassLoader加载dex</span><br><span class="line">//PathClassLoader loader = new PathClassLoader(dex.getAbsolutePath(), getClassLoader());</span><br><span class="line"></span><br><span class="line">//使用DexClassLoader加载dex</span><br><span class="line">DexClassLoader loader = new DexClassLoader(</span><br><span class="line">    dex.getAbsolutePath(),</span><br><span class="line">    dexOutputDir.getAbsolutePath(),</span><br><span class="line">    null,</span><br><span class="line">    getClassLoader());</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">Class clazz = loader.loadClass(&quot;linjw.demo.classloader.ext.Test&quot;);</span><br><span class="line"></span><br><span class="line">if (clazz != null) &#123;</span><br><span class="line">    //注意这里,使用的是ITest</span><br><span class="line">    ITest obj = (ITest) clazz.newInstance();</span><br><span class="line">    String result = obj.getData();</span><br><span class="line">    Log.d(&quot;DxClassLoader&quot;, result);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    Log.d(&quot;DxClassLoader&quot;, &quot;can&apos;t load class&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (InstantiationException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实我比较推荐使用在程序主体中定义接口,加载外部实现代码的这种方法。一方面它比反射的效率高,另一方面也比较容易阅读。</p>

    
  </div>
</article>

</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              target="_self"
              >
              搜索
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              target="_self"
              >
              RSS
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    




  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235687', function() {
      // load success
    });
  }
</script>

  <footer style="flex: 0 0 auto;text-align: center;">
<a style="font-size:12px; color:#6C6C6C" target="_blank">© 2021  林嘉伟 ❤ <a style="font-size:12px; color:#6C6C6C" target="_blank" href="http://beian.miit.gov.cn/" rel="nofollow">粤ICP备2021021473号</a></footer>
</body>
</html>
