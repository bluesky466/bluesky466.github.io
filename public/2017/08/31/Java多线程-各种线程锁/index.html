<!DOCTYPE html>


  <html class="light page-home">


<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>Java多线程 - 各种线程锁 | LinJW</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="技术相关,java,">
  

  <meta name="description" content="多个线程同时对同一个对象进行读写操作,很容易会出现一些难以预料的问题。所以很多时候我们需要给代码块加锁,同一时刻只允许一个线程对某个对象进行操作。多线程之所以会容易引发一些难以发现的bug,很多时候是写代码的程序员对线程锁不熟悉或者干脆就没有在必要的地方给线程加锁导致的。这里我想总结一下java多线程中的各种锁的作用和用法,还有容易踩的坑。 这篇文章里面有很多的文字和代码都来自于《实战Java高并">
<meta name="keywords" content="技术相关,java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java多线程 - 各种线程锁">
<meta property="og:url" content="http://139.199.4.241/2017/08/31/Java多线程-各种线程锁/index.html">
<meta property="og:site_name" content="LinJW">
<meta property="og:description" content="多个线程同时对同一个对象进行读写操作,很容易会出现一些难以预料的问题。所以很多时候我们需要给代码块加锁,同一时刻只允许一个线程对某个对象进行操作。多线程之所以会容易引发一些难以发现的bug,很多时候是写代码的程序员对线程锁不熟悉或者干脆就没有在必要的地方给线程加锁导致的。这里我想总结一下java多线程中的各种锁的作用和用法,还有容易踩的坑。 这篇文章里面有很多的文字和代码都来自于《实战Java高并">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-10-14T14:06:52.262Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java多线程 - 各种线程锁">
<meta name="twitter:description" content="多个线程同时对同一个对象进行读写操作,很容易会出现一些难以预料的问题。所以很多时候我们需要给代码块加锁,同一时刻只允许一个线程对某个对象进行操作。多线程之所以会容易引发一些难以发现的bug,很多时候是写代码的程序员对线程锁不熟悉或者干脆就没有在必要的地方给线程加锁导致的。这里我想总结一下java多线程中的各种锁的作用和用法,还有容易踩的坑。 这篇文章里面有很多的文字和代码都来自于《实战Java高并">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=32204ee7" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>
</html>
<body>

  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#synchronized关键字"><span class="toc-text">synchronized关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized的作用"><span class="toc-text">synchronized的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#等待-wait-和通知-notify"><span class="toc-text">等待(wait)和通知(notify)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized容易犯的隐蔽错误"><span class="toc-text">synchronized容易犯的隐蔽错误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#是否给同一个对象加锁"><span class="toc-text">是否给同一个对象加锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#是否给错误的对象加锁"><span class="toc-text">是否给错误的对象加锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重入锁"><span class="toc-text">重入锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock是可中断的"><span class="toc-text">ReentrantLock是可中断的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock可以设置等待限时"><span class="toc-text">ReentrantLock可以设置等待限时</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock可以设置公平锁"><span class="toc-text">ReentrantLock可以设置公平锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock可以与Condition配合使用"><span class="toc-text">ReentrantLock可以与Condition配合使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#信号量"><span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他的一些锁"><span class="toc-text">其他的一些锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#读写锁"><span class="toc-text">读写锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#倒计时器、循环栅栏"><span class="toc-text">倒计时器、循环栅栏</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Java多线程-各种线程锁" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Java多线程 - 各种线程锁</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.08.31</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>林嘉伟</span>
        </span>
      

      


      

    </div>
  </header>

  <div class="article-content">
    
      <p>多个线程同时对同一个对象进行读写操作,很容易会出现一些难以预料的问题。所以很多时候我们需要给代码块加锁,同一时刻只允许一个线程对某个对象进行操作。多线程之所以会容易引发一些难以发现的bug,很多时候是写代码的程序员对线程锁不熟悉或者干脆就没有在必要的地方给线程加锁导致的。这里我想总结一下java多线程中的各种锁的作用和用法,还有容易踩的坑。</p>
<p>这篇文章里面有很多的文字和代码都来自于《实战Java高并发程序设计》。它真的是一本很不错的书,建议大家有空可以去看一下。</p>
<h1 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h1><h2 id="synchronized的作用"><a href="#synchronized的作用" class="headerlink" title="synchronized的作用"></a>synchronized的作用</h2><p>关键字synchronized的作用是实现线程间的同步。它的工作是对同步的代码加锁,使得每一次,只能有一个线程进入同步块,从而保证线程间的安全性。</p>
<p>关键字synchronized可以有多张用法,这里做一个简单的整理:</p>
<blockquote>
<p>指定加锁对象:对给定对象加锁,进入同步代码前要获取给定对象的锁。<br>直接作用于实例方法:相当于给当前实例加锁,进入同步代码块前要获得当前实例的锁。<br>直接作用于静态方法:相当于对当前类加锁,进入同步代码前要获取当前类的锁。</p>
</blockquote>
<p>下面来分别说一下上面的三点:</p>
<p>假设我们有下面这样一个Runnable,在run方法里对<strong>静态</strong>成员变量sCount自增10000次:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Count implements Runnable &#123;</span><br><span class="line">    private static int sCount = 0;</span><br><span class="line"></span><br><span class="line">    public static int getCount() &#123;</span><br><span class="line">        return sCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            sCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们在两个Thread里面同时跑这个Runnable:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Count count = new Count();</span><br><span class="line">Thread t1 = new Thread(count);</span><br><span class="line">Thread t2 = new Thread(count);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">try &#123;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(Count.getCount());</span><br></pre></td></tr></table></figure>

<p>得到的结果并不是20000,而是一个比20000小的数,如14233。</p>
<p>这是为什么呢？假设两个线程分别读取sCount为0,然后各自技术得到sCount为1,并先后写入这个结果,因此,虽然sCount++执行了2次,但是实际sCount的值只增加了1。</p>
<p>我们可以用指定加锁对象的方法解决这个问题,这里因为两个Thread跑的是同一个Count实例,所以可以直接给this加锁:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Count implements Runnable &#123;</span><br><span class="line">    private static int sCount = 0;</span><br><span class="line"></span><br><span class="line">    public static int getCount() &#123;</span><br><span class="line">        return sCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                sCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以给实例方法加锁,这种方式和上面那一种的区别就是给this加锁,锁的区域比较小,两个线程交替执行sCount++操作,而给方法加锁的话,先拿到锁的线程会连续执行1000次sCount自增,然后再释放锁给另一个线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Count implements Runnable &#123;</span><br><span class="line">    private static int sCount = 0;</span><br><span class="line"></span><br><span class="line">    public static int getCount() &#123;</span><br><span class="line">        return sCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            sCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized直接作用于静态方法的用法和上面的给实例方法加锁类似,不过它是作用于静态方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Count implements Runnable &#123;</span><br><span class="line">    private static int sCount = 0;</span><br><span class="line"></span><br><span class="line">    public static int getCount() &#123;</span><br><span class="line">        return sCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static synchronized void increase() &#123;</span><br><span class="line">        sCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="等待-wait-和通知-notify"><a href="#等待-wait-和通知-notify" class="headerlink" title="等待(wait)和通知(notify)"></a>等待(wait)和通知(notify)</h2><p>Object有两个很重要的接口:Object.wait()和Object.notify()</p>
<p>当在一个对象实例上调用了wait()方法后,当前线程就会在这个对象上等待。直到其他线程调用了这个对象的notify()方法或者notifyAll()方法。notifyAll()方法与notify()方法的区别是它会唤醒所有正在等待这个对象的线程,而notify()方法只会随机唤醒一个等待该对象的线程。</p>
<p>wait()、notify()和notifyAll()都需要在synchronized语句中使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">    private Object mLock;</span><br><span class="line"></span><br><span class="line">    public MyThread(Object lock) &#123;</span><br><span class="line">        this.mLock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();</span><br><span class="line"></span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                mLock.wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;in MyThread&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Object lock = new Object();</span><br><span class="line">MyThread t = new MyThread(lock);</span><br><span class="line">t.start();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;before sleep&quot;);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    Thread.sleep(2000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;after sleep&quot;);</span><br><span class="line"></span><br><span class="line">synchronized (lock) &#123;</span><br><span class="line">    lock.notify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    t.join();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的例子可以看出来,在调用wait()方法实际上已经释放了对象的锁,所以在其他线程中才能获取到这个对象的锁,从而进行notify操作。而等待的线程被唤醒后又需要重新获得对象的锁。</p>
<h2 id="synchronized容易犯的隐蔽错误"><a href="#synchronized容易犯的隐蔽错误" class="headerlink" title="synchronized容易犯的隐蔽错误"></a>synchronized容易犯的隐蔽错误</h2><h3 id="是否给同一个对象加锁"><a href="#是否给同一个对象加锁" class="headerlink" title="是否给同一个对象加锁"></a>是否给同一个对象加锁</h3><p>在用synchronized给对象加锁的时候需要注意加锁是不是同一个,如将代码改成这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = new Thread(new Count());</span><br><span class="line">Thread t2 = new Thread(new Count());</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">try &#123;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(Count.getCount());</span><br></pre></td></tr></table></figure>

<p>因为两个线程跑的是不同的Count实例,所以用给指定对象加锁和给实例方法加锁的方法都不能避免两个线程同时对<strong>静态</strong>成员变量sCount进行自增操作。</p>
<p>但是如果用第三种作用于静态方法的写法,就能正确的加锁。</p>
<h3 id="是否给错误的对象加锁"><a href="#是否给错误的对象加锁" class="headerlink" title="是否给错误的对象加锁"></a>是否给错误的对象加锁</h3><p>如我们将sCount的类型改成Integer,并且在sCount++的时候直接对sCount加锁会发生什么事情呢(毕竟我们会很自然的给要操作的对象加锁来实现线程同步)？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Count implements Runnable &#123;</span><br><span class="line">    private static Integer sCount = 0;</span><br><span class="line"></span><br><span class="line">    public static int getCount() &#123;</span><br><span class="line">        return sCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            synchronized (sCount) &#123;</span><br><span class="line">                sCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Count count = new Count();</span><br><span class="line">Thread t1 = new Thread(count);</span><br><span class="line">Thread t2 = new Thread(count);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">try &#123;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(Count.getCount());</span><br></pre></td></tr></table></figure>

<p>最后的得到的结果仍然是比20000小的值。</p>
<p>这是为什么呢？《实战Java高并发程序设计》中给出的解释是这样的:</p>
<blockquote>
<p>在Java中,Integer使用不变对象。也就是对象一旦被创建,就不可能被修改。也就是说,如果你有一个Integer代表1,那么它就永远是1,你不可能改变Integer的值,使它位。那如果你需要2怎么办呢？也很简单,新建一个Integer,并让它表示2即可。</p>
</blockquote>
<p>也就是说sCount在真实执行时变成了:</p>
<blockquote>
<p>sCount = Integer.valueOf(sCount.intValue()+1);</p>
</blockquote>
<p>进一步看Integer.valueOf()，我们可以看到:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    assert IntegerCache.high &gt;= 127;</span><br><span class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以在多个线程中,由于sCount一直在变,并不是同一个对象,所以两个线程的加锁可能加在了不同的Integer对象上,并没有真正的锁住代码块。</p>
<p>我再举一个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void increase(Integer integer)&#123;</span><br><span class="line">    integer++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在外面这样调用它,并不会使得传入的Integer增加:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = 0;</span><br><span class="line">increase(i);</span><br></pre></td></tr></table></figure>

<h1 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h1><p>ReentrantLock的意思是Re-Entrant-Lock也就是重入锁,它的特点就是在同一个线程中可以重复加锁,只需要解锁同样的次数就能真正解锁:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">    private ReentrantLock mLock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();</span><br><span class="line"></span><br><span class="line">        mLock.lock();</span><br><span class="line">        System.out.println(&quot;outside&quot;);</span><br><span class="line"></span><br><span class="line">        mLock.lock();</span><br><span class="line">        System.out.println(&quot;inside&quot;);</span><br><span class="line">        mLock.unlock();</span><br><span class="line"></span><br><span class="line">        mLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上synchronized也是可重入的,比如下面的代码同样是可以正常退出的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            System.out.println(&quot;outside&quot;);</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                System.out.println(&quot;inside&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与synchronized相比,重入锁需要程序员手动调用加锁和解锁,也因为如此,重入锁对逻辑控制的灵活性要远远好于synchronized。</p>
<p>重入锁可以完全替代synchronized关键字。在JDK 5.0的早起版本中,重入锁的性能远远好于synchronized。但从JDK 6.0开始,JDK在synchronized做了大量优化,使得两者的性能差距并不大。</p>
<h2 id="ReentrantLock是可中断的"><a href="#ReentrantLock是可中断的" class="headerlink" title="ReentrantLock是可中断的"></a>ReentrantLock是可中断的</h2><p>对于synchronized,如果它在等待锁,那么它就只有两个状态:获得锁继续执行或者保持等待。但是对于重入锁,就有了另外一种可能,那就是重入锁在等待的时候可以被中断:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">    private ReentrantLock mLock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            mLock.lockInterruptibly();</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(5000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            if(mLock.isHeldByCurrentThread())&#123;</span><br><span class="line">                mLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ReentrantLock可以设置等待限时"><a href="#ReentrantLock可以设置等待限时" class="headerlink" title="ReentrantLock可以设置等待限时"></a>ReentrantLock可以设置等待限时</h2><p>ReentrantLock.tryLock()方法可以给等待锁设置最长等待时间,如果在设置的时间结束之前获取到锁就会返回true,否则返回false:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">    private ReentrantLock mLock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            if (mLock.tryLock(2, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (mLock.isHeldByCurrentThread()) &#123;</span><br><span class="line">                mLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock.tryLock()也可以不带参数直接运行。在这种情况下,当前线程会尝试获得锁,如果锁并未被其他线程占用,则申请锁会成功,并立即返回true。如果锁被其他线程占用,则当前线程不会进行等待,而是立即返回false。</p>
<h2 id="ReentrantLock可以设置公平锁"><a href="#ReentrantLock可以设置公平锁" class="headerlink" title="ReentrantLock可以设置公平锁"></a>ReentrantLock可以设置公平锁</h2><p>大多数情况下,锁的申请是非公平的。也就是说,线程1首先请求了锁A，接着线程2也请求了锁A。那么当锁A可用时,是线程1可以获得锁还是线程2可以获得锁呢？这是不一定的。系统只是会从这个锁的等待队列里随机挑选一个:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">    private ReentrantLock mLock;</span><br><span class="line"></span><br><span class="line">    public MyThread(String name, ReentrantLock lock) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.mLock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            mLock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;获得锁&quot;);</span><br><span class="line">            mLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock();</span><br><span class="line">MyThread t1 = new MyThread(&quot;t1&quot;, lock);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">MyThread t2 = new MyThread(&quot;t2&quot;, lock);</span><br><span class="line">t2.start();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">t1获得锁</span><br><span class="line">t2获得锁</span><br><span class="line">t2获得锁</span><br><span class="line">t2获得锁</span><br><span class="line">t1获得锁</span><br><span class="line">t2获得锁</span><br><span class="line">t2获得锁</span><br><span class="line">t1获得锁</span><br><span class="line">t2获得锁</span><br><span class="line">t1获得锁</span><br><span class="line">t2获得锁</span><br><span class="line">t2获得锁</span><br><span class="line">t2获得锁</span><br><span class="line">t1获得锁</span><br><span class="line">t1获得锁</span><br></pre></td></tr></table></figure>

<p>synchronized产生的锁也是非公平的。但如果使用ReentrantLock(boolean fair)构造函数创建ReentrantLock,并且传入true。则该重入锁是公平的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock(true);</span><br><span class="line">MyThread t1 = new MyThread(&quot;t1&quot;, lock);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">MyThread t2 = new MyThread(&quot;t2&quot;, lock);</span><br><span class="line">t2.start();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t1获得锁</span><br><span class="line">t2获得锁</span><br><span class="line">t1获得锁</span><br><span class="line">t2获得锁</span><br><span class="line">t1获得锁</span><br><span class="line">t2获得锁</span><br><span class="line">t1获得锁</span><br><span class="line">t2获得锁</span><br><span class="line">t1获得锁</span><br><span class="line">t2获得锁</span><br><span class="line">t1获得锁</span><br></pre></td></tr></table></figure>

<p>需要注意的是实现公平锁必然要求系统维护一个有序队列,所以公平锁的实现成本较高,性能也相对低下,因此,默认情况下,锁是非公平的。</p>
<h2 id="ReentrantLock可以与Condition配合使用"><a href="#ReentrantLock可以与Condition配合使用" class="headerlink" title="ReentrantLock可以与Condition配合使用"></a>ReentrantLock可以与Condition配合使用</h2><p>Condition和之前讲过的Object.wait()还有Object.notify()的作用大致相同:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">	private ReentrantLock mLock;</span><br><span class="line">	private Condition mCondition;</span><br><span class="line">	</span><br><span class="line">	public MyThread(ReentrantLock lock, Condition condition) &#123;</span><br><span class="line">	    this.mLock = lock;</span><br><span class="line">	    this.mCondition = condition;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">	    super.run();</span><br><span class="line">	</span><br><span class="line">	    mLock.lock();</span><br><span class="line">	    try &#123;</span><br><span class="line">	        mCondition.await();</span><br><span class="line">	    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">	        e.printStackTrace();</span><br><span class="line">	    &#125;</span><br><span class="line">	    mLock.unlock();</span><br><span class="line">	</span><br><span class="line">	    System.out.println(&quot;in MyThread&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line">MyThread t = new MyThread(lock, condition);</span><br><span class="line">t.start();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;before sleep&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">    Thread.sleep(2000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;after sleep&quot;);</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line">condition.signal();</span><br><span class="line">lock.unlock();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    t.join();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Condition的操作需要在ReentrantLock.lock()和ReentrantLock.unlock()之间进行的。</p>
<p>ReentrantLock.newCondition()可以创建一个Condition。Condition.await()方法相当于Object.wait()方法,而Condition.signal()方法相当于Object.notify()方法。当然它也有对应的Condition.signalAll()方法。</p>
<p>同样的在调用Condition.await()之后,线程占用的锁会被释放。这样在Condition.signal()方法调用的时候才获取到锁。</p>
<p>需要注意的是Condition.signal()方法调用之后,被唤醒的线程因为需要重新获取锁。所以需要等到调用Condition.signal()的线程释放了锁(调用ReentrantLock.unlock())之后才能继续执行。</p>
<p>Condition接口的基本方法如下,它提供了限时等待、不可中断的等待之类的操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void await() throws InterruptedException;</span><br><span class="line">void awaitUninterruptibly();</span><br><span class="line">long awaitNanos(long nanosTimeout) throws InterruptedException;</span><br><span class="line">boolean await(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line">boolean awaitUntil(Date deadline) throws InterruptedException;</span><br><span class="line">void signal();</span><br><span class="line">void signalAll();</span><br></pre></td></tr></table></figure>

<h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>信号量为多线程协作提供了更为强大的控制方法。广义上说,信号量是对锁的拓展。无论是synchronize还是重入锁,一次都只运行一个线程访问一个资源,而信号锁则可以指定多个线程,同时访问某一个资源。</p>
<p>像下面的代码, MyRunnable被加锁的代码块一次会被5个线程执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line">    private Semaphore mSemaphore;</span><br><span class="line"></span><br><span class="line">    public MyRunnable(Semaphore semaphore) &#123;</span><br><span class="line">        mSemaphore = semaphore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            mSemaphore.acquire();</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">            System.out.println(&quot;thread &quot; + Thread.currentThread().getId() + &quot; working&quot;);</span><br><span class="line">            mSemaphore.release();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> Semaphore semaphore = new Semaphore(5);</span><br><span class="line">for (int i = 0; i &lt; 19; i++) &#123;</span><br><span class="line">    new Thread(new MyRunnable(semaphore)).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread t = new Thread(new MyRunnable(semaphore));</span><br><span class="line">t.start();</span><br><span class="line">t.join();</span><br></pre></td></tr></table></figure>

<p>Semaphore.acquire()方法尝试获得一个准入许可。如无法获得,线程就会等待。而Semaphore.release()则在线程访问资源结束后,释放一个许可。</p>
<p>Semaphore有下面的一些常用方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Semaphore(int permits)</span><br><span class="line">public Semaphore(int permits, boolean fair)</span><br><span class="line">public void acquire() </span><br><span class="line">public void acquireUninterruptibly()</span><br><span class="line">public boolean tryAcquire()</span><br><span class="line">public boolean tryAcquire(long timeout, TimeUnit unit)</span><br><span class="line">public void release()</span><br></pre></td></tr></table></figure>

<h1 id="其他的一些锁"><a href="#其他的一些锁" class="headerlink" title="其他的一些锁"></a>其他的一些锁</h1><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>读写锁(ReadWriteLock)是JDK5中提供的分离锁。读写分离锁可以有效的减少锁竞争。</p>
<p>读写锁允许多个线程同时读,但是写写操作和读写操作就需要相互等待了。读写锁的访问约束如下:</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">读</th>
<th align="center">写</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读</td>
<td align="center">非阻塞</td>
<td align="center">阻塞</td>
</tr>
<tr>
<td align="center">写</td>
<td align="center">阻塞</td>
<td align="center">阻塞</td>
</tr>
</tbody></table>
<p>读写操作在某些特定操作下可以提高程序的性能,如下面的代码。如果使用重入锁,需要十一秒左右才能运行完:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Data &#123;</span><br><span class="line">    private String mData = &quot;data&quot;;</span><br><span class="line">    private ReentrantLock mLock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public String readData()&#123;</span><br><span class="line">        mLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;read data : &quot; + mData);</span><br><span class="line">        String data = mData;</span><br><span class="line">        mLock.unlock();</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void writeData(String data)&#123;</span><br><span class="line">        mLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        mData = data;</span><br><span class="line">        System.out.println(&quot;write data : &quot; + mData);</span><br><span class="line">        mLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final Data data = new Data();</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            data.readData();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread write = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">       data.writeData(&quot;update data&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">write.start();</span><br></pre></td></tr></table></figure>

<p>但是如果将重入锁改成读写锁的话只需要两秒左右就能完成:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Data &#123;</span><br><span class="line">    private String mData = &quot;data&quot;;</span><br><span class="line">    private ReadWriteLock mLock = new ReentrantReadWriteLock();</span><br><span class="line">    private Lock mReadLock = mLock.readLock();</span><br><span class="line">    private Lock mWriteLock = mLock.writeLock();</span><br><span class="line"></span><br><span class="line">    public String readData()&#123;</span><br><span class="line">        mReadLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        String data = mData;</span><br><span class="line">        System.out.println(&quot;read data : &quot; + mData);</span><br><span class="line">        mReadLock.unlock();</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void writeData(String data)&#123;</span><br><span class="line">        mWriteLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;write data : &quot; + mData);</span><br><span class="line">        mData = data;</span><br><span class="line">        mWriteLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="倒计时器、循环栅栏"><a href="#倒计时器、循环栅栏" class="headerlink" title="倒计时器、循环栅栏"></a>倒计时器、循环栅栏</h1><p>倒计时器(CountDownLatch)和循环栅栏(CyclicBarrier)因为比较不常用,所以这里就不讲了,有兴趣的同学可以自己去看一下《实战Java高并发程序设计》这本书。</p>

    
  </div>
</article>

</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    




  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235687', function() {
      // load success
    });
  }
</script>

  <footer style="flex: 0 0 auto;text-align: center;">
<a style="font-size:12px; color:#6C6C6C" target="_blank">© 2021  林嘉伟 ❤ <a style="font-size:12px; color:#6C6C6C" target="_blank" href="http://beian.miit.gov.cn/" rel="nofollow">粤ICP备2021021473号</a></footer>
</body>
</html>
