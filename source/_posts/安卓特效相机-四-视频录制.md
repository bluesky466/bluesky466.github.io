title: 安卓特效相机(四) 视频录制
date: 2019-10-09 22:40:46
tags:
  - 技术相关
  - Android
---

系列文章:

[安卓特效相机(一) Camera2的使用](http://blog.islinjw.cn/2019/08/27/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%B8%80-Camera2%E7%9A%84%E4%BD%BF%E7%94%A8/)
[安卓特效相机(二) EGL基础](http://blog.islinjw.cn/2019/09/13/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%BA%8C-EGL%E5%9F%BA%E7%A1%80/)
[安卓特效相机(三) OpenGL ES 特效渲染](http://blog.islinjw.cn/2019/09/22/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%B8%89-OpenGL-ES-%E7%89%B9%E6%95%88%E6%B8%B2%E6%9F%93/)
[安卓特效相机(四) 视频录制](http://blog.islinjw.cn/2019/10/09/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E5%9B%9B-%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/)

前几篇文章已经讲完了摄像头画面的捕捉和特效渲染,这篇文章我们来讲一讲最后的视频录制部分。

我们这里将使用MediaRecorder去录制视频。MediaRecorder可以同时录制视频和音频。我们将音频源直接设置成摄像头,让它从摄像头里面读取音频数据:

```
mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);
mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);
mMediaRecorder.setAudioEncodingBitRate(AUDIO_BIT_RATE);
```

但是视频源并不能直接设置成摄像头,因为摄像头捕捉到的画面是原始的视频画面,我们上上一篇文章中讲到了如何将这个原始画面绘制到纹理,然后通过特效处理现实到TextureView上:

{% img /安卓特效相机四/1.png %}

所以如果我们直接将MediaRecorder的视频源设置成摄像头的话录制下来的视频并没有带上特效。

那要怎么做呢? MediaRecorder有一种视频源叫做MediaRecorder.VideoSource.SURFACE,意思是从Surface里面读取画面去录制。那我们是不是直接吧TextureView的SurfaceTexture创建的Surface传给MediaRecorder让它捕捉TextureView的内容就行了呢?

可惜的是如果直接用MediaRecorder.setInputSurface将Surface设置进去,会抛出异常:

```
09-22 14:53:47.473   897   943 E AndroidRuntime: java.lang.IllegalArgumentException: not a PersistentSurface
09-22 14:53:47.473   897   943 E AndroidRuntime:        at android.media.MediaRecorder.setInputSurface(MediaRecorder.java:165)
```

原因是只能设置MediaCodec.PersistentSurface类型的Surface:

```
/**
 * Configures the recorder to use a persistent surface when using SURFACE video source.
 * <p> May only be called before {@link #prepare}. If called, {@link #getSurface} should
 * not be used and will throw IllegalStateException. Frames rendered to the Surface
 * before {@link #start} will be discarded.</p>

 * @param surface a persistent input surface created by
 *           {@link MediaCodec#createPersistentInputSurface}
 * @throws IllegalStateException if it is called after {@link #prepare} and before
 * {@link #stop}.
 * @throws IllegalArgumentException if the surface was not created by
 *           {@link MediaCodec#createPersistentInputSurface}.
 * @see MediaCodec#createPersistentInputSurface
 * @see MediaRecorder.VideoSource
 */
public void setInputSurface(@NonNull Surface surface) {
    if (!(surface instanceof MediaCodec.PersistentSurface)) {
        throw new IllegalArgumentException("not a PersistentSurface");
    }
    native_setInputSurface(surface);
}
```

好吧直接滴干活不行那我们就悄悄滴干活。

首先还是需要视频源设置成MediaRecorder.VideoSource.SURFACE,然后配置一堆的视频信息。这些设置项具体是什么意思讲起来比较费劲,我就不展开了,大家感兴趣的可以自行搜索:

```
mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.SURFACE);
mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);
mMediaRecorder.setOutputFile(mLastVideo.getPath());
mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.H264);
mMediaRecorder.setVideoEncodingBitRate(VIDEO_BIT_RATE);
mMediaRecorder.setVideoSize(mPreview.getWidth(), mPreview.getHeight());
mMediaRecorder.setVideoFrameRate(VIDEO_FRAME_RATE);
mMediaRecorder.setOrientationHint(0);
```

配置完之后开启录制:

```
try {
    mMediaRecorder.prepare();
} catch (IOException e) {
    Toast.makeText(this, "failed to prepare MediaRecorder", Toast.LENGTH_LONG)
        .show();
}
mMediaRecorder.start();
```

上面的都是一些常规操作,大部分使用MediaRecorder的代码都是这样用的,下面我们来看正片:

```
return mGLRender.createEGLSurface(mMediaRecorder.getSurface());
```

这里拿到MediaRecorder的那个视频源Surface,给它创建了一个EGLSurface。我们在之前那篇[EGL基础](http://blog.islinjw.cn/2019/09/13/%E5%AE%89%E5%8D%93%E7%89%B9%E6%95%88%E7%9B%B8%E6%9C%BA-%E4%BA%8C-EGL%E5%9F%BA%E7%A1%80/)里面介绍过它。

我们可以用EGL14.eglMakeCurrent方法指定OpenGL往哪个Surface里面绘制,所以我们直接修改代码将OpenGL的目标Suface设置成这个视频源Surface就可以了吗?

恭喜你,得到了一个BUG。

现在视频是可以录制了,但是预览画面黑了。为什么,回顾下这幅图:

{% img /安卓特效相机四/1.png %}

我们需要要将OpenGL的画面绘制到TextureView上才能在屏幕上看到特效渲染后的预览画面。

那怎么办?TextureView和MediaRecorder只能二选一了吗?不,小孩子才做选择题，成年人当然是全都要。

我们让OpengGL辛苦点,画两次...

{% img /安卓特效相机四/2.png %}

首先修改下GLRender.render方法, EGLSurface由外面传进来,这样我们就能在外面控制它往TextureView和MediaRecord绘制了:

```
public void render(float[] matrix, EGLSurface eglSurface) {
    makeCurrent(eglSurface);
    GLES20.glUniformMatrix4fv(mTransformMatrixId, 1, false, matrix, 0);

    GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
    GLES20.glBindTexture(GLES11Ext.GL_SAMPLER_EXTERNAL_OES, mGLTextureId);
    GLES20.glUniform1i(mTexPreviewId, 0);

    GLES20.glClear(GLES20.GL_DEPTH_BUFFER_BIT | GLES20.GL_COLOR_BUFFER_BIT);
    GLES20.glDrawElements(GLES20.GL_TRIANGLES, ORDERS.length, GLES20.GL_UNSIGNED_SHORT, mOrder);
    EGL14.eglSwapBuffers(mEGLDisplay, eglSurface);
}
```

然后在绘制的时候绘制两次:

```
mCameraTexture.updateTexImage();
mCameraTexture.getTransformMatrix(mTransformMatrix);

mGLRender.render(mTransformMatrix, mGLRender.getDefaultEGLSurface());
if (mRecordSurface != null) {
    mGLRender.render(mTransformMatrix, mRecordSurface);
    mGLRender.setPresentationTime(mRecordSurface, mCameraTexture.getTimestamp());
}
```

这里需要注意的是我们需要给这一帧设置下时间戳,用于录制视频的时间同步:

```
public void setPresentationTime(EGLSurface eglSurface, long nsecs) {
    EGLExt.eglPresentationTimeANDROID(mEGLDisplay, eglSurface, nsecs);
}
```

好了,这个录像的实现方法比较简单。到此整个特效相机的教程就结束了,希望对大家有用。

这篇文章的demo依然在[github](https://github.com/bluesky466/CameraDemo/tree/feature_record)(注意是feature_record分支)